(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var config = {
    'overpassBase': 'https://overpass-cfn-staging.tilestream.net/api/interpreter',
    //'overpassBase': 'https://overpass-api.de/api/interpreter',
    'osmBase': 'https://www.openstreetmap.org/api/0.6/',
    // 'mapboxAccessToken': 'pk.eyJ1Ijoic2FuamF5YiIsImEiOiI3NjVvMFY0In0.byn_eCZGAwR1yaPeC-SVKw'
    'mapboxAccessToken': 'pk.eyJ1IjoicGxhbmVtYWQiLCJhIjoiemdYSVVLRSJ9.g3lbg_eN0kztmsfIPxa9MQ'
};

module.exports = config;

},{}],2:[function(require,module,exports){
'use strict';

function getChanges(geojson, changeset) {
    var features = geojson.features;
    var featureMap = {};
    var changeGeoJSON = {
        'type': 'FeatureCollection',
        'features': []
    };
    for (var i = 0, len = features.length; i < len; i++) {
        var id = features[i].properties.id;
        featureMap[id] = featureMap[id] || [];
        featureMap[id].push(features[i]);
    }
    for (var osmID in featureMap) {
        for (var j = 0; j < featureMap[osmID].length; j++) {
            var f = featureMap[osmID][j];
            var type = getChangeType(f, featureMap, changeset);
            f.properties.changeType = type;
            changeGeoJSON.features.push(f);
        }
    }
    return {
        'featureMap': featureMap,
        'geojson': changeGeoJSON
    };
}

function getChangeType(feature, features, changeset) {
    var props = feature.properties;
    var version = parseInt(props.version);
    var hasNext = hasNextVersion(version, feature, features);
    if (hasNext) {
        return 'modifiedOld';
    }
    var hasPrev = hasPreviousVersion(version, feature, features);
    if (hasPrev) {
        return 'modifiedNew';
    }
    if (version === 1) {
        if (props.uid === parseInt(changeset.uid) && props.changeset === parseInt(changeset.id)) {
            return 'added';
        } else {
            return 'deleted';
        }
    }
    return 'deleted'; //this is possibly wrong.
}

function hasNextVersion(version, feature, features) {
    var id = feature.properties.id;
    for (var i = 0; i < features[id].length; i++) {
        var f = features[id][i];
        if (f.properties.version === (version + 1)) {
            return f;
        }
    }
    for (var i = 0; i < features[id].length; i++) {
        var f = features[id][i];
        for (var nodeId in f.properties._nodeVersions) {
            var currentVersion = feature.properties._nodeVersions[nodeId];
            if (currentVersion < f.properties._nodeVersions[nodeId]) {
                return f;
            }
        }
    }
    return false;
}

function hasPreviousVersion(version, feature, features) {
    var id = feature.properties.id;
    for (var i = 0; i < features[id].length; i++) {
        var f = features[id][i];
        if (f.properties.version === (version - 1)) {
            return f;
        }
    }
    for (var i = 0; i < features[id].length; i++) {
        var f = features[id][i];
        for (var nodeId in f.properties._nodeVersions) {
            var currentVersion = feature.properties._nodeVersions[nodeId];
            if (currentVersion > f.properties._nodeVersions[nodeId]) {
                return f;
            }
        }
    }
    return false;
}

module.exports = getChanges;

},{}],3:[function(require,module,exports){
'use strict';

var render = require('./render');

if (location.hash !== '') {
    document.getElementById('formContainer').style.display = 'none';
    render(location.hash, {});
}

document.getElementById('changesetForm').addEventListener('submit', function (e) {
    e.preventDefault();
    document.getElementById('formContainer').style.display = 'none';
    var changesetID = document.getElementById('changesetInput').value;
    location.hash = changesetID;
    render(location.hash, {});
});

},{"./render":8}],4:[function(require,module,exports){
'use strict';

var xhr = require('xhr');
var moment = require('moment');
var config = require('./config');

var query = function (changesetID, callback) {
    var url = config.osmBase + 'changeset/' + changesetID;
    var xhrOptions = {
        'responseType': 'document'
    };
    xhr.get(url, xhrOptions, function (err, response) {
        if (err) {
            return callback(err, null);
        }
        var xml = response.body;
        var csFeature = xml.getElementsByTagName('changeset')[0];
        var cs = csFeature.attributes;
        var uid = cs.uid.textContent;
        var user = cs.user.textContent;
        var from = moment(cs.created_at.textContent, 'YYYY-MM-DDTHH:mm:ss\\Z').subtract('seconds', 1).format('YYYY-MM-DDTHH:mm:ss\\Z');
        var to = cs.closed_at ? cs.closed_at.textContent : null;
        var left = cs.min_lon.textContent;
        var bottom = cs.min_lat.textContent;
        var right = cs.max_lon.textContent;
        var top = cs.max_lat.textContent;
        var changeset = {
            'id': changesetID,
            'uid': uid,
            'user': user,
            'from': from,
            'to': to,
            'bbox': {
                'left': left,
                'bottom': bottom,
                'right': right,
                'top': top
            }
        };
        return callback(null, changeset);
    });
};

module.exports = {
    'query': query
};

},{"./config":1,"moment":189,"xhr":190}],5:[function(require,module,exports){
'use strict';

var xhr = require('xhr');
var config = require('./config');
var osm = require('./osm');
var overpassToGeoJSON = require('./overpassToGeoJSON');
var geojsonChanges = require('./geojsonChanges');

var query = function (changesetID, callback) {
    osm.query(changesetID, function (err, changeset) {
        if (err) {
            callback({
                'msg': 'OSM Query failed. Are you sure you entered a valid changeset id?',
                'error': err
            }, null);
        }
        var data = getDataParam(changeset);
        var bbox = getBboxParam(changeset.bbox);
        var url = config.overpassBase + '?data=' + data + '&bbox=' + bbox;
        var xhrOptions = {
            'responseType': 'json'
        };
        xhr.get(url, xhrOptions, function (err, response) {
            if (err) {
                return callback({
                    'msg': 'Overpass query failed.',
                    'error': err
                }, null);
            }
            var elements = response.body.elements;
            var geojson = overpassToGeoJSON(elements);
            var changes = geojsonChanges(geojson, changeset);

            var ret = {
                'geojson': changes.geojson,
                'featureMap': changes.featureMap,
                'changeset': changeset
            };
            return callback(null, ret);
        });
    });
};

function getDataParam(c) {
    return '[out:json][adiff:%22' + c.from.toString()  + ',%22,%22' + c.to.toString() + '%22];(node(bbox)(changed);way(bbox)(changed););out%20meta%20geom(bbox);';
}

function getBboxParam(bbox) {
    return [bbox.left, bbox.bottom, bbox.right, bbox.top].join(',');
}

module.exports = {
    'query': query
};

},{"./config":1,"./geojsonChanges":2,"./osm":4,"./overpassToGeoJSON":6,"xhr":190}],6:[function(require,module,exports){
'use strict';

function overpassToGeoJSON(overpassElements) {
    var NODES = getNodesById(overpassElements);

    var features = [];
    overpassElements.forEach(function (el) {
        var geojson;
        if (el.type === 'node') {
            geojson = getNodeGeoJSON(el);
        } else {
            geojson = getWayGeoJSON(el, NODES);
        }
        features.push(geojson);
    });
    return {
        'type': 'FeatureCollection',
        'features': features
    };
}

function getNodesById(overpassElements) {
    return overpassElements
      .filter(function (elt) { return elt.type === 'node'; })
      .reduce(function (nodes, node) {
          nodes[node.id] = nodes[node.id] || [];
          nodes[node.id].push({
              lat: node.lat,
              lon: node.lon,
              version: node.version
          });
          return nodes;
      }, {});
}

function getProps(obj) {
    var props = obj.tags || {};
    props.changeset = obj.changeset;
    props.timestamp = obj.timestamp;
    props.version = obj.version;
    props.uid = obj.uid;
    props.user = obj.user;
    props.id = obj.id;
    props.type = obj.type;
    return props;
}

// get geojson for a point type
function getNodeGeoJSON(node) {
    var props = getProps(node);
    return {
        'type': 'Feature',
        'properties': props,
        'geometry': {
            'type': 'Point',
            'coordinates': [node.lon, node.lat]
        }
    };
}

function getCoords(geom) {
    return geom.map(function (pt) {
        if (pt && pt.lon && pt.lat) {
            return [pt.lon, pt.lat];
        } else {
            return null;
        }
    }).filter(function (pt) {
        return !!pt;
    });
}

// get geojson for a "way" - either line or polygon
function getWayGeoJSON(way, NODES) {
    var props = getProps(way);

    // for some reason, Overpass sometime returns nodes in a geometry as null
    // since I don't know what else to do with them, let's just filter them out
    // along with their corresponding nodes
    for (var i = 0; i < way.geometry.length; i++) {
        if (way.geometry[i] === null) {
            way.geometry.splice(i, 1);
            way.nodes.splice(i, 1);
            i--;
        }
    }

    var nodeVersions = {};
    for (var i = 0; i < way.nodes.length; i++) {
        var id = way.nodes[i];
        var geometry = way.geometry[i];
        if (NODES[id]) {
            var node = NODES[id].filter(function (node) {
                return node.lat === geometry.lat &&
                       node.lon === geometry.lon;
            })[0];
            nodeVersions[id] = node.version;
        }
    }
    // add as a non-enumerable property, so that it doesn't
    // get picked up when generating the props table
    Object.defineProperty(props, '_nodeVersions', {
        enumerable: false,
        value: nodeVersions
    });

    var firstNode = way.geometry[0];
    var lastNode = way.geometry[way.geometry.length - 1];
    var geomType;
    if (firstNode.lat === lastNode.lat && firstNode.lon === lastNode.lon) {
        geomType = 'Polygon';
    } else {
        geomType = 'LineString';
    }
    var coords = getCoords(way.geometry);
    if (geomType === 'Polygon') {
        coords = [coords];
    }
    return {
        'type': 'Feature',
        'properties': props,
        'geometry': {
            'type': geomType,
            'coordinates': coords
        }
    };
}

module.exports = overpassToGeoJSON;

},{}],7:[function(require,module,exports){
'use strict';

function propsDiff(propsArray) {
    if (propsArray.length === 1) {
        var changeType = propsArray[0].changeType;
        if (changeType === 'added') {
            return getAdded(propsArray[0]);
        } else if (changeType === 'deleted') {
            return getDeleted(propsArray[0]);
        } else {
            throw new Error('only 1 element but neither added nor deleted');
        }
    } else {
        var modifiedOld = getOld(propsArray);
        var modifiedNew = getNew(propsArray);
        return getDiff(modifiedOld, modifiedNew);
    }
}

function getDiff(oldProps, newProps) {
    var ret = {};
    for (var prop in newProps) {
        ret[prop] = {};
        if (!oldProps.hasOwnProperty(prop)) {
            ret[prop]['added'] = newProps[prop];
        } else {
            var oldValue = oldProps[prop];
            var newValue = newProps[prop];
            if (oldValue === newValue) {
                ret[prop]['unchanged'] = newValue;
            } else {
                ret[prop]['modifiedOld'] = oldValue;
                ret[prop]['modifiedNew'] = newValue;
            }
        }
    }
    for (var oldProp in oldProps) {
        if (!ret.hasOwnProperty(oldProp)) {
            ret[oldProp] = {
                'deleted': oldProps[oldProp]
            };
        }
    }
    return ret;
}

function getAdded(props) {
    var ret = {};
    for (var prop in props) {
        ret[prop] = {
            'added': props[prop]
        };
    }
    return ret;
}

function getDeleted(props) {
    var ret = {};
    for (var prop in props) {
        ret[prop] = {
            'deleted': props[prop]
        };
    }
    return ret;
}

function getOld(propsArray) {
    for (var i = 0; i < propsArray.length; i++) {
        if (propsArray[i].changeType === 'modifiedOld') {
            return propsArray[i];
        }
    }
    return null;
}

function getNew(propsArray) {
    for (var i = 0; i < propsArray.length; i++) {
        if (propsArray[i].changeType === 'modifiedNew') {
            return propsArray[i];
        }
    }
    return null;
}

module.exports = propsDiff;

},{}],8:[function(require,module,exports){
'use strict';

var mapboxgl = require('mapbox-gl');
var overpass = require('./overpass');
var propsDiff = require('./propsDiff');
var config = require('./config');
var moment = require('moment');

function render(hash, options) {
    var changesetId = hash.split('/')[0].replace('#', '');

    document.getElementById('loading').style.display = 'block';
    options = options || {};
    var container = options.container || 'map';
    mapboxgl.accessToken = config.mapboxAccessToken;

    var map = new mapboxgl.Map({
        container: container,
        style: 'mapbox://styles/planemad/cijcefp3q00elbskq4cgvcivf',
        center: [0, 0],
        zoom: 3
    });

    overpass.query(changesetId, function (err, result) {
        if (err) {
            if (err.msg) {
                alert(err.msg);
                console.log(err.error);
            } else {
                alert('An unexpected error occured');
                console.log(err);
            }
            return;
        }
        document.getElementById('loading').style.display = 'none';
        document.getElementById('layerSelector').style.display = 'block';
        document.getElementById('changeset').text = changesetId;
        document.getElementById('user').text = result.changeset.user;
        var time = result.changeset.to ? result.changeset.to : result.changeset.from;
        document.getElementById('time').textContent = moment(time).format('MMMM Do YYYY, h:mm a');
        document.getElementById('user').href = 'https://openstreetmap.org/user/' + result.changeset.user;
        document.getElementById('changeset').href = 'https://openstreetmap.org/changeset/' + changesetId;
        document.getElementById('sidebar').style.display = 'block';
        var bbox = result.changeset.bbox;
        var featureMap = result.featureMap;
        map.addSource('changeset', {
            'type': 'geojson',
            'data': result.geojson
        });
        map.addLayer({
            'id': 'changeset-line',
            'source': 'changeset',
            'type': 'line',
            'layout': {
                'line-join': 'round',
                'line-cap': 'round',
                'visibility': 'visible'
            },
            'paint': {
                'line-color': '#fff',
                'line-width': 3
            },
            'filter': [
                '==', 'id', ''
            ]
        });
        map.addLayer({
            'id': 'changeset-point',
            'source': 'changeset',
            'type': 'circle',
            'layout': {
                'visibility': 'visible'
            },
            'paint': {
                'circle-radius': 4,
                'circle-color': '#fff'
            },
            'filter': [
                '==', 'id', ''
            ]
        });
        map.addLayer({
            'id': 'added-line',
            'source': 'changeset',
            'type': 'line',
            'interactive': true,
            'layout': {
                'visibility': 'visible'
            },
            'paint': {
                'line-color': '#859900',
                'line-width': 2
            },
            'filter': [
                '==', 'changeType', 'added'
            ]
        });
        map.addLayer({
            'id': 'added-point',
            'source': 'changeset',
            'type': 'circle',
            'interactive': true,
            'layout': {
                'visibility': 'visible'
            },
            'paint': {
                'circle-color': '#859900',
                'circle-radius': 3,
                'circle-blur': 1
            },
            'filter': [
                '==', 'changeType', 'added'
            ]
        });
        map.addLayer({
            'id': 'modified-old-line',
            'source': 'changeset',
            'type': 'line',
            'interactive': true,
            'layout': {
                'visibility': 'visible'
            },
            'paint': {
                'line-color': '#fdf6e3',
                'line-width': 2
            },
            'filter': [
                '==', 'changeType', 'modifiedOld'
            ]
        });
        map.addLayer({
            'id': 'modified-old-point',
            'source': 'changeset',
            'type': 'circle',
            'interactive': true,
            'layout': {
                'visibility': 'visible'
            },
            'paint': {
                'circle-color': '#fdf6e3',
                'circle-radius': 3,
                'circle-blur': 1
            },
            'filter': [
                '==', 'changeType', 'modifiedOld'
            ]
        });
        map.addLayer({
            'id': 'modified-new-line',
            'source': 'changeset',
            'type': 'line',
            'interactive': true,
            'layout': {
                'visibility': 'visible'
            },
            'paint': {
                'line-color': '#b58900',
                'line-width': 2
            },
            'filter': [
                '==', 'changeType', 'modifiedNew'
            ]
        });
        map.addLayer({
            'id': 'modified-new-point',
            'source': 'changeset',
            'type': 'circle',
            'interactive': true,
            'layout': {
                'visibility': 'visible'
            },
            'paint': {
                'circle-color': '#b58900',
                'circle-radius': 3,
                'circle-blur': 1
            },
            'filter': [
                '==', 'changeType', 'modifiedNew'
            ]
        });
        map.addLayer({
            'id': 'deleted-line',
            'source': 'changeset',
            'type': 'line',
            'interactive': true,
            'layout': {
                'visibility': 'visible'
            },
            'paint': {
                'line-color': '#dc322f',
                'line-width': 2
            },
            'filter': [
                '==', 'changeType', 'deleted'
            ]
        });
        map.addLayer({
            'id': 'deleted-point',
            'source': 'changeset',
            'type': 'circle',
            'interactive': true,
            'layout': {
                'visibility': 'visible'
            },
            'paint': {
                'circle-color': '#dc322f',
                'circle-radius': 3,
                'circle-blur': 1
            },
            'filter': [
                '==', 'changeType', 'deleted'
            ]
        });

        map.on('click', function (e) {
            var x1y1 = [e.point.x - 5, e.point.y - 5];
            var x2y2 = [e.point.x + 5, e.point.y + 5];
            var features = map.queryRenderedFeatures([x1y1, x2y2], {
                'layers': [
                    'added-line',
                    'added-point',
                    'modified-old-line',
                    'modified-old-point',
                    'modified-new-line',
                    'modified-new-point',
                    'deleted-line',
                    'deleted-point'
                ]
            });

            if (features.length) {
                selectFeature(features[0], featureMap);
            } else {
                clearFeature();
            }
        });

        var bounds = [
            [bbox.left, bbox.top],
            [bbox.right, bbox.bottom]
        ];
        map.fitBounds(bounds);

        var layersKey = {
            'added': [
                'added-line',
                'added-point'
            ],
            'modified': [
                'modified-old-line',
                'modified-old-point',
                'modified-new-line',
                'modified-new-point'
            ],
            'deleted': [
                'deleted-line',
                'deleted-point'
            ]
        };
        var selectedLayers = [
            'added-line',
            'added-point',
            'modified-old-line',
            'modified-old-point',
            'modified-new-line',
            'modified-new-point',
            'deleted-line',
            'deleted-point'
        ];
        var layerSelector = document.getElementById('layerSelector');
        layerSelector.addEventListener('change', function (e) {
            var key = e.target.value;
            if (e.target.checked) {
                selectedLayers = selectedLayers.concat(layersKey[key]);
                layersKey[key].forEach(function (layer) {
                    map.setLayoutProperty(layer, 'visibility', 'visible');
                });
            } else {
                selectedLayers = selectedLayers.filter(function (layer) {
                    return !(layer in layersKey[key]);
                });
                layersKey[key].forEach(function (layer) {
                    map.setLayoutProperty(layer, 'visibility', 'none');
                });
            }
        });

        var [, geometryType, featureId] = hash.split('/');

        if (geometryType && featureId) {
            selectFeature(featureMap[featureId][0], featureMap);
        }
    });

    function displayDiff(id, featureMap) {
        var featuresWithId = featureMap[id];
        var propsArray = featuresWithId.map(function (f) {
            return f.properties;
        });

        var diff = propsDiff(propsArray);
        var diffHTML = getDiffHTML(diff);

        document.getElementById('diff').innerHTML = '';
        document.getElementById('diff').appendChild(diffHTML);
        document.getElementById('diff').style.display = 'block';
    }

    function clearDiff() {
        document.getElementById('diff').innerHTML = '';
        document.getElementById('diff').style.display = 'none';
    }

    function getDiffHTML(diff) {
        var root = document.createElement('table');
        root.classList.add('diff-table');

        var types = ['added', 'unchanged', 'deleted', 'modifiedOld', 'modifiedNew'];
        for (var prop in diff) {
            var tr = document.createElement('tr');

            var th = document.createElement('th');
            th.textContent = prop;
            tr.appendChild(th);

            types.forEach(function (type) {
                if (diff[prop].hasOwnProperty(type)) {
                    if (type === 'added') {
                        var empty = document.createElement('td');
                        empty.classList.add('diff-property');
                        empty.classList.add(type);

                        tr.appendChild(empty);
                    }

                    var td = document.createElement('td');
                    td.classList.add('diff-property');
                    td.classList.add(type);

                    td.textContent = diff[prop][type];
                    tr.appendChild(td);

                    if (type === 'deleted') {
                        var empty = document.createElement('td');
                        empty.classList.add('diff-property');
                        empty.classList.add(type);

                        tr.appendChild(empty);
                    }

                    if (type === 'unchanged') {
                        tr.appendChild(td.cloneNode(true));
                    }
                }
            });

            root.appendChild(tr);
        }
        return root;
    }

    // function addLayer (name, id) {
    //     var link = document.createElement('a');
    //     link.href = '#';
    //     link.className = 'active';
    //     link.textContent = name;
    //
    //     link.onclick = function (e) {
    //         e.preventDefault();
    //         e.stopPropagation();
    //
    //         var visibility = map.getLayoutProperty(id, 'visibility');
    //
    //         if (visibility === 'visible') {
    //             map.setLayoutProperty(id, 'visibility', 'none');
    //             this.className = '';
    //         } else {
    //             this.className = 'active';
    //             map.setLayoutProperty(id, 'visibility', 'visible');
    //         }
    //     };
    //
    //     var layers = document.getElementById('menu');
    //     layers.appendChild(link);
    // }

    function highlightFeature(featureId) {
        map.setFilter('changeset-line', [
            '==', 'id', featureId
        ]);
        map.setFilter('changeset-point', [
            '==', 'id', featureId
        ]);
    }

    function clearHighlight() {
        map.setFilter('changeset-line', [
            '==', 'id', ''
        ]);
        map.setFilter('changeset-point', [
            '==', 'id', ''
        ]);
    }

    function updateHash(osmType, featureId) {
        clearHash();

        location.hash += '/' + osmType;
        location.hash += '/' + featureId;
    }

    function clearHash() {
        var changesetId = location.hash
          .split('/')[0]
          .replace('#', '');

        location.hash = changesetId;
    }

    function selectFeature(feature, featureMap) {
        var featureId = feature.properties.id;
        var osmType = feature.properties.type;

        highlightFeature(featureId);
        displayDiff(featureId, featureMap);
        updateHash(osmType, featureId);
    }

    function clearFeature() {
        clearHighlight();
        clearDiff();
        clearHash();
    }
}

module.exports = render;

},{"./config":1,"./overpass":5,"./propsDiff":7,"mapbox-gl":28,"moment":189}],9:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && !isFinite(value)) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) {
    return a === b;
  }
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":14}],10:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],11:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":12}],12:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],13:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],14:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":13,"_process":12,"inherits":10}],15:[function(require,module,exports){
'use strict';

var featureFilter = require('feature-filter');
var Buffer = require('./buffer');
var util = require('../util/util');
var StructArrayType = require('../util/struct_array');
var VertexArrayObject = require('../render/vertex_array_object');

module.exports = Bucket;

/**
 * Instantiate the appropriate subclass of `Bucket` for `options`.
 * @private
 * @param options See `Bucket` constructor options
 * @returns {Bucket}
 */
Bucket.create = function(options) {
    var Classes = {
        fill: require('./bucket/fill_bucket'),
        line: require('./bucket/line_bucket'),
        circle: require('./bucket/circle_bucket'),
        symbol: require('./bucket/symbol_bucket')
    };
    return new Classes[options.layer.type](options);
};


/**
 * The maximum extent of a feature that can be safely stored in the buffer.
 * In practice, all features are converted to this extent before being added.
 *
 * Positions are stored as signed 16bit integers.
 * One bit is lost for signedness to support featuers extending past the left edge of the tile.
 * One bit is lost because the line vertex buffer packs 1 bit of other data into the int.
 * One bit is lost to support features extending past the extent on the right edge of the tile.
 * This leaves us with 2^13 = 8192
 *
 * @private
 * @readonly
 */
Bucket.EXTENT = 8192;

/**
 * The `Bucket` class is the single point of knowledge about turning vector
 * tiles into WebGL buffers.
 *
 * `Bucket` is an abstract class. A subclass exists for each Mapbox GL
 * style spec layer type. Because `Bucket` is an abstract class,
 * instances should be created via the `Bucket.create` method.
 *
 * @class Bucket
 * @private
 * @param options
 * @param {number} options.zoom Zoom level of the buffers being built. May be
 *     a fractional zoom level.
 * @param options.layer A Mapbox GL style layer object
 * @param {Object.<string, Buffer>} options.buffers The set of `Buffer`s being
 *     built for this tile. This object facilitates sharing of `Buffer`s be
       between `Bucket`s.
 */
function Bucket(options) {
    this.zoom = options.zoom;
    this.overscaling = options.overscaling;
    this.layer = options.layer;
    this.childLayers = options.childLayers;

    this.type = this.layer.type;
    this.features = [];
    this.id = this.layer.id;
    this.index = options.index;
    this.sourceLayer = this.layer.sourceLayer;
    this.sourceLayerIndex = options.sourceLayerIndex;
    this.minZoom = this.layer.minzoom;
    this.maxZoom = this.layer.maxzoom;

    this.paintAttributes = createPaintAttributes(this);

    if (options.arrays) {
        var childLayers = this.childLayers;
        this.bufferGroups = util.mapObject(options.arrays, function(programArrayGroups, programName) {
            return programArrayGroups.map(function(programArrayGroup) {

                var group = util.mapObject(programArrayGroup, function(arrays, layoutOrPaint) {
                    return util.mapObject(arrays, function(array, name) {
                        var arrayType = options.arrayTypes[programName][layoutOrPaint][name];
                        var type = (arrayType.members.length && arrayType.members[0].name === 'vertices' ? Buffer.BufferType.ELEMENT : Buffer.BufferType.VERTEX);
                        return new Buffer(array, arrayType, type);
                    });
                });

                group.vaos = {};
                if (group.layout.element2) group.secondVaos = {};
                for (var l = 0; l < childLayers.length; l++) {
                    var layerName = childLayers[l].id;
                    group.vaos[layerName] = new VertexArrayObject();
                    if (group.layout.element2) group.secondVaos[layerName] = new VertexArrayObject();
                }

                return group;
            });
        });
    }
}

/**
 * Build the buffers! Features are set directly to the `features` property.
 * @private
 */
Bucket.prototype.populateBuffers = function() {
    this.createArrays();
    this.recalculateStyleLayers();

    for (var i = 0; i < this.features.length; i++) {
        this.addFeature(this.features[i]);
    }

    this.trimArrays();
};

/**
 * Check if there is enough space available in the current element group for
 * `vertexLength` vertices. If not, append a new elementGroup. Should be called
 * by `populateBuffers` and its callees.
 * @private
 * @param {string} programName the name of the program associated with the buffer that will receive the vertices
 * @param {number} vertexLength The number of vertices that will be inserted to the buffer.
 */
Bucket.prototype.makeRoomFor = function(programName, numVertices) {
    var groups = this.arrayGroups[programName];
    var currentGroup = groups.length && groups[groups.length - 1];

    if (!currentGroup || currentGroup.layout.vertex.length + numVertices > 65535) {

        var arrayTypes = this.arrayTypes[programName];
        var VertexArrayType = arrayTypes.layout.vertex;
        var ElementArrayType = arrayTypes.layout.element;
        var ElementArrayType2 = arrayTypes.layout.element2;

        currentGroup = {
            index: groups.length,
            layout: {},
            paint: {}
        };

        currentGroup.layout.vertex = new VertexArrayType();
        if (ElementArrayType) currentGroup.layout.element = new ElementArrayType();
        if (ElementArrayType2) currentGroup.layout.element2 = new ElementArrayType2();

        for (var i = 0; i < this.childLayers.length; i++) {
            var layerName = this.childLayers[i].id;
            var PaintVertexArrayType = arrayTypes.paint[layerName];
            currentGroup.paint[layerName] = new PaintVertexArrayType();
        }

        groups.push(currentGroup);
    }

    return currentGroup;
};

/**
 * Start using a new shared `buffers` object and recreate instances of `Buffer`
 * as necessary.
 * @private
 */
Bucket.prototype.createArrays = function() {
    this.arrayGroups = {};
    this.arrayTypes = {};

    for (var programName in this.programInterfaces) {
        var programInterface = this.programInterfaces[programName];
        var programArrayTypes = this.arrayTypes[programName] = { layout: {}, paint: {} };
        this.arrayGroups[programName] = [];

        if (programInterface.vertexBuffer) {
            var VertexArrayType = new StructArrayType({
                members: this.programInterfaces[programName].layoutAttributes,
                alignment: Buffer.VERTEX_ATTRIBUTE_ALIGNMENT
            });

            programArrayTypes.layout.vertex = VertexArrayType;

            var layerPaintAttributes = this.paintAttributes[programName];
            for (var layerName in layerPaintAttributes) {
                var PaintVertexArrayType = new StructArrayType({
                    members: layerPaintAttributes[layerName].attributes,
                    alignment: Buffer.VERTEX_ATTRIBUTE_ALIGNMENT
                });

                programArrayTypes.paint[layerName] = PaintVertexArrayType;
            }
        }

        if (programInterface.elementBuffer) {
            var ElementArrayType = createElementBufferType(programInterface.elementBufferComponents);
            programArrayTypes.layout.element = ElementArrayType;
        }

        if (programInterface.elementBuffer2) {
            var ElementArrayType2 = createElementBufferType(programInterface.elementBuffer2Components);
            programArrayTypes.layout.element2 = ElementArrayType2;
        }
    }
};

Bucket.prototype.destroy = function(gl) {
    for (var programName in this.bufferGroups) {
        var programBufferGroups = this.bufferGroups[programName];
        for (var i = 0; i < programBufferGroups.length; i++) {
            var programBuffers = programBufferGroups[i];
            for (var paintBuffer in programBuffers.paint) {
                programBuffers.paint[paintBuffer].destroy(gl);
            }
            for (var layoutBuffer in programBuffers.layout) {
                programBuffers.layout[layoutBuffer].destroy(gl);
            }
            for (var j in programBuffers.vaos) {
                programBuffers.vaos[j].destroy(gl);
            }
            for (var k in programBuffers.secondVaos) {
                programBuffers.secondVaos[k].destroy(gl);
            }
        }
    }

};

Bucket.prototype.trimArrays = function() {
    for (var programName in this.arrayGroups) {
        var programArrays = this.arrayGroups[programName];
        for (var paintArray in programArrays.paint) {
            programArrays.paint[paintArray].trim();
        }
        for (var layoutArray in programArrays.layout) {
            programArrays.layout[layoutArray].trim();
        }
    }
};

Bucket.prototype.setUniforms = function(gl, programName, program, layer, globalProperties) {
    var uniforms = this.paintAttributes[programName][layer.id].uniforms;
    for (var i = 0; i < uniforms.length; i++) {
        var uniform = uniforms[i];
        var uniformLocation = program[uniform.name];
        gl['uniform' + uniform.components + 'fv'](uniformLocation, uniform.getValue(layer, globalProperties));
    }
};

Bucket.prototype.serialize = function() {
    return {
        layerId: this.layer.id,
        zoom: this.zoom,
        arrays: util.mapObject(this.arrayGroups, function(programArrayGroups) {
            return programArrayGroups.map(function(arrayGroup) {
                return util.mapObject(arrayGroup, function(arrays) {
                    return util.mapObject(arrays, function(array) {
                        return array.serialize();
                    });
                });
            });
        }),
        arrayTypes: util.mapObject(this.arrayTypes, function(programArrayTypes) {
            return util.mapObject(programArrayTypes, function(arrayTypes) {
                return util.mapObject(arrayTypes, function(arrayType) {
                    return arrayType.serialize();
                });
            });
        }),

        childLayerIds: this.childLayers.map(function(layer) {
            return layer.id;
        })
    };
};

Bucket.prototype.createFilter = function() {
    if (!this.filter) {
        this.filter = featureFilter(this.layer.filter);
    }
};

var FAKE_ZOOM_HISTORY = { lastIntegerZoom: Infinity, lastIntegerZoomTime: 0, lastZoom: 0 };
Bucket.prototype.recalculateStyleLayers = function() {
    for (var i = 0; i < this.childLayers.length; i++) {
        this.childLayers[i].recalculate(this.zoom, FAKE_ZOOM_HISTORY);
    }
};

Bucket.prototype.getProgramMacros = function(programInterface, layer) {
    var macros = [];
    var attributes = this.paintAttributes[programInterface][layer.id].attributes;
    for (var i = 0; i < attributes.length; i++) {
        var attribute = attributes[i];
        macros.push('ATTRIBUTE_' + (attribute.isFunction ? 'ZOOM_FUNCTION_' : '') + attribute.name.toUpperCase());
    }
    return macros;
};

Bucket.prototype.addPaintAttributes = function(interfaceName, globalProperties, featureProperties, startGroup, startIndex) {
    for (var l = 0; l < this.childLayers.length; l++) {
        var layer = this.childLayers[l];
        var groups = this.arrayGroups[interfaceName];
        for (var g = startGroup.index; g < groups.length; g++) {
            var group = groups[g];
            var length = group.layout.vertex.length;
            var vertexArray = group.paint[layer.id];
            vertexArray.resize(length);

            var attributes = this.paintAttributes[interfaceName][layer.id].attributes;
            for (var m = 0; m < attributes.length; m++) {
                var attribute = attributes[m];

                var value = attribute.getValue(layer, globalProperties, featureProperties);
                var multiplier = attribute.multiplier || 1;
                var components = attribute.components || 1;

                for (var i = startIndex; i < length; i++) {
                    var vertex = vertexArray.get(i);
                    for (var c = 0; c < components; c++) {
                        var memberName = components > 1 ? (attribute.name + c) : attribute.name;
                        vertex[memberName] = value[c] * multiplier;
                    }
                }
            }
        }
    }
};

function createElementBufferType(components) {
    return new StructArrayType({
        members: [{
            type: Buffer.ELEMENT_ATTRIBUTE_TYPE,
            name: 'vertices',
            components: components || 3
        }]
    });
}

function createPaintAttributes(bucket) {
    var attributes = {};
    for (var interfaceName in bucket.programInterfaces) {
        var layerPaintAttributes = attributes[interfaceName] = {};

        for (var c = 0; c < bucket.childLayers.length; c++) {
            var childLayer = bucket.childLayers[c];
            layerPaintAttributes[childLayer.id] = { attributes: [], uniforms: [] };
        }

        var interface_ = bucket.programInterfaces[interfaceName];
        if (!interface_.paintAttributes) continue;
        for (var i = 0; i < interface_.paintAttributes.length; i++) {
            var attribute = interface_.paintAttributes[i];

            for (var j = 0; j < bucket.childLayers.length; j++) {
                var layer = bucket.childLayers[j];
                var paintAttributes = layerPaintAttributes[layer.id];

                if (layer.isPaintValueFeatureConstant(attribute.paintProperty)) {
                    paintAttributes.uniforms.push(attribute);
                } else if (layer.isPaintValueZoomConstant(attribute.paintProperty)) {
                    paintAttributes.attributes.push(attribute);
                } else {

                    var zoomLevels = layer.getPaintValueStopZoomLevels(attribute.paintProperty);

                    // Pick the index of the first offset to add to the buffers.
                    // Find the four closest stops, ideally with two on each side of the zoom level.
                    var numStops = 0;
                    while (numStops < zoomLevels.length && zoomLevels[numStops] < bucket.zoom) numStops++;
                    var stopOffset = Math.max(0, Math.min(zoomLevels.length - 4, numStops - 2));

                    var fourZoomLevels = [];
                    for (var s = 0; s < 4; s++) {
                        fourZoomLevels.push(zoomLevels[Math.min(stopOffset + s, zoomLevels.length - 1)]);
                    }

                    var components = attribute.components;
                    if (components === 1) {
                        paintAttributes.attributes.push(util.extend({}, attribute, {
                            getValue: createFunctionGetValue(attribute, fourZoomLevels),
                            isFunction: true,
                            components: components * 4
                        }));
                    } else {
                        for (var k = 0; k < 4; k++) {
                            paintAttributes.attributes.push(util.extend({}, attribute, {
                                getValue: createFunctionGetValue(attribute, [fourZoomLevels[k]]),
                                isFunction: true,
                                name: attribute.name + k
                            }));
                        }
                    }

                    paintAttributes.uniforms.push(util.extend({}, attribute, {
                        name: 'u_' + attribute.name.slice(2) + '_t',
                        getValue: createGetUniform(attribute, stopOffset),
                        components: 1
                    }));
                }
            }
        }
    }
    return attributes;
}

function createFunctionGetValue(attribute, stopZoomLevels) {
    return function(layer, globalProperties, featureProperties) {
        if (stopZoomLevels.length === 1) {
            // return one multi-component value like color0
            return attribute.getValue(layer, util.extend({}, globalProperties, { zoom: stopZoomLevels[0] }), featureProperties);
        } else {
            // pack multiple single-component values into a four component attribute
            var values = [];
            for (var z = 0; z < stopZoomLevels.length; z++) {
                var stopZoomLevel = stopZoomLevels[z];
                values.push(attribute.getValue(layer, util.extend({}, globalProperties, { zoom: stopZoomLevel }), featureProperties)[0]);
            }
            return values;
        }
    };
}

function createGetUniform(attribute, stopOffset) {
    return function(layer, globalProperties) {
        // stopInterp indicates which stops need to be interpolated.
        // If stopInterp is 3.5 then interpolate half way between stops 3 and 4.
        var stopInterp = layer.getPaintInterpolationT(attribute.paintProperty, globalProperties.zoom);
        // We can only store four stop values in the buffers. stopOffset is the number of stops that come
        // before the stops that were added to the buffers.
        return [Math.max(0, Math.min(4, stopInterp - stopOffset))];
    };
}

},{"../render/vertex_array_object":41,"../util/struct_array":115,"../util/util":117,"./bucket/circle_bucket":16,"./bucket/fill_bucket":17,"./bucket/line_bucket":18,"./bucket/symbol_bucket":19,"./buffer":20,"feature-filter":120}],16:[function(require,module,exports){
'use strict';

var Bucket = require('../bucket');
var util = require('../../util/util');
var loadGeometry = require('../load_geometry');
var EXTENT = Bucket.EXTENT;

module.exports = CircleBucket;

/**
 * Circles are represented by two triangles.
 *
 * Each corner has a pos that is the center of the circle and an extrusion
 * vector that is where it points.
 * @private
 */
function CircleBucket() {
    Bucket.apply(this, arguments);
}

CircleBucket.prototype = util.inherit(Bucket, {});

CircleBucket.prototype.addCircleVertex = function(vertexArray, x, y, extrudeX, extrudeY) {
    return vertexArray.emplaceBack(
            (x * 2) + ((extrudeX + 1) / 2),
            (y * 2) + ((extrudeY + 1) / 2));
};

CircleBucket.prototype.programInterfaces = {
    circle: {
        vertexBuffer: true,
        elementBuffer: true,

        layoutAttributes: [{
            name: 'a_pos',
            components: 2,
            type: 'Int16'
        }],
        paintAttributes: [{
            name: 'a_color',
            components: 4,
            type: 'Uint8',
            getValue: function(layer, globalProperties, featureProperties) {
                return util.premultiply(layer.getPaintValue("circle-color", globalProperties, featureProperties));
            },
            multiplier: 255,
            paintProperty: 'circle-color'
        }, {
            name: 'a_radius',
            components: 1,
            type: 'Uint16',
            isLayerConstant: false,
            getValue: function(layer, globalProperties, featureProperties) {
                return [layer.getPaintValue("circle-radius", globalProperties, featureProperties)];
            },
            multiplier: 10,
            paintProperty: 'circle-radius'
        }]
    }
};

CircleBucket.prototype.addFeature = function(feature) {
    var globalProperties = {zoom: this.zoom};
    var geometries = loadGeometry(feature);

    var startGroup = this.makeRoomFor('circle', 0);
    var startIndex = startGroup.layout.vertex.length;

    for (var j = 0; j < geometries.length; j++) {
        for (var k = 0; k < geometries[j].length; k++) {

            var x = geometries[j][k].x;
            var y = geometries[j][k].y;

            // Do not include points that are outside the tile boundaries.
            if (x < 0 || x >= EXTENT || y < 0 || y >= EXTENT) continue;

            // this geometry will be of the Point type, and we'll derive
            // two triangles from it.
            //
            // ┌─────────┐
            // │ 3     2 │
            // │         │
            // │ 0     1 │
            // └─────────┘

            var group = this.makeRoomFor('circle', 4);
            var vertexArray = group.layout.vertex;

            var index = this.addCircleVertex(vertexArray, x, y, -1, -1);
            this.addCircleVertex(vertexArray, x, y, 1, -1);
            this.addCircleVertex(vertexArray, x, y, 1, 1);
            this.addCircleVertex(vertexArray, x, y, -1, 1);

            group.layout.element.emplaceBack(index, index + 1, index + 2);
            group.layout.element.emplaceBack(index, index + 3, index + 2);
        }
    }

    this.addPaintAttributes('circle', globalProperties, feature.properties, startGroup, startIndex);
};

},{"../../util/util":117,"../bucket":15,"../load_geometry":22}],17:[function(require,module,exports){
'use strict';

var Bucket = require('../bucket');
var util = require('../../util/util');
var loadGeometry = require('../load_geometry');

module.exports = FillBucket;

function FillBucket() {
    Bucket.apply(this, arguments);
}

FillBucket.prototype = util.inherit(Bucket, {});

FillBucket.prototype.programInterfaces = {
    fill: {
        vertexBuffer: true,
        elementBuffer: true,
        elementBuffer2: true,
        elementBuffer2Components: 2,

        layoutAttributes: [{
            name: 'a_pos',
            components: 2,
            type: 'Int16'
        }]
    }
};

FillBucket.prototype.addFeature = function(feature) {
    var lines = loadGeometry(feature);
    for (var i = 0; i < lines.length; i++) {
        this.addFill(lines[i]);
    }
};

FillBucket.prototype.addFill = function(vertices) {
    if (vertices.length < 3) {
        //console.warn('a fill must have at least three vertices');
        return;
    }

    // Calculate the total number of vertices we're going to produce so that we
    // can resize the buffer beforehand, or detect whether the current line
    // won't fit into the buffer anymore.
    // In order to be able to use the vertex buffer for drawing the antialiased
    // outlines, we separate all polygon vertices with a degenerate (out-of-
    // viewplane) vertex.

    var len = vertices.length;

    // Expand this geometry buffer to hold all the required vertices.
    var group = this.makeRoomFor('fill', len + 1);

    // We're generating triangle fans, so we always start with the first coordinate in this polygon.
    var firstIndex, prevIndex;
    for (var i = 0; i < vertices.length; i++) {
        var currentVertex = vertices[i];

        var currentIndex = group.layout.vertex.emplaceBack(currentVertex.x, currentVertex.y);
        if (i === 0) firstIndex = currentIndex;

        // Only add triangles that have distinct vertices.
        if (i >= 2 && (currentVertex.x !== vertices[0].x || currentVertex.y !== vertices[0].y)) {
            group.layout.element.emplaceBack(firstIndex, prevIndex, currentIndex);
        }

        if (i >= 1) {
            group.layout.element2.emplaceBack(prevIndex, currentIndex);
        }

        prevIndex = currentIndex;
    }
};

},{"../../util/util":117,"../bucket":15,"../load_geometry":22}],18:[function(require,module,exports){
'use strict';

var Bucket = require('../bucket');
var util = require('../../util/util');
var loadGeometry = require('../load_geometry');
var EXTENT = Bucket.EXTENT;

// NOTE ON EXTRUDE SCALE:
// scale the extrusion vector so that the normal length is this value.
// contains the "texture" normals (-1..1). this is distinct from the extrude
// normals for line joins, because the x-value remains 0 for the texture
// normal array, while the extrude normal actually moves the vertex to create
// the acute/bevelled line join.
var EXTRUDE_SCALE = 63;

/*
 * Sharp corners cause dashed lines to tilt because the distance along the line
 * is the same at both the inner and outer corners. To improve the appearance of
 * dashed lines we add extra points near sharp corners so that a smaller part
 * of the line is tilted.
 *
 * COS_HALF_SHARP_CORNER controls how sharp a corner has to be for us to add an
 * extra vertex. The default is 75 degrees.
 *
 * The newly created vertices are placed SHARP_CORNER_OFFSET pixels from the corner.
 */
var COS_HALF_SHARP_CORNER = Math.cos(75 / 2 * (Math.PI / 180));
var SHARP_CORNER_OFFSET = 15;

// The number of bits that is used to store the line distance in the buffer.
var LINE_DISTANCE_BUFFER_BITS = 14;

// We don't have enough bits for the line distance as we'd like to have, so
// use this value to scale the line distance (in tile units) down to a smaller
// value. This lets us store longer distances while sacrificing precision.
var LINE_DISTANCE_SCALE = 1 / 2;

// The maximum line distance, in tile units, that fits in the buffer.
var MAX_LINE_DISTANCE = Math.pow(2, LINE_DISTANCE_BUFFER_BITS) / LINE_DISTANCE_SCALE;


module.exports = LineBucket;

/**
 * @private
 */
function LineBucket() {
    Bucket.apply(this, arguments);
}

LineBucket.prototype = util.inherit(Bucket, {});

LineBucket.prototype.addLineVertex = function(vertexBuffer, point, extrude, tx, ty, dir, linesofar) {
    return vertexBuffer.emplaceBack(
            // a_pos
            (point.x << 1) | tx,
            (point.y << 1) | ty,
            // a_data
            // add 128 to store an byte in an unsigned byte
            Math.round(EXTRUDE_SCALE * extrude.x) + 128,
            Math.round(EXTRUDE_SCALE * extrude.y) + 128,
            // Encode the -1/0/1 direction value into the first two bits of .z of a_data.
            // Combine it with the lower 6 bits of `linesofar` (shifted by 2 bites to make
            // room for the direction value). The upper 8 bits of `linesofar` are placed in
            // the `w` component. `linesofar` is scaled down by `LINE_DISTANCE_SCALE` so that
            // we can store longer distances while sacrificing precision.
            ((dir === 0 ? 0 : (dir < 0 ? -1 : 1)) + 1) | (((linesofar * LINE_DISTANCE_SCALE) & 0x3F) << 2),
            (linesofar * LINE_DISTANCE_SCALE) >> 6);
};

LineBucket.prototype.programInterfaces = {
    line: {
        vertexBuffer: true,
        elementBuffer: true,

        layoutAttributes: [{
            name: 'a_pos',
            components: 2,
            type: 'Int16'
        }, {
            name: 'a_data',
            components: 4,
            type: 'Uint8'
        }]
    }
};

LineBucket.prototype.addFeature = function(feature) {
    var lines = loadGeometry(feature);
    for (var i = 0; i < lines.length; i++) {
        this.addLine(
            lines[i],
            this.layer.layout['line-join'],
            this.layer.layout['line-cap'],
            this.layer.layout['line-miter-limit'],
            this.layer.layout['line-round-limit']
        );
    }
};

LineBucket.prototype.addLine = function(vertices, join, cap, miterLimit, roundLimit) {

    var len = vertices.length;
    // If the line has duplicate vertices at the end, adjust length to remove them.
    while (len > 2 && vertices[len - 1].equals(vertices[len - 2])) {
        len--;
    }

    if (vertices.length < 2) {
        //console.warn('a line must have at least two vertices');
        return;
    }

    if (join === 'bevel') miterLimit = 1.05;

    var sharpCornerOffset = SHARP_CORNER_OFFSET * (EXTENT / (512 * this.overscaling));

    var firstVertex = vertices[0],
        lastVertex = vertices[len - 1],
        closed = firstVertex.equals(lastVertex);

    // we could be more precise, but it would only save a negligible amount of space
    this.makeRoomFor('line', len * 10);

    if (len === 2 && closed) {
        // console.warn('a line may not have coincident points');
        return;
    }

    this.distance = 0;

    var beginCap = cap,
        endCap = closed ? 'butt' : cap,
        startOfLine = true,
        currentVertex, prevVertex, nextVertex, prevNormal, nextNormal, offsetA, offsetB;

    // the last three vertices added
    this.e1 = this.e2 = this.e3 = -1;

    if (closed) {
        currentVertex = vertices[len - 2];
        nextNormal = firstVertex.sub(currentVertex)._unit()._perp();
    }

    for (var i = 0; i < len; i++) {

        nextVertex = closed && i === len - 1 ?
            vertices[1] : // if the line is closed, we treat the last vertex like the first
            vertices[i + 1]; // just the next vertex

        // if two consecutive vertices exist, skip the current one
        if (nextVertex && vertices[i].equals(nextVertex)) continue;

        if (nextNormal) prevNormal = nextNormal;
        if (currentVertex) prevVertex = currentVertex;

        currentVertex = vertices[i];

        // Calculate the normal towards the next vertex in this line. In case
        // there is no next vertex, pretend that the line is continuing straight,
        // meaning that we are just using the previous normal.
        nextNormal = nextVertex ? nextVertex.sub(currentVertex)._unit()._perp() : prevNormal;

        // If we still don't have a previous normal, this is the beginning of a
        // non-closed line, so we're doing a straight "join".
        prevNormal = prevNormal || nextNormal;

        // Determine the normal of the join extrusion. It is the angle bisector
        // of the segments between the previous line and the next line.
        var joinNormal = prevNormal.add(nextNormal)._unit();

        /*  joinNormal     prevNormal
         *             ↖      ↑
         *                .________. prevVertex
         *                |
         * nextNormal  ←  |  currentVertex
         *                |
         *     nextVertex !
         *
         */

        // Calculate the length of the miter (the ratio of the miter to the width).
        // Find the cosine of the angle between the next and join normals
        // using dot product. The inverse of that is the miter length.
        var cosHalfAngle = joinNormal.x * nextNormal.x + joinNormal.y * nextNormal.y;
        var miterLength = 1 / cosHalfAngle;

        var isSharpCorner = cosHalfAngle < COS_HALF_SHARP_CORNER && prevVertex && nextVertex;

        if (isSharpCorner && i > 0) {
            var prevSegmentLength = currentVertex.dist(prevVertex);
            if (prevSegmentLength > 2 * sharpCornerOffset) {
                var newPrevVertex = currentVertex.sub(currentVertex.sub(prevVertex)._mult(sharpCornerOffset / prevSegmentLength)._round());
                this.distance += newPrevVertex.dist(prevVertex);
                this.addCurrentVertex(newPrevVertex, this.distance, prevNormal.mult(1), 0, 0, false);
                prevVertex = newPrevVertex;
            }
        }

        // The join if a middle vertex, otherwise the cap.
        var middleVertex = prevVertex && nextVertex;
        var currentJoin = middleVertex ? join : nextVertex ? beginCap : endCap;

        if (middleVertex && currentJoin === 'round') {
            if (miterLength < roundLimit) {
                currentJoin = 'miter';
            } else if (miterLength <= 2) {
                currentJoin = 'fakeround';
            }
        }

        if (currentJoin === 'miter' && miterLength > miterLimit) {
            currentJoin = 'bevel';
        }

        if (currentJoin === 'bevel') {
            // The maximum extrude length is 128 / 63 = 2 times the width of the line
            // so if miterLength >= 2 we need to draw a different type of bevel where.
            if (miterLength > 2) currentJoin = 'flipbevel';

            // If the miterLength is really small and the line bevel wouldn't be visible,
            // just draw a miter join to save a triangle.
            if (miterLength < miterLimit) currentJoin = 'miter';
        }

        // Calculate how far along the line the currentVertex is
        if (prevVertex) this.distance += currentVertex.dist(prevVertex);

        if (currentJoin === 'miter') {

            joinNormal._mult(miterLength);
            this.addCurrentVertex(currentVertex, this.distance, joinNormal, 0, 0, false);

        } else if (currentJoin === 'flipbevel') {
            // miter is too big, flip the direction to make a beveled join

            if (miterLength > 100) {
                // Almost parallel lines
                joinNormal = nextNormal.clone();

            } else {
                var direction = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x > 0 ? -1 : 1;
                var bevelLength = miterLength * prevNormal.add(nextNormal).mag() / prevNormal.sub(nextNormal).mag();
                joinNormal._perp()._mult(bevelLength * direction);
            }
            this.addCurrentVertex(currentVertex, this.distance, joinNormal, 0, 0, false);
            this.addCurrentVertex(currentVertex, this.distance, joinNormal.mult(-1), 0, 0, false);

        } else if (currentJoin === 'bevel' || currentJoin === 'fakeround') {
            var lineTurnsLeft = (prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x) > 0;
            var offset = -Math.sqrt(miterLength * miterLength - 1);
            if (lineTurnsLeft) {
                offsetB = 0;
                offsetA = offset;
            } else {
                offsetA = 0;
                offsetB = offset;
            }

            // Close previous segment with a bevel
            if (!startOfLine) {
                this.addCurrentVertex(currentVertex, this.distance, prevNormal, offsetA, offsetB, false);
            }

            if (currentJoin === 'fakeround') {
                // The join angle is sharp enough that a round join would be visible.
                // Bevel joins fill the gap between segments with a single pie slice triangle.
                // Create a round join by adding multiple pie slices. The join isn't actually round, but
                // it looks like it is at the sizes we render lines at.

                // Add more triangles for sharper angles.
                // This math is just a good enough approximation. It isn't "correct".
                var n = Math.floor((0.5 - (cosHalfAngle - 0.5)) * 8);
                var approxFractionalJoinNormal;

                for (var m = 0; m < n; m++) {
                    approxFractionalJoinNormal = nextNormal.mult((m + 1) / (n + 1))._add(prevNormal)._unit();
                    this.addPieSliceVertex(currentVertex, this.distance, approxFractionalJoinNormal, lineTurnsLeft);
                }

                this.addPieSliceVertex(currentVertex, this.distance, joinNormal, lineTurnsLeft);

                for (var k = n - 1; k >= 0; k--) {
                    approxFractionalJoinNormal = prevNormal.mult((k + 1) / (n + 1))._add(nextNormal)._unit();
                    this.addPieSliceVertex(currentVertex, this.distance, approxFractionalJoinNormal, lineTurnsLeft);
                }
            }

            // Start next segment
            if (nextVertex) {
                this.addCurrentVertex(currentVertex, this.distance, nextNormal, -offsetA, -offsetB, false);
            }

        } else if (currentJoin === 'butt') {
            if (!startOfLine) {
                // Close previous segment with a butt
                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 0, 0, false);
            }

            // Start next segment with a butt
            if (nextVertex) {
                this.addCurrentVertex(currentVertex, this.distance, nextNormal, 0, 0, false);
            }

        } else if (currentJoin === 'square') {

            if (!startOfLine) {
                // Close previous segment with a square cap
                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 1, 1, false);

                // The segment is done. Unset vertices to disconnect segments.
                this.e1 = this.e2 = -1;
            }

            // Start next segment
            if (nextVertex) {
                this.addCurrentVertex(currentVertex, this.distance, nextNormal, -1, -1, false);
            }

        } else if (currentJoin === 'round') {

            if (!startOfLine) {
                // Close previous segment with butt
                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 0, 0, false);

                // Add round cap or linejoin at end of segment
                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 1, 1, true);

                // The segment is done. Unset vertices to disconnect segments.
                this.e1 = this.e2 = -1;
            }


            // Start next segment with a butt
            if (nextVertex) {
                // Add round cap before first segment
                this.addCurrentVertex(currentVertex, this.distance, nextNormal, -1, -1, true);

                this.addCurrentVertex(currentVertex, this.distance, nextNormal, 0, 0, false);
            }
        }

        if (isSharpCorner && i < len - 1) {
            var nextSegmentLength = currentVertex.dist(nextVertex);
            if (nextSegmentLength > 2 * sharpCornerOffset) {
                var newCurrentVertex = currentVertex.add(nextVertex.sub(currentVertex)._mult(sharpCornerOffset / nextSegmentLength)._round());
                this.distance += newCurrentVertex.dist(currentVertex);
                this.addCurrentVertex(newCurrentVertex, this.distance, nextNormal.mult(1), 0, 0, false);
                currentVertex = newCurrentVertex;
            }
        }

        startOfLine = false;
    }

};

/**
 * Add two vertices to the buffers.
 *
 * @param {Object} currentVertex the line vertex to add buffer vertices for
 * @param {number} distance the distance from the beginning of the line to the vertex
 * @param {number} endLeft extrude to shift the left vertex along the line
 * @param {number} endRight extrude to shift the left vertex along the line
 * @param {boolean} round whether this is a round cap
 * @private
 */
LineBucket.prototype.addCurrentVertex = function(currentVertex, distance, normal, endLeft, endRight, round) {
    var tx = round ? 1 : 0;
    var extrude;
    var layoutArrays = this.arrayGroups.line[this.arrayGroups.line.length - 1].layout;
    var vertexArray = layoutArrays.vertex;
    var elementArray = layoutArrays.element;

    extrude = normal.clone();
    if (endLeft) extrude._sub(normal.perp()._mult(endLeft));
    this.e3 = this.addLineVertex(vertexArray, currentVertex, extrude, tx, 0, endLeft, distance);
    if (this.e1 >= 0 && this.e2 >= 0) {
        elementArray.emplaceBack(this.e1, this.e2, this.e3);
    }
    this.e1 = this.e2;
    this.e2 = this.e3;

    extrude = normal.mult(-1);
    if (endRight) extrude._sub(normal.perp()._mult(endRight));
    this.e3 = this.addLineVertex(vertexArray, currentVertex, extrude, tx, 1, -endRight, distance);
    if (this.e1 >= 0 && this.e2 >= 0) {
        elementArray.emplaceBack(this.e1, this.e2, this.e3);
    }
    this.e1 = this.e2;
    this.e2 = this.e3;

    // There is a maximum "distance along the line" that we can store in the buffers.
    // When we get close to the distance, reset it to zero and add the vertex again with
    // a distance of zero. The max distance is determined by the number of bits we allocate
    // to `linesofar`.
    if (distance > MAX_LINE_DISTANCE / 2) {
        this.distance = 0;
        this.addCurrentVertex(currentVertex, this.distance, normal, endLeft, endRight, round);
    }
};

/**
 * Add a single new vertex and a triangle using two previous vertices.
 * This adds a pie slice triangle near a join to simulate round joins
 *
 * @param {Object} currentVertex the line vertex to add buffer vertices for
 * @param {number} distance the distance from the beggining of the line to the vertex
 * @param {Object} extrude the offset of the new vertex from the currentVertex
 * @param {boolean} whether the line is turning left or right at this angle
 * @private
 */
LineBucket.prototype.addPieSliceVertex = function(currentVertex, distance, extrude, lineTurnsLeft) {
    var ty = lineTurnsLeft ? 1 : 0;
    extrude = extrude.mult(lineTurnsLeft ? -1 : 1);
    var layoutArrays = this.arrayGroups.line[this.arrayGroups.line.length - 1].layout;
    var vertexArray = layoutArrays.vertex;
    var elementArray = layoutArrays.element;

    this.e3 = this.addLineVertex(vertexArray, currentVertex, extrude, 0, ty, 0, distance);

    if (this.e1 >= 0 && this.e2 >= 0) {
        elementArray.emplaceBack(this.e1, this.e2, this.e3);
    }

    if (lineTurnsLeft) {
        this.e2 = this.e3;
    } else {
        this.e1 = this.e3;
    }
};

},{"../../util/util":117,"../bucket":15,"../load_geometry":22}],19:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

var Bucket = require('../bucket');
var Anchor = require('../../symbol/anchor');
var getAnchors = require('../../symbol/get_anchors');
var resolveTokens = require('../../util/token');
var Quads = require('../../symbol/quads');
var Shaping = require('../../symbol/shaping');
var resolveText = require('../../symbol/resolve_text');
var mergeLines = require('../../symbol/mergelines');
var clipLine = require('../../symbol/clip_line');
var util = require('../../util/util');
var loadGeometry = require('../load_geometry');
var CollisionFeature = require('../../symbol/collision_feature');

var shapeText = Shaping.shapeText;
var shapeIcon = Shaping.shapeIcon;
var getGlyphQuads = Quads.getGlyphQuads;
var getIconQuads = Quads.getIconQuads;

var EXTENT = Bucket.EXTENT;

module.exports = SymbolBucket;

function SymbolBucket(options) {
    Bucket.apply(this, arguments);
    this.showCollisionBoxes = options.showCollisionBoxes;
    this.overscaling = options.overscaling;
    this.collisionBoxArray = options.collisionBoxArray;

    this.sdfIcons = options.sdfIcons;
    this.iconsNeedLinear = options.iconsNeedLinear;
    this.adjustedTextSize = options.adjustedTextSize;
    this.adjustedIconSize = options.adjustedIconSize;
    this.fontstack = options.fontstack;
}

SymbolBucket.prototype = util.inherit(Bucket, {});

SymbolBucket.prototype.serialize = function() {
    var serialized = Bucket.prototype.serialize.apply(this);
    serialized.sdfIcons = this.sdfIcons;
    serialized.iconsNeedLinear = this.iconsNeedLinear;
    serialized.adjustedTextSize = this.adjustedTextSize;
    serialized.adjustedIconSize = this.adjustedIconSize;
    serialized.fontstack = this.fontstack;
    return serialized;
};

var programAttributes = [{
    name: 'a_pos',
    components: 2,
    type: 'Int16'
}, {
    name: 'a_offset',
    components: 2,
    type: 'Int16'
}, {
    name: 'a_data1',
    components: 4,
    type: 'Uint8'
}, {
    name: 'a_data2',
    components: 2,
    type: 'Uint8'
}];

function addVertex(array, x, y, ox, oy, tx, ty, minzoom, maxzoom, labelminzoom) {
    return array.emplaceBack(
            // pos
            x,
            y,
            // offset
            Math.round(ox * 64), // use 1/64 pixels for placement
            Math.round(oy * 64),
            // data1
            tx / 4,                   // tex
            ty / 4,                   // tex
            (labelminzoom || 0) * 10, // labelminzoom
            0,
            // data2
            (minzoom || 0) * 10,               // minzoom
            Math.min(maxzoom || 25, 25) * 10); // minzoom
}

SymbolBucket.prototype.addCollisionBoxVertex = function(vertexArray, point, extrude, maxZoom, placementZoom) {
    return vertexArray.emplaceBack(
            // pos
            point.x,
            point.y,
            // extrude
            Math.round(extrude.x),
            Math.round(extrude.y),
            // data
            maxZoom * 10,
            placementZoom * 10);
};

SymbolBucket.prototype.programInterfaces = {

    glyph: {
        vertexBuffer: true,
        elementBuffer: true,
        layoutAttributes: programAttributes
    },

    icon: {
        vertexBuffer: true,
        elementBuffer: true,
        layoutAttributes: programAttributes
    },

    collisionBox: {
        vertexBuffer: true,

        layoutAttributes: [{
            name: 'a_pos',
            components: 2,
            type: 'Int16'
        }, {
            name: 'a_extrude',
            components: 2,
            type: 'Int16'
        }, {
            name: 'a_data',
            components: 2,
            type: 'Uint8'
        }]
    }
};

SymbolBucket.prototype.populateBuffers = function(collisionTile, stacks, icons) {

    // To reduce the number of labels that jump around when zooming we need
    // to use a text-size value that is the same for all zoom levels.
    // This calculates text-size at a high zoom level so that all tiles can
    // use the same value when calculating anchor positions.
    var zoomHistory = { lastIntegerZoom: Infinity, lastIntegerZoomTime: 0, lastZoom: 0 };
    this.adjustedTextMaxSize = this.layer.getLayoutValue('text-size', {zoom: 18, zoomHistory: zoomHistory});
    this.adjustedTextSize = this.layer.getLayoutValue('text-size', {zoom: this.zoom + 1, zoomHistory: zoomHistory});
    this.adjustedIconMaxSize = this.layer.getLayoutValue('icon-size', {zoom: 18, zoomHistory: zoomHistory});
    this.adjustedIconSize = this.layer.getLayoutValue('icon-size', {zoom: this.zoom + 1, zoomHistory: zoomHistory});

    var tileSize = 512 * this.overscaling;
    this.tilePixelRatio = EXTENT / tileSize;
    this.compareText = {};
    this.symbolInstances = [];
    this.iconsNeedLinear = false;

    var layout = this.layer.layout;
    var features = this.features;
    var textFeatures = this.textFeatures;

    var horizontalAlign = 0.5,
        verticalAlign = 0.5;

    switch (layout['text-anchor']) {
    case 'right':
    case 'top-right':
    case 'bottom-right':
        horizontalAlign = 1;
        break;
    case 'left':
    case 'top-left':
    case 'bottom-left':
        horizontalAlign = 0;
        break;
    }

    switch (layout['text-anchor']) {
    case 'bottom':
    case 'bottom-right':
    case 'bottom-left':
        verticalAlign = 1;
        break;
    case 'top':
    case 'top-right':
    case 'top-left':
        verticalAlign = 0;
        break;
    }

    var justify = layout['text-justify'] === 'right' ? 1 :
        layout['text-justify'] === 'left' ? 0 :
        0.5;

    var oneEm = 24;
    var lineHeight = layout['text-line-height'] * oneEm;
    var maxWidth = layout['symbol-placement'] !== 'line' ? layout['text-max-width'] * oneEm : 0;
    var spacing = layout['text-letter-spacing'] * oneEm;
    var textOffset = [layout['text-offset'][0] * oneEm, layout['text-offset'][1] * oneEm];
    var fontstack = this.fontstack = layout['text-font'].join(',');

    var geometries = [];
    for (var g = 0; g < features.length; g++) {
        geometries.push(loadGeometry(features[g]));
    }

    if (layout['symbol-placement'] === 'line') {
        // Merge adjacent lines with the same text to improve labelling.
        // It's better to place labels on one long line than on many short segments.
        var merged = mergeLines(features, textFeatures, geometries);

        geometries = merged.geometries;
        features = merged.features;
        textFeatures = merged.textFeatures;
    }

    var shapedText, shapedIcon;

    for (var k = 0; k < features.length; k++) {
        if (!geometries[k]) continue;

        if (textFeatures[k]) {
            shapedText = shapeText(textFeatures[k], stacks[fontstack], maxWidth,
                    lineHeight, horizontalAlign, verticalAlign, justify, spacing, textOffset);
        } else {
            shapedText = null;
        }

        if (layout['icon-image']) {
            var iconName = resolveTokens(features[k].properties, layout['icon-image']);
            var image = icons[iconName];
            shapedIcon = shapeIcon(image, layout);

            if (image) {
                if (this.sdfIcons === undefined) {
                    this.sdfIcons = image.sdf;
                } else if (this.sdfIcons !== image.sdf) {
                    console.warn('Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer');
                }
                if (image.pixelRatio !== 1) {
                    this.iconsNeedLinear = true;
                }
            }
        } else {
            shapedIcon = null;
        }

        if (shapedText || shapedIcon) {
            this.addFeature(geometries[k], shapedText, shapedIcon, features[k].index);
        }
    }

    this.placeFeatures(collisionTile, this.showCollisionBoxes);

    this.trimArrays();
};

SymbolBucket.prototype.addFeature = function(lines, shapedText, shapedIcon, featureIndex) {
    var layout = this.layer.layout;

    var glyphSize = 24;

    var fontScale = this.adjustedTextSize / glyphSize,
        textMaxSize = this.adjustedTextMaxSize !== undefined ? this.adjustedTextMaxSize : this.adjustedTextSize,
        textBoxScale = this.tilePixelRatio * fontScale,
        textMaxBoxScale = this.tilePixelRatio * textMaxSize / glyphSize,
        iconBoxScale = this.tilePixelRatio * this.adjustedIconSize,
        symbolMinDistance = this.tilePixelRatio * layout['symbol-spacing'],
        avoidEdges = layout['symbol-avoid-edges'],
        textPadding = layout['text-padding'] * this.tilePixelRatio,
        iconPadding = layout['icon-padding'] * this.tilePixelRatio,
        textMaxAngle = layout['text-max-angle'] / 180 * Math.PI,
        textAlongLine = layout['text-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line',
        iconAlongLine = layout['icon-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line',
        mayOverlap = layout['text-allow-overlap'] || layout['icon-allow-overlap'] ||
            layout['text-ignore-placement'] || layout['icon-ignore-placement'],
        isLine = layout['symbol-placement'] === 'line',
        textRepeatDistance = symbolMinDistance / 2;

    if (isLine) {
        lines = clipLine(lines, 0, 0, EXTENT, EXTENT);
    }

    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];

        // Calculate the anchor points around which you want to place labels
        var anchors;
        if (isLine) {
            anchors = getAnchors(
                line,
                symbolMinDistance,
                textMaxAngle,
                shapedText,
                shapedIcon,
                glyphSize,
                textMaxBoxScale,
                this.overscaling,
                EXTENT
            );
        } else {
            anchors = [ new Anchor(line[0].x, line[0].y, 0) ];
        }

        // For each potential label, create the placement features used to check for collisions, and the quads use for rendering.
        for (var j = 0, len = anchors.length; j < len; j++) {
            var anchor = anchors[j];

            if (shapedText && isLine) {
                if (this.anchorIsTooClose(shapedText.text, textRepeatDistance, anchor)) {
                    continue;
                }
            }

            var inside = !(anchor.x < 0 || anchor.x > EXTENT || anchor.y < 0 || anchor.y > EXTENT);

            if (avoidEdges && !inside) continue;

            // Normally symbol layers are drawn across tile boundaries. Only symbols
            // with their anchors within the tile boundaries are added to the buffers
            // to prevent symbols from being drawn twice.
            //
            // Symbols in layers with overlap are sorted in the y direction so that
            // symbols lower on the canvas are drawn on top of symbols near the top.
            // To preserve this order across tile boundaries these symbols can't
            // be drawn across tile boundaries. Instead they need to be included in
            // the buffers for both tiles and clipped to tile boundaries at draw time.
            var addToBuffers = inside || mayOverlap;

            this.symbolInstances.push(new SymbolInstance(anchor, line, shapedText, shapedIcon, layout,
                        addToBuffers, this.symbolInstances.length, this.collisionBoxArray, featureIndex, this.sourceLayerIndex, this.index,
                        textBoxScale, textPadding, textAlongLine,
                        iconBoxScale, iconPadding, iconAlongLine));
        }
    }
};

SymbolBucket.prototype.anchorIsTooClose = function(text, repeatDistance, anchor) {
    var compareText = this.compareText;
    if (!(text in compareText)) {
        compareText[text] = [];
    } else {
        var otherAnchors = compareText[text];
        for (var k = otherAnchors.length - 1; k >= 0; k--) {
            if (anchor.dist(otherAnchors[k]) < repeatDistance) {
                // If it's within repeatDistance of one anchor, stop looking
                return true;
            }
        }
    }
    // If anchor is not within repeatDistance of any other anchor, add to array
    compareText[text].push(anchor);
    return false;
};

SymbolBucket.prototype.placeFeatures = function(collisionTile, showCollisionBoxes) {
    this.recalculateStyleLayers();

    // Calculate which labels can be shown and when they can be shown and
    // create the bufers used for rendering.

    this.createArrays();

    var layout = this.layer.layout;

    var maxScale = collisionTile.maxScale;

    var textAlongLine = layout['text-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line';
    var iconAlongLine = layout['icon-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line';

    var mayOverlap = layout['text-allow-overlap'] || layout['icon-allow-overlap'] ||
        layout['text-ignore-placement'] || layout['icon-ignore-placement'];

    // Sort symbols by their y position on the canvas so that they lower symbols
    // are drawn on top of higher symbols.
    // Don't sort symbols that won't overlap because it isn't necessary and
    // because it causes more labels to pop in and out when rotating.
    if (mayOverlap) {
        var angle = collisionTile.angle;
        var sin = Math.sin(angle),
            cos = Math.cos(angle);

        this.symbolInstances.sort(function(a, b) {
            var aRotated = (sin * a.x + cos * a.y) | 0;
            var bRotated = (sin * b.x + cos * b.y) | 0;
            return (aRotated - bRotated) || (b.index - a.index);
        });
    }

    for (var p = 0; p < this.symbolInstances.length; p++) {
        var symbolInstance = this.symbolInstances[p];
        var hasText = symbolInstance.hasText;
        var hasIcon = symbolInstance.hasIcon;

        var iconWithoutText = layout['text-optional'] || !hasText,
            textWithoutIcon = layout['icon-optional'] || !hasIcon;


        // Calculate the scales at which the text and icon can be placed without collision.

        var glyphScale = hasText ?
            collisionTile.placeCollisionFeature(symbolInstance.textCollisionFeature,
                    layout['text-allow-overlap'], layout['symbol-avoid-edges']) :
            collisionTile.minScale;

        var iconScale = hasIcon ?
            collisionTile.placeCollisionFeature(symbolInstance.iconCollisionFeature,
                    layout['icon-allow-overlap'], layout['symbol-avoid-edges']) :
            collisionTile.minScale;


        // Combine the scales for icons and text.

        if (!iconWithoutText && !textWithoutIcon) {
            iconScale = glyphScale = Math.max(iconScale, glyphScale);
        } else if (!textWithoutIcon && glyphScale) {
            glyphScale = Math.max(iconScale, glyphScale);
        } else if (!iconWithoutText && iconScale) {
            iconScale = Math.max(iconScale, glyphScale);
        }


        // Insert final placement into collision tree and add glyphs/icons to buffers

        if (hasText) {
            collisionTile.insertCollisionFeature(symbolInstance.textCollisionFeature, glyphScale, layout['text-ignore-placement']);
            if (glyphScale <= maxScale) {
                this.addSymbols('glyph', symbolInstance.glyphQuads, glyphScale, layout['text-keep-upright'], textAlongLine, collisionTile.angle);
            }
        }

        if (hasIcon) {
            collisionTile.insertCollisionFeature(symbolInstance.iconCollisionFeature, iconScale, layout['icon-ignore-placement']);
            if (iconScale <= maxScale) {
                this.addSymbols('icon', symbolInstance.iconQuads, iconScale, layout['icon-keep-upright'], iconAlongLine, collisionTile.angle);
            }
        }

    }

    if (showCollisionBoxes) this.addToDebugBuffers(collisionTile);
};

SymbolBucket.prototype.addSymbols = function(programName, quads, scale, keepUpright, alongLine, placementAngle) {

    var group = this.makeRoomFor(programName, 4 * quads.length);

    var elementArray = group.layout.element;
    var vertexArray = group.layout.vertex;

    var zoom = this.zoom;
    var placementZoom = Math.max(Math.log(scale) / Math.LN2 + zoom, 0);

    for (var k = 0; k < quads.length; k++) {

        var symbol = quads[k],
            angle = symbol.angle;

        // drop upside down versions of glyphs
        var a = (angle + placementAngle + Math.PI) % (Math.PI * 2);
        if (keepUpright && alongLine && (a <= Math.PI / 2 || a > Math.PI * 3 / 2)) continue;

        var tl = symbol.tl,
            tr = symbol.tr,
            bl = symbol.bl,
            br = symbol.br,
            tex = symbol.tex,
            anchorPoint = symbol.anchorPoint,

            minZoom = Math.max(zoom + Math.log(symbol.minScale) / Math.LN2, placementZoom),
            maxZoom = Math.min(zoom + Math.log(symbol.maxScale) / Math.LN2, 25);

        if (maxZoom <= minZoom) continue;

        // Lower min zoom so that while fading out the label it can be shown outside of collision-free zoom levels
        if (minZoom === placementZoom) minZoom = 0;

        var index = addVertex(vertexArray, anchorPoint.x, anchorPoint.y, tl.x, tl.y, tex.x, tex.y, minZoom, maxZoom, placementZoom);
        addVertex(vertexArray, anchorPoint.x, anchorPoint.y, tr.x, tr.y, tex.x + tex.w, tex.y, minZoom, maxZoom, placementZoom);
        addVertex(vertexArray, anchorPoint.x, anchorPoint.y, bl.x, bl.y, tex.x, tex.y + tex.h, minZoom, maxZoom, placementZoom);
        addVertex(vertexArray, anchorPoint.x, anchorPoint.y, br.x, br.y, tex.x + tex.w, tex.y + tex.h, minZoom, maxZoom, placementZoom);

        elementArray.emplaceBack(index, index + 1, index + 2);
        elementArray.emplaceBack(index + 1, index + 2, index + 3);
    }

};

SymbolBucket.prototype.updateIcons = function(icons) {
    this.recalculateStyleLayers();
    var iconValue = this.layer.layout['icon-image'];
    if (!iconValue) return;

    for (var i = 0; i < this.features.length; i++) {
        var iconName = resolveTokens(this.features[i].properties, iconValue);
        if (iconName)
            icons[iconName] = true;
    }
};

SymbolBucket.prototype.updateFont = function(stacks) {
    this.recalculateStyleLayers();
    var fontName = this.layer.layout['text-font'],
        stack = stacks[fontName] = stacks[fontName] || {};

    this.textFeatures = resolveText(this.features, this.layer.layout, stack);
};

SymbolBucket.prototype.addToDebugBuffers = function(collisionTile) {
    var group = this.makeRoomFor('collisionBox', 0);
    var vertexArray = group.layout.vertex;
    var angle = -collisionTile.angle;
    var yStretch = collisionTile.yStretch;

    for (var j = 0; j < this.symbolInstances.length; j++) {
        for (var i = 0; i < 2; i++) {
            var feature = this.symbolInstances[j][i === 0 ? 'textCollisionFeature' : 'iconCollisionFeature'];
            if (!feature) continue;

            for (var b = feature.boxStartIndex; b < feature.boxEndIndex; b++) {
                var box = this.collisionBoxArray.get(b);
                var anchorPoint = box.anchorPoint;

                var tl = new Point(box.x1, box.y1 * yStretch)._rotate(angle);
                var tr = new Point(box.x2, box.y1 * yStretch)._rotate(angle);
                var bl = new Point(box.x1, box.y2 * yStretch)._rotate(angle);
                var br = new Point(box.x2, box.y2 * yStretch)._rotate(angle);

                var maxZoom = Math.max(0, Math.min(25, this.zoom + Math.log(box.maxScale) / Math.LN2));
                var placementZoom = Math.max(0, Math.min(25, this.zoom + Math.log(box.placementScale) / Math.LN2));

                this.addCollisionBoxVertex(vertexArray, anchorPoint, tl, maxZoom, placementZoom);
                this.addCollisionBoxVertex(vertexArray, anchorPoint, tr, maxZoom, placementZoom);
                this.addCollisionBoxVertex(vertexArray, anchorPoint, tr, maxZoom, placementZoom);
                this.addCollisionBoxVertex(vertexArray, anchorPoint, br, maxZoom, placementZoom);
                this.addCollisionBoxVertex(vertexArray, anchorPoint, br, maxZoom, placementZoom);
                this.addCollisionBoxVertex(vertexArray, anchorPoint, bl, maxZoom, placementZoom);
                this.addCollisionBoxVertex(vertexArray, anchorPoint, bl, maxZoom, placementZoom);
                this.addCollisionBoxVertex(vertexArray, anchorPoint, tl, maxZoom, placementZoom);
            }
        }
    }
};

function SymbolInstance(anchor, line, shapedText, shapedIcon, layout, addToBuffers, index, collisionBoxArray, featureIndex, sourceLayerIndex, bucketIndex,
                        textBoxScale, textPadding, textAlongLine,
                        iconBoxScale, iconPadding, iconAlongLine) {

    this.x = anchor.x;
    this.y = anchor.y;
    this.index = index;
    this.hasText = !!shapedText;
    this.hasIcon = !!shapedIcon;

    if (this.hasText) {
        this.glyphQuads = addToBuffers ? getGlyphQuads(anchor, shapedText, textBoxScale, line, layout, textAlongLine) : [];
        this.textCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex,
                shapedText, textBoxScale, textPadding, textAlongLine, false);
    }

    if (this.hasIcon) {
        this.iconQuads = addToBuffers ? getIconQuads(anchor, shapedIcon, iconBoxScale, line, layout, iconAlongLine) : [];
        this.iconCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex,
                shapedIcon, iconBoxScale, iconPadding, iconAlongLine, true);
    }
}

},{"../../symbol/anchor":71,"../../symbol/clip_line":73,"../../symbol/collision_feature":75,"../../symbol/get_anchors":77,"../../symbol/mergelines":80,"../../symbol/quads":81,"../../symbol/resolve_text":82,"../../symbol/shaping":83,"../../util/token":116,"../../util/util":117,"../bucket":15,"../load_geometry":22,"point-geometry":172}],20:[function(require,module,exports){
'use strict';

var assert = require('assert');

module.exports = Buffer;

/**
 * The `Buffer` class turns a `StructArray` into a WebGL buffer. Each member of the StructArray's
 * Struct type is converted to a WebGL atribute.
 *
 * @class Buffer
 * @private
 * @param {object} array A serialized StructArray.
 * @param {object} arrayType A serialized StructArrayType.
 * @param {BufferType} type
 */
function Buffer(array, arrayType, type) {
    this.arrayBuffer = array.arrayBuffer;
    this.length = array.length;
    this.attributes = arrayType.members;
    this.itemSize = arrayType.bytesPerElement;
    this.type = type;
    this.arrayType = arrayType;
}

/**
 * Bind this buffer to a WebGL context.
 * @private
 * @param gl The WebGL context
 */
Buffer.prototype.bind = function(gl) {
    var type = gl[this.type];

    if (!this.buffer) {
        this.buffer = gl.createBuffer();
        gl.bindBuffer(type, this.buffer);
        gl.bufferData(type, this.arrayBuffer, gl.STATIC_DRAW);

        // dump array buffer once it's bound to gl
        this.arrayBuffer = null;
    } else {
        gl.bindBuffer(type, this.buffer);
    }
};

/**
 * @enum {string} AttributeType
 * @private
 * @readonly
 */
var AttributeType = {
    Int8:   'BYTE',
    Uint8:  'UNSIGNED_BYTE',
    Int16:  'SHORT',
    Uint16: 'UNSIGNED_SHORT'
};

/**
 * Set the attribute pointers in a WebGL context
 * @private
 * @param gl The WebGL context
 * @param program The active WebGL program
 */
Buffer.prototype.setVertexAttribPointers = function(gl, program) {
    for (var j = 0; j < this.attributes.length; j++) {
        var member = this.attributes[j];
        var attribIndex = program[member.name];
        assert(attribIndex !== undefined, 'array member "' + member.name + '" name does not match shader attribute name');

        gl.vertexAttribPointer(
            attribIndex,
            member.components,
            gl[AttributeType[member.type]],
            false,
            this.arrayType.bytesPerElement,
            member.offset
        );
    }
};

/**
 * Destroy the GL buffer bound to the given WebGL context
 * @private
 * @param gl The WebGL context
 */
Buffer.prototype.destroy = function(gl) {
    if (this.buffer) {
        gl.deleteBuffer(this.buffer);
    }
};

/**
 * @enum {string} BufferType
 * @private
 * @readonly
 */
Buffer.BufferType = {
    VERTEX: 'ARRAY_BUFFER',
    ELEMENT: 'ELEMENT_ARRAY_BUFFER'
};

/**
 * An `BufferType.ELEMENT` buffer holds indicies of a corresponding `BufferType.VERTEX` buffer.
 * These indicies are stored in the `BufferType.ELEMENT` buffer as `UNSIGNED_SHORT`s.
 *
 * @private
 * @readonly
 */
Buffer.ELEMENT_ATTRIBUTE_TYPE = 'Uint16';

/**
 * WebGL performs best if vertex attribute offsets are aligned to 4 byte boundaries.
 * @private
 * @readonly
 */
Buffer.VERTEX_ATTRIBUTE_ALIGNMENT = 4;

},{"assert":9}],21:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');
var loadGeometry = require('./load_geometry');
var EXTENT = require('./bucket').EXTENT;
var featureFilter = require('feature-filter');
var StructArrayType = require('../util/struct_array');
var Grid = require('grid-index');
var DictionaryCoder = require('../util/dictionary_coder');
var vt = require('vector-tile');
var Protobuf = require('pbf');
var GeoJSONFeature = require('../util/vectortile_to_geojson');
var arraysIntersect = require('../util/util').arraysIntersect;

var intersection = require('../util/intersection_tests');
var multiPolygonIntersectsBufferedMultiPoint = intersection.multiPolygonIntersectsBufferedMultiPoint;
var multiPolygonIntersectsMultiPolygon = intersection.multiPolygonIntersectsMultiPolygon;
var multiPolygonIntersectsBufferedMultiLine = intersection.multiPolygonIntersectsBufferedMultiLine;


var FeatureIndexArray = new StructArrayType({
    members: [
        // the index of the feature in the original vectortile
        { type: 'Uint32', name: 'featureIndex' },
        // the source layer the feature appears in
        { type: 'Uint16', name: 'sourceLayerIndex' },
        // the bucket the feature appears in
        { type: 'Uint16', name: 'bucketIndex' }
    ]});

module.exports = FeatureIndex;

function FeatureIndex(coord, overscaling, collisionTile) {
    if (coord.grid) {
        var serialized = coord;
        var rawTileData = overscaling;
        coord = serialized.coord;
        overscaling = serialized.overscaling;
        this.grid = new Grid(serialized.grid);
        this.featureIndexArray = new FeatureIndexArray(serialized.featureIndexArray);
        this.rawTileData = rawTileData;
        this.bucketLayerIDs = serialized.bucketLayerIDs;
    } else {
        this.grid = new Grid(EXTENT, 16, 0);
        this.featureIndexArray = new FeatureIndexArray();
    }
    this.coord = coord;
    this.overscaling = overscaling;
    this.x = coord.x;
    this.y = coord.y;
    this.z = coord.z - Math.log(overscaling) / Math.LN2;
    this.setCollisionTile(collisionTile);
}

FeatureIndex.prototype.insert = function(feature, featureIndex, sourceLayerIndex, bucketIndex) {
    var key = this.featureIndexArray.length;
    this.featureIndexArray.emplaceBack(featureIndex, sourceLayerIndex, bucketIndex);
    var geometry = loadGeometry(feature);

    for (var r = 0; r < geometry.length; r++) {
        var ring = geometry[r];

        // TODO: skip holes when we start using vector tile spec 2.0

        var bbox = [Infinity, Infinity, -Infinity, -Infinity];
        for (var i = 0; i < ring.length; i++) {
            var p = ring[i];
            bbox[0] = Math.min(bbox[0], p.x);
            bbox[1] = Math.min(bbox[1], p.y);
            bbox[2] = Math.max(bbox[2], p.x);
            bbox[3] = Math.max(bbox[3], p.y);
        }

        this.grid.insert(key, bbox[0], bbox[1], bbox[2], bbox[3]);
    }
};

FeatureIndex.prototype.setCollisionTile = function(collisionTile) {
    this.collisionTile = collisionTile;
};

FeatureIndex.prototype.serialize = function() {
    var data = {
        coord: this.coord,
        overscaling: this.overscaling,
        grid: this.grid.toArrayBuffer(),
        featureIndexArray: this.featureIndexArray.serialize(),
        bucketLayerIDs: this.bucketLayerIDs
    };
    return {
        data: data,
        transferables: [data.grid, data.featureIndexArray.arrayBuffer]
    };
};

function translateDistance(translate) {
    return Math.sqrt(translate[0] * translate[0] + translate[1] * translate[1]);
}

// Finds features in this tile at a particular position.
FeatureIndex.prototype.query = function(args, styleLayers) {
    if (!this.vtLayers) {
        this.vtLayers = new vt.VectorTile(new Protobuf(new Uint8Array(this.rawTileData))).layers;
        this.sourceLayerCoder = new DictionaryCoder(this.vtLayers ? Object.keys(this.vtLayers).sort() : ['_geojsonTileLayer']);
    }

    var result = {};

    var params = args.params || {},
        pixelsToTileUnits = EXTENT / args.tileSize / args.scale,
        filter = featureFilter(params.filter);

    // Features are indexed their original geometries. The rendered geometries may
    // be buffered, translated or offset. Figure out how much the search radius needs to be
    // expanded by to include these features.
    var additionalRadius = 0;
    for (var id in styleLayers) {
        var styleLayer = styleLayers[id];
        var paint = styleLayer.paint;

        var styleLayerDistance = 0;
        if (styleLayer.type === 'line') {
            styleLayerDistance = getLineWidth(paint) / 2 + Math.abs(paint['line-offset']) + translateDistance(paint['line-translate']);
        } else if (styleLayer.type === 'fill') {
            styleLayerDistance = translateDistance(paint['fill-translate']);
        } else if (styleLayer.type === 'circle') {
            styleLayerDistance = paint['circle-radius'] + translateDistance(paint['circle-translate']);
        }
        additionalRadius = Math.max(additionalRadius, styleLayerDistance * pixelsToTileUnits);
    }

    var queryGeometry = args.queryGeometry.map(function(q) {
        return q.map(function(p) {
            return new Point(p.x, p.y);
        });
    });

    var minX = Infinity;
    var minY = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    for (var i = 0; i < queryGeometry.length; i++) {
        var ring = queryGeometry[i];
        for (var k = 0; k < ring.length; k++) {
            var p = ring[k];
            minX = Math.min(minX, p.x);
            minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x);
            maxY = Math.max(maxY, p.y);
        }
    }

    var matching = this.grid.query(minX - additionalRadius, minY - additionalRadius, maxX + additionalRadius, maxY + additionalRadius);
    matching.sort(topDownFeatureComparator);
    this.filterMatching(result, matching, this.featureIndexArray, queryGeometry, filter, params.layers, styleLayers, args.bearing, pixelsToTileUnits);

    var matchingSymbols = this.collisionTile.queryRenderedSymbols(minX, minY, maxX, maxY, args.scale);
    matchingSymbols.sort();
    this.filterMatching(result, matchingSymbols, this.collisionTile.collisionBoxArray, queryGeometry, filter, params.layers, styleLayers, args.bearing, pixelsToTileUnits);

    return result;
};

function topDownFeatureComparator(a, b) {
    return b - a;
}

function getLineWidth(paint) {
    if (paint['line-gap-width'] > 0) {
        return paint['line-gap-width'] + 2 * paint['line-width'];
    } else {
        return paint['line-width'];
    }
}

FeatureIndex.prototype.filterMatching = function(result, matching, array, queryGeometry, filter, filterLayerIDs, styleLayers, bearing, pixelsToTileUnits) {
    var previousIndex;
    for (var k = 0; k < matching.length; k++) {
        var index = matching[k];

        // don't check the same feature more than once
        if (index === previousIndex) continue;
        previousIndex = index;

        var match = array.get(index);

        var layerIDs = this.bucketLayerIDs[match.bucketIndex];
        if (filterLayerIDs && !arraysIntersect(filterLayerIDs, layerIDs)) continue;

        var sourceLayerName = this.sourceLayerCoder.decode(match.sourceLayerIndex);
        var sourceLayer = this.vtLayers[sourceLayerName];
        var feature = sourceLayer.feature(match.featureIndex);

        if (!filter(feature)) continue;

        var geometry = null;

        for (var l = 0; l < layerIDs.length; l++) {
            var layerID = layerIDs[l];

            if (filterLayerIDs && filterLayerIDs.indexOf(layerID) < 0) {
                continue;
            }

            var styleLayer = styleLayers[layerID];
            if (!styleLayer) continue;

            var translatedPolygon;
            if (styleLayer.type !== 'symbol') {
                // all symbols already match the style

                if (!geometry) geometry = loadGeometry(feature);

                var paint = styleLayer.paint;

                if (styleLayer.type === 'line') {
                    translatedPolygon = translate(queryGeometry,
                            paint['line-translate'], paint['line-translate-anchor'],
                            bearing, pixelsToTileUnits);
                    var halfWidth = getLineWidth(paint) / 2 * pixelsToTileUnits;
                    if (paint['line-offset']) {
                        geometry = offsetLine(geometry, paint['line-offset'] * pixelsToTileUnits);
                    }
                    if (!multiPolygonIntersectsBufferedMultiLine(translatedPolygon, geometry, halfWidth)) continue;

                } else if (styleLayer.type === 'fill') {
                    translatedPolygon = translate(queryGeometry,
                            paint['fill-translate'], paint['fill-translate-anchor'],
                            bearing, pixelsToTileUnits);
                    if (!multiPolygonIntersectsMultiPolygon(translatedPolygon, geometry)) continue;

                } else if (styleLayer.type === 'circle') {
                    translatedPolygon = translate(queryGeometry,
                            paint['circle-translate'], paint['circle-translate-anchor'],
                            bearing, pixelsToTileUnits);
                    var circleRadius = paint['circle-radius'] * pixelsToTileUnits;
                    if (!multiPolygonIntersectsBufferedMultiPoint(translatedPolygon, geometry, circleRadius)) continue;
                }
            }

            var geojsonFeature = new GeoJSONFeature(feature, this.z, this.x, this.y);
            geojsonFeature.layer = styleLayer.serialize({
                includeRefProperties: true
            });
            var layerResult = result[layerID];
            if (layerResult === undefined) {
                layerResult = result[layerID] = [];
            }
            layerResult.push(geojsonFeature);
        }
    }
};

function translate(queryGeometry, translate, translateAnchor, bearing, pixelsToTileUnits) {
    if (!translate[0] && !translate[1]) {
        return queryGeometry;
    }

    translate = Point.convert(translate);

    if (translateAnchor === "viewport") {
        translate._rotate(-bearing);
    }

    var translated = [];
    for (var i = 0; i < queryGeometry.length; i++) {
        var ring = queryGeometry[i];
        var translatedRing = [];
        for (var k = 0; k < ring.length; k++) {
            translatedRing.push(ring[k].sub(translate._mult(pixelsToTileUnits)));
        }
        translated.push(translatedRing);
    }
    return translated;
}

function offsetLine(rings, offset) {
    var newRings = [];
    var zero = new Point(0, 0);
    for (var k = 0; k < rings.length; k++) {
        var ring = rings[k];
        var newRing = [];
        for (var i = 0; i < ring.length; i++) {
            var a = ring[i - 1];
            var b = ring[i];
            var c = ring[i + 1];
            var aToB = i === 0 ? zero : b.sub(a)._unit()._perp();
            var bToC = i === ring.length - 1 ? zero : c.sub(b)._unit()._perp();
            var extrude = aToB._add(bToC)._unit();

            var cosHalfAngle = extrude.x * bToC.x + extrude.y * bToC.y;
            extrude._mult(1 / cosHalfAngle);

            newRing.push(extrude._mult(offset)._add(b));
        }
        newRings.push(newRing);
    }
    return newRings;
}

},{"../util/dictionary_coder":108,"../util/intersection_tests":112,"../util/struct_array":115,"../util/util":117,"../util/vectortile_to_geojson":118,"./bucket":15,"./load_geometry":22,"feature-filter":120,"grid-index":141,"pbf":170,"point-geometry":172,"vector-tile":181}],22:[function(require,module,exports){
'use strict';

var EXTENT = require('./bucket').EXTENT;
var EXTENT_MIN = EXTENT * -2;
var EXTENT_MAX = (EXTENT * 2) - 1;

// only log a geometry warning once per context
var warned = false;

/**
 * Loads a geometry from a VectorTileFeature and scales it to the common extent
 * used internally.
 * @private
 */
module.exports = function loadGeometry(feature) {
    var scale = EXTENT / feature.extent;
    var geometry = feature.loadGeometry();
    for (var r = 0; r < geometry.length; r++) {
        var ring = geometry[r];
        for (var p = 0; p < ring.length; p++) {
            var point = ring[p];
            // round here because mapbox-gl-native uses integers to represent
            // points and we need to do the same to avoid renering differences.
            point.x = Math.round(point.x * scale);
            point.y = Math.round(point.y * scale);
            if (warned === false && (
                point.x < EXTENT_MIN ||
                point.x > EXTENT_MAX ||
                point.y < EXTENT_MIN ||
                point.y > EXTENT_MAX)) {
                console.warn('Geometry exceeds allowed extent, reduce your vector tile buffer size');
                warned = true;
            }
        }
    }
    return geometry;
};

},{"./bucket":15}],23:[function(require,module,exports){
'use strict';

module.exports = Coordinate;

/**
 * A coordinate is a column, row, zoom combination, often used
 * as the data component of a tile.
 *
 * @param {number} column
 * @param {number} row
 * @param {number} zoom
 * @private
 */
function Coordinate(column, row, zoom) {
    this.column = column;
    this.row = row;
    this.zoom = zoom;
}

Coordinate.prototype = {

    /**
     * Create a clone of this coordinate that can be mutated without
     * changing the original coordinate
     *
     * @returns {Coordinate} clone
     * @private
     * var coord = new Coordinate(0, 0, 0);
     * var c2 = coord.clone();
     * // since coord is cloned, modifying a property of c2 does
     * // not modify it.
     * c2.zoom = 2;
     */
    clone: function() {
        return new Coordinate(this.column, this.row, this.zoom);
    },

    /**
     * Zoom this coordinate to a given zoom level. This returns a new
     * coordinate object, not mutating the old one.
     *
     * @param {number} zoom
     * @returns {Coordinate} zoomed coordinate
     * @private
     * @example
     * var coord = new Coordinate(0, 0, 0);
     * var c2 = coord.zoomTo(1);
     * c2 // equals new Coordinate(0, 0, 1);
     */
    zoomTo: function(zoom) { return this.clone()._zoomTo(zoom); },

    /**
     * Subtract the column and row values of this coordinate from those
     * of another coordinate. The other coordinat will be zoomed to the
     * same level as `this` before the subtraction occurs
     *
     * @param {Coordinate} c other coordinate
     * @returns {Coordinate} result
     * @private
     */
    sub: function(c) { return this.clone()._sub(c); },

    _zoomTo: function(zoom) {
        var scale = Math.pow(2, zoom - this.zoom);
        this.column *= scale;
        this.row *= scale;
        this.zoom = zoom;
        return this;
    },

    _sub: function(c) {
        c = c.zoomTo(this.zoom);
        this.column -= c.column;
        this.row -= c.row;
        return this;
    }
};

},{}],24:[function(require,module,exports){
'use strict';

module.exports = LngLat;

var wrap = require('../util/util').wrap;

/**
 * Create a longitude, latitude object from a given longitude and latitude pair in degrees.
 * Mapbox GL uses Longitude, Latitude coordinate order to match GeoJSON.
 *
 * Note that any Mapbox GL method that accepts a `LngLat` object can also accept an
 * `Array` and will perform an implicit conversion.  The following lines are equivalent:
 ```
 map.setCenter([-73.9749, 40.7736]);
 map.setCenter( new mapboxgl.LngLat(-73.9749, 40.7736) );
 ```
 *
 * @class LngLat
 * @classdesc A representation of a longitude, latitude point, in degrees.
 * @param {number} lng longitude
 * @param {number} lat latitude
 * @example
 * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);
 */
function LngLat(lng, lat) {
    if (isNaN(lng) || isNaN(lat)) {
        throw new Error('Invalid LngLat object: (' + lng + ', ' + lat + ')');
    }
    this.lng = +lng;
    this.lat = +lat;
    if (this.lat > 90 || this.lat < -90) {
        throw new Error('Invalid LngLat latitude value: must be between -90 and 90');
    }
}

/**
 * Return a new `LngLat` object whose longitude is wrapped to the range (-180, 180).
 *
 * @returns {LngLat} wrapped LngLat object
 * @example
 * var ll = new mapboxgl.LngLat(286.0251, 40.7736);
 * var wrapped = ll.wrap();
 * wrapped.lng; // = -73.9749
 */
LngLat.prototype.wrap = function () {
    return new LngLat(wrap(this.lng, -180, 180), this.lat);
};

/**
 * Return a `LngLat` as an array
 *
 * @returns {array} [lng, lat]
 * @example
 * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);
 * ll.toArray(); // = [-73.9749, 40.7736]
 */
LngLat.prototype.toArray = function () {
    return [this.lng, this.lat];
};

/**
 * Return a `LngLat` as a string
 *
 * @returns {string} "LngLat(lng, lat)"
 * @example
 * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);
 * ll.toString(); // = "LngLat(-73.9749, 40.7736)"
 */
LngLat.prototype.toString = function () {
    return 'LngLat(' + this.lng + ', ' + this.lat + ')';
};

/**
 * Convert an array to a `LngLat` object, or return an existing `LngLat` object
 * unchanged.
 *
 * @param {Array<number>|LngLat} input `input` to convert
 * @returns {LngLat} LngLat object or original input
 * @example
 * var arr = [-73.9749, 40.7736];
 * var ll = mapboxgl.LngLat.convert(arr);
 * ll;   // = LngLat {lng: -73.9749, lat: 40.7736}
 */
LngLat.convert = function (input) {
    if (input instanceof LngLat) {
        return input;
    }
    if (Array.isArray(input)) {
        return new LngLat(input[0], input[1]);
    }
    return input;
};

},{"../util/util":117}],25:[function(require,module,exports){
'use strict';

module.exports = LngLatBounds;

var LngLat = require('./lng_lat');

/**
 * Creates a bounding box from the given pair of points. If parameteres are omitted, a `null` bounding box is created.
 *
 * @class LngLatBounds
 * @classdesc A representation of rectangular box on the earth, defined by its southwest and northeast points in longitude and latitude.
 * @param {LngLat} sw southwest
 * @param {LngLat} ne northeast
 * @example
 * var sw = new mapboxgl.LngLat(-73.9876, 40.7661);
 * var ne = new mapboxgl.LngLat(-73.9397, 40.8002);
 * var llb = new mapboxgl.LngLatBounds(sw, ne);
 */
function LngLatBounds(sw, ne) {
    if (!sw) {
        return;
    } else if (ne) {
        this.extend(sw).extend(ne);
    } else if (sw.length === 4) {
        this.extend([sw[0], sw[1]]).extend([sw[2], sw[3]]);
    } else {
        this.extend(sw[0]).extend(sw[1]);
    }
}

LngLatBounds.prototype = {

    /**
     * Extend the bounds to include a given LngLat or LngLatBounds.
     *
     * @param {LngLat|LngLatBounds} obj object to extend to
     * @returns {LngLatBounds} `this`
     */
    extend: function(obj) {
        var sw = this._sw,
            ne = this._ne,
            sw2, ne2;

        if (obj instanceof LngLat) {
            sw2 = obj;
            ne2 = obj;

        } else if (obj instanceof LngLatBounds) {
            sw2 = obj._sw;
            ne2 = obj._ne;

            if (!sw2 || !ne2) return this;

        } else {
            return obj ? this.extend(LngLat.convert(obj) || LngLatBounds.convert(obj)) : this;
        }

        if (!sw && !ne) {
            this._sw = new LngLat(sw2.lng, sw2.lat);
            this._ne = new LngLat(ne2.lng, ne2.lat);

        } else {
            sw.lng = Math.min(sw2.lng, sw.lng);
            sw.lat = Math.min(sw2.lat, sw.lat);
            ne.lng = Math.max(ne2.lng, ne.lng);
            ne.lat = Math.max(ne2.lat, ne.lat);
        }

        return this;
    },

    /**
     * Get the point equidistant from this box's corners
     * @returns {LngLat} centerpoint
     * @example
     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
     * llb.getCenter(); // = LngLat {lng: -73.96365, lat: 40.78315}
     */
    getCenter: function() {
        return new LngLat((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
    },

    /**
     * Get southwest corner
     * @returns {LngLat} southwest
     */
    getSouthWest: function() { return this._sw; },

    /**
     * Get northeast corner
     * @returns {LngLat} northeast
     */
    getNorthEast: function() { return this._ne; },

    /**
     * Get northwest corner
     * @returns {LngLat} northwest
     */
    getNorthWest: function() { return new LngLat(this.getWest(), this.getNorth()); },

    /**
     * Get southeast corner
     * @returns {LngLat} southeast
     */
    getSouthEast: function() { return new LngLat(this.getEast(), this.getSouth()); },

    /**
     * Get west edge longitude
     * @returns {number} west
     */
    getWest:  function() { return this._sw.lng; },

    /**
     * Get south edge latitude
     * @returns {number} south
     */
    getSouth: function() { return this._sw.lat; },

    /**
     * Get east edge longitude
     * @returns {number} east
     */
    getEast:  function() { return this._ne.lng; },

    /**
     * Get north edge latitude
     * @returns {number} north
     */
    getNorth: function() { return this._ne.lat; },

    /**
     * Return a `LngLatBounds` as an array
     *
     * @returns {array} [lng, lat]
     * @example
     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
     * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]
     */
    toArray: function () {
        return [this._sw.toArray(), this._ne.toArray()];
    },

    /**
     * Return a `LngLatBounds` as a string
     *
     * @returns {string} "LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))"
     * @example
     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
     * llb.toString(); // = "LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))"
     */
    toString: function () {
        return 'LngLatBounds(' + this._sw.toString() + ', ' + this._ne.toString() + ')';
    }
};

/**
 * Convert an array to a `LngLatBounds` object, or return an existing
 * `LngLatBounds` object unchanged.
 *
 * Calls `LngLat#convert` internally to convert arrays as `LngLat` values.
 *
 * @param {LngLatBounds|Array<number>|Array<Array<number>>} input input to convert to a LngLatBounds
 * @returns {LngLatBounds} LngLatBounds object or original input
 * @example
 * var arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];
 * var llb = mapboxgl.LngLatBounds.convert(arr);
 * llb;   // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}
 */
LngLatBounds.convert = function (input) {
    if (!input || input instanceof LngLatBounds) return input;
    return new LngLatBounds(input);
};

},{"./lng_lat":24}],26:[function(require,module,exports){
'use strict';

var LngLat = require('./lng_lat'),
    Point = require('point-geometry'),
    Coordinate = require('./coordinate'),
    wrap = require('../util/util').wrap,
    interp = require('../util/interpolate'),
    TileCoord = require('../source/tile_coord'),
    EXTENT = require('../data/bucket').EXTENT,
    glmatrix = require('gl-matrix');

var vec4 = glmatrix.vec4,
    mat4 = glmatrix.mat4,
    mat2 = glmatrix.mat2;

module.exports = Transform;

/**
 * A single transform, generally used for a single tile to be
 * scaled, rotated, and zoomed.
 *
 * @param {number} minZoom
 * @param {number} maxZoom
 * @private
 */
function Transform(minZoom, maxZoom) {
    this.tileSize = 512; // constant

    this._minZoom = minZoom || 0;
    this._maxZoom = maxZoom || 22;

    this.latRange = [-85.05113, 85.05113];

    this.width = 0;
    this.height = 0;
    this._center = new LngLat(0, 0);
    this.zoom = 0;
    this.angle = 0;
    this._altitude = 1.5;
    this._pitch = 0;
    this._unmodified = true;
}

Transform.prototype = {
    get minZoom() { return this._minZoom; },
    set minZoom(zoom) {
        if (this._minZoom === zoom) return;
        this._minZoom = zoom;
        this.zoom = Math.max(this.zoom, zoom);
    },

    get maxZoom() { return this._maxZoom; },
    set maxZoom(zoom) {
        if (this._maxZoom === zoom) return;
        this._maxZoom = zoom;
        this.zoom = Math.min(this.zoom, zoom);
    },

    get worldSize() {
        return this.tileSize * this.scale;
    },

    get centerPoint() {
        return this.size._div(2);
    },

    get size() {
        return new Point(this.width, this.height);
    },

    get bearing() {
        return -this.angle / Math.PI * 180;
    },
    set bearing(bearing) {
        var b = -wrap(bearing, -180, 180) * Math.PI / 180;
        if (this.angle === b) return;
        this._unmodified = false;
        this.angle = b;
        this._calcProjMatrix();

        // 2x2 matrix for rotating points
        this.rotationMatrix = mat2.create();
        mat2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle);
    },

    get pitch() {
        return this._pitch / Math.PI * 180;
    },
    set pitch(pitch) {
        var p = Math.min(60, pitch) / 180 * Math.PI;
        if (this._pitch === p) return;
        this._unmodified = false;
        this._pitch = p;
        this._calcProjMatrix();
    },

    get altitude() {
        return this._altitude;
    },
    set altitude(altitude) {
        var a = Math.max(0.75, altitude);
        if (this._altitude === a) return;
        this._unmodified = false;
        this._altitude = a;
        this._calcProjMatrix();
    },

    get zoom() { return this._zoom; },
    set zoom(zoom) {
        var z = Math.min(Math.max(zoom, this.minZoom), this.maxZoom);
        if (this._zoom === z) return;
        this._unmodified = false;
        this._zoom = z;
        this.scale = this.zoomScale(z);
        this.tileZoom = Math.floor(z);
        this.zoomFraction = z - this.tileZoom;
        this._calcProjMatrix();
        this._constrain();
    },

    get center() { return this._center; },
    set center(center) {
        if (center.lat === this._center.lat && center.lng === this._center.lng) return;
        this._unmodified = false;
        this._center = center;
        this._calcProjMatrix();
        this._constrain();
    },

    resize: function(width, height) {
        this.width = width;
        this.height = height;

        this.pixelsToGLUnits = [2 / width, -2 / height];
        this._calcProjMatrix();
        this._constrain();
    },

    get unmodified() { return this._unmodified; },

    zoomScale: function(zoom) { return Math.pow(2, zoom); },
    scaleZoom: function(scale) { return Math.log(scale) / Math.LN2; },

    project: function(lnglat, worldSize) {
        return new Point(
            this.lngX(lnglat.lng, worldSize),
            this.latY(lnglat.lat, worldSize));
    },

    unproject: function(point, worldSize) {
        return new LngLat(
            this.xLng(point.x, worldSize),
            this.yLat(point.y, worldSize));
    },

    get x() { return this.lngX(this.center.lng); },
    get y() { return this.latY(this.center.lat); },

    get point() { return new Point(this.x, this.y); },

    /**
     * latitude to absolute x coord
     * @param {number} lon
     * @param {number} [worldSize=this.worldSize]
     * @returns {number} pixel coordinate
     * @private
     */
    lngX: function(lng, worldSize) {
        return (180 + lng) * (worldSize || this.worldSize) / 360;
    },
    /**
     * latitude to absolute y coord
     * @param {number} lat
     * @param {number} [worldSize=this.worldSize]
     * @returns {number} pixel coordinate
     * @private
     */
    latY: function(lat, worldSize) {
        var y = 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360));
        return (180 - y) * (worldSize || this.worldSize) / 360;
    },

    xLng: function(x, worldSize) {
        return x * 360 / (worldSize || this.worldSize) - 180;
    },
    yLat: function(y, worldSize) {
        var y2 = 180 - y * 360 / (worldSize || this.worldSize);
        return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
    },

    panBy: function(offset) {
        var point = this.centerPoint._add(offset);
        this.center = this.pointLocation(point);
    },

    setLocationAtPoint: function(lnglat, point) {
        var c = this.locationCoordinate(lnglat);
        var coordAtPoint = this.pointCoordinate(point);
        var coordCenter = this.pointCoordinate(this.centerPoint);
        var translate = coordAtPoint._sub(c);
        this._unmodified = false;
        this.center = this.coordinateLocation(coordCenter._sub(translate));
    },

    /**
     * Given a location, return the screen point that corresponds to it
     * @param {LngLat} lnglat location
     * @returns {Point} screen point
     * @private
     */
    locationPoint: function(lnglat) {
        return this.coordinatePoint(this.locationCoordinate(lnglat));
    },

    /**
     * Given a point on screen, return its lnglat
     * @param {Point} p screen point
     * @returns {LngLat} lnglat location
     * @private
     */
    pointLocation: function(p) {
        return this.coordinateLocation(this.pointCoordinate(p));
    },

    /**
     * Given a geographical lnglat, return an unrounded
     * coordinate that represents it at this transform's zoom level and
     * worldsize.
     * @param {LngLat} lnglat
     * @returns {Coordinate}
     * @private
     */
    locationCoordinate: function(lnglat) {
        var k = this.zoomScale(this.tileZoom) / this.worldSize,
            ll = LngLat.convert(lnglat);

        return new Coordinate(
            this.lngX(ll.lng) * k,
            this.latY(ll.lat) * k,
            this.tileZoom);
    },

    /**
     * Given a Coordinate, return its geographical position.
     * @param {Coordinate} coord
     * @returns {LngLat} lnglat
     * @private
     */
    coordinateLocation: function(coord) {
        var worldSize = this.zoomScale(coord.zoom);
        return new LngLat(
            this.xLng(coord.column, worldSize),
            this.yLat(coord.row, worldSize));
    },

    pointCoordinate: function(p) {

        var targetZ = 0;

        var matrix = this.coordinatePointMatrix(this.tileZoom);
        mat4.invert(matrix, matrix);

        if (!matrix) throw new Error("failed to invert matrix");

        // since we don't know the correct projected z value for the point,
        // unproject two points to get a line and then find the point on that
        // line with z=0

        var coord0 = [p.x, p.y, 0, 1];
        var coord1 = [p.x, p.y, 1, 1];

        vec4.transformMat4(coord0, coord0, matrix);
        vec4.transformMat4(coord1, coord1, matrix);

        var w0 = coord0[3];
        var w1 = coord1[3];
        var x0 = coord0[0] / w0;
        var x1 = coord1[0] / w1;
        var y0 = coord0[1] / w0;
        var y1 = coord1[1] / w1;
        var z0 = coord0[2] / w0;
        var z1 = coord1[2] / w1;


        var t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);

        return new Coordinate(
            interp(x0, x1, t),
            interp(y0, y1, t),
            this.tileZoom);
    },

    /**
     * Given a coordinate, return the screen point that corresponds to it
     * @param {Coordinate} coord
     * @returns {Point} screen point
     * @private
     */
    coordinatePoint: function(coord) {
        var matrix = this.coordinatePointMatrix(coord.zoom);
        var p = [coord.column, coord.row, 0, 1];
        vec4.transformMat4(p, p, matrix);
        return new Point(p[0] / p[3], p[1] / p[3]);
    },

    coordinatePointMatrix: function(z) {
        var proj = mat4.copy(new Float64Array(16), this.projMatrix);
        var scale = this.worldSize / this.zoomScale(z);
        mat4.scale(proj, proj, [scale, scale, 1]);
        mat4.multiply(proj, this.getPixelMatrix(), proj);
        return proj;
    },

    /**
     * converts gl coordinates -1..1 to pixels 0..width
     * @returns {Object} matrix
     * @private
     */
    getPixelMatrix: function() {
        var m = mat4.create();
        mat4.scale(m, m, [this.width / 2, -this.height / 2, 1]);
        mat4.translate(m, m, [1, -1, 0]);
        return m;
    },

    /**
     * Calculate the posMatrix that, given a tile coordinate, would be used to display the tile on a map.
     * @param {TileCoord|Coordinate} coord
     * @param {Number} maxZoom maximum source zoom to account for overscaling
     * @private
     */
    calculatePosMatrix: function(coord, maxZoom) {
        if (maxZoom === undefined) maxZoom = Infinity;
        if (coord instanceof TileCoord) coord = coord.toCoordinate(maxZoom);

        // Initialize model-view matrix that converts from the tile coordinates to screen coordinates.

        // if z > maxzoom then the tile is actually a overscaled maxzoom tile,
        // so calculate the matrix the maxzoom tile would use.
        var z = Math.min(coord.zoom, maxZoom);

        var scale = this.worldSize / Math.pow(2, z);
        var posMatrix = new Float64Array(16);

        mat4.identity(posMatrix);
        mat4.translate(posMatrix, posMatrix, [coord.column * scale, coord.row * scale, 0]);
        mat4.scale(posMatrix, posMatrix, [ scale / EXTENT, scale / EXTENT, 1 ]);
        mat4.multiply(posMatrix, this.projMatrix, posMatrix);

        return new Float32Array(posMatrix);
    },

    _constrain: function() {
        if (!this.center || !this.width || !this.height || this._constraining) return;

        this._constraining = true;

        var minY, maxY, minX, maxX, sy, sx, x2, y2,
            size = this.size,
            unmodified = this._unmodified;

        if (this.latRange) {
            minY = this.latY(this.latRange[1]);
            maxY = this.latY(this.latRange[0]);
            sy = maxY - minY < size.y ? size.y / (maxY - minY) : 0;
        }

        if (this.lngRange) {
            minX = this.lngX(this.lngRange[0]);
            maxX = this.lngX(this.lngRange[1]);
            sx = maxX - minX < size.x ? size.x / (maxX - minX) : 0;
        }

        // how much the map should scale to fit the screen into given latitude/longitude ranges
        var s = Math.max(sx || 0, sy || 0);

        if (s) {
            this.center = this.unproject(new Point(
                sx ? (maxX + minX) / 2 : this.x,
                sy ? (maxY + minY) / 2 : this.y));
            this.zoom += this.scaleZoom(s);
            this._unmodified = unmodified;
            this._constraining = false;
            return;
        }

        if (this.latRange) {
            var y = this.y,
                h2 = size.y / 2;

            if (y - h2 < minY) y2 = minY + h2;
            if (y + h2 > maxY) y2 = maxY - h2;
        }

        if (this.lngRange) {
            var x = this.x,
                w2 = size.x / 2;

            if (x - w2 < minX) x2 = minX + w2;
            if (x + w2 > maxX) x2 = maxX - w2;
        }

        // pan the map if the screen goes off the range
        if (x2 !== undefined || y2 !== undefined) {
            this.center = this.unproject(new Point(
                x2 !== undefined ? x2 : this.x,
                y2 !== undefined ? y2 : this.y));
        }

        this._unmodified = unmodified;
        this._constraining = false;
    },

    _calcProjMatrix: function() {
        var m = new Float64Array(16);

        // Find the distance from the center point to the center top in altitude units using law of sines.
        var halfFov = Math.atan(0.5 / this.altitude);
        var topHalfSurfaceDistance = Math.sin(halfFov) * this.altitude / Math.sin(Math.PI / 2 - this._pitch - halfFov);

        // Calculate z value of the farthest fragment that should be rendered.
        var farZ = Math.cos(Math.PI / 2 - this._pitch) * topHalfSurfaceDistance + this.altitude;

        mat4.perspective(m, 2 * Math.atan((this.height / 2) / this.altitude), this.width / this.height, 0.1, farZ);

        mat4.translate(m, m, [0, 0, -this.altitude]);

        // After the rotateX, z values are in pixel units. Convert them to
        // altitude units. 1 altitude unit = the screen height.
        mat4.scale(m, m, [1, -1, 1 / this.height]);

        mat4.rotateX(m, m, this._pitch);
        mat4.rotateZ(m, m, this.angle);
        mat4.translate(m, m, [-this.x, -this.y, 0]);

        this.projMatrix = m;
    }
};

},{"../data/bucket":15,"../source/tile_coord":49,"../util/interpolate":111,"../util/util":117,"./coordinate":23,"./lng_lat":24,"gl-matrix":131,"point-geometry":172}],27:[function(require,module,exports){
'use strict';

// Font data From Hershey Simplex Font
// http://paulbourke.net/dataformats/hershey/
var simplexFont = {
    " ": [16, []],
    "!": [10, [5, 21, 5, 7, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
    "\"": [16, [4, 21, 4, 14, -1, -1, 12, 21, 12, 14]],
    "#": [21, [11, 25, 4, -7, -1, -1, 17, 25, 10, -7, -1, -1, 4, 12, 18, 12, -1, -1, 3, 6, 17, 6]],
    "$": [20, [8, 25, 8, -4, -1, -1, 12, 25, 12, -4, -1, -1, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],
    "%": [24, [21, 21, 3, 0, -1, -1, 8, 21, 10, 19, 10, 17, 9, 15, 7, 14, 5, 14, 3, 16, 3, 18, 4, 20, 6, 21, 8, 21, 10, 20, 13, 19, 16, 19, 19, 20, 21, 21, -1, -1, 17, 7, 15, 6, 14, 4, 14, 2, 16, 0, 18, 0, 20, 1, 21, 3, 21, 5, 19, 7, 17, 7]],
    "&": [26, [23, 12, 23, 13, 22, 14, 21, 14, 20, 13, 19, 11, 17, 6, 15, 3, 13, 1, 11, 0, 7, 0, 5, 1, 4, 2, 3, 4, 3, 6, 4, 8, 5, 9, 12, 13, 13, 14, 14, 16, 14, 18, 13, 20, 11, 21, 9, 20, 8, 18, 8, 16, 9, 13, 11, 10, 16, 3, 18, 1, 20, 0, 22, 0, 23, 1, 23, 2]],
    "'": [10, [5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15]],
    "(": [14, [11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, -2, 9, -5, 11, -7]],
    ")": [14, [3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, -2, 5, -5, 3, -7]],
    "*": [16, [8, 21, 8, 9, -1, -1, 3, 18, 13, 12, -1, -1, 13, 18, 3, 12]],
    "+": [26, [13, 18, 13, 0, -1, -1, 4, 9, 22, 9]],
    ",": [10, [6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],
    "-": [26, [4, 9, 22, 9]],
    ".": [10, [5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
    "/": [22, [20, 25, 2, -7]],
    "0": [20, [9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12, 16, 17, 14, 20, 11, 21, 9, 21]],
    "1": [20, [6, 17, 8, 18, 11, 21, 11, 0]],
    "2": [20, [4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0]],
    "3": [20, [5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
    "4": [20, [13, 21, 3, 7, 18, 7, -1, -1, 13, 21, 13, 0]],
    "5": [20, [15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
    "6": [20, [16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14, 1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7]],
    "7": [20, [17, 21, 7, 0, -1, -1, 3, 21, 17, 21]],
    "8": [20, [8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15, 1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16, 18, 15, 20, 12, 21, 8, 21]],
    "9": [20, [16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10, 21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3]],
    ":": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
    ";": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],
    "<": [24, [20, 18, 4, 9, 20, 0]],
    "=": [26, [4, 12, 22, 12, -1, -1, 4, 6, 22, 6]],
    ">": [24, [4, 18, 20, 9, 4, 0]],
    "?": [18, [3, 16, 3, 17, 4, 19, 5, 20, 7, 21, 11, 21, 13, 20, 14, 19, 15, 17, 15, 15, 14, 13, 13, 12, 9, 10, 9, 7, -1, -1, 9, 2, 8, 1, 9, 0, 10, 1, 9, 2]],
    "@": [27, [18, 13, 17, 15, 15, 16, 12, 16, 10, 15, 9, 14, 8, 11, 8, 8, 9, 6, 11, 5, 14, 5, 16, 6, 17, 8, -1, -1, 12, 16, 10, 14, 9, 11, 9, 8, 10, 6, 11, 5, -1, -1, 18, 16, 17, 8, 17, 6, 19, 5, 21, 5, 23, 7, 24, 10, 24, 12, 23, 15, 22, 17, 20, 19, 18, 20, 15, 21, 12, 21, 9, 20, 7, 19, 5, 17, 4, 15, 3, 12, 3, 9, 4, 6, 5, 4, 7, 2, 9, 1, 12, 0, 15, 0, 18, 1, 20, 2, 21, 3, -1, -1, 19, 16, 18, 8, 18, 6, 19, 5]],
    "A": [18, [9, 21, 1, 0, -1, -1, 9, 21, 17, 0, -1, -1, 4, 7, 14, 7]],
    "B": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, -1, -1, 4, 11, 13, 11, 16, 10, 17, 9, 18, 7, 18, 4, 17, 2, 16, 1, 13, 0, 4, 0]],
    "C": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5]],
    "D": [21, [4, 21, 4, 0, -1, -1, 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0]],
    "E": [19, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11, -1, -1, 4, 0, 17, 0]],
    "F": [18, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11]],
    "G": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 18, 8, -1, -1, 13, 8, 18, 8]],
    "H": [22, [4, 21, 4, 0, -1, -1, 18, 21, 18, 0, -1, -1, 4, 11, 18, 11]],
    "I": [8, [4, 21, 4, 0]],
    "J": [16, [12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7]],
    "K": [21, [4, 21, 4, 0, -1, -1, 18, 21, 4, 7, -1, -1, 9, 12, 18, 0]],
    "L": [17, [4, 21, 4, 0, -1, -1, 4, 0, 16, 0]],
    "M": [24, [4, 21, 4, 0, -1, -1, 4, 21, 12, 0, -1, -1, 20, 21, 12, 0, -1, -1, 20, 21, 20, 0]],
    "N": [22, [4, 21, 4, 0, -1, -1, 4, 21, 18, 0, -1, -1, 18, 21, 18, 0]],
    "O": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21]],
    "P": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10]],
    "Q": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, -1, -1, 12, 4, 18, -2]],
    "R": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, 4, 11, -1, -1, 11, 11, 18, 0]],
    "S": [20, [17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],
    "T": [16, [8, 21, 8, 0, -1, -1, 1, 21, 15, 21]],
    "U": [22, [4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21]],
    "V": [18, [1, 21, 9, 0, -1, -1, 17, 21, 9, 0]],
    "W": [24, [2, 21, 7, 0, -1, -1, 12, 21, 7, 0, -1, -1, 12, 21, 17, 0, -1, -1, 22, 21, 17, 0]],
    "X": [20, [3, 21, 17, 0, -1, -1, 17, 21, 3, 0]],
    "Y": [18, [1, 21, 9, 11, 9, 0, -1, -1, 17, 21, 9, 11]],
    "Z": [20, [17, 21, 3, 0, -1, -1, 3, 21, 17, 21, -1, -1, 3, 0, 17, 0]],
    "[": [14, [4, 25, 4, -7, -1, -1, 5, 25, 5, -7, -1, -1, 4, 25, 11, 25, -1, -1, 4, -7, 11, -7]],
    "\\": [14, [0, 21, 14, -3]],
    "]": [14, [9, 25, 9, -7, -1, -1, 10, 25, 10, -7, -1, -1, 3, 25, 10, 25, -1, -1, 3, -7, 10, -7]],
    "^": [16, [6, 15, 8, 18, 10, 15, -1, -1, 3, 12, 8, 17, 13, 12, -1, -1, 8, 17, 8, 0]],
    "_": [16, [0, -2, 16, -2]],
    "`": [10, [6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17]],
    "a": [19, [15, 14, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "b": [19, [4, 21, 4, 0, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],
    "c": [18, [15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "d": [19, [15, 21, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "e": [18, [3, 8, 15, 8, 15, 10, 14, 12, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "f": [12, [10, 21, 8, 21, 6, 20, 5, 17, 5, 0, -1, -1, 2, 14, 9, 14]],
    "g": [19, [15, 14, 15, -2, 14, -5, 13, -6, 11, -7, 8, -7, 6, -6, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "h": [19, [4, 21, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
    "i": [8, [3, 21, 4, 20, 5, 21, 4, 22, 3, 21, -1, -1, 4, 14, 4, 0]],
    "j": [10, [5, 21, 6, 20, 7, 21, 6, 22, 5, 21, -1, -1, 6, 14, 6, -3, 5, -6, 3, -7, 1, -7]],
    "k": [17, [4, 21, 4, 0, -1, -1, 14, 14, 4, 4, -1, -1, 8, 8, 15, 0]],
    "l": [8, [4, 21, 4, 0]],
    "m": [30, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, -1, -1, 15, 10, 18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0]],
    "n": [19, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
    "o": [19, [8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3, 16, 6, 16, 8, 15, 11, 13, 13, 11, 14, 8, 14]],
    "p": [19, [4, 14, 4, -7, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],
    "q": [19, [15, 14, 15, -7, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "r": [13, [4, 14, 4, 0, -1, -1, 4, 8, 5, 11, 7, 13, 9, 14, 12, 14]],
    "s": [17, [14, 11, 13, 13, 10, 14, 7, 14, 4, 13, 3, 11, 4, 9, 6, 8, 11, 7, 13, 6, 14, 4, 14, 3, 13, 1, 10, 0, 7, 0, 4, 1, 3, 3]],
    "t": [12, [5, 21, 5, 4, 6, 1, 8, 0, 10, 0, -1, -1, 2, 14, 9, 14]],
    "u": [19, [4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, -1, -1, 15, 14, 15, 0]],
    "v": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0]],
    "w": [22, [3, 14, 7, 0, -1, -1, 11, 14, 7, 0, -1, -1, 11, 14, 15, 0, -1, -1, 19, 14, 15, 0]],
    "x": [17, [3, 14, 14, 0, -1, -1, 14, 14, 3, 0]],
    "y": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7]],
    "z": [17, [14, 14, 3, 0, -1, -1, 3, 14, 14, 14, -1, -1, 3, 0, 14, 0]],
    "{": [14, [9, 25, 7, 24, 6, 23, 5, 21, 5, 19, 6, 17, 7, 16, 8, 14, 8, 12, 6, 10, -1, -1, 7, 24, 6, 22, 6, 20, 7, 18, 8, 17, 9, 15, 9, 13, 8, 11, 4, 9, 8, 7, 9, 5, 9, 3, 8, 1, 7, 0, 6, -2, 6, -4, 7, -6, -1, -1, 6, 8, 8, 6, 8, 4, 7, 2, 6, 1, 5, -1, 5, -3, 6, -5, 7, -6, 9, -7]],
    "|": [8, [4, 25, 4, -7]],
    "}": [14, [5, 25, 7, 24, 8, 23, 9, 21, 9, 19, 8, 17, 7, 16, 6, 14, 6, 12, 8, 10, -1, -1, 7, 24, 8, 22, 8, 20, 7, 18, 6, 17, 5, 15, 5, 13, 6, 11, 10, 9, 6, 7, 5, 5, 5, 3, 6, 1, 7, 0, 8, -2, 8, -4, 7, -6, -1, -1, 8, 8, 6, 6, 6, 4, 7, 2, 8, 1, 9, -1, 9, -3, 8, -5, 7, -6, 5, -7]],
    "~": [24, [3, 6, 3, 8, 4, 11, 6, 12, 8, 12, 10, 11, 14, 8, 16, 7, 18, 7, 20, 8, 21, 10, -1, -1, 3, 8, 4, 10, 6, 11, 8, 11, 10, 10, 14, 7, 16, 6, 18, 6, 20, 7, 21, 10, 21, 12]]
};

module.exports = function textVertices(text, left, baseline, scale) {
    scale = scale || 1;

    var strokes = [],
        i, len, j, len2, glyph, x, y, prev;

    for (i = 0, len = text.length; i < len; i++) {
        glyph = simplexFont[text[i]];
        if (!glyph) continue;
        prev = null;

        for (j = 0, len2 = glyph[1].length; j < len2; j += 2) {
            if (glyph[1][j] === -1 && glyph[1][j + 1] === -1) {
                prev = null;

            } else {
                x = left + glyph[1][j] * scale;
                y = baseline - glyph[1][j + 1] * scale;
                if (prev) {
                    strokes.push(prev.x, prev.y, x, y);
                }
                prev = {x: x, y: y};
            }
        }
        left += glyph[0] * scale;
    }

    return strokes;
};

},{}],28:[function(require,module,exports){
'use strict';

/**
 * mapboxgl is a A WebGL JavaScript interactive maps library that can render
 * [Mapbox vector tiles](https://www.mapbox.com/blog/vector-tiles/).
 *
 * @module mapboxgl
 * @summary WebGL JavaScript map library
 */

// jshint -W079
var mapboxgl = module.exports = {};

mapboxgl.Map = require('./ui/map');
mapboxgl.Control = require('./ui/control/control');
mapboxgl.Navigation = require('./ui/control/navigation');
mapboxgl.Geolocate = require('./ui/control/geolocate');
mapboxgl.Attribution = require('./ui/control/attribution');
mapboxgl.Popup = require('./ui/popup');

mapboxgl.GeoJSONSource = require('./source/geojson_source');
mapboxgl.VideoSource = require('./source/video_source');
mapboxgl.ImageSource = require('./source/image_source');

mapboxgl.Style = require('./style/style');

mapboxgl.LngLat = require('./geo/lng_lat');
mapboxgl.LngLatBounds = require('./geo/lng_lat_bounds');
mapboxgl.Point = require('point-geometry');

mapboxgl.Evented = require('./util/evented');
mapboxgl.util = require('./util/util');

mapboxgl.supported = require('./util/browser').supported;

var ajax = require('./util/ajax');
mapboxgl.util.getJSON = ajax.getJSON;
mapboxgl.util.getArrayBuffer = ajax.getArrayBuffer;

var config = require('./util/config');
mapboxgl.config = config;

Object.defineProperty(mapboxgl, 'accessToken', {
    get: function() { return config.ACCESS_TOKEN; },
    set: function(token) { config.ACCESS_TOKEN = token; }
});

},{"./geo/lng_lat":24,"./geo/lng_lat_bounds":25,"./source/geojson_source":42,"./source/image_source":44,"./source/video_source":52,"./style/style":58,"./ui/control/attribution":86,"./ui/control/control":87,"./ui/control/geolocate":88,"./ui/control/navigation":89,"./ui/map":99,"./ui/popup":100,"./util/ajax":102,"./util/browser":103,"./util/config":107,"./util/evented":109,"./util/util":117,"point-geometry":172}],29:[function(require,module,exports){
'use strict';

var TilePyramid = require('../source/tile_pyramid');
var pyramid = new TilePyramid({ tileSize: 512 });
var util = require('../util/util');
var pixelsToTileUnits = require('../source/pixels_to_tile_units');

module.exports = drawBackground;

function drawBackground(painter, source, layer) {
    var gl = painter.gl;
    var transform = painter.transform;
    var color = util.premultiply(layer.paint['background-color']);
    var image = layer.paint['background-pattern'];
    var opacity = layer.paint['background-opacity'];
    var program;

    var imagePosA = image ? painter.spriteAtlas.getPosition(image.from, true) : null;
    var imagePosB = image ? painter.spriteAtlas.getPosition(image.to, true) : null;

    painter.setDepthSublayer(0);
    if (imagePosA && imagePosB) {

        if (painter.isOpaquePass) return;

        // Draw texture fill
        program = painter.useProgram('pattern');
        gl.uniform1i(program.u_image, 0);
        gl.uniform2fv(program.u_pattern_tl_a, imagePosA.tl);
        gl.uniform2fv(program.u_pattern_br_a, imagePosA.br);
        gl.uniform2fv(program.u_pattern_tl_b, imagePosB.tl);
        gl.uniform2fv(program.u_pattern_br_b, imagePosB.br);
        gl.uniform1f(program.u_opacity, opacity);

        gl.uniform1f(program.u_mix, image.t);

        painter.spriteAtlas.bind(gl, true);

        painter.tileExtentPatternVAO.bind(gl, program, painter.tileExtentBuffer);
    } else {
        // Draw filling rectangle.
        if (painter.isOpaquePass !== (color[3] === 1)) return;

        program = painter.useProgram('fill');
        gl.uniform4fv(program.u_color, color);
        gl.uniform1f(program.u_opacity, opacity);
        painter.tileExtentVAO.bind(gl, program, painter.tileExtentBuffer);
    }

    gl.disable(gl.STENCIL_TEST);

    // We need to draw the background in tiles in order to use calculatePosMatrix
    // which applies the projection matrix (transform.projMatrix). Otherwise
    // the depth and stencil buffers get into a bad state.
    // This can be refactored into a single draw call once earcut lands and
    // we don't have so much going on in the stencil buffer.
    var coords = pyramid.coveringTiles(transform);
    for (var c = 0; c < coords.length; c++) {
        var coord = coords[c];
        var tileSize = 512;
        // var pixelsToTileUnitsBound = pixelsToTileUnits.bind({coord:coord, tileSize: tileSize});
        if (imagePosA && imagePosB) {
            var imageSizeScaledA = [
                (imagePosA.size[0] * image.fromScale),
                (imagePosA.size[1] * image.fromScale)
            ];
            var imageSizeScaledB = [
                (imagePosB.size[0] * image.toScale),
                (imagePosB.size[1] * image.toScale)
            ];
            var tile = {coord:coord, tileSize: tileSize};

            gl.uniform2fv(program.u_patternscale_a, [
                1 / pixelsToTileUnits(tile, imageSizeScaledA[0], painter.transform.tileZoom),
                1 / pixelsToTileUnits(tile, imageSizeScaledA[1], painter.transform.tileZoom)
            ]);

            gl.uniform2fv(program.u_patternscale_b, [
                1 / pixelsToTileUnits(tile, imageSizeScaledB[0], painter.transform.tileZoom),
                1 / pixelsToTileUnits(tile, imageSizeScaledB[1], painter.transform.tileZoom)
            ]);
            var tileSizeAtNearestZoom = tileSize * Math.pow(2, painter.transform.tileZoom - coord.z);

            var offsetAx = ((tileSizeAtNearestZoom / imageSizeScaledA[0]) % 1) * (coord.x + coord.w * Math.pow(2, coord.z));
            var offsetAy = ((tileSizeAtNearestZoom / imageSizeScaledA[1]) % 1) * coord.y;

            var offsetBx = ((tileSizeAtNearestZoom / imageSizeScaledB[0]) % 1) * (coord.x + coord.w * Math.pow(2, coord.z));
            var offsetBy = ((tileSizeAtNearestZoom / imageSizeScaledB[1]) % 1) * coord.y;

            gl.uniform2fv(program.u_offset_a, [offsetAx, offsetAy]);
            gl.uniform2fv(program.u_offset_b, [offsetBx, offsetBy]);
        }

        gl.uniformMatrix4fv(program.u_matrix, false, painter.transform.calculatePosMatrix(coord));
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, painter.tileExtentBuffer.length);
    }

    gl.stencilMask(0x00);
    gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
}

},{"../source/pixels_to_tile_units":45,"../source/tile_pyramid":50,"../util/util":117}],30:[function(require,module,exports){
'use strict';

var browser = require('../util/browser');

module.exports = drawCircles;

function drawCircles(painter, source, layer, coords) {
    if (painter.isOpaquePass) return;

    var gl = painter.gl;

    painter.setDepthSublayer(0);
    painter.depthMask(false);

    // Allow circles to be drawn across boundaries, so that
    // large circles are not clipped to tiles
    gl.disable(gl.STENCIL_TEST);

    for (var i = 0; i < coords.length; i++) {
        var coord = coords[i];

        var tile = source.getTile(coord);
        var bucket = tile.getBucket(layer);
        if (!bucket) continue;
        var bufferGroups = bucket.bufferGroups.circle;
        if (!bufferGroups) continue;

        var program = painter.useProgram('circle', bucket.getProgramMacros('circle', layer));

        gl.uniform2fv(program.u_extrude_scale, painter.transform.pixelsToGLUnits);
        gl.uniform1f(program.u_blur, layer.paint['circle-blur']);
        gl.uniform1f(program.u_devicepixelratio, browser.devicePixelRatio);
        gl.uniform1f(program.u_opacity, layer.paint['circle-opacity']);

        gl.uniformMatrix4fv(program.u_matrix, false, painter.translatePosMatrix(
            coord.posMatrix,
            tile,
            layer.paint['circle-translate'],
            layer.paint['circle-translate-anchor']
        ));

        bucket.setUniforms(gl, 'circle', program, layer, {zoom: painter.transform.zoom});

        for (var k = 0; k < bufferGroups.length; k++) {
            var group = bufferGroups[k];
            group.vaos[layer.id].bind(gl, program, group.layout.vertex, group.layout.element, group.paint[layer.id]);
            gl.drawElements(gl.TRIANGLES, group.layout.element.length * 3, gl.UNSIGNED_SHORT, 0);
        }
    }
}

},{"../util/browser":103}],31:[function(require,module,exports){
'use strict';

module.exports = drawCollisionDebug;

function drawCollisionDebug(painter, source, layer, coords) {
    var gl = painter.gl;
    gl.enable(gl.STENCIL_TEST);
    var program = painter.useProgram('collisionbox');

    for (var i = 0; i < coords.length; i++) {
        var coord = coords[i];
        var tile = source.getTile(coord);
        var bucket = tile.getBucket(layer);
        if (!bucket) continue;
        var bufferGroups = bucket.bufferGroups.collisionBox;

        if (!bufferGroups || !bufferGroups.length) continue;
        var group = bufferGroups[0];
        if (group.layout.vertex.length === 0) continue;

        gl.uniformMatrix4fv(program.u_matrix, false, coord.posMatrix);

        painter.enableTileClippingMask(coord);

        painter.lineWidth(1);
        gl.uniform1f(program.u_scale, Math.pow(2, painter.transform.zoom - tile.coord.z));
        gl.uniform1f(program.u_zoom, painter.transform.zoom * 10);
        gl.uniform1f(program.u_maxzoom, (tile.coord.z + 1) * 10);

        group.vaos[layer.id].bind(gl, program, group.layout.vertex);
        gl.drawArrays(gl.LINES, 0, group.layout.vertex.length);
    }
}

},{}],32:[function(require,module,exports){
'use strict';

var textVertices = require('../lib/debugtext');
var browser = require('../util/browser');
var mat4 = require('gl-matrix').mat4;
var EXTENT = require('../data/bucket').EXTENT;
var Buffer = require('../data/buffer');
var VertexArrayObject = require('./vertex_array_object');

module.exports = drawDebug;

function drawDebug(painter, source, coords) {
    if (painter.isOpaquePass) return;
    if (!painter.options.debug) return;

    for (var i = 0; i < coords.length; i++) {
        drawDebugTile(painter, source, coords[i]);
    }
}

function drawDebugTile(painter, source, coord) {
    var gl = painter.gl;

    gl.disable(gl.STENCIL_TEST);
    painter.lineWidth(1 * browser.devicePixelRatio);

    var posMatrix = coord.posMatrix;
    var program = painter.useProgram('debug');

    gl.uniformMatrix4fv(program.u_matrix, false, posMatrix);
    gl.uniform4f(program.u_color, 1, 0, 0, 1);
    painter.debugVAO.bind(gl, program, painter.debugBuffer);
    gl.drawArrays(gl.LINE_STRIP, 0, painter.debugBuffer.length);

    var vertices = textVertices(coord.toString(), 50, 200, 5);
    var debugTextArray = new painter.PosArray();
    for (var v = 0; v < vertices.length; v += 2) {
        debugTextArray.emplaceBack(vertices[v], vertices[v + 1]);
    }
    var debugTextBuffer = new Buffer(debugTextArray.serialize(), painter.PosArray.serialize(), Buffer.BufferType.VERTEX);
    var debugTextVAO = new VertexArrayObject();
    debugTextVAO.bind(gl, program, debugTextBuffer);
    gl.uniform4f(program.u_color, 1, 1, 1, 1);

    // Draw the halo with multiple 1px lines instead of one wider line because
    // the gl spec doesn't guarantee support for lines with width > 1.
    var tileSize = source.getTile(coord).tileSize;
    var onePixel = EXTENT / (Math.pow(2, painter.transform.zoom - coord.z) * tileSize);
    var translations = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
    for (var i = 0; i < translations.length; i++) {
        var translation = translations[i];
        gl.uniformMatrix4fv(program.u_matrix, false, mat4.translate([], posMatrix, [onePixel * translation[0], onePixel * translation[1], 0]));
        gl.drawArrays(gl.LINES, 0, debugTextBuffer.length);
    }

    gl.uniform4f(program.u_color, 0, 0, 0, 1);
    gl.uniformMatrix4fv(program.u_matrix, false, posMatrix);
    gl.drawArrays(gl.LINES, 0, debugTextBuffer.length);
}

},{"../data/bucket":15,"../data/buffer":20,"../lib/debugtext":27,"../util/browser":103,"./vertex_array_object":41,"gl-matrix":131}],33:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var pixelsToTileUnits = require('../source/pixels_to_tile_units');

module.exports = draw;

function draw(painter, source, layer, coords) {
    var gl = painter.gl;
    gl.enable(gl.STENCIL_TEST);

    var color = util.premultiply(layer.paint['fill-color']);
    var image = layer.paint['fill-pattern'];
    var strokeColor = util.premultiply(layer.paint['fill-outline-color']);
    var opacity = layer.paint['fill-opacity'];

    // Draw fill
    if (image ? !painter.isOpaquePass : painter.isOpaquePass === (color[3] === 1 && opacity === 1)) {
        // Once we switch to earcut drawing we can pull most of the WebGL setup
        // outside of this coords loop.
        for (var i = 0; i < coords.length; i++) {
            drawFill(painter, source, layer, coords[i]);
        }
    }

    // Draw stroke
    if (!painter.isOpaquePass && layer.paint['fill-antialias']) {
        if (strokeColor || !layer.paint['fill-pattern']) {
            var outlineProgram = painter.useProgram('outline');
            painter.lineWidth(2);
            painter.depthMask(false);

            if (strokeColor) {
                // If we defined a different color for the fill outline, we are
                // going to ignore the bits in 0x07 and just care about the global
                // clipping mask.
                painter.setDepthSublayer(2);
            } else {
                // Otherwise, we only want to drawFill the antialiased parts that are
                // *outside* the current shape. This is important in case the fill
                // or stroke color is translucent. If we wouldn't clip to outside
                // the current shape, some pixels from the outline stroke overlapped
                // the (non-antialiased) fill.
                painter.setDepthSublayer(0);
            }
            gl.uniform2f(outlineProgram.u_world, gl.drawingBufferWidth, gl.drawingBufferHeight);
            gl.uniform4fv(outlineProgram.u_color, strokeColor ? strokeColor : color);
            gl.uniform1f(outlineProgram.u_opacity, opacity);

            for (var j = 0; j < coords.length; j++) {
                drawStroke(painter, source, layer, coords[j]);
            }
        } else {
            var outlinePatternProgram = painter.useProgram('outlinepattern');
            painter.lineWidth(2);
            painter.depthMask(false);
            // Otherwise, we only want to drawFill the antialiased parts that are
            // *outside* the current shape. This is important in case the fill
            // or stroke color is translucent. If we wouldn't clip to outside
            // the current shape, some pixels from the outline stroke overlapped
            // the (non-antialiased) fill.
            painter.setDepthSublayer(0);
            gl.uniform2f(outlinePatternProgram.u_world, gl.drawingBufferWidth, gl.drawingBufferHeight);

            for (var k = 0; k < coords.length; k++) {
                drawStroke(painter, source, layer, coords[k]);
            }
        }

    }
}

function drawFill(painter, source, layer, coord) {
    var tile = source.getTile(coord);
    var bucket = tile.getBucket(layer);
    if (!bucket) return;
    var bufferGroups = bucket.bufferGroups.fill;
    if (!bufferGroups) return;

    var gl = painter.gl;

    var color = util.premultiply(layer.paint['fill-color']);
    var image = layer.paint['fill-pattern'];
    var opacity = layer.paint['fill-opacity'];

    var posMatrix = coord.posMatrix;
    var translatedPosMatrix = painter.translatePosMatrix(posMatrix, tile, layer.paint['fill-translate'], layer.paint['fill-translate-anchor']);

    // Draw the stencil mask.
    painter.setDepthSublayer(1);

    // We're only drawFilling to the first seven bits (== support a maximum of
    // 8 overlapping polygons in one place before we get rendering errors).
    gl.stencilMask(0x07);
    gl.clear(gl.STENCIL_BUFFER_BIT);

    // Draw front facing triangles. Wherever the 0x80 bit is 1, we are
    // increasing the lower 7 bits by one if the triangle is a front-facing
    // triangle. This means that all visible polygons should be in CCW
    // orientation, while all holes (see below) are in CW orientation.
    painter.enableTileClippingMask(coord);

    // When we do a nonzero fill, we count the number of times a pixel is
    // covered by a counterclockwise polygon, and subtract the number of
    // times it is "uncovered" by a clockwise polygon.
    gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.INCR_WRAP);
    gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.DECR_WRAP);

    // When drawFilling a shape, we first drawFill all shapes to the stencil buffer
    // and incrementing all areas where polygons are
    gl.colorMask(false, false, false, false);
    painter.depthMask(false);

    // Draw the actual triangle fan into the stencil buffer.
    var fillProgram = painter.useProgram('fill');
    gl.uniformMatrix4fv(fillProgram.u_matrix, false, translatedPosMatrix);

    for (var i = 0; i < bufferGroups.length; i++) {
        var group = bufferGroups[i];
        group.vaos[layer.id].bind(gl, fillProgram, group.layout.vertex, group.layout.element);
        gl.drawElements(gl.TRIANGLES, group.layout.element.length * 3, gl.UNSIGNED_SHORT, 0);
    }

    // Now that we have the stencil mask in the stencil buffer, we can start
    // writing to the color buffer.
    gl.colorMask(true, true, true, true);
    painter.depthMask(true);

    // From now on, we don't want to update the stencil buffer anymore.
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    gl.stencilMask(0x0);
    var program;

    if (image) {
        // Draw texture fill
        program = painter.useProgram('pattern');
        setPattern(image, opacity, tile, coord, painter, program);

        gl.activeTexture(gl.TEXTURE0);
        painter.spriteAtlas.bind(gl, true);

        painter.tileExtentPatternVAO.bind(gl, program, painter.tileExtentBuffer);

    } else {
        // Draw filling rectangle.
        program = painter.useProgram('fill');
        gl.uniform4fv(fillProgram.u_color, color);
        gl.uniform1f(fillProgram.u_opacity, opacity);
        painter.tileExtentVAO.bind(gl, program, painter.tileExtentBuffer);
    }

    gl.uniformMatrix4fv(program.u_matrix, false, posMatrix);

    // Only draw regions that we marked
    gl.stencilFunc(gl.NOTEQUAL, 0x0, 0x07);

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, painter.tileExtentBuffer.length);

    gl.stencilMask(0x00);
}

function drawStroke(painter, source, layer, coord) {
    var tile = source.getTile(coord);
    var bucket = tile.getBucket(layer);
    if (!bucket) return;

    var gl = painter.gl;
    var bufferGroups = bucket.bufferGroups.fill;

    var image = layer.paint['fill-pattern'];
    var opacity = layer.paint['fill-opacity'];
    var program = image ? painter.useProgram('outlinepattern') : painter.useProgram('outline');

    gl.uniformMatrix4fv(program.u_matrix, false, painter.translatePosMatrix(
        coord.posMatrix,
        tile,
        layer.paint['fill-translate'],
        layer.paint['fill-translate-anchor']
    ));

    if (image) { setPattern(image, opacity, tile, coord, painter, program); }

    painter.enableTileClippingMask(coord);

    for (var k = 0; k < bufferGroups.length; k++) {
        var group = bufferGroups[k];
        group.secondVaos[layer.id].bind(gl, program, group.layout.vertex, group.layout.element2);
        gl.drawElements(gl.LINES, group.layout.element2.length * 2, gl.UNSIGNED_SHORT, 0);
    }
}


function setPattern(image, opacity, tile, coord, painter, program) {
    var gl = painter.gl;

    var imagePosA = painter.spriteAtlas.getPosition(image.from, true);
    var imagePosB = painter.spriteAtlas.getPosition(image.to, true);
    if (!imagePosA || !imagePosB) return;


    gl.uniform1i(program.u_image, 0);
    gl.uniform2fv(program.u_pattern_tl_a, imagePosA.tl);
    gl.uniform2fv(program.u_pattern_br_a, imagePosA.br);
    gl.uniform2fv(program.u_pattern_tl_b, imagePosB.tl);
    gl.uniform2fv(program.u_pattern_br_b, imagePosB.br);
    gl.uniform1f(program.u_opacity, opacity);
    gl.uniform1f(program.u_mix, image.t);

    var imageSizeScaledA = [
        (imagePosA.size[0] * image.fromScale),
        (imagePosA.size[1] * image.fromScale)
    ];
    var imageSizeScaledB = [
        (imagePosB.size[0] * image.toScale),
        (imagePosB.size[1] * image.toScale)
    ];

    gl.uniform2fv(program.u_patternscale_a, [
        1 / pixelsToTileUnits(tile, imageSizeScaledA[0], painter.transform.tileZoom),
        1 / pixelsToTileUnits(tile, imageSizeScaledA[1], painter.transform.tileZoom)
    ]);

    gl.uniform2fv(program.u_patternscale_b, [
        1 / pixelsToTileUnits(tile, imageSizeScaledB[0], painter.transform.tileZoom),
        1 / pixelsToTileUnits(tile, imageSizeScaledB[1], painter.transform.tileZoom)
    ]);

    var tileSizeAtNearestZoom = tile.tileSize * Math.pow(2, painter.transform.tileZoom - tile.coord.z);

    // shift images to match at tile boundaries
    var offsetAx = ((tileSizeAtNearestZoom / imageSizeScaledA[0]) % 1) * (tile.coord.x + coord.w * Math.pow(2, tile.coord.z));
    var offsetAy = ((tileSizeAtNearestZoom / imageSizeScaledA[1]) % 1) * tile.coord.y;

    var offsetBx = ((tileSizeAtNearestZoom / imageSizeScaledB[0]) % 1) * (tile.coord.x + coord.w * Math.pow(2, tile.coord.z));
    var offsetBy = ((tileSizeAtNearestZoom / imageSizeScaledB[1]) % 1) * tile.coord.y;

    gl.uniform2fv(program.u_offset_a, [offsetAx, offsetAy]);
    gl.uniform2fv(program.u_offset_b, [offsetBx, offsetBy]);

    gl.activeTexture(gl.TEXTURE0);
    painter.spriteAtlas.bind(gl, true);
}

},{"../source/pixels_to_tile_units":45,"../util/util":117}],34:[function(require,module,exports){
'use strict';

var browser = require('../util/browser');
var mat2 = require('gl-matrix').mat2;
var util = require('../util/util');
var pixelsToTileUnits = require('../source/pixels_to_tile_units');

/**
 * Draw a line. Under the hood this will read elements from
 * a tile, dash textures from a lineAtlas, and style properties from a layer.
 * @param {Object} painter
 * @param {Object} layer
 * @param {Object} posMatrix
 * @param {Tile} tile
 * @returns {undefined} draws with the painter
 * @private
 */
module.exports = function drawLine(painter, source, layer, coords) {
    if (painter.isOpaquePass) return;
    painter.setDepthSublayer(0);
    painter.depthMask(false);

    var gl = painter.gl;
    gl.enable(gl.STENCIL_TEST);

    // don't draw zero-width lines
    if (layer.paint['line-width'] <= 0) return;

    // the distance over which the line edge fades out.
    // Retina devices need a smaller distance to avoid aliasing.
    var antialiasing = 1 / browser.devicePixelRatio;

    var blur = layer.paint['line-blur'] + antialiasing;
    var edgeWidth = layer.paint['line-width'] / 2;
    var inset = -1;
    var offset = 0;
    var shift = 0;

    if (layer.paint['line-gap-width'] > 0) {
        inset = layer.paint['line-gap-width'] / 2 + antialiasing * 0.5;
        edgeWidth = layer.paint['line-width'];

        // shift outer lines half a pixel towards the middle to eliminate the crack
        offset = inset - antialiasing / 2;
    }

    var outset = offset + edgeWidth + antialiasing / 2 + shift;
    var color = util.premultiply(layer.paint['line-color']);

    var tr = painter.transform;

    var antialiasingMatrix = mat2.create();
    mat2.scale(antialiasingMatrix, antialiasingMatrix, [1, Math.cos(tr._pitch)]);
    mat2.rotate(antialiasingMatrix, antialiasingMatrix, painter.transform.angle);

    // calculate how much longer the real world distance is at the top of the screen
    // than at the middle of the screen.
    var topedgelength = Math.sqrt(tr.height * tr.height / 4  * (1 + tr.altitude * tr.altitude));
    var x = tr.height / 2 * Math.tan(tr._pitch);
    var extra = (topedgelength + x) / topedgelength - 1;

    var dasharray = layer.paint['line-dasharray'];
    var image = layer.paint['line-pattern'];
    var program, posA, posB, imagePosA, imagePosB;

    if (dasharray) {
        program = painter.useProgram('linesdfpattern');

        gl.uniform2fv(program.u_linewidth, [ outset, inset ]);
        gl.uniform1f(program.u_blur, blur);
        gl.uniform4fv(program.u_color, color);
        gl.uniform1f(program.u_opacity, layer.paint['line-opacity']);

        posA = painter.lineAtlas.getDash(dasharray.from, layer.layout['line-cap'] === 'round');
        posB = painter.lineAtlas.getDash(dasharray.to, layer.layout['line-cap'] === 'round');

        gl.uniform1i(program.u_image, 0);
        gl.activeTexture(gl.TEXTURE0);
        painter.lineAtlas.bind(gl);

        gl.uniform1f(program.u_tex_y_a, posA.y);
        gl.uniform1f(program.u_tex_y_b, posB.y);
        gl.uniform1f(program.u_mix, dasharray.t);
        gl.uniform1f(program.u_extra, extra);
        gl.uniform1f(program.u_offset, -layer.paint['line-offset']);
        gl.uniformMatrix2fv(program.u_antialiasingmatrix, false, antialiasingMatrix);

    } else if (image) {
        imagePosA = painter.spriteAtlas.getPosition(image.from, true);
        imagePosB = painter.spriteAtlas.getPosition(image.to, true);
        if (!imagePosA || !imagePosB) return;

        program = painter.useProgram('linepattern');

        gl.uniform1i(program.u_image, 0);
        gl.activeTexture(gl.TEXTURE0);
        painter.spriteAtlas.bind(gl, true);

        gl.uniform2fv(program.u_linewidth, [ outset, inset ]);
        gl.uniform1f(program.u_blur, blur);
        gl.uniform2fv(program.u_pattern_tl_a, imagePosA.tl);
        gl.uniform2fv(program.u_pattern_br_a, imagePosA.br);
        gl.uniform2fv(program.u_pattern_tl_b, imagePosB.tl);
        gl.uniform2fv(program.u_pattern_br_b, imagePosB.br);
        gl.uniform1f(program.u_fade, image.t);
        gl.uniform1f(program.u_opacity, layer.paint['line-opacity']);
        gl.uniform1f(program.u_extra, extra);
        gl.uniform1f(program.u_offset, -layer.paint['line-offset']);
        gl.uniformMatrix2fv(program.u_antialiasingmatrix, false, antialiasingMatrix);

    } else {
        program = painter.useProgram('line');

        gl.uniform2fv(program.u_linewidth, [ outset, inset ]);
        gl.uniform1f(program.u_blur, blur);
        gl.uniform1f(program.u_extra, extra);
        gl.uniform1f(program.u_offset, -layer.paint['line-offset']);
        gl.uniformMatrix2fv(program.u_antialiasingmatrix, false, antialiasingMatrix);
        gl.uniform4fv(program.u_color, color);
        gl.uniform1f(program.u_opacity, layer.paint['line-opacity']);
    }

    for (var k = 0; k < coords.length; k++) {
        var coord = coords[k];
        var tile = source.getTile(coord);
        var bucket = tile.getBucket(layer);
        if (!bucket) continue;
        var bufferGroups = bucket.bufferGroups.line;
        if (!bufferGroups) continue;

        painter.enableTileClippingMask(coord);

        // set uniforms that are different for each tile
        var posMatrix = painter.translatePosMatrix(coord.posMatrix, tile, layer.paint['line-translate'], layer.paint['line-translate-anchor']);
        gl.uniformMatrix4fv(program.u_matrix, false, posMatrix);

        var ratio = 1 / pixelsToTileUnits(tile, 1, painter.transform.zoom);

        if (dasharray) {
            var widthA = posA.width * dasharray.fromScale;
            var widthB = posB.width * dasharray.toScale;
            var scaleA = [1 / pixelsToTileUnits(tile, widthA, painter.transform.tileZoom), -posA.height / 2];
            var scaleB = [1 / pixelsToTileUnits(tile, widthB, painter.transform.tileZoom), -posB.height / 2];
            var gamma = painter.lineAtlas.width / (Math.min(widthA, widthB) * 256 * browser.devicePixelRatio) / 2;
            gl.uniform1f(program.u_ratio, ratio);
            gl.uniform2fv(program.u_patternscale_a, scaleA);
            gl.uniform2fv(program.u_patternscale_b, scaleB);
            gl.uniform1f(program.u_sdfgamma, gamma);

        } else if (image) {
            gl.uniform1f(program.u_ratio, ratio);
            gl.uniform2fv(program.u_pattern_size_a, [
                pixelsToTileUnits(tile, imagePosA.size[0] * image.fromScale, painter.transform.tileZoom),
                imagePosB.size[1]
            ]);
            gl.uniform2fv(program.u_pattern_size_b, [
                pixelsToTileUnits(tile, imagePosB.size[0] * image.toScale, painter.transform.tileZoom),
                imagePosB.size[1]
            ]);

        } else {
            gl.uniform1f(program.u_ratio, ratio);
        }

        for (var i = 0; i < bufferGroups.length; i++) {
            var group = bufferGroups[i];
            group.vaos[layer.id].bind(gl, program, group.layout.vertex, group.layout.element);
            gl.drawElements(gl.TRIANGLES, group.layout.element.length * 3, gl.UNSIGNED_SHORT, 0);
        }
    }

};

},{"../source/pixels_to_tile_units":45,"../util/browser":103,"../util/util":117,"gl-matrix":131}],35:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var StructArrayType = require('../util/struct_array');

module.exports = drawRaster;

function drawRaster(painter, source, layer, coords) {
    if (painter.isOpaquePass) return;

    var gl = painter.gl;

    gl.enable(gl.DEPTH_TEST);
    painter.depthMask(true);

    // Change depth function to prevent double drawing in areas where tiles overlap.
    gl.depthFunc(gl.LESS);

    var minTileZ = coords.length && coords[0].z;

    for (var i = 0; i < coords.length; i++) {
        var coord = coords[i];
        // set the lower zoom level to sublayer 0, and higher zoom levels to higher sublayers
        painter.setDepthSublayer(coord.z - minTileZ);
        drawRasterTile(painter, source, layer, coord);
    }

    gl.depthFunc(gl.LEQUAL);
}

drawRaster.RasterBoundsArray = new StructArrayType({
    members: [
        { name: 'a_pos', type: 'Int16', components: 2 },
        { name: 'a_texture_pos', type: 'Int16', components: 2 }
    ]
});

function drawRasterTile(painter, source, layer, coord) {

    var gl = painter.gl;

    gl.disable(gl.STENCIL_TEST);

    var tile = source.getTile(coord);
    var posMatrix = painter.transform.calculatePosMatrix(coord, source.maxzoom);

    var program = painter.useProgram('raster');
    gl.uniformMatrix4fv(program.u_matrix, false, posMatrix);

    // color parameters
    gl.uniform1f(program.u_brightness_low, layer.paint['raster-brightness-min']);
    gl.uniform1f(program.u_brightness_high, layer.paint['raster-brightness-max']);
    gl.uniform1f(program.u_saturation_factor, saturationFactor(layer.paint['raster-saturation']));
    gl.uniform1f(program.u_contrast_factor, contrastFactor(layer.paint['raster-contrast']));
    gl.uniform3fv(program.u_spin_weights, spinWeights(layer.paint['raster-hue-rotate']));

    var parentTile = tile.source && tile.source._pyramid.findLoadedParent(coord, 0, {}),
        opacities = getOpacities(tile, parentTile, layer, painter.transform);

    var parentScaleBy, parentTL;

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, tile.texture);

    if (parentTile) {
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, parentTile.texture);

        parentScaleBy = Math.pow(2, parentTile.coord.z - tile.coord.z);
        parentTL = [tile.coord.x * parentScaleBy % 1, tile.coord.y * parentScaleBy % 1];
    } else {
        opacities[1] = 0;
    }

    // cross-fade parameters
    gl.uniform2fv(program.u_tl_parent, parentTL || [0, 0]);
    gl.uniform1f(program.u_scale_parent, parentScaleBy || 1);
    gl.uniform1f(program.u_buffer_scale, 1);
    gl.uniform1f(program.u_opacity0, opacities[0]);
    gl.uniform1f(program.u_opacity1, opacities[1]);
    gl.uniform1i(program.u_image0, 0);
    gl.uniform1i(program.u_image1, 1);

    var buffer = tile.boundsBuffer || painter.rasterBoundsBuffer;
    var vao = tile.boundsVAO || painter.rasterBoundsVAO;
    vao.bind(gl, program, buffer);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, buffer.length);
}

function spinWeights(angle) {
    angle *= Math.PI / 180;
    var s = Math.sin(angle);
    var c = Math.cos(angle);
    return [
        (2 * c + 1) / 3,
        (-Math.sqrt(3) * s - c + 1) / 3,
        (Math.sqrt(3) * s - c + 1) / 3
    ];
}

function contrastFactor(contrast) {
    return contrast > 0 ?
        1 / (1 - contrast) :
        1 + contrast;
}

function saturationFactor(saturation) {
    return saturation > 0 ?
        1 - 1 / (1.001 - saturation) :
        -saturation;
}

function getOpacities(tile, parentTile, layer, transform) {
    var opacity = [1, 0];
    var fadeDuration = layer.paint['raster-fade-duration'];

    if (tile.source && fadeDuration > 0) {
        var now = new Date().getTime();

        var sinceTile = (now - tile.timeAdded) / fadeDuration;
        var sinceParent = parentTile ? (now - parentTile.timeAdded) / fadeDuration : -1;

        var idealZ = tile.source._pyramid.coveringZoomLevel(transform);
        var parentFurther = parentTile ? Math.abs(parentTile.coord.z - idealZ) > Math.abs(tile.coord.z - idealZ) : false;

        if (!parentTile || parentFurther) {
            // if no parent or parent is older
            opacity[0] = util.clamp(sinceTile, 0, 1);
            opacity[1] = 1 - opacity[0];
        } else {
            // parent is younger, zooming out
            opacity[0] = util.clamp(1 - sinceParent, 0, 1);
            opacity[1] = 1 - opacity[0];
        }
    }

    var op = layer.paint['raster-opacity'];
    opacity[0] *= op;
    opacity[1] *= op;

    return opacity;
}

},{"../util/struct_array":115,"../util/util":117}],36:[function(require,module,exports){
'use strict';

var browser = require('../util/browser');
var drawCollisionDebug = require('./draw_collision_debug');
var util = require('../util/util');
var pixelsToTileUnits = require('../source/pixels_to_tile_units');


module.exports = drawSymbols;

function drawSymbols(painter, source, layer, coords) {
    if (painter.isOpaquePass) return;

    var drawAcrossEdges = !(layer.layout['text-allow-overlap'] || layer.layout['icon-allow-overlap'] ||
        layer.layout['text-ignore-placement'] || layer.layout['icon-ignore-placement']);

    var gl = painter.gl;

    // Disable the stencil test so that labels aren't clipped to tile boundaries.
    //
    // Layers with features that may be drawn overlapping aren't clipped. These
    // layers are sorted in the y direction, and to draw the correct ordering near
    // tile edges the icons are included in both tiles and clipped when drawing.
    if (drawAcrossEdges) {
        gl.disable(gl.STENCIL_TEST);
    } else {
        gl.enable(gl.STENCIL_TEST);
    }

    painter.setDepthSublayer(0);
    painter.depthMask(false);
    gl.disable(gl.DEPTH_TEST);

    drawLayerSymbols(painter, source, layer, coords, false,
            layer.paint['icon-translate'],
            layer.paint['icon-translate-anchor'],
            layer.layout['icon-rotation-alignment'],
            layer.layout['icon-size'],
            layer.paint['icon-halo-width'],
            layer.paint['icon-halo-color'],
            layer.paint['icon-halo-blur'],
            layer.paint['icon-opacity'],
            layer.paint['icon-color']);

    drawLayerSymbols(painter, source, layer, coords, true,
            layer.paint['text-translate'],
            layer.paint['text-translate-anchor'],
            layer.layout['text-rotation-alignment'],
            layer.layout['text-size'],
            layer.paint['text-halo-width'],
            layer.paint['text-halo-color'],
            layer.paint['text-halo-blur'],
            layer.paint['text-opacity'],
            layer.paint['text-color']);

    gl.enable(gl.DEPTH_TEST);

    drawCollisionDebug(painter, source, layer, coords);
}

function drawLayerSymbols(painter, source, layer, coords, isText,
        translate,
        translateAnchor,
        rotationAlignment,
        size,
        haloWidth,
        haloColor,
        haloBlur,
        opacity,
        color) {

    haloColor = util.premultiply(haloColor);
    color = util.premultiply(color);

    for (var j = 0; j < coords.length; j++) {
        var tile = source.getTile(coords[j]);
        var bucket = tile.getBucket(layer);
        if (!bucket) continue;
        var bothBufferGroups = bucket.bufferGroups;
        var bufferGroups = isText ? bothBufferGroups.glyph : bothBufferGroups.icon;
        if (!bufferGroups.length) continue;

        painter.enableTileClippingMask(coords[j]);
        drawSymbol(painter, layer, coords[j].posMatrix, tile, bucket, bufferGroups, isText,
                isText || bucket.sdfIcons, !isText && bucket.iconsNeedLinear,
                isText ? bucket.adjustedTextSize : bucket.adjustedIconSize, bucket.fontstack,
                translate,
                translateAnchor,
                rotationAlignment,
                size,
                haloWidth,
                haloColor,
                haloBlur,
                opacity,
                color);
    }
}

function drawSymbol(painter, layer, posMatrix, tile, bucket, bufferGroups, isText, sdf, iconsNeedLinear, adjustedSize, fontstack,
        translate,
        translateAnchor,
        rotationAlignment,
        size,
        haloWidth,
        haloColor,
        haloBlur,
        opacity,
        color) {
    var gl = painter.gl;
    var tr = painter.transform;
    var alignedWithMap = rotationAlignment === 'map';

    var defaultSize = isText ? 24 : 1;
    var fontScale = size / defaultSize;

    var extrudeScale, s, gammaScale;
    if (alignedWithMap) {
        s = pixelsToTileUnits(tile, 1, painter.transform.zoom) * fontScale;
        gammaScale = 1 / Math.cos(tr._pitch);
        extrudeScale = [s, s];
    } else {
        s = painter.transform.altitude * fontScale;
        gammaScale = 1;
        extrudeScale = [ tr.pixelsToGLUnits[0] * s, tr.pixelsToGLUnits[1] * s];
    }

    // calculate how much longer the real world distance is at the top of the screen
    // than at the middle of the screen.
    var topedgelength = Math.sqrt(tr.height * tr.height / 4  * (1 + tr.altitude * tr.altitude));
    var x = tr.height / 2 * Math.tan(tr._pitch);
    var extra = (topedgelength + x) / topedgelength - 1;

    if (!isText && !painter.style.sprite.loaded())
        return;

    var program = painter.useProgram(sdf ? 'sdf' : 'icon');
    gl.uniformMatrix4fv(program.u_matrix, false, painter.translatePosMatrix(posMatrix, tile, translate, translateAnchor));
    gl.uniform1i(program.u_skewed, alignedWithMap);
    gl.uniform1f(program.u_extra, extra);
    gl.uniform2fv(program.u_extrude_scale, extrudeScale);

    gl.activeTexture(gl.TEXTURE0);
    gl.uniform1i(program.u_texture, 0);

    if (isText) {
        // use the fonstack used when parsing the tile, not the fontstack
        // at the current zoom level (layout['text-font']).
        var glyphAtlas = fontstack && painter.glyphSource.getGlyphAtlas(fontstack);
        if (!glyphAtlas) return;

        glyphAtlas.updateTexture(gl);
        gl.uniform2f(program.u_texsize, glyphAtlas.width / 4, glyphAtlas.height / 4);
    } else {
        var mapMoving = painter.options.rotating || painter.options.zooming;
        var iconScaled = fontScale !== 1 || browser.devicePixelRatio !== painter.spriteAtlas.pixelRatio || iconsNeedLinear;
        var iconTransformed = alignedWithMap || painter.transform.pitch;
        painter.spriteAtlas.bind(gl, sdf || mapMoving || iconScaled || iconTransformed);
        gl.uniform2f(program.u_texsize, painter.spriteAtlas.width / 4, painter.spriteAtlas.height / 4);
    }

    // adjust min/max zooms for variable font sizes
    var zoomAdjust = Math.log(size / adjustedSize) / Math.LN2 || 0;
    gl.uniform1f(program.u_zoom, (painter.transform.zoom - zoomAdjust) * 10); // current zoom level

    gl.activeTexture(gl.TEXTURE1);
    painter.frameHistory.bind(gl);
    gl.uniform1i(program.u_fadetexture, 1);

    var group;

    if (sdf) {
        var sdfPx = 8;
        var blurOffset = 1.19;
        var haloOffset = 6;
        var gamma = 0.105 * defaultSize / size / browser.devicePixelRatio;

        if (haloWidth) {
            // Draw halo underneath the text.
            gl.uniform1f(program.u_gamma, (haloBlur * blurOffset / fontScale / sdfPx + gamma) * gammaScale);
            gl.uniform4fv(program.u_color, haloColor);
            gl.uniform1f(program.u_opacity, opacity);
            gl.uniform1f(program.u_buffer, (haloOffset - haloWidth / fontScale) / sdfPx);

            for (var j = 0; j < bufferGroups.length; j++) {
                group = bufferGroups[j];
                group.vaos[layer.id].bind(gl, program, group.layout.vertex, group.layout.element);
                gl.drawElements(gl.TRIANGLES, group.layout.element.length * 3, gl.UNSIGNED_SHORT, 0);
            }
        }

        gl.uniform1f(program.u_gamma, gamma * gammaScale);
        gl.uniform4fv(program.u_color, color);
        gl.uniform1f(program.u_opacity, opacity);
        gl.uniform1f(program.u_buffer, (256 - 64) / 256);

        for (var i = 0; i < bufferGroups.length; i++) {
            group = bufferGroups[i];
            group.vaos[layer.id].bind(gl, program, group.layout.vertex, group.layout.element);
            gl.drawElements(gl.TRIANGLES, group.layout.element.length * 3, gl.UNSIGNED_SHORT, 0);
        }

    } else {
        gl.uniform1f(program.u_opacity, opacity);
        for (var k = 0; k < bufferGroups.length; k++) {
            group = bufferGroups[k];
            group.vaos[layer.id].bind(gl, program, group.layout.vertex, group.layout.element);
            gl.drawElements(gl.TRIANGLES, group.layout.element.length * 3, gl.UNSIGNED_SHORT, 0);
        }
    }
}

},{"../source/pixels_to_tile_units":45,"../util/browser":103,"../util/util":117,"./draw_collision_debug":31}],37:[function(require,module,exports){
'use strict';

module.exports = FrameHistory;

function FrameHistory() {
    this.changeTimes = new Float64Array(256);
    this.changeOpacities = new Uint8Array(256);
    this.opacities = new Uint8ClampedArray(256);
    this.array = new Uint8Array(this.opacities.buffer);

    this.fadeDuration = 300;
    this.previousZoom = 0;
    this.firstFrame = true;
}

FrameHistory.prototype.record = function(zoom) {
    var now = Date.now();

    if (this.firstFrame) {
        now = 0;
        this.firstFrame = false;
    }

    zoom = Math.floor(zoom * 10);

    var z;
    if (zoom < this.previousZoom) {
        for (z = zoom + 1; z <= this.previousZoom; z++) {
            this.changeTimes[z] = now;
            this.changeOpacities[z] = this.opacities[z];
        }
    } else {
        for (z = zoom; z > this.previousZoom; z--) {
            this.changeTimes[z] = now;
            this.changeOpacities[z] = this.opacities[z];
        }
    }

    for (z = 0; z < 256; z++) {
        var timeSince = now - this.changeTimes[z];
        var opacityChange = timeSince / this.fadeDuration * 255;
        if (z <= zoom) {
            this.opacities[z] = this.changeOpacities[z] + opacityChange;
        } else {
            this.opacities[z] = this.changeOpacities[z] - opacityChange;
        }
    }

    this.changed = true;
    this.previousZoom = zoom;
};

FrameHistory.prototype.bind = function(gl) {
    if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, 256, 1, 0, gl.ALPHA, gl.UNSIGNED_BYTE, this.array);

    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        if (this.changed) {
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 256, 1, gl.ALPHA, gl.UNSIGNED_BYTE, this.array);
            this.changed = false;
        }
    }
};

},{}],38:[function(require,module,exports){
'use strict';

module.exports = LineAtlas;

/**
 * A LineAtlas lets us reuse rendered dashed lines
 * by writing many of them to a texture and then fetching their positions
 * using .getDash.
 *
 * @param {number} width
 * @param {number} height
 * @private
 */
function LineAtlas(width, height) {
    this.width = width;
    this.height = height;
    this.nextRow = 0;

    this.bytes = 4;
    this.data = new Uint8Array(this.width * this.height * this.bytes);

    this.positions = {};
}

LineAtlas.prototype.setSprite = function(sprite) {
    this.sprite = sprite;
};

/**
 * Get or create a dash line pattern.
 *
 * @param {Array<number>} dasharray
 * @param {boolean} round whether to add circle caps in between dash segments
 * @returns {Object} position of dash texture in { y, height, width }
 * @private
 */
LineAtlas.prototype.getDash = function(dasharray, round) {
    var key = dasharray.join(",") + round;

    if (!this.positions[key]) {
        this.positions[key] = this.addDash(dasharray, round);
    }
    return this.positions[key];
};

LineAtlas.prototype.addDash = function(dasharray, round) {

    var n = round ? 7 : 0;
    var height = 2 * n + 1;
    var offset = 128;

    if (this.nextRow + height > this.height) {
        console.warn('LineAtlas out of space');
        return null;
    }

    var length = 0;
    for (var i = 0; i < dasharray.length; i++) {
        length += dasharray[i];
    }

    var stretch = this.width / length;
    var halfWidth = stretch / 2;

    // If dasharray has an odd length, both the first and last parts
    // are dashes and should be joined seamlessly.
    var oddLength = dasharray.length % 2 === 1;

    for (var y = -n; y <= n; y++) {
        var row = this.nextRow + n + y;
        var index = this.width * row;

        var left = oddLength ? -dasharray[dasharray.length - 1] : 0;
        var right = dasharray[0];
        var partIndex = 1;

        for (var x = 0; x < this.width; x++) {

            while (right < x / stretch) {
                left = right;
                right = right + dasharray[partIndex];

                if (oddLength && partIndex === dasharray.length - 1) {
                    right += dasharray[0];
                }

                partIndex++;
            }

            var distLeft = Math.abs(x - left * stretch);
            var distRight = Math.abs(x - right * stretch);
            var dist = Math.min(distLeft, distRight);
            var inside = (partIndex % 2) === 1;
            var signedDistance;

            if (round) {
                // Add circle caps
                var distMiddle = n ? y / n * (halfWidth + 1) : 0;
                if (inside) {
                    var distEdge = halfWidth - Math.abs(distMiddle);
                    signedDistance = Math.sqrt(dist * dist + distEdge * distEdge);
                } else {
                    signedDistance = halfWidth - Math.sqrt(dist * dist + distMiddle * distMiddle);
                }
            } else {
                signedDistance = (inside ? 1 : -1) * dist;
            }

            this.data[3 + (index + x) * 4] = Math.max(0, Math.min(255, signedDistance + offset));
        }
    }

    var pos = {
        y: (this.nextRow + n + 0.5) / this.height,
        height: 2 * n / this.height,
        width: length
    };

    this.nextRow += height;
    this.dirty = true;

    return pos;
};

LineAtlas.prototype.bind = function(gl) {
    if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.data);

    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);

        if (this.dirty) {
            this.dirty = false;
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
        }
    }
};

},{}],39:[function(require,module,exports){
'use strict';

var browser = require('../util/browser');
var mat4 = require('gl-matrix').mat4;
var FrameHistory = require('./frame_history');
var TilePyramid = require('../source/tile_pyramid');
var EXTENT = require('../data/bucket').EXTENT;
var pixelsToTileUnits = require('../source/pixels_to_tile_units');
var util = require('../util/util');
var StructArrayType = require('../util/struct_array');
var Buffer = require('../data/buffer');
var VertexArrayObject = require('./vertex_array_object');
var RasterBoundsArray = require('./draw_raster').RasterBoundsArray;

module.exports = Painter;

/**
 * Initialize a new painter object.
 *
 * @param {Canvas} gl an experimental-webgl drawing context
 * @private
 */
function Painter(gl, transform) {
    this.gl = gl;
    this.transform = transform;

    this.reusableTextures = {};
    this.preFbos = {};

    this.frameHistory = new FrameHistory();

    this.setup();

    // Within each layer there are multiple distinct z-planes that can be drawn to.
    // This is implemented using the WebGL depth buffer.
    this.numSublayers = TilePyramid.maxUnderzooming + TilePyramid.maxOverzooming + 1;
    this.depthEpsilon = 1 / Math.pow(2, 16);

    this.lineWidthRange = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE);
}

util.extend(Painter.prototype, require('./painter/use_program'));

/*
 * Update the GL viewport, projection matrix, and transforms to compensate
 * for a new width and height value.
 */
Painter.prototype.resize = function(width, height) {
    var gl = this.gl;

    this.width = width * browser.devicePixelRatio;
    this.height = height * browser.devicePixelRatio;
    gl.viewport(0, 0, this.width, this.height);

};

Painter.prototype.setup = function() {
    var gl = this.gl;

    gl.verbose = true;

    // We are blending the new pixels *behind* the existing pixels. That way we can
    // draw front-to-back and use then stencil buffer to cull opaque pixels early.
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

    gl.enable(gl.STENCIL_TEST);

    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);

    this._depthMask = false;
    gl.depthMask(false);

    var PosArray = this.PosArray = new StructArrayType({
        members: [{ name: 'a_pos', type: 'Int16', components: 2 }]
    });

    var tileExtentArray = new PosArray();
    tileExtentArray.emplaceBack(0, 0);
    tileExtentArray.emplaceBack(EXTENT, 0);
    tileExtentArray.emplaceBack(0, EXTENT);
    tileExtentArray.emplaceBack(EXTENT, EXTENT);
    this.tileExtentBuffer = new Buffer(tileExtentArray.serialize(), PosArray.serialize(), Buffer.BufferType.VERTEX);
    this.tileExtentVAO = new VertexArrayObject();
    this.tileExtentPatternVAO = new VertexArrayObject();

    var debugArray = new PosArray();
    debugArray.emplaceBack(0, 0);
    debugArray.emplaceBack(EXTENT, 0);
    debugArray.emplaceBack(EXTENT, EXTENT);
    debugArray.emplaceBack(0, EXTENT);
    debugArray.emplaceBack(0, 0);
    this.debugBuffer = new Buffer(debugArray.serialize(), PosArray.serialize(), Buffer.BufferType.VERTEX);
    this.debugVAO = new VertexArrayObject();

    var rasterBoundsArray = new RasterBoundsArray();
    rasterBoundsArray.emplaceBack(0, 0, 0, 0);
    rasterBoundsArray.emplaceBack(EXTENT, 0, 32767, 0);
    rasterBoundsArray.emplaceBack(0, EXTENT, 0, 32767);
    rasterBoundsArray.emplaceBack(EXTENT, EXTENT, 32767, 32767);
    this.rasterBoundsBuffer = new Buffer(rasterBoundsArray.serialize(), RasterBoundsArray.serialize(), Buffer.BufferType.VERTEX);
    this.rasterBoundsVAO = new VertexArrayObject();
};

/*
 * Reset the color buffers of the drawing canvas.
 */
Painter.prototype.clearColor = function() {
    var gl = this.gl;
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
};

/*
 * Reset the drawing canvas by clearing the stencil buffer so that we can draw
 * new tiles at the same location, while retaining previously drawn pixels.
 */
Painter.prototype.clearStencil = function() {
    var gl = this.gl;
    gl.clearStencil(0x0);
    gl.stencilMask(0xFF);
    gl.clear(gl.STENCIL_BUFFER_BIT);
};

Painter.prototype.clearDepth = function() {
    var gl = this.gl;
    gl.clearDepth(1);
    this.depthMask(true);
    gl.clear(gl.DEPTH_BUFFER_BIT);
};

Painter.prototype._renderTileClippingMasks = function(coords) {
    var gl = this.gl;
    gl.colorMask(false, false, false, false);
    this.depthMask(false);
    gl.disable(gl.DEPTH_TEST);
    gl.enable(gl.STENCIL_TEST);

    // Only write clipping IDs to the last 5 bits. The first three are used for drawing fills.
    gl.stencilMask(0xF8);
    // Tests will always pass, and ref value will be written to stencil buffer.
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);

    var idNext = 1;
    this._tileClippingMaskIDs = {};
    for (var i = 0; i < coords.length; i++) {
        var coord = coords[i];
        var id = this._tileClippingMaskIDs[coord.id] = (idNext++) << 3;

        gl.stencilFunc(gl.ALWAYS, id, 0xF8);

        var program = this.useProgram('fill');
        gl.uniformMatrix4fv(program.u_matrix, false, coord.posMatrix);

        // Draw the clipping mask
        this.tileExtentVAO.bind(gl, program, this.tileExtentBuffer);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.tileExtentBuffer.length);
    }

    gl.stencilMask(0x00);
    gl.colorMask(true, true, true, true);
    this.depthMask(true);
    gl.enable(gl.DEPTH_TEST);
};

Painter.prototype.enableTileClippingMask = function(coord) {
    var gl = this.gl;
    gl.stencilFunc(gl.EQUAL, this._tileClippingMaskIDs[coord.id], 0xF8);
};

// Overridden by headless tests.
Painter.prototype.prepareBuffers = function() {};
Painter.prototype.bindDefaultFramebuffer = function() {
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};

var draw = {
    symbol: require('./draw_symbol'),
    circle: require('./draw_circle'),
    line: require('./draw_line'),
    fill: require('./draw_fill'),
    raster: require('./draw_raster'),
    background: require('./draw_background'),
    debug: require('./draw_debug')
};

Painter.prototype.render = function(style, options) {
    this.style = style;
    this.options = options;

    this.lineAtlas = style.lineAtlas;

    this.spriteAtlas = style.spriteAtlas;
    this.spriteAtlas.setSprite(style.sprite);

    this.glyphSource = style.glyphSource;

    this.frameHistory.record(this.transform.zoom);

    this.prepareBuffers();
    this.clearColor();
    this.clearDepth();

    this.showOverdrawInspector(options.showOverdrawInspector);

    this.depthRange = (style._order.length + 2) * this.numSublayers * this.depthEpsilon;

    this.renderPass({isOpaquePass: true});
    this.renderPass({isOpaquePass: false});
};

Painter.prototype.renderPass = function(options) {
    var groups = this.style._groups;
    var isOpaquePass = options.isOpaquePass;
    this.currentLayer = isOpaquePass ? this.style._order.length : -1;

    for (var i = 0; i < groups.length; i++) {
        var group = groups[isOpaquePass ? groups.length - 1 - i : i];
        var source = this.style.sources[group.source];

        var j;
        var coords = [];
        if (source) {
            coords = source.getVisibleCoordinates();
            for (j = 0; j < coords.length; j++) {
                coords[j].posMatrix = this.transform.calculatePosMatrix(coords[j], source.maxzoom);
            }
            this.clearStencil();
            if (source.prepare) source.prepare();
            if (source.isTileClipped) {
                this._renderTileClippingMasks(coords);
            }
        }

        if (isOpaquePass) {
            if (!this._showOverdrawInspector) {
                this.gl.disable(this.gl.BLEND);
            }
            this.isOpaquePass = true;
        } else {
            this.gl.enable(this.gl.BLEND);
            this.isOpaquePass = false;
            coords.reverse();
        }

        for (j = 0; j < group.length; j++) {
            var layer = group[isOpaquePass ? group.length - 1 - j : j];
            this.currentLayer += isOpaquePass ? -1 : 1;
            this.renderLayer(this, source, layer, coords);
        }

        if (source) {
            draw.debug(this, source, coords);
        }
    }
};

Painter.prototype.depthMask = function(mask) {
    if (mask !== this._depthMask) {
        this._depthMask = mask;
        this.gl.depthMask(mask);
    }
};

Painter.prototype.renderLayer = function(painter, source, layer, coords) {
    if (layer.isHidden(this.transform.zoom)) return;
    if (layer.type !== 'background' && !coords.length) return;
    this.id = layer.id;
    draw[layer.type](painter, source, layer, coords);
};

Painter.prototype.setDepthSublayer = function(n) {
    var farDepth = 1 - ((1 + this.currentLayer) * this.numSublayers + n) * this.depthEpsilon;
    var nearDepth = farDepth - 1 + this.depthRange;
    this.gl.depthRange(nearDepth, farDepth);
};

Painter.prototype.translatePosMatrix = function(matrix, tile, translate, anchor) {
    if (!translate[0] && !translate[1]) return matrix;

    if (anchor === 'viewport') {
        var sinA = Math.sin(-this.transform.angle);
        var cosA = Math.cos(-this.transform.angle);
        translate = [
            translate[0] * cosA - translate[1] * sinA,
            translate[0] * sinA + translate[1] * cosA
        ];
    }

    var translation = [
        pixelsToTileUnits(tile, translate[0], this.transform.zoom),
        pixelsToTileUnits(tile, translate[1], this.transform.zoom),
        0
    ];

    var translatedMatrix = new Float32Array(16);
    mat4.translate(translatedMatrix, matrix, translation);
    return translatedMatrix;
};

Painter.prototype.saveTexture = function(texture) {
    var textures = this.reusableTextures[texture.size];
    if (!textures) {
        this.reusableTextures[texture.size] = [texture];
    } else {
        textures.push(texture);
    }
};


Painter.prototype.getTexture = function(size) {
    var textures = this.reusableTextures[size];
    return textures && textures.length > 0 ? textures.pop() : null;
};

Painter.prototype.lineWidth = function(width) {
    this.gl.lineWidth(util.clamp(width, this.lineWidthRange[0], this.lineWidthRange[1]));
};

Painter.prototype.showOverdrawInspector = function(enabled) {
    if (!enabled && !this._showOverdrawInspector) return;
    this._showOverdrawInspector = enabled;

    var gl = this.gl;
    if (enabled) {
        gl.blendFunc(gl.CONSTANT_COLOR, gl.ONE);
        var numOverdrawSteps = 8;
        var a = 1 / numOverdrawSteps;
        gl.blendColor(a, a, a, 0);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
    } else {
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    }
};

},{"../data/bucket":15,"../data/buffer":20,"../source/pixels_to_tile_units":45,"../source/tile_pyramid":50,"../util/browser":103,"../util/struct_array":115,"../util/util":117,"./draw_background":29,"./draw_circle":30,"./draw_debug":32,"./draw_fill":33,"./draw_line":34,"./draw_raster":35,"./draw_symbol":36,"./frame_history":37,"./painter/use_program":40,"./vertex_array_object":41,"gl-matrix":131}],40:[function(require,module,exports){
'use strict';


var path = require('path');
var assert = require('assert');
var util = require('../../util/util');

// readFileSync calls must be written out long-form for brfs.
var definitions = {
    debug: {
        fragmentSource: "precision mediump float;\n\nuniform lowp vec4 u_color;\n\nvoid main() {\n    gl_FragColor = u_color;\n}\n",
        vertexSource: "precision highp float;\n\nattribute vec2 a_pos;\n\nuniform mat4 u_matrix;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, step(32767.0, a_pos.x), 1);\n}\n"
    },
    fill: {
        fragmentSource: "precision mediump float;\n\nuniform lowp vec4 u_color;\nuniform lowp float u_opacity;\n\nvoid main() {\n    gl_FragColor = u_color * u_opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
        vertexSource: "precision highp float;\n\nattribute vec2 a_pos;\nuniform mat4 u_matrix;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n}\n"
    },
    circle: {
        fragmentSource: "precision mediump float;\n\nuniform lowp float u_blur;\nuniform lowp float u_opacity;\n\nvarying lowp vec4 v_color;\nvarying vec2 v_extrude;\nvarying lowp float v_antialiasblur;\n\nvoid main() {\n    float t = smoothstep(1.0 - max(u_blur, v_antialiasblur), 1.0, length(v_extrude));\n    gl_FragColor = v_color * (1.0 - t) * u_opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
        vertexSource: "precision highp float;\n\nuniform mat4 u_matrix;\nuniform vec2 u_extrude_scale;\nuniform float u_devicepixelratio;\n\nattribute vec2 a_pos;\n\n#ifdef ATTRIBUTE_A_COLOR\nattribute lowp vec4 a_color;\n#elif defined ATTRIBUTE_ZOOM_FUNCTION_A_COLOR0\nuniform lowp float u_color_t;\nattribute lowp vec4 a_color0;\nattribute lowp vec4 a_color1;\nattribute lowp vec4 a_color2;\nattribute lowp vec4 a_color3;\n#else\nuniform lowp vec4 a_color;\n#endif\n\n#ifdef ATTRIBUTE_A_RADIUS\nattribute mediump float a_radius;\n#elif defined ATTRIBUTE_ZOOM_FUNCTION_A_RADIUS\nuniform lowp float u_radius_t;\nattribute mediump vec4 a_radius;\n#else\nuniform mediump float a_radius;\n#endif\n\nvarying vec2 v_extrude;\nvarying lowp vec4 v_color;\nvarying lowp float v_antialiasblur;\n\nfloat evaluate_zoom_function_1(const vec4 values, const float t) {\n    if (t < 1.0) {\n        return mix(values[0], values[1], t);\n    } else if (t < 2.0) {\n        return mix(values[1], values[2], t - 1.0);\n    } else {\n        return mix(values[2], values[3], t - 2.0);\n    }\n}\n\nvec4 evaluate_zoom_function_4(const vec4 value0, const vec4 value1, const vec4 value2, const vec4 value3, const float t) {\n    if (t < 1.0) {\n        return mix(value0, value1, t);\n    } else if (t < 2.0) {\n        return mix(value1, value2, t - 1.0);\n    } else {\n        return mix(value2, value3, t - 2.0);\n    }\n}\n\nvoid main(void) {\n\n#ifdef ATTRIBUTE_A_RADIUS\n    mediump float radius = a_radius / 10.0;\n#elif defined ATTRIBUTE_ZOOM_FUNCTION_A_RADIUS\n    mediump float radius = evaluate_zoom_function_1(a_radius, u_radius_t) / 10.0;\n#else\n    mediump float radius = a_radius;\n#endif\n\n    // unencode the extrusion vector that we snuck into the a_pos vector\n    v_extrude = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\n\n    vec2 extrude = v_extrude * radius * u_extrude_scale;\n    // multiply a_pos by 0.5, since we had it * 2 in order to sneak\n    // in extrusion data\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5), 0, 1);\n\n    // gl_Position is divided by gl_Position.w after this shader runs.\n    // Multiply the extrude by it so that it isn't affected by it.\n    gl_Position.xy += extrude * gl_Position.w;\n\n#ifdef ATTRIBUTE_A_COLOR\n    v_color = a_color / 255.0;\n#elif defined ATTRIBUTE_ZOOM_FUNCTION_A_COLOR0\n    v_color = evaluate_zoom_function_4(a_color0, a_color1, a_color2, a_color3, u_color_t) / 255.0;\n#else\n    v_color = a_color;\n#endif\n\n    // This is a minimum blur distance that serves as a faux-antialiasing for\n    // the circle. since blur is a ratio of the circle's size and the intent is\n    // to keep the blur at roughly 1px, the two are inversely related.\n    v_antialiasblur = 1.0 / u_devicepixelratio / radius;\n}\n"
    },
    line: {
        fragmentSource: "precision mediump float;\n\nuniform vec2 u_linewidth;\nuniform lowp vec4 u_color;\nuniform lowp float u_opacity;\nuniform float u_blur;\n\nvarying vec2 v_normal;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\nvoid main() {\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * u_linewidth.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_linewidth.t) or when fading out\n    // (v_linewidth.s)\n    float blur = u_blur * v_gamma_scale;\n    float alpha = clamp(min(dist - (u_linewidth.t - blur), u_linewidth.s - dist) / blur, 0.0, 1.0);\n\n    gl_FragColor = u_color * (alpha * u_opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
        vertexSource: "precision highp float;\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\nattribute vec2 a_pos;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform float u_ratio;\nuniform mediump vec2 u_linewidth;\nuniform float u_extra;\nuniform mat2 u_antialiasingmatrix;\nuniform mediump float u_offset;\n\nvarying vec2 v_normal;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\nvoid main() {\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n\n    // We store the texture normals in the most insignificant bit\n    // transform y so that 0 => -1 and 1 => 1\n    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = mod(a_pos, 2.0);\n    normal.y = sign(normal.y - 0.5);\n    v_normal = normal;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec4 dist = vec4(u_linewidth.s * a_extrude * scale, 0.0, 0.0);\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset = u_offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    // Remove the texture normal bit of the position before scaling it with the\n    // model/view matrix.\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5) + (offset + dist.xy) / u_ratio, 0.0, 1.0);\n\n    // position of y on the screen\n    float y = gl_Position.y / gl_Position.w;\n\n    // how much features are squished in the y direction by the tilt\n    float squish_scale = length(a_extrude) / length(u_antialiasingmatrix * a_extrude);\n\n    // how much features are squished in all directions by the perspectiveness\n    float perspective_scale = 1.0 / (1.0 - min(y * u_extra, 0.9));\n\n    v_gamma_scale = perspective_scale * squish_scale;\n}\n"
    },
    linepattern: {
        fragmentSource: "precision mediump float;\n\nuniform vec2 u_linewidth;\nuniform float u_point;\nuniform float u_blur;\n\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform float u_fade;\nuniform float u_opacity;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_normal;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\nvoid main() {\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * u_linewidth.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_linewidth.t) or when fading out\n    // (v_linewidth.s)\n    float blur = u_blur * v_gamma_scale;\n    float alpha = clamp(min(dist - (u_linewidth.t - blur), u_linewidth.s - dist) / blur, 0.0, 1.0);\n\n    float x_a = mod(v_linesofar / u_pattern_size_a.x, 1.0);\n    float x_b = mod(v_linesofar / u_pattern_size_b.x, 1.0);\n    float y_a = 0.5 + (v_normal.y * u_linewidth.s / u_pattern_size_a.y);\n    float y_b = 0.5 + (v_normal.y * u_linewidth.s / u_pattern_size_b.y);\n    vec2 pos = mix(u_pattern_tl_a, u_pattern_br_a, vec2(x_a, y_a));\n    vec2 pos2 = mix(u_pattern_tl_b, u_pattern_br_b, vec2(x_b, y_b));\n\n    vec4 color = mix(texture2D(u_image, pos), texture2D(u_image, pos2), u_fade);\n\n    alpha *= u_opacity;\n\n    gl_FragColor = color * alpha;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
        vertexSource: "precision highp float;\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\n// We scale the distance before adding it to the buffers so that we can store\n// long distances for long segments. Use this value to unscale the distance.\n#define LINE_DISTANCE_SCALE 2.0\n\nattribute vec2 a_pos;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform mediump float u_ratio;\nuniform mediump vec2 u_linewidth;\nuniform float u_extra;\nuniform mat2 u_antialiasingmatrix;\nuniform mediump float u_offset;\n\nvarying vec2 v_normal;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\nvoid main() {\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n    float a_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * LINE_DISTANCE_SCALE;\n\n    // We store the texture normals in the most insignificant bit\n    // transform y so that 0 => -1 and 1 => 1\n    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = mod(a_pos, 2.0);\n    normal.y = sign(normal.y - 0.5);\n    v_normal = normal;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec2 extrude = a_extrude * scale;\n    mediump vec2 dist = u_linewidth.s * extrude;\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset = u_offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    // Remove the texture normal bit of the position before scaling it with the\n    // model/view matrix.\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5) + (offset + dist.xy) / u_ratio, 0.0, 1.0);\n    v_linesofar = a_linesofar;\n\n    // position of y on the screen\n    float y = gl_Position.y / gl_Position.w;\n\n    // how much features are squished in the y direction by the tilt\n    float squish_scale = length(a_extrude) / length(u_antialiasingmatrix * a_extrude);\n\n    // how much features are squished in all directions by the perspectiveness\n    float perspective_scale = 1.0 / (1.0 - min(y * u_extra, 0.9));\n\n    v_gamma_scale = perspective_scale * squish_scale;\n}\n"
    },
    linesdfpattern: {
        fragmentSource: "precision mediump float;\n\nuniform vec2 u_linewidth;\nuniform lowp vec4 u_color;\nuniform lowp float u_opacity;\nuniform float u_blur;\nuniform sampler2D u_image;\nuniform float u_sdfgamma;\nuniform float u_mix;\n\nvarying vec2 v_normal;\nvarying vec2 v_tex_a;\nvarying vec2 v_tex_b;\nvarying float v_gamma_scale;\n\nvoid main() {\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * u_linewidth.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_linewidth.t) or when fading out\n    // (v_linewidth.s)\n    float blur = u_blur * v_gamma_scale;\n    float alpha = clamp(min(dist - (u_linewidth.t - blur), u_linewidth.s - dist) / blur, 0.0, 1.0);\n\n    float sdfdist_a = texture2D(u_image, v_tex_a).a;\n    float sdfdist_b = texture2D(u_image, v_tex_b).a;\n    float sdfdist = mix(sdfdist_a, sdfdist_b, u_mix);\n    alpha *= smoothstep(0.5 - u_sdfgamma, 0.5 + u_sdfgamma, sdfdist);\n\n    gl_FragColor = u_color * (alpha * u_opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
        vertexSource: "precision highp float;\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\n// We scale the distance before adding it to the buffers so that we can store\n// long distances for long segments. Use this value to unscale the distance.\n#define LINE_DISTANCE_SCALE 2.0\n\nattribute vec2 a_pos;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform mediump vec2 u_linewidth;\nuniform mediump float u_ratio;\nuniform vec2 u_patternscale_a;\nuniform float u_tex_y_a;\nuniform vec2 u_patternscale_b;\nuniform float u_tex_y_b;\nuniform float u_extra;\nuniform mat2 u_antialiasingmatrix;\nuniform mediump float u_offset;\n\nvarying vec2 v_normal;\nvarying vec2 v_tex_a;\nvarying vec2 v_tex_b;\nvarying float v_gamma_scale;\n\nvoid main() {\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n    float a_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * LINE_DISTANCE_SCALE;\n\n    // We store the texture normals in the most insignificant bit\n    // transform y so that 0 => -1 and 1 => 1\n    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = mod(a_pos, 2.0);\n    normal.y = sign(normal.y - 0.5);\n    v_normal = normal;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec4 dist = vec4(u_linewidth.s * a_extrude * scale, 0.0, 0.0);\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset = u_offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    // Remove the texture normal bit of the position before scaling it with the\n    // model/view matrix.\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5) + (offset + dist.xy) / u_ratio, 0.0, 1.0);\n\n    v_tex_a = vec2(a_linesofar * u_patternscale_a.x, normal.y * u_patternscale_a.y + u_tex_y_a);\n    v_tex_b = vec2(a_linesofar * u_patternscale_b.x, normal.y * u_patternscale_b.y + u_tex_y_b);\n\n    // position of y on the screen\n    float y = gl_Position.y / gl_Position.w;\n\n    // how much features are squished in the y direction by the tilt\n    float squish_scale = length(a_extrude) / length(u_antialiasingmatrix * a_extrude);\n\n    // how much features are squished in all directions by the perspectiveness\n    float perspective_scale = 1.0 / (1.0 - min(y * u_extra, 0.9));\n\n    v_gamma_scale = perspective_scale * squish_scale;\n}\n"
    },
    outline: {
        fragmentSource: "precision mediump float;\n\nuniform lowp vec4 u_color;\nuniform lowp float u_opacity;\n\nvarying vec2 v_pos;\n\nvoid main() {\n    float dist = length(v_pos - gl_FragCoord.xy);\n    float alpha = smoothstep(1.0, 0.0, dist);\n    gl_FragColor = u_color * (alpha * u_opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
        vertexSource: "precision highp float;\n\nattribute vec2 a_pos;\n\nuniform mat4 u_matrix;\nuniform vec2 u_world;\n\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos = (gl_Position.xy/gl_Position.w + 1.0) / 2.0 * u_world;\n}\n"
    },
    outlinepattern: {
        fragmentSource: "precision mediump float;\n\nuniform float u_opacity;\nuniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform float u_mix;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec2 v_pos;\n\nvoid main() {\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a, u_pattern_br_a, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b, u_pattern_br_b, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    // find distance to outline for alpha interpolation\n\n    float dist = length(v_pos - gl_FragCoord.xy);\n    float alpha = smoothstep(1.0, 0.0, dist);\n    \n\n    gl_FragColor = mix(color1, color2, u_mix) * alpha * u_opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
        vertexSource: "precision highp float;\n\nuniform vec2 u_patternscale_a;\nuniform vec2 u_patternscale_b;\nuniform vec2 u_offset_a;\nuniform vec2 u_offset_b;\n\nattribute vec2 a_pos;\n\nuniform mat4 u_matrix;\nuniform vec2 u_world;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec2 v_pos;\n\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos_a = u_patternscale_a * a_pos + u_offset_a;\n    v_pos_b = u_patternscale_b * a_pos + u_offset_b;\n    v_pos = (gl_Position.xy/gl_Position.w + 1.0) / 2.0 * u_world;\n}\n"
    },
    pattern: {
        fragmentSource: "precision mediump float;\n\nuniform float u_opacity;\nuniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform float u_mix;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\nvoid main() {\n\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a, u_pattern_br_a, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b, u_pattern_br_b, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    gl_FragColor = mix(color1, color2, u_mix) * u_opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
        vertexSource: "precision highp float;\n\nuniform mat4 u_matrix;\nuniform vec2 u_patternscale_a;\nuniform vec2 u_patternscale_b;\nuniform vec2 u_offset_a;\nuniform vec2 u_offset_b;\n\nattribute vec2 a_pos;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos_a = u_patternscale_a * a_pos + u_offset_a;\n    v_pos_b = u_patternscale_b * a_pos + u_offset_b;\n}\n"
    },
    raster: {
        fragmentSource: "precision mediump float;\n\nuniform float u_opacity0;\nuniform float u_opacity1;\nuniform sampler2D u_image0;\nuniform sampler2D u_image1;\nvarying vec2 v_pos0;\nvarying vec2 v_pos1;\n\nuniform float u_brightness_low;\nuniform float u_brightness_high;\n\nuniform float u_saturation_factor;\nuniform float u_contrast_factor;\nuniform vec3 u_spin_weights;\n\nvoid main() {\n\n    // read and cross-fade colors from the main and parent tiles\n    vec4 color0 = texture2D(u_image0, v_pos0);\n    vec4 color1 = texture2D(u_image1, v_pos1);\n    vec4 color = color0 * u_opacity0 + color1 * u_opacity1;\n    vec3 rgb = color.rgb;\n\n    // spin\n    rgb = vec3(\n        dot(rgb, u_spin_weights.xyz),\n        dot(rgb, u_spin_weights.zxy),\n        dot(rgb, u_spin_weights.yzx));\n\n    // saturation\n    float average = (color.r + color.g + color.b) / 3.0;\n    rgb += (average - rgb) * u_saturation_factor;\n\n    // contrast\n    rgb = (rgb - 0.5) * u_contrast_factor + 0.5;\n\n    // brightness\n    vec3 u_high_vec = vec3(u_brightness_low, u_brightness_low, u_brightness_low);\n    vec3 u_low_vec = vec3(u_brightness_high, u_brightness_high, u_brightness_high);\n\n    gl_FragColor = vec4(mix(u_high_vec, u_low_vec, rgb), color.a);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
        vertexSource: "precision highp float;\n\nuniform mat4 u_matrix;\nuniform vec2 u_tl_parent;\nuniform float u_scale_parent;\nuniform float u_buffer_scale;\n\nattribute vec2 a_pos;\nattribute vec2 a_texture_pos;\n\nvarying vec2 v_pos0;\nvarying vec2 v_pos1;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos0 = (((a_texture_pos / 32767.0) - 0.5) / u_buffer_scale ) + 0.5;\n    v_pos1 = (v_pos0 * u_scale_parent) + u_tl_parent;\n}\n"
    },
    icon: {
        fragmentSource: "precision mediump float;\n\nuniform sampler2D u_texture;\nuniform sampler2D u_fadetexture;\nuniform lowp float u_opacity;\n\nvarying vec2 v_tex;\nvarying vec2 v_fade_tex;\n\nvoid main() {\n    lowp float alpha = texture2D(u_fadetexture, v_fade_tex).a * u_opacity;\n    gl_FragColor = texture2D(u_texture, v_tex) * alpha;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
        vertexSource: "precision highp float;\n\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec4 a_data1;\nattribute vec4 a_data2;\n\n\n// matrix is for the vertex position, exmatrix is for rotating and projecting\n// the extrusion vector.\nuniform mat4 u_matrix;\n\nuniform mediump float u_zoom;\nuniform bool u_skewed;\nuniform float u_extra;\nuniform vec2 u_extrude_scale;\n\nuniform vec2 u_texsize;\n\nvarying vec2 v_tex;\nvarying vec2 v_fade_tex;\n\nvoid main() {\n    vec2 a_tex = a_data1.xy;\n    mediump float a_labelminzoom = a_data1[2];\n    mediump vec2 a_zoom = a_data2.st;\n    mediump float a_minzoom = a_zoom[0];\n    mediump float a_maxzoom = a_zoom[1];\n\n    // u_zoom is the current zoom level adjusted for the change in font size\n    mediump float z = 2.0 - step(a_minzoom, u_zoom) - (1.0 - step(a_maxzoom, u_zoom));\n\n    vec2 extrude = u_extrude_scale * (a_offset / 64.0);\n    if (u_skewed) {\n        gl_Position = u_matrix * vec4(a_pos + extrude, 0, 1);\n        gl_Position.z += z * gl_Position.w;\n    } else {\n        gl_Position = u_matrix * vec4(a_pos, 0, 1) + vec4(extrude, 0, 0);\n    }\n\n    v_tex = a_tex / u_texsize;\n    v_fade_tex = vec2(a_labelminzoom / 255.0, 0.0);\n}\n"
    },
    sdf: {
        fragmentSource: "precision mediump float;\n\nuniform sampler2D u_texture;\nuniform sampler2D u_fadetexture;\nuniform lowp vec4 u_color;\nuniform lowp float u_opacity;\nuniform lowp float u_buffer;\nuniform lowp float u_gamma;\n\nvarying vec2 v_tex;\nvarying vec2 v_fade_tex;\nvarying float v_gamma_scale;\n\nvoid main() {\n    lowp float dist = texture2D(u_texture, v_tex).a;\n    lowp float fade_alpha = texture2D(u_fadetexture, v_fade_tex).a;\n    lowp float gamma = u_gamma * v_gamma_scale;\n    lowp float alpha = smoothstep(u_buffer - gamma, u_buffer + gamma, dist) * fade_alpha;\n    gl_FragColor = u_color * (alpha * u_opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
        vertexSource: "precision highp float;\n\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec4 a_data1;\nattribute vec4 a_data2;\n\n\n// matrix is for the vertex position, exmatrix is for rotating and projecting\n// the extrusion vector.\nuniform mat4 u_matrix;\n\nuniform mediump float u_zoom;\nuniform bool u_skewed;\nuniform float u_extra;\nuniform vec2 u_extrude_scale;\n\nuniform vec2 u_texsize;\n\nvarying vec2 v_tex;\nvarying vec2 v_fade_tex;\nvarying float v_gamma_scale;\n\nvoid main() {\n    vec2 a_tex = a_data1.xy;\n    mediump float a_labelminzoom = a_data1[2];\n    mediump vec2 a_zoom = a_data2.st;\n    mediump float a_minzoom = a_zoom[0];\n    mediump float a_maxzoom = a_zoom[1];\n\n    // u_zoom is the current zoom level adjusted for the change in font size\n    mediump float z = 2.0 - step(a_minzoom, u_zoom) - (1.0 - step(a_maxzoom, u_zoom));\n\n    vec2 extrude = u_extrude_scale * (a_offset / 64.0);\n    if (u_skewed) {\n        gl_Position = u_matrix * vec4(a_pos + extrude, 0, 1);\n        gl_Position.z += z * gl_Position.w;\n    } else {\n        gl_Position = u_matrix * vec4(a_pos, 0, 1) + vec4(extrude, 0, 0);\n    }\n\n    // position of y on the screen\n    float y = gl_Position.y / gl_Position.w;\n    // how much features are squished in all directions by the perspectiveness\n    float perspective_scale = 1.0 / (1.0 - y * u_extra);\n    v_gamma_scale = perspective_scale;\n\n    v_tex = a_tex / u_texsize;\n    v_fade_tex = vec2(a_labelminzoom / 255.0, 0.0);\n}\n"
    },
    collisionbox: {
        fragmentSource: "precision mediump float;\n\nuniform float u_zoom;\nuniform float u_maxzoom;\n\nvarying float v_max_zoom;\nvarying float v_placement_zoom;\n\nvoid main() {\n\n    float alpha = 0.5;\n\n    gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0) * alpha;\n\n    if (v_placement_zoom > u_zoom) {\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0) * alpha;\n    }\n\n    if (u_zoom >= v_max_zoom) {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0) * alpha * 0.25;\n    }\n\n    if (v_placement_zoom >= u_maxzoom) {\n        gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0) * alpha * 0.2;\n    }\n}\n",
        vertexSource: "precision highp float;\n\nattribute vec2 a_pos;\nattribute vec2 a_extrude;\nattribute vec2 a_data;\n\nuniform mat4 u_matrix;\nuniform float u_scale;\n\nvarying float v_max_zoom;\nvarying float v_placement_zoom;\n\nvoid main() {\n     gl_Position = u_matrix * vec4(a_pos + a_extrude / u_scale, 0.0, 1.0);\n\n     v_max_zoom = a_data.x;\n     v_placement_zoom = a_data.y;\n}\n"
    }
};

module.exports._createProgram = function(name, macros) {
    var gl = this.gl;
    var program = gl.createProgram();
    var definition = definitions[name];

    var defines = '';
    if (macros) {
        for (var m = 0; m < macros.length; m++) {
            defines += '#define ' + macros[m] + '\n';
        }
    }

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, defines + definition.fragmentSource);
    gl.compileShader(fragmentShader);
    assert(gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS), gl.getShaderInfoLog(fragmentShader));
    gl.attachShader(program, fragmentShader);

    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, defines + definition.vertexSource);
    gl.compileShader(vertexShader);
    assert(gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS), gl.getShaderInfoLog(vertexShader));
    gl.attachShader(program, vertexShader);

    gl.linkProgram(program);
    assert(gl.getProgramParameter(program, gl.LINK_STATUS), gl.getProgramInfoLog(program));

    var attributes = {};
    var numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (var i = 0; i < numAttributes; i++) {
        var attribute = gl.getActiveAttrib(program, i);
        attributes[attribute.name] = i;
    }

    var uniforms = {};
    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (var ui = 0; ui < numUniforms; ui++) {
        var uniform = gl.getActiveUniform(program, ui);
        uniforms[uniform.name] = gl.getUniformLocation(program, uniform.name);
    }

    return util.extend({
        program: program,
        definition: definition,
        attributes: attributes,
        numAttributes: numAttributes
    }, attributes, uniforms);
};

module.exports._createProgramCached = function(name, macros) {
    this.cache = this.cache || {};
    if (this._showOverdrawInspector) {
        macros = macros || [];
        macros.push('OVERDRAW_INSPECTOR');
    }
    var key = JSON.stringify({name: name, macros: macros});
    if (!this.cache[key]) {
        this.cache[key] = this._createProgram(name, macros);
    }
    return this.cache[key];
};

module.exports.useProgram = function (nextProgramName, macros) {
    var gl = this.gl;

    var nextProgram = this._createProgramCached(nextProgramName, macros);
    var previousProgram = this.currentProgram;

    if (previousProgram !== nextProgram) {
        gl.useProgram(nextProgram.program);
        this.currentProgram = nextProgram;
    }

    return nextProgram;
};

},{"../../util/util":117,"assert":9,"path":11}],41:[function(require,module,exports){
'use strict';

var assert = require('assert');

module.exports = VertexArrayObject;

function VertexArrayObject() {
    this.boundProgram = null;
    this.boundVertexBuffer = null;
    this.boundVertexBuffer2 = null;
    this.boundElementBuffer = null;
    this.vao = null;
}

var reported = false;

VertexArrayObject.prototype.bind = function(gl, program, vertexBuffer, elementBuffer, vertexBuffer2) {

    var ext = gl.extVertexArrayObject;
    if (ext === undefined) {
        ext = gl.extVertexArrayObject = gl.getExtension("OES_vertex_array_object");
    }

    if (ext) {
        if (!this.vao) this.vao = ext.createVertexArrayOES();
        ext.bindVertexArrayOES(this.vao);
    } else if (!reported) {
        console.warn('Not using VertexArrayObject extension.');
        reported = true;
    }

    if (!this.boundProgram) {

        var numPrevAttributes = ext ? 0 : (gl.currentNumAttributes || 0);
        var numNextAttributes = program.numAttributes;
        var i;

        // Enable all attributes for the new program.
        for (i = numPrevAttributes; i < numNextAttributes; i++) {
            gl.enableVertexAttribArray(i);
        }

        if (!ext) {
            // Disable all attributes from the previous program that aren't used in
            // the new program. Note: attribute indices are *not* program specific!
            // WebGL breaks if you disable attribute 0. http://stackoverflow.com/questions/20305231
            assert(i > 0);
            for (i = numNextAttributes; i < numPrevAttributes; i++) {
                gl.disableVertexAttribArray(i);
            }
            gl.currentNumAttributes = numNextAttributes;
        }

        vertexBuffer.bind(gl);
        vertexBuffer.setVertexAttribPointers(gl, program);
        if (vertexBuffer2) {
            vertexBuffer2.bind(gl);
            vertexBuffer2.setVertexAttribPointers(gl, program);
        }
        if (elementBuffer) {
            elementBuffer.bind(gl);
        }

        if (ext) {
            // store the arguments so that we can verify them when the vao is bound again
            this.boundProgram = program;
            this.boundVertexBuffer = vertexBuffer;
            this.boundVertexBuffer2 = vertexBuffer2;
            this.boundElementBuffer = elementBuffer;
        }

    } else {
        // verify that bind was called with the same arguments
        assert(this.boundProgram === program, 'trying to bind a VAO to a different shader');
        assert(this.boundVertexBuffer === vertexBuffer, 'trying to bind a VAO to a different vertex buffer');
        assert(this.boundVertexBuffer2 === vertexBuffer2, 'trying to bind a VAO to a different vertex buffer');
        assert(this.boundElementBuffer === elementBuffer, 'trying to bind a VAO to a different element buffer');
    }
};

VertexArrayObject.prototype.unbind = function(gl) {
    var ext = gl.extVertexArrayObject;
    if (ext) {
        ext.bindVertexArrayOES(null);
    }
};

VertexArrayObject.prototype.destroy = function(gl) {
    var ext = gl.extVertexArrayObject;
    if (ext && this.vao) {
        ext.deleteVertexArrayOES(this.vao);
        this.vao = null;
    }
};

},{"assert":9}],42:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var Evented = require('../util/evented');
var TilePyramid = require('./tile_pyramid');
var Source = require('./source');
var urlResolve = require('resolve-url');
var EXTENT = require('../data/bucket').EXTENT;

module.exports = GeoJSONSource;

/**
 * Create a GeoJSON data source instance given an options object
 * @class GeoJSONSource
 * @param {Object} [options]
 * @param {Object|string} options.data A GeoJSON data object or URL to it. The latter is preferable in case of large GeoJSON files.
 * @param {number} [options.maxzoom=18] Maximum zoom to preserve detail at.
 * @param {number} [options.buffer] Tile buffer on each side in pixels.
 * @param {number} [options.tolerance] Simplification tolerance (higher means simpler) in pixels.
 * @param {number} [options.cluster] If the data is a collection of point features, setting this to true clusters the points by radius into groups.
 * @param {number} [options.clusterRadius=50] Radius of each cluster when clustering points, in pixels.
 * @param {number} [options.clusterMaxZoom] Max zoom to cluster points on. Defaults to one zoom less than `maxzoom` (so that last zoom features are not clustered).

 * @example
 * var sourceObj = new mapboxgl.GeoJSONSource({
 *    data: {
 *        "type": "FeatureCollection",
 *        "features": [{
 *            "type": "Feature",
 *            "geometry": {
 *                "type": "Point",
 *                "coordinates": [
 *                    -76.53063297271729,
 *                    39.18174077994108
 *                ]
 *            }
 *        }]
 *    }
 * });
 * map.addSource('some id', sourceObj); // add
 * map.removeSource('some id');  // remove
 */
function GeoJSONSource(options) {
    options = options || {};

    this._data = options.data;

    if (options.maxzoom !== undefined) this.maxzoom = options.maxzoom;

    var scale = EXTENT / this.tileSize;

    this.geojsonVtOptions = {
        buffer: (options.buffer !== undefined ? options.buffer : 128) * scale,
        tolerance: (options.tolerance !== undefined ? options.tolerance : 0.375) * scale,
        extent: EXTENT,
        maxZoom: this.maxzoom
    };

    this.cluster = options.cluster || false;
    this.superclusterOptions = {
        maxZoom: Math.min(options.clusterMaxZoom, this.maxzoom - 1) || (this.maxzoom - 1),
        extent: EXTENT,
        radius: (options.clusterRadius || 50) * scale,
        log: false
    };

    this._pyramid = new TilePyramid({
        tileSize: this.tileSize,
        minzoom: this.minzoom,
        maxzoom: this.maxzoom,
        reparseOverscaled: true,
        load: this._loadTile.bind(this),
        abort: this._abortTile.bind(this),
        unload: this._unloadTile.bind(this),
        add: this._addTile.bind(this),
        remove: this._removeTile.bind(this),
        redoPlacement: this._redoTilePlacement.bind(this)
    });
}

GeoJSONSource.prototype = util.inherit(Evented, /** @lends GeoJSONSource.prototype */{
    minzoom: 0,
    maxzoom: 18,
    tileSize: 512,
    _dirty: true,
    isTileClipped: true,

    /**
     * Update source geojson data and rerender map
     *
     * @param {Object|string} data A GeoJSON data object or URL to it. The latter is preferable in case of large GeoJSON files.
     * @returns {GeoJSONSource} this
     */
    setData: function(data) {
        this._data = data;
        this._dirty = true;

        this.fire('change');

        if (this.map)
            this.update(this.map.transform);

        return this;
    },

    onAdd: function(map) {
        this.map = map;
    },

    loaded: function() {
        return this._loaded && this._pyramid.loaded();
    },

    update: function(transform) {
        if (this._dirty) {
            this._updateData();
        }

        if (this._loaded) {
            this._pyramid.update(this.used, transform);
        }
    },

    reload: function() {
        if (this._loaded) {
            this._pyramid.reload();
        }
    },

    serialize: function() {
        return {
            type: 'geojson',
            data: this._data
        };
    },

    getVisibleCoordinates: Source._getVisibleCoordinates,
    getTile: Source._getTile,

    queryRenderedFeatures: Source._queryRenderedVectorFeatures,
    querySourceFeatures: Source._querySourceFeatures,

    _updateData: function() {
        this._dirty = false;
        var options = {
            tileSize: this.tileSize,
            source: this.id,
            geojsonVtOptions: this.geojsonVtOptions,
            cluster: this.cluster,
            superclusterOptions: this.superclusterOptions
        };

        var data = this._data;
        if (typeof data === 'string') {
            options.url = typeof window != 'undefined' ? urlResolve(window.location.href, data) : data;
        } else {
            options.data = JSON.stringify(data);
        }
        this.workerID = this.dispatcher.send('parse geojson', options, function(err) {
            this._loaded = true;
            if (err) {
                this.fire('error', {error: err});
            } else {
                this._pyramid.reload();
                this.fire('change');
            }

        }.bind(this));
    },

    _loadTile: function(tile) {
        var overscaling = tile.coord.z > this.maxzoom ? Math.pow(2, tile.coord.z - this.maxzoom) : 1;
        var params = {
            uid: tile.uid,
            coord: tile.coord,
            zoom: tile.coord.z,
            maxZoom: this.maxzoom,
            tileSize: this.tileSize,
            source: this.id,
            overscaling: overscaling,
            angle: this.map.transform.angle,
            pitch: this.map.transform.pitch,
            showCollisionBoxes: this.map.showCollisionBoxes
        };

        tile.workerID = this.dispatcher.send('load geojson tile', params, function(err, data) {

            tile.unloadVectorData(this.map.painter);

            if (tile.aborted)
                return;

            if (err) {
                this.fire('tile.error', {tile: tile});
                return;
            }

            tile.loadVectorData(data, this.map.style);

            if (tile.redoWhenDone) {
                tile.redoWhenDone = false;
                tile.redoPlacement(this);
            }

            this.fire('tile.load', {tile: tile});

        }.bind(this), this.workerID);
    },

    _abortTile: function(tile) {
        tile.aborted = true;
    },

    _addTile: function(tile) {
        this.fire('tile.add', {tile: tile});
    },

    _removeTile: function(tile) {
        this.fire('tile.remove', {tile: tile});
    },

    _unloadTile: function(tile) {
        tile.unloadVectorData(this.map.painter);
        this.dispatcher.send('remove tile', { uid: tile.uid, source: this.id }, null, tile.workerID);
    },

    redoPlacement: Source.redoPlacement,

    _redoTilePlacement: function(tile) {
        tile.redoPlacement(this);
    }
});

},{"../data/bucket":15,"../util/evented":109,"../util/util":117,"./source":47,"./tile_pyramid":50,"resolve-url":173}],43:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');
var VectorTileFeature = require('vector-tile').VectorTileFeature;
var EXTENT = require('../data/bucket').EXTENT;

module.exports = GeoJSONWrapper;

// conform to vectortile api
function GeoJSONWrapper(features) {
    this.features = features;
    this.length = features.length;
    this.extent = EXTENT;
}

GeoJSONWrapper.prototype.feature = function(i) {
    return new FeatureWrapper(this.features[i]);
};

function FeatureWrapper(feature) {
    this.type = feature.type;
    this.rawGeometry = feature.type === 1 ? [feature.geometry] : feature.geometry;
    this.properties = feature.tags;
    this.extent = EXTENT;
}

FeatureWrapper.prototype.loadGeometry = function() {
    var rings = this.rawGeometry;
    this.geometry = [];

    for (var i = 0; i < rings.length; i++) {
        var ring = rings[i],
            newRing = [];
        for (var j = 0; j < ring.length; j++) {
            newRing.push(new Point(ring[j][0], ring[j][1]));
        }
        this.geometry.push(newRing);
    }
    return this.geometry;
};

FeatureWrapper.prototype.bbox = function() {
    if (!this.geometry) this.loadGeometry();

    var rings = this.geometry,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    for (var i = 0; i < rings.length; i++) {
        var ring = rings[i];

        for (var j = 0; j < ring.length; j++) {
            var coord = ring[j];

            x1 = Math.min(x1, coord.x);
            x2 = Math.max(x2, coord.x);
            y1 = Math.min(y1, coord.y);
            y2 = Math.max(y2, coord.y);
        }
    }

    return [x1, y1, x2, y2];
};

FeatureWrapper.prototype.toGeoJSON = VectorTileFeature.prototype.toGeoJSON;

},{"../data/bucket":15,"point-geometry":172,"vector-tile":181}],44:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var Tile = require('./tile');
var TileCoord = require('./tile_coord');
var LngLat = require('../geo/lng_lat');
var Point = require('point-geometry');
var Evented = require('../util/evented');
var ajax = require('../util/ajax');
var EXTENT = require('../data/bucket').EXTENT;
var RasterBoundsArray = require('../render/draw_raster').RasterBoundsArray;
var Buffer = require('../data/buffer');
var VertexArrayObject = require('../render/vertex_array_object');

module.exports = ImageSource;

/**
 * Create an Image source instance given an options object
 * @class ImageSource
 * @param {Object} [options]
 * @param {string} options.url A string URL of an image file
 * @param {Array} options.coordinates Four geographical [lng, lat] coordinates in clockwise order defining the corners (starting with top left) of the image. Does not have to be a rectangle.
 * @example
 * var sourceObj = new mapboxgl.ImageSource({
 *    url: 'https://www.mapbox.com/images/foo.png',
 *    coordinates: [
 *        [-76.54335737228394, 39.18579907229748],
 *        [-76.52803659439087, 39.1838364847587],
 *        [-76.5295386314392, 39.17683392507606],
 *        [-76.54520273208618, 39.17876344106642]
 *    ]
 * });
 * map.addSource('some id', sourceObj); // add
 * map.removeSource('some id');  // remove
 */
function ImageSource(options) {
    this.urls = options.urls;
    this.coordinates = options.coordinates;

    ajax.getImage(options.url, function(err, image) {
        // @TODO handle errors via event.
        if (err) return;

        this.image = image;

        this.image.addEventListener('load', function() {
            this.map._rerender();
        }.bind(this));

        this._loaded = true;

        if (this.map) {
            this.setCoordinates(options.coordinates);
        }
    }.bind(this));
}

ImageSource.prototype = util.inherit(Evented, /** @lends ImageSource.prototype */ {
    onAdd: function(map) {
        this.map = map;
        if (this.image) {
            this.setCoordinates(this.coordinates);
        }
    },

    /**
     * Update image coordinates and rerender map
     *
     * @param {Array} coordinates Four geographical [lng, lat] coordinates in clockwise order defining the corners (starting with top left) of the image. Does not have to be a rectangle.
     * @returns {ImageSource} this
     */
    setCoordinates: function(coordinates) {
        this.coordinates = coordinates;

        // Calculate which mercator tile is suitable for rendering the image in
        // and create a buffer with the corner coordinates. These coordinates
        // may be outside the tile, because raster tiles aren't clipped when rendering.

        var map = this.map;
        var cornerZ0Coords = coordinates.map(function(coord) {
            return map.transform.locationCoordinate(LngLat.convert(coord)).zoomTo(0);
        });

        var centerCoord = this.centerCoord = util.getCoordinatesCenter(cornerZ0Coords);
        centerCoord.column = Math.round(centerCoord.column);
        centerCoord.row = Math.round(centerCoord.row);

        var tileCoords = cornerZ0Coords.map(function(coord) {
            var zoomedCoord = coord.zoomTo(centerCoord.zoom);
            return new Point(
                Math.round((zoomedCoord.column - centerCoord.column) * EXTENT),
                Math.round((zoomedCoord.row - centerCoord.row) * EXTENT));
        });

        var maxInt16 = 32767;
        var array = new RasterBoundsArray();
        array.emplaceBack(tileCoords[0].x, tileCoords[0].y, 0, 0);
        array.emplaceBack(tileCoords[1].x, tileCoords[1].y, maxInt16, 0);
        array.emplaceBack(tileCoords[3].x, tileCoords[3].y, 0, maxInt16);
        array.emplaceBack(tileCoords[2].x, tileCoords[2].y, maxInt16, maxInt16);

        this.tile = new Tile(new TileCoord(centerCoord.zoom, centerCoord.column, centerCoord.row));
        this.tile.buckets = {};

        this.tile.boundsBuffer = new Buffer(array.serialize(), RasterBoundsArray.serialize(), Buffer.BufferType.VERTEX);
        this.tile.boundsVAO = new VertexArrayObject();

        this.fire('change');

        return this;
    },

    loaded: function() {
        return this.image && this.image.complete;
    },

    update: function() {
        // noop
    },

    reload: function() {
        // noop
    },

    prepare: function() {
        if (!this._loaded || !this.loaded()) return;

        var painter = this.map.painter;
        var gl = painter.gl;

        if (!this.tile.texture) {
            this.tile.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.image);
        } else {
            gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.image);
        }
    },

    getVisibleCoordinates: function() {
        if (this.tile) return [this.tile.coord];
        else return [];
    },

    getTile: function() {
        return this.tile;
    },

    serialize: function() {
        return {
            type: 'image',
            urls: this.urls,
            coordinates: this.coordinates
        };
    }
});

},{"../data/bucket":15,"../data/buffer":20,"../geo/lng_lat":24,"../render/draw_raster":35,"../render/vertex_array_object":41,"../util/ajax":102,"../util/evented":109,"../util/util":117,"./tile":48,"./tile_coord":49,"point-geometry":172}],45:[function(require,module,exports){
'use strict';

var Bucket = require('../data/bucket');

/**
 * Converts a pixel value at a the given zoom level to tile units.
 *
 * The shaders mostly calculate everything in tile units so style
 * properties need to be converted from pixels to tile units using this.
 *
 * For example, a translation by 30 pixels at zoom 6.5 will be a
 * translation by pixelsToTileUnits(30, 6.5) tile units.
 *
 * @param {object} tile a {Tile object} will work well, but any object that follows the format {coord: {TileCord object}, tileSize: {number}} will work
 * @param {number} pixelValue
 * @param {number} z
 * @returns {number} value in tile units
 * @private
 */
module.exports = function(tile, pixelValue, z) {
    return pixelValue * (Bucket.EXTENT / (tile.tileSize * Math.pow(2, z - tile.coord.z)));
};


},{"../data/bucket":15}],46:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var ajax = require('../util/ajax');
var Evented = require('../util/evented');
var Source = require('./source');
var normalizeURL = require('../util/mapbox').normalizeTileURL;

module.exports = RasterTileSource;

function RasterTileSource(options) {
    util.extend(this, util.pick(options, ['url', 'tileSize']));

    Source._loadTileJSON.call(this, options);
}

RasterTileSource.prototype = util.inherit(Evented, {
    minzoom: 0,
    maxzoom: 22,
    roundZoom: true,
    tileSize: 512,
    _loaded: false,

    onAdd: function(map) {
        this.map = map;
    },

    loaded: function() {
        return this._pyramid && this._pyramid.loaded();
    },

    update: function(transform) {
        if (this._pyramid) {
            this._pyramid.update(this.used, transform, this.map.style.rasterFadeDuration);
        }
    },

    reload: function() {
        // noop
    },

    serialize: function() {
        return {
            type: 'raster',
            url: this.url,
            tileSize: this.tileSize
        };
    },

    getVisibleCoordinates: Source._getVisibleCoordinates,
    getTile: Source._getTile,

    _loadTile: function(tile) {
        var url = normalizeURL(tile.coord.url(this.tiles), this.url, this.tileSize);

        tile.request = ajax.getImage(url, done.bind(this));

        function done(err, img) {
            delete tile.request;

            if (tile.aborted)
                return;

            if (err) {
                tile.errored = true;
                this.fire('tile.error', {tile: tile, error: err});
                return;
            }

            var gl = this.map.painter.gl;
            tile.texture = this.map.painter.getTexture(img.width);
            if (tile.texture) {
                gl.bindTexture(gl.TEXTURE_2D, tile.texture);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, img);
            } else {
                tile.texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, tile.texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
                tile.texture.size = img.width;
            }
            gl.generateMipmap(gl.TEXTURE_2D);

            tile.timeAdded = new Date().getTime();
            this.map.animationLoop.set(this.style.rasterFadeDuration);

            tile.source = this;
            tile.loaded = true;

            this.fire('tile.load', {tile: tile});
        }
    },

    _abortTile: function(tile) {
        tile.aborted = true;

        if (tile.request) {
            tile.request.abort();
            delete tile.request;
        }
    },

    _addTile: function(tile) {
        this.fire('tile.add', {tile: tile});
    },

    _removeTile: function(tile) {
        this.fire('tile.remove', {tile: tile});
    },

    _unloadTile: function(tile) {
        if (tile.texture) this.map.painter.saveTexture(tile.texture);
    }
});

},{"../util/ajax":102,"../util/evented":109,"../util/mapbox":114,"../util/util":117,"./source":47}],47:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var ajax = require('../util/ajax');
var browser = require('../util/browser');
var TilePyramid = require('./tile_pyramid');
var normalizeURL = require('../util/mapbox').normalizeSourceURL;
var TileCoord = require('./tile_coord');

exports._loadTileJSON = function(options) {
    var loaded = function(err, tileJSON) {
        if (err) {
            this.fire('error', {error: err});
            return;
        }

        util.extend(this, util.pick(tileJSON,
            ['tiles', 'minzoom', 'maxzoom', 'attribution']));

        if (tileJSON.vector_layers) {
            this.vectorLayers = tileJSON.vector_layers;
            this.vectorLayerIds = this.vectorLayers.map(function(layer) { return layer.id; });
        }

        this._pyramid = new TilePyramid({
            tileSize: this.tileSize,
            minzoom: this.minzoom,
            maxzoom: this.maxzoom,
            roundZoom: this.roundZoom,
            reparseOverscaled: this.reparseOverscaled,
            load: this._loadTile.bind(this),
            abort: this._abortTile.bind(this),
            unload: this._unloadTile.bind(this),
            add: this._addTile.bind(this),
            remove: this._removeTile.bind(this),
            redoPlacement: this._redoTilePlacement ? this._redoTilePlacement.bind(this) : undefined
        });

        this.fire('load');
    }.bind(this);

    if (options.url) {
        ajax.getJSON(normalizeURL(options.url), loaded);
    } else {
        browser.frame(loaded.bind(this, null, options));
    }
};

exports.redoPlacement = function() {
    if (!this._pyramid) {
        return;
    }

    var ids = this._pyramid.orderedIDs();
    for (var i = 0; i < ids.length; i++) {
        var tile = this._pyramid.getTile(ids[i]);
        this._redoTilePlacement(tile);
    }
};

exports._getTile = function(coord) {
    return this._pyramid.getTile(coord.id);
};

exports._getVisibleCoordinates = function() {
    if (!this._pyramid) return [];
    else return this._pyramid.renderedIDs().map(TileCoord.fromID);
};

function sortTilesIn(a, b) {
    var coordA = a.tile.coord;
    var coordB = b.tile.coord;
    return (coordA.z - coordB.z) || (coordA.y - coordB.y) || (coordA.x - coordB.x);
}

function mergeRenderedFeatureLayers(tiles) {
    var result = tiles[0] || {};
    for (var i = 1; i < tiles.length; i++) {
        var tile = tiles[i];
        for (var layerID in tile) {
            var tileFeatures = tile[layerID];
            var resultFeatures = result[layerID];
            if (resultFeatures === undefined) {
                resultFeatures = result[layerID] = tileFeatures;
            } else {
                for (var f = 0; f < tileFeatures.length; f++) {
                    resultFeatures.push(tileFeatures[f]);
                }
            }
        }
    }
    return result;
}

exports._queryRenderedVectorFeatures = function(queryGeometry, params, zoom, bearing) {
    if (!this._pyramid)
        return {};

    var tilesIn = this._pyramid.tilesIn(queryGeometry);

    tilesIn.sort(sortTilesIn);

    var styleLayers = this.map.style._layers;

    var renderedFeatureLayers = [];
    for (var r = 0; r < tilesIn.length; r++) {
        var tileIn = tilesIn[r];
        if (!tileIn.tile.featureIndex) continue;

        renderedFeatureLayers.push(tileIn.tile.featureIndex.query({
            queryGeometry: tileIn.queryGeometry,
            scale: tileIn.scale,
            tileSize: tileIn.tile.tileSize,
            bearing: bearing,
            params: params
        }, styleLayers));
    }
    return mergeRenderedFeatureLayers(renderedFeatureLayers);
};

exports._querySourceFeatures = function(params) {
    if (!this._pyramid) {
        return [];
    }

    var pyramid = this._pyramid;
    var tiles = pyramid.renderedIDs().map(function(id) {
        return pyramid.getTile(id);
    });

    var result = [];

    var dataTiles = {};
    for (var i = 0; i < tiles.length; i++) {
        var tile = tiles[i];
        var dataID = new TileCoord(Math.min(tile.sourceMaxZoom, tile.coord.z), tile.coord.x, tile.coord.y, 0).id;
        if (!dataTiles[dataID]) {
            dataTiles[dataID] = true;
            tile.querySourceFeatures(result, params);
        }
    }

    return result;
};

/*
 * Create a tiled data source instance given an options object
 *
 * @param {Object} options
 * @param {string} options.type Either `raster` or `vector`.
 * @param {string} options.url A tile source URL. This should either be `mapbox://{mapid}` or a full `http[s]` url that points to a TileJSON endpoint.
 * @param {Array} options.tiles An array of tile sources. If `url` is not specified, `tiles` can be used instead to specify tile sources, as in the TileJSON spec. Other TileJSON keys such as `minzoom` and `maxzoom` can be specified in a source object if `tiles` is used.
 * @param {string} options.id An optional `id` to assign to the source
 * @param {number} [options.tileSize=512] Optional tile size (width and height in pixels, assuming tiles are square). This option is only configurable for raster sources
 * @example
 * var sourceObj = new mapboxgl.Source.create({
 *    type: 'vector',
 *    url: 'mapbox://mapbox.mapbox-streets-v5'
 * });
 * map.addSource('some id', sourceObj); // add
 * map.removeSource('some id');  // remove
 */
exports.create = function(source) {
    // This is not at file scope in order to avoid a circular require.
    var sources = {
        vector: require('./vector_tile_source'),
        raster: require('./raster_tile_source'),
        geojson: require('./geojson_source'),
        video: require('./video_source'),
        image: require('./image_source')
    };

    return exports.is(source) ? source : new sources[source.type](source);
};

exports.is = function(source) {
    // This is not at file scope in order to avoid a circular require.
    var sources = {
        vector: require('./vector_tile_source'),
        raster: require('./raster_tile_source'),
        geojson: require('./geojson_source'),
        video: require('./video_source'),
        image: require('./image_source')
    };

    for (var type in sources) {
        if (source instanceof sources[type]) {
            return true;
        }
    }

    return false;
};

},{"../util/ajax":102,"../util/browser":103,"../util/mapbox":114,"../util/util":117,"./geojson_source":42,"./image_source":44,"./raster_tile_source":46,"./tile_coord":49,"./tile_pyramid":50,"./vector_tile_source":51,"./video_source":52}],48:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var Bucket = require('../data/bucket');
var FeatureIndex = require('../data/feature_index');
var vt = require('vector-tile');
var Protobuf = require('pbf');
var GeoJSONFeature = require('../util/vectortile_to_geojson');
var featureFilter = require('feature-filter');
var CollisionTile = require('../symbol/collision_tile');
var CollisionBoxArray = require('../symbol/collision_box');

module.exports = Tile;

/**
 * A tile object is the combination of a Coordinate, which defines
 * its place, as well as a unique ID and data tracking for its content
 *
 * @param {Coordinate} coord
 * @param {number} size
 * @private
 */
function Tile(coord, size, sourceMaxZoom) {
    this.coord = coord;
    this.uid = util.uniqueId();
    this.loaded = false; // TODO rename loaded
    this.isUnloaded = false;
    this.uses = 0;
    this.tileSize = size;
    this.sourceMaxZoom = sourceMaxZoom;
    this.buckets = {};
}

Tile.prototype = {

    /**
     * Given a data object with a 'buffers' property, load it into
     * this tile's elementGroups and buffers properties and set loaded
     * to true. If the data is null, like in the case of an empty
     * GeoJSON tile, no-op but still set loaded to true.
     * @param {Object} data
     * @returns {undefined}
     * @private
     */
    loadVectorData: function(data, style) {
        this.loaded = true;

        // empty GeoJSON tile
        if (!data) return;

        this.collisionBoxArray = new CollisionBoxArray(data.collisionBoxArray);
        this.collisionTile = new CollisionTile(data.collisionTile, this.collisionBoxArray);
        this.featureIndex = new FeatureIndex(data.featureIndex, data.rawTileData, this.collisionTile);
        this.rawTileData = data.rawTileData;
        this.buckets = unserializeBuckets(data.buckets, style);
    },

    /**
     * given a data object and a GL painter, destroy and re-create
     * all of its buffers.
     * @param {Object} data
     * @param {Object} painter
     * @returns {undefined}
     * @private
     */
    reloadSymbolData: function(data, painter, style) {
        if (this.isUnloaded) return;

        this.collisionTile = new CollisionTile(data.collisionTile, this.collisionBoxArray);
        this.featureIndex.setCollisionTile(this.collisionTile);

        // Destroy and delete existing symbol buckets
        for (var id in this.buckets) {
            var bucket = this.buckets[id];
            if (bucket.type === 'symbol') {
                bucket.destroy(painter.gl);
                delete this.buckets[id];
            }
        }

        // Add new symbol buckets
        util.extend(this.buckets, unserializeBuckets(data.buckets, style));
    },

    /**
     * Make sure that this tile doesn't own any data within a given
     * painter, so that it doesn't consume any memory or maintain
     * any references to the painter.
     * @param {Object} painter gl painter object
     * @returns {undefined}
     * @private
     */
    unloadVectorData: function(painter) {
        for (var id in this.buckets) {
            var bucket = this.buckets[id];
            bucket.destroy(painter.gl);
        }

        this.collisionBoxArray = null;
        this.collisionTile = null;
        this.featureIndex = null;
        this.rawTileData = null;
        this.buckets = null;
        this.loaded = false;
        this.isUnloaded = true;
    },

    redoPlacement: function(source) {
        if (!this.loaded || this.redoingPlacement) {
            this.redoWhenDone = true;
            return;
        }

        this.redoingPlacement = true;

        source.dispatcher.send('redo placement', {
            uid: this.uid,
            source: source.id,
            angle: source.map.transform.angle,
            pitch: source.map.transform.pitch,
            showCollisionBoxes: source.map.showCollisionBoxes
        }, done.bind(this), this.workerID);

        function done(_, data) {
            this.reloadSymbolData(data, source.map.painter, source.map.style);
            source.fire('tile.load', {tile: this});

            this.redoingPlacement = false;
            if (this.redoWhenDone) {
                this.redoPlacement(source);
                this.redoWhenDone = false;
            }
        }
    },

    getBucket: function(layer) {
        return this.buckets && this.buckets[layer.ref || layer.id];
    },

    querySourceFeatures: function(result, params) {
        if (!this.rawTileData) return;

        if (!this.vtLayers) {
            this.vtLayers = new vt.VectorTile(new Protobuf(new Uint8Array(this.rawTileData))).layers;
        }

        var layer = this.vtLayers._geojsonTileLayer || this.vtLayers[params.sourceLayer];

        if (!layer) return;

        var filter = featureFilter(params.filter);
        var coord = { z: this.coord.z, x: this.coord.x, y: this.coord.y };

        for (var i = 0; i < layer.length; i++) {
            var feature = layer.feature(i);
            if (filter(feature)) {
                var geojsonFeature = new GeoJSONFeature(feature, this.coord.z, this.coord.x, this.coord.y);
                geojsonFeature.tile = coord;
                result.push(geojsonFeature);
            }
        }
    }
};

function unserializeBuckets(input, style) {
    var output = {};
    for (var i = 0; i < input.length; i++) {
        var layer = style.getLayer(input[i].layerId);
        if (!layer) continue;

        var bucket = Bucket.create(util.extend({
            layer: layer,
            childLayers: input[i].childLayerIds
                .map(style.getLayer.bind(style))
                .filter(function(layer) { return layer; })
        }, input[i]));
        output[bucket.id] = bucket;
    }
    return output;
}

},{"../data/bucket":15,"../data/feature_index":21,"../symbol/collision_box":74,"../symbol/collision_tile":76,"../util/util":117,"../util/vectortile_to_geojson":118,"feature-filter":120,"pbf":170,"vector-tile":181}],49:[function(require,module,exports){
'use strict';

var assert = require('assert');
var Coordinate = require('../geo/coordinate');

module.exports = TileCoord;

function TileCoord(z, x, y, w) {
    assert(!isNaN(z) && z >= 0 && z % 1 === 0);
    assert(!isNaN(x) && x >= 0 && x % 1 === 0);
    assert(!isNaN(y) && y >= 0 && y % 1 === 0);

    if (isNaN(w)) w = 0;

    this.z = +z;
    this.x = +x;
    this.y = +y;
    this.w = +w;

    // calculate id
    w *= 2;
    if (w < 0) w = w * -1 - 1;
    var dim = 1 << this.z;
    this.id = ((dim * dim * w + dim * this.y + this.x) * 32) + this.z;

    // for caching pos matrix calculation when rendering
    this.posMatrix = null;
}

TileCoord.prototype.toString = function() {
    return this.z + "/" + this.x + "/" + this.y;
};

TileCoord.prototype.toCoordinate = function(sourceMaxZoom) {
    var zoom = Math.min(this.z, sourceMaxZoom);
    var tileScale = Math.pow(2, zoom);
    var row = this.y;
    var column = this.x + tileScale * this.w;
    return new Coordinate(column, row, zoom);
};

// Parse a packed integer id into a TileCoord object
TileCoord.fromID = function(id) {
    var z = id % 32, dim = 1 << z;
    var xy = ((id - z) / 32);
    var x = xy % dim, y = ((xy - x) / dim) % dim;
    var w = Math.floor(xy / (dim * dim));
    if (w % 2 !== 0) w = w * -1 - 1;
    w /= 2;
    return new TileCoord(z, x, y, w);
};

// given a list of urls, choose a url template and return a tile URL
TileCoord.prototype.url = function(urls, sourceMaxZoom) {
    return urls[(this.x + this.y) % urls.length]
        .replace('{prefix}', (this.x % 16).toString(16) + (this.y % 16).toString(16))
        .replace('{z}', Math.min(this.z, sourceMaxZoom || this.z))
        .replace('{x}', this.x)
        .replace('{y}', this.y);
};

// Return the coordinate of the parent tile
TileCoord.prototype.parent = function(sourceMaxZoom) {
    if (this.z === 0) return null;

    // the id represents an overscaled tile, return the same coordinates with a lower z
    if (this.z > sourceMaxZoom) {
        return new TileCoord(this.z - 1, this.x, this.y, this.w);
    }

    return new TileCoord(this.z - 1, Math.floor(this.x / 2), Math.floor(this.y / 2), this.w);
};

TileCoord.prototype.wrapped = function() {
    return new TileCoord(this.z, this.x, this.y, 0);
};

// Return the coordinates of the tile's children
TileCoord.prototype.children = function(sourceMaxZoom) {

    if (this.z >= sourceMaxZoom) {
        // return a single tile coord representing a an overscaled tile
        return [new TileCoord(this.z + 1, this.x, this.y, this.w)];
    }

    var z = this.z + 1;
    var x = this.x * 2;
    var y = this.y * 2;
    return [
        new TileCoord(z, x, y, this.w),
        new TileCoord(z, x + 1, y, this.w),
        new TileCoord(z, x, y + 1, this.w),
        new TileCoord(z, x + 1, y + 1, this.w)
    ];
};

// Taken from polymaps src/Layer.js
// https://github.com/simplegeo/polymaps/blob/master/src/Layer.js#L333-L383

function edge(a, b) {
    if (a.row > b.row) { var t = a; a = b; b = t; }
    return {
        x0: a.column,
        y0: a.row,
        x1: b.column,
        y1: b.row,
        dx: b.column - a.column,
        dy: b.row - a.row
    };
}

function scanSpans(e0, e1, ymin, ymax, scanLine) {
    var y0 = Math.max(ymin, Math.floor(e1.y0));
    var y1 = Math.min(ymax, Math.ceil(e1.y1));

    // sort edges by x-coordinate
    if ((e0.x0 === e1.x0 && e0.y0 === e1.y0) ?
            (e0.x0 + e1.dy / e0.dy * e0.dx < e1.x1) :
            (e0.x1 - e1.dy / e0.dy * e0.dx < e1.x0)) {
        var t = e0; e0 = e1; e1 = t;
    }

    // scan lines!
    var m0 = e0.dx / e0.dy;
    var m1 = e1.dx / e1.dy;
    var d0 = e0.dx > 0; // use y + 1 to compute x0
    var d1 = e1.dx < 0; // use y + 1 to compute x1
    for (var y = y0; y < y1; y++) {
        var x0 = m0 * Math.max(0, Math.min(e0.dy, y + d0 - e0.y0)) + e0.x0;
        var x1 = m1 * Math.max(0, Math.min(e1.dy, y + d1 - e1.y0)) + e1.x0;
        scanLine(Math.floor(x1), Math.ceil(x0), y);
    }
}

function scanTriangle(a, b, c, ymin, ymax, scanLine) {
    var ab = edge(a, b),
        bc = edge(b, c),
        ca = edge(c, a);

    var t;

    // sort edges by y-length
    if (ab.dy > bc.dy) { t = ab; ab = bc; bc = t; }
    if (ab.dy > ca.dy) { t = ab; ab = ca; ca = t; }
    if (bc.dy > ca.dy) { t = bc; bc = ca; ca = t; }

    // scan span! scan span!
    if (ab.dy) scanSpans(ca, ab, ymin, ymax, scanLine);
    if (bc.dy) scanSpans(ca, bc, ymin, ymax, scanLine);
}

TileCoord.cover = function(z, bounds, actualZ) {
    var tiles = 1 << z;
    var t = {};

    function scanLine(x0, x1, y) {
        var x, wx, coord;
        if (y >= 0 && y <= tiles) {
            for (x = x0; x < x1; x++) {
                wx = (x % tiles + tiles) % tiles;
                coord = new TileCoord(actualZ, wx, y, Math.floor(x / tiles));
                t[coord.id] = coord;
            }
        }
    }

    // Divide the screen up in two triangles and scan each of them:
    // +---/
    // | / |
    // /---+
    scanTriangle(bounds[0], bounds[1], bounds[2], 0, tiles, scanLine);
    scanTriangle(bounds[2], bounds[3], bounds[0], 0, tiles, scanLine);

    return Object.keys(t).map(function(id) {
        return t[id];
    });
};

},{"../geo/coordinate":23,"assert":9}],50:[function(require,module,exports){
'use strict';

var Tile = require('./tile');
var TileCoord = require('./tile_coord');
var Point = require('point-geometry');
var Cache = require('../util/lru_cache');
var Coordinate = require('../geo/coordinate');
var util = require('../util/util');
var EXTENT = require('../data/bucket').EXTENT;

module.exports = TilePyramid;

/**
 * A tile pyramid is a specialized cache and datastructure
 * that contains tiles. It's used by sources to manage their
 * data.
 *
 * @param {Object} options
 * @param {number} options.tileSize
 * @param {number} options.minzoom
 * @param {number} options.maxzoom
 * @private
 */
function TilePyramid(options) {
    this.tileSize = options.tileSize;
    this.minzoom = options.minzoom;
    this.maxzoom = options.maxzoom;
    this.roundZoom = options.roundZoom;
    this.reparseOverscaled = options.reparseOverscaled;

    this._load = options.load;
    this._abort = options.abort;
    this._unload = options.unload;
    this._add = options.add;
    this._remove = options.remove;
    this._redoPlacement = options.redoPlacement;

    this._tiles = {};
    this._cache = new Cache(0, function(tile) { return this._unload(tile); }.bind(this));

    this._filterRendered = this._filterRendered.bind(this);
}


TilePyramid.maxOverzooming = 10;
TilePyramid.maxUnderzooming = 3;

TilePyramid.prototype = {
    /**
     * Confirm that every tracked tile is loaded.
     * @returns {boolean} whether all tiles are loaded.
     * @private
     */
    loaded: function() {
        for (var t in this._tiles) {
            if (!this._tiles[t].loaded && !this._tiles[t].errored)
                return false;
        }
        return true;
    },

    /**
     * Return all tile ids ordered with z-order, and cast to numbers
     * @returns {Array<number>} ids
     * @private
     */
    orderedIDs: function() {
        return Object.keys(this._tiles).map(Number).sort(compareKeyZoom);
    },

    renderedIDs: function() {
        return this.orderedIDs().filter(this._filterRendered);
    },

    _filterRendered: function(id) {
        return this._tiles[id].loaded && !this._coveredTiles[id];
    },

    reload: function() {
        this._cache.reset();
        for (var i in this._tiles) {
            this._load(this._tiles[i]);
        }
    },

    /**
     * Get a specific tile by id
     * @param {string|number} id tile id
     * @returns {Object} tile
     * @private
     */
    getTile: function(id) {
        return this._tiles[id];
    },

    /**
     * get the zoom level adjusted for the difference in map and source tilesizes
     * @param {Object} transform
     * @returns {number} zoom level
     * @private
     */
    getZoom: function(transform) {
        return transform.zoom + Math.log(transform.tileSize / this.tileSize) / Math.LN2;
    },

    /**
     * Return a zoom level that will cover all tiles in a given transform
     * @param {Object} transform
     * @returns {number} zoom level
     * @private
     */
    coveringZoomLevel: function(transform) {
        return (this.roundZoom ? Math.round : Math.floor)(this.getZoom(transform));
    },

    /**
     * Given a transform, return all coordinates that could cover that
     * transform for a covering zoom level.
     * @param {Object} transform
     * @returns {Array<Tile>} tiles
     * @private
     */
    coveringTiles: function(transform) {
        var z = this.coveringZoomLevel(transform);
        var actualZ = z;

        if (z < this.minzoom) return [];
        if (z > this.maxzoom) z = this.maxzoom;

        var tr = transform,
            tileCenter = tr.locationCoordinate(tr.center)._zoomTo(z),
            centerPoint = new Point(tileCenter.column - 0.5, tileCenter.row - 0.5);

        return TileCoord.cover(z, [
            tr.pointCoordinate(new Point(0, 0))._zoomTo(z),
            tr.pointCoordinate(new Point(tr.width, 0))._zoomTo(z),
            tr.pointCoordinate(new Point(tr.width, tr.height))._zoomTo(z),
            tr.pointCoordinate(new Point(0, tr.height))._zoomTo(z)
        ], this.reparseOverscaled ? actualZ : z).sort(function(a, b) {
            return centerPoint.dist(a) - centerPoint.dist(b);
        });
    },

    /**
     * Recursively find children of the given tile (up to maxCoveringZoom) that are already loaded;
     * adds found tiles to retain object; returns true if any child is found.
     *
     * @param {Coordinate} coord
     * @param {number} maxCoveringZoom
     * @param {boolean} retain
     * @returns {boolean} whether the operation was complete
     * @private
     */
    findLoadedChildren: function(coord, maxCoveringZoom, retain) {
        var found = false;

        for (var id in this._tiles) {
            var tile = this._tiles[id];

            // only consider loaded tiles on higher zoom levels (up to maxCoveringZoom)
            if (retain[id] || !tile.loaded || tile.coord.z <= coord.z || tile.coord.z > maxCoveringZoom) continue;

            // disregard tiles that are not descendants of the given tile coordinate
            var z2 = Math.pow(2, Math.min(tile.coord.z, this.maxzoom) - Math.min(coord.z, this.maxzoom));
            if (Math.floor(tile.coord.x / z2) !== coord.x ||
                Math.floor(tile.coord.y / z2) !== coord.y)
                continue;

            // found loaded child
            retain[id] = true;
            found = true;

            // loop through parents; retain the topmost loaded one if found
            while (tile && tile.coord.z - 1 > coord.z) {
                var parentId = tile.coord.parent(this.maxzoom).id;
                tile = this._tiles[parentId];

                if (tile && tile.loaded) {
                    delete retain[id];
                    retain[parentId] = true;
                }
            }
        }
        return found;
    },

    /**
     * Find a loaded parent of the given tile (up to minCoveringZoom);
     * adds the found tile to retain object and returns the tile if found
     *
     * @param {Coordinate} coord
     * @param {number} minCoveringZoom
     * @param {boolean} retain
     * @returns {Tile} tile object
     * @private
     */
    findLoadedParent: function(coord, minCoveringZoom, retain) {
        for (var z = coord.z - 1; z >= minCoveringZoom; z--) {
            coord = coord.parent(this.maxzoom);
            var tile = this._tiles[coord.id];
            if (tile && tile.loaded) {
                retain[coord.id] = true;
                return tile;
            }
            if (this._cache.has(coord.id)) {
                this.addTile(coord);
                retain[coord.id] = true;
                return this._tiles[coord.id];
            }
        }
    },

    /**
     * Resizes the tile cache based on the current viewport's size.
     *
     * Larger viewports use more tiles and need larger caches. Larger viewports
     * are more likely to be found on devices with more memory and on pages where
     * the map is more important.
     *
     * @private
     */
    updateCacheSize: function(transform) {
        var widthInTiles = Math.ceil(transform.width / transform.tileSize) + 1;
        var heightInTiles = Math.ceil(transform.height / transform.tileSize) + 1;
        var approxTilesInView = widthInTiles * heightInTiles;
        var commonZoomRange = 5;
        this._cache.setMaxSize(Math.floor(approxTilesInView * commonZoomRange));
    },

    /**
     * Removes tiles that are outside the viewport and adds new tiles that
     * are inside the viewport.
     * @private
     */
    update: function(used, transform, fadeDuration) {
        var i;
        var coord;
        var tile;

        this.updateCacheSize(transform);

        // Determine the overzooming/underzooming amounts.
        var zoom = (this.roundZoom ? Math.round : Math.floor)(this.getZoom(transform));
        var minCoveringZoom = Math.max(zoom - TilePyramid.maxOverzooming, this.minzoom);
        var maxCoveringZoom = Math.max(zoom + TilePyramid.maxUnderzooming,  this.minzoom);

        // Retain is a list of tiles that we shouldn't delete, even if they are not
        // the most ideal tile for the current viewport. This may include tiles like
        // parent or child tiles that are *already* loaded.
        var retain = {};
        var now = new Date().getTime();

        // Covered is a list of retained tiles who's areas are full covered by other,
        // better, retained tiles. They are not drawn separately.
        this._coveredTiles = {};

        var required = used ? this.coveringTiles(transform) : [];
        for (i = 0; i < required.length; i++) {
            coord = required[i];
            tile = this.addTile(coord);

            retain[coord.id] = true;

            if (tile.loaded)
                continue;

            // The tile we require is not yet loaded.
            // Retain child or parent tiles that cover the same area.
            if (!this.findLoadedChildren(coord, maxCoveringZoom, retain)) {
                this.findLoadedParent(coord, minCoveringZoom, retain);
            }
        }

        var parentsForFading = {};

        var ids = Object.keys(retain);
        for (var k = 0; k < ids.length; k++) {
            var id = ids[k];
            coord = TileCoord.fromID(id);
            tile = this._tiles[id];
            if (tile && tile.timeAdded > now - (fadeDuration || 0)) {
                // This tile is still fading in. Find tiles to cross-fade with it.
                if (this.findLoadedChildren(coord, maxCoveringZoom, retain)) {
                    retain[id] = true;
                }
                this.findLoadedParent(coord, minCoveringZoom, parentsForFading);
            }
        }

        var fadedParent;
        for (fadedParent in parentsForFading) {
            if (!retain[fadedParent]) {
                // If a tile is only needed for fading, mark it as covered so that it isn't rendered on it's own.
                this._coveredTiles[fadedParent] = true;
            }
        }
        for (fadedParent in parentsForFading) {
            retain[fadedParent] = true;
        }

        // Remove the tiles we don't need anymore.
        var remove = util.keysDifference(this._tiles, retain);
        for (i = 0; i < remove.length; i++) {
            this.removeTile(+remove[i]);
        }

        this.transform = transform;
    },

    /**
     * Add a tile, given its coordinate, to the pyramid.
     * @param {Coordinate} coord
     * @returns {Coordinate} the coordinate.
     * @private
     */
    addTile: function(coord) {
        var tile = this._tiles[coord.id];
        if (tile)
            return tile;

        var wrapped = coord.wrapped();
        tile = this._tiles[wrapped.id];

        if (!tile) {
            tile = this._cache.get(wrapped.id);
            if (tile && this._redoPlacement) {
                this._redoPlacement(tile);
            }
        }

        if (!tile) {
            var zoom = coord.z;
            var overscaling = zoom > this.maxzoom ? Math.pow(2, zoom - this.maxzoom) : 1;
            tile = new Tile(wrapped, this.tileSize * overscaling, this.maxzoom);
            this._load(tile);
        }

        tile.uses++;
        this._tiles[coord.id] = tile;
        this._add(tile, coord);

        return tile;
    },

    /**
     * Remove a tile, given its id, from the pyramid
     * @param {string|number} id tile id
     * @returns {undefined} nothing
     * @private
     */
    removeTile: function(id) {
        var tile = this._tiles[id];
        if (!tile)
            return;

        tile.uses--;
        delete this._tiles[id];
        this._remove(tile);

        if (tile.uses > 0)
            return;

        if (tile.loaded) {
            this._cache.add(tile.coord.wrapped().id, tile);
        } else {
            this._abort(tile);
            this._unload(tile);
        }
    },

    /**
     * Remove all tiles from this pyramid
     * @private
     */
    clearTiles: function() {
        for (var id in this._tiles)
            this.removeTile(id);
        this._cache.reset();
    },

    /**
     * Search through our current tiles and attempt to find the tiles that
     * cover the given bounds.
     * @param {Array<Coordinate>} queryGeometry coordinates of the corners of bounding rectangle
     * @returns {Array<Object>} result items have {tile, minX, maxX, minY, maxY}, where min/max bounding values are the given bounds transformed in into the coordinate space of this tile.
     * @private
     */
    tilesIn: function(queryGeometry) {
        var tileResults = {};
        var ids = this.orderedIDs();

        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var z = queryGeometry[0].zoom;

        for (var k = 0; k < queryGeometry.length; k++) {
            var p = queryGeometry[k];
            minX = Math.min(minX, p.column);
            minY = Math.min(minY, p.row);
            maxX = Math.max(maxX, p.column);
            maxY = Math.max(maxY, p.row);
        }

        for (var i = 0; i < ids.length; i++) {
            var tile = this._tiles[ids[i]];
            var coord = TileCoord.fromID(ids[i]);

            var tileSpaceBounds = [
                coordinateToTilePoint(coord, tile.sourceMaxZoom, new Coordinate(minX, minY, z)),
                coordinateToTilePoint(coord, tile.sourceMaxZoom, new Coordinate(maxX, maxY, z))
            ];

            if (tileSpaceBounds[0].x < EXTENT && tileSpaceBounds[0].y < EXTENT &&
                tileSpaceBounds[1].x >= 0 && tileSpaceBounds[1].y >= 0) {

                var tileSpaceQueryGeometry = [];
                for (var j = 0; j < queryGeometry.length; j++) {
                    tileSpaceQueryGeometry.push(coordinateToTilePoint(coord, tile.sourceMaxZoom, queryGeometry[j]));
                }

                var tileResult = tileResults[tile.coord.id];
                if (tileResult === undefined) {
                    tileResult = tileResults[tile.coord.id] = {
                        tile: tile,
                        queryGeometry: [],
                        scale: Math.pow(2, this.transform.zoom - tile.coord.z)
                    };
                }

                // Wrapped tiles share one tileResult object but can have multiple queryGeometry parts
                tileResult.queryGeometry.push(tileSpaceQueryGeometry);
            }
        }

        var results = [];
        for (var t in tileResults) {
            results.push(tileResults[t]);
        }
        return results;
    }
};

/**
 * Convert a coordinate to a point in a tile's coordinate space.
 * @param {Coordinate} tileCoord
 * @param {Coordinate} coord
 * @returns {Object} position
 * @private
 */
function coordinateToTilePoint(tileCoord, sourceMaxZoom, coord) {
    var zoomedCoord = coord.zoomTo(Math.min(tileCoord.z, sourceMaxZoom));
    return {
        x: (zoomedCoord.column - (tileCoord.x + tileCoord.w * Math.pow(2, tileCoord.z))) * EXTENT,
        y: (zoomedCoord.row - tileCoord.y) * EXTENT
    };

}

function compareKeyZoom(a, b) {
    return (a % 32) - (b % 32);
}

},{"../data/bucket":15,"../geo/coordinate":23,"../util/lru_cache":113,"../util/util":117,"./tile":48,"./tile_coord":49,"point-geometry":172}],51:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var Evented = require('../util/evented');
var Source = require('./source');
var normalizeURL = require('../util/mapbox').normalizeTileURL;

module.exports = VectorTileSource;

function VectorTileSource(options) {
    util.extend(this, util.pick(options, ['url', 'tileSize']));
    this._options = util.extend({ type: 'vector' }, options);

    if (this.tileSize !== 512) {
        throw new Error('vector tile sources must have a tileSize of 512');
    }

    Source._loadTileJSON.call(this, options);
}

VectorTileSource.prototype = util.inherit(Evented, {
    minzoom: 0,
    maxzoom: 22,
    tileSize: 512,
    reparseOverscaled: true,
    _loaded: false,
    isTileClipped: true,

    onAdd: function(map) {
        this.map = map;
    },

    loaded: function() {
        return this._pyramid && this._pyramid.loaded();
    },

    update: function(transform) {
        if (this._pyramid) {
            this._pyramid.update(this.used, transform);
        }
    },

    reload: function() {
        if (this._pyramid) {
            this._pyramid.reload();
        }
    },

    serialize: function() {
        return util.extend({}, this._options);
    },

    getVisibleCoordinates: Source._getVisibleCoordinates,
    getTile: Source._getTile,

    queryRenderedFeatures: Source._queryRenderedVectorFeatures,
    querySourceFeatures: Source._querySourceFeatures,

    _loadTile: function(tile) {
        var overscaling = tile.coord.z > this.maxzoom ? Math.pow(2, tile.coord.z - this.maxzoom) : 1;
        var params = {
            url: normalizeURL(tile.coord.url(this.tiles, this.maxzoom), this.url),
            uid: tile.uid,
            coord: tile.coord,
            zoom: tile.coord.z,
            tileSize: this.tileSize * overscaling,
            source: this.id,
            overscaling: overscaling,
            angle: this.map.transform.angle,
            pitch: this.map.transform.pitch,
            showCollisionBoxes: this.map.showCollisionBoxes
        };

        if (tile.workerID) {
            params.rawTileData = tile.rawTileData;
            this.dispatcher.send('reload tile', params, this._tileLoaded.bind(this, tile), tile.workerID);
        } else {
            tile.workerID = this.dispatcher.send('load tile', params, this._tileLoaded.bind(this, tile));
        }
    },

    _tileLoaded: function(tile, err, data) {
        if (tile.aborted)
            return;

        if (err) {
            tile.errored = true;
            this.fire('tile.error', {tile: tile, error: err});
            return;
        }

        tile.loadVectorData(data, this.map.style);

        if (tile.redoWhenDone) {
            tile.redoWhenDone = false;
            tile.redoPlacement(this);
        }

        this.fire('tile.load', {tile: tile});
        this.fire('tile.stats', data.bucketStats);
    },

    _abortTile: function(tile) {
        tile.aborted = true;
        this.dispatcher.send('abort tile', { uid: tile.uid, source: this.id }, null, tile.workerID);
    },

    _addTile: function(tile) {
        this.fire('tile.add', {tile: tile});
    },

    _removeTile: function(tile) {
        this.fire('tile.remove', {tile: tile});
    },

    _unloadTile: function(tile) {
        tile.unloadVectorData(this.map.painter);
        this.dispatcher.send('remove tile', { uid: tile.uid, source: this.id }, null, tile.workerID);
    },

    redoPlacement: Source.redoPlacement,

    _redoTilePlacement: function(tile) {
        tile.redoPlacement(this);
    }
});

},{"../util/evented":109,"../util/mapbox":114,"../util/util":117,"./source":47}],52:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var Tile = require('./tile');
var TileCoord = require('./tile_coord');
var LngLat = require('../geo/lng_lat');
var Point = require('point-geometry');
var Evented = require('../util/evented');
var ajax = require('../util/ajax');
var EXTENT = require('../data/bucket').EXTENT;
var RasterBoundsArray = require('../render/draw_raster').RasterBoundsArray;
var Buffer = require('../data/buffer');
var VertexArrayObject = require('../render/vertex_array_object');

module.exports = VideoSource;

/**
 * Create a Video data source instance given an options object
 * @class VideoSource
 * @param {Object} [options]
 * @param {Array<string>} options.urls An array of URLs to video files
 * @param {Array} options.coordinates Four geographical [lng, lat] coordinates in clockwise order defining the corners (starting with top left) of the video. Does not have to be a rectangle.
 * @example
 * var sourceObj = new mapboxgl.VideoSource({
 *    url: [
 *        'https://www.mapbox.com/videos/baltimore-smoke.mp4',
 *        'https://www.mapbox.com/videos/baltimore-smoke.webm'
 *    ],
 *    coordinates: [
 *        [-76.54335737228394, 39.18579907229748],
 *        [-76.52803659439087, 39.1838364847587],
 *        [-76.5295386314392, 39.17683392507606],
 *        [-76.54520273208618, 39.17876344106642]
 *    ]
 * });
 * map.addSource('some id', sourceObj); // add
 * map.removeSource('some id');  // remove
 */
function VideoSource(options) {
    this.urls = options.urls;
    this.coordinates = options.coordinates;

    ajax.getVideo(options.urls, function(err, video) {
        // @TODO handle errors via event.
        if (err) return;

        this.video = video;
        this.video.loop = true;

        var loopID;

        // start repainting when video starts playing
        this.video.addEventListener('playing', function() {
            loopID = this.map.style.animationLoop.set(Infinity);
            this.map._rerender();
        }.bind(this));

        // stop repainting when video stops
        this.video.addEventListener('pause', function() {
            this.map.style.animationLoop.cancel(loopID);
        }.bind(this));

        this._loaded = true;

        if (this.map) {
            this.video.play();
            this.setCoordinates(options.coordinates);
        }
    }.bind(this));
}

VideoSource.prototype = util.inherit(Evented, /** @lends VideoSource.prototype */{
    roundZoom: true,

    /**
     * Return the HTML video element.
     *
     * @returns {Object}
     */
    getVideo: function() {
        return this.video;
    },

    onAdd: function(map) {
        this.map = map;
        if (this.video) {
            this.video.play();
            this.setCoordinates(this.coordinates);
        }
    },

    /**
     * Update video coordinates and rerender map
     *
     * @param {Array} coordinates Four geographical [lng, lat] coordinates in clockwise order defining the corners (starting with top left) of the video. Does not have to be a rectangle.
     * @returns {VideoSource} this
     */
    setCoordinates: function(coordinates) {
        this.coordinates = coordinates;

        // Calculate which mercator tile is suitable for rendering the video in
        // and create a buffer with the corner coordinates. These coordinates
        // may be outside the tile, because raster tiles aren't clipped when rendering.

        var map = this.map;
        var cornerZ0Coords = coordinates.map(function(coord) {
            return map.transform.locationCoordinate(LngLat.convert(coord)).zoomTo(0);
        });

        var centerCoord = this.centerCoord = util.getCoordinatesCenter(cornerZ0Coords);
        centerCoord.column = Math.round(centerCoord.column);
        centerCoord.row = Math.round(centerCoord.row);


        var tileCoords = cornerZ0Coords.map(function(coord) {
            var zoomedCoord = coord.zoomTo(centerCoord.zoom);
            return new Point(
                Math.round((zoomedCoord.column - centerCoord.column) * EXTENT),
                Math.round((zoomedCoord.row - centerCoord.row) * EXTENT));
        });

        var maxInt16 = 32767;
        var array = new RasterBoundsArray();
        array.emplaceBack(tileCoords[0].x, tileCoords[0].y, 0, 0);
        array.emplaceBack(tileCoords[1].x, tileCoords[1].y, maxInt16, 0);
        array.emplaceBack(tileCoords[3].x, tileCoords[3].y, 0, maxInt16);
        array.emplaceBack(tileCoords[2].x, tileCoords[2].y, maxInt16, maxInt16);

        this.tile = new Tile(new TileCoord(centerCoord.zoom, centerCoord.column, centerCoord.row));
        this.tile.buckets = {};

        this.tile.boundsBuffer = new Buffer(array.serialize(), RasterBoundsArray.serialize(), Buffer.BufferType.VERTEX);
        this.tile.boundsVAO = new VertexArrayObject();

        this.fire('change');

        return this;
    },

    loaded: function() {
        return this.video && this.video.readyState >= 2;
    },

    update: function() {
        // noop
    },

    reload: function() {
        // noop
    },

    prepare: function() {
        if (!this._loaded) return;
        if (this.video.readyState < 2) return; // not enough data for current position

        var gl = this.map.painter.gl;
        if (!this.tile.texture) {
            this.tile.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
        } else {
            gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
        }

        this._currentTime = this.video.currentTime;
    },

    getVisibleCoordinates: function() {
        if (this.tile) return [this.tile.coord];
        else return [];
    },

    getTile: function() {
        return this.tile;
    },

    serialize: function() {
        return {
            type: 'video',
            urls: this.urls,
            coordinates: this.coordinates
        };
    }
});

},{"../data/bucket":15,"../data/buffer":20,"../geo/lng_lat":24,"../render/draw_raster":35,"../render/vertex_array_object":41,"../util/ajax":102,"../util/evented":109,"../util/util":117,"./tile":48,"./tile_coord":49,"point-geometry":172}],53:[function(require,module,exports){
'use strict';

var Actor = require('../util/actor');
var WorkerTile = require('./worker_tile');
var StyleLayer = require('../style/style_layer');
var util = require('../util/util');
var ajax = require('../util/ajax');
var vt = require('vector-tile');
var Protobuf = require('pbf');
var supercluster = require('supercluster');

var geojsonvt = require('geojson-vt');
var rewind = require('geojson-rewind');
var GeoJSONWrapper = require('./geojson_wrapper');
var vtpbf = require('vt-pbf');

module.exports = function(self) {
    return new Worker(self);
};

function Worker(self) {
    this.self = self;
    this.actor = new Actor(self, this);
    this.loading = {};

    this.loaded = {};
    this.geoJSONIndexes = {};
}

util.extend(Worker.prototype, {
    'set layers': function(layers) {
        this.layers = {};
        var that = this;

        // Filter layers and create an id -> layer map
        var childLayerIndicies = [];
        for (var i = 0; i < layers.length; i++) {
            var layer = layers[i];
            if (layer.type === 'fill' || layer.type === 'line' || layer.type === 'circle' || layer.type === 'symbol') {
                if (layer.ref) {
                    childLayerIndicies.push(i);
                } else {
                    setLayer(layer);
                }
            }
        }

        // Create an instance of StyleLayer per layer
        for (var j = 0; j < childLayerIndicies.length; j++) {
            setLayer(layers[childLayerIndicies[j]]);
        }

        function setLayer(serializedLayer) {
            var styleLayer = StyleLayer.create(
                serializedLayer,
                serializedLayer.ref && that.layers[serializedLayer.ref]
            );
            styleLayer.updatePaintTransitions({}, {transition: false});
            that.layers[styleLayer.id] = styleLayer;
        }

        this.layerFamilies = createLayerFamilies(this.layers);
    },

    'update layers': function(layers) {
        var that = this;
        var id;
        var layer;

        // Update ref parents
        for (id in layers) {
            layer = layers[id];
            if (layer.ref) updateLayer(layer);
        }

        // Update ref children
        for (id in layers) {
            layer = layers[id];
            if (!layer.ref) updateLayer(layer);
        }

        function updateLayer(layer) {
            var refLayer = that.layers[layer.ref];
            if (that.layers[layer.id]) {
                that.layers[layer.id].set(layer, refLayer);
            } else {
                that.layers[layer.id] = StyleLayer.create(layer, refLayer);
            }
            that.layers[layer.id].updatePaintTransitions({}, {transition: false});
        }

        this.layerFamilies = createLayerFamilies(this.layers);
    },

    'load tile': function(params, callback) {
        var source = params.source,
            uid = params.uid;

        if (!this.loading[source])
            this.loading[source] = {};


        var tile = this.loading[source][uid] = new WorkerTile(params);

        tile.xhr = ajax.getArrayBuffer(params.url, done.bind(this));

        function done(err, data) {
            delete this.loading[source][uid];

            if (err) return callback(err);

            tile.data = new vt.VectorTile(new Protobuf(new Uint8Array(data)));
            tile.parse(tile.data, this.layerFamilies, this.actor, data, callback);

            this.loaded[source] = this.loaded[source] || {};
            this.loaded[source][uid] = tile;
        }
    },

    'reload tile': function(params, callback) {
        var loaded = this.loaded[params.source],
            uid = params.uid;
        if (loaded && loaded[uid]) {
            var tile = loaded[uid];
            tile.parse(tile.data, this.layerFamilies, this.actor, params.rawTileData, callback);
        }
    },

    'abort tile': function(params) {
        var loading = this.loading[params.source],
            uid = params.uid;
        if (loading && loading[uid]) {
            loading[uid].xhr.abort();
            delete loading[uid];
        }
    },

    'remove tile': function(params) {
        var loaded = this.loaded[params.source],
            uid = params.uid;
        if (loaded && loaded[uid]) {
            delete loaded[uid];
        }
    },

    'redo placement': function(params, callback) {
        var loaded = this.loaded[params.source],
            loading = this.loading[params.source],
            uid = params.uid;

        if (loaded && loaded[uid]) {
            var tile = loaded[uid];
            var result = tile.redoPlacement(params.angle, params.pitch, params.showCollisionBoxes);

            if (result.result) {
                callback(null, result.result, result.transferables);
            }

        } else if (loading && loading[uid]) {
            loading[uid].angle = params.angle;
        }
    },

    'parse geojson': function(params, callback) {
        var indexData = function(err, data) {
            rewind(data, true);
            if (err) return callback(err);
            if (typeof data != 'object') {
                return callback(new Error("Input data is not a valid GeoJSON object."));
            }
            try {
                this.geoJSONIndexes[params.source] = params.cluster ?
                    supercluster(params.superclusterOptions).load(data.features) :
                    geojsonvt(data, params.geojsonVtOptions);
            } catch (err) {
                return callback(err);
            }
            callback(null);
        }.bind(this);

        // Not, because of same origin issues, urls must either include an
        // explicit origin or absolute path.
        // ie: /foo/bar.json or http://example.com/bar.json
        // but not ../foo/bar.json
        if (params.url) {
            ajax.getJSON(params.url, indexData);
        } else if (typeof params.data === 'string') {
            indexData(null, JSON.parse(params.data));
        } else {
            return callback(new Error("Input data is not a valid GeoJSON object."));
        }
    },

    'load geojson tile': function(params, callback) {
        var source = params.source,
            coord = params.coord;

        if (!this.geoJSONIndexes[source]) return callback(null, null); // we couldn't load the file

        // console.time('tile ' + coord.z + ' ' + coord.x + ' ' + coord.y);

        var geoJSONTile = this.geoJSONIndexes[source].getTile(Math.min(coord.z, params.maxZoom), coord.x, coord.y);

        // console.timeEnd('tile ' + coord.z + ' ' + coord.x + ' ' + coord.y);

        // if (!geoJSONTile) console.log('not found', this.geoJSONIndexes[source], coord);

        var tile = geoJSONTile ? new WorkerTile(params) : undefined;

        this.loaded[source] = this.loaded[source] || {};
        this.loaded[source][params.uid] = tile;

        if (geoJSONTile) {
            var geojsonWrapper = new GeoJSONWrapper(geoJSONTile.features);
            geojsonWrapper.name = '_geojsonTileLayer';
            var rawTileData = vtpbf({ layers: { '_geojsonTileLayer': geojsonWrapper }}).buffer;
            tile.parse(geojsonWrapper, this.layerFamilies, this.actor, rawTileData, callback);
        } else {
            return callback(null, null); // nothing in the given tile
        }
    }
});

function createLayerFamilies(layers) {
    var families = {};

    for (var layerId in layers) {
        var layer = layers[layerId];
        var parentLayerId = layer.ref || layer.id;
        var parentLayer = layers[parentLayerId];

        if (parentLayer.layout && parentLayer.layout.visibility === 'none') continue;

        families[parentLayerId] = families[parentLayerId] || [];
        if (layerId === parentLayerId) {
            families[parentLayerId].unshift(layer);
        } else {
            families[parentLayerId].push(layer);
        }
    }

    return families;
}

},{"../style/style_layer":61,"../util/actor":101,"../util/ajax":102,"../util/util":117,"./geojson_wrapper":43,"./worker_tile":54,"geojson-rewind":121,"geojson-vt":126,"pbf":170,"supercluster":175,"vector-tile":181,"vt-pbf":185}],54:[function(require,module,exports){
'use strict';

var FeatureIndex = require('../data/feature_index');
var CollisionTile = require('../symbol/collision_tile');
var Bucket = require('../data/bucket');
var CollisionBoxArray = require('../symbol/collision_box');
var DictionaryCoder = require('../util/dictionary_coder');

module.exports = WorkerTile;

function WorkerTile(params) {
    this.coord = params.coord;
    this.uid = params.uid;
    this.zoom = params.zoom;
    this.tileSize = params.tileSize;
    this.source = params.source;
    this.overscaling = params.overscaling;
    this.angle = params.angle;
    this.pitch = params.pitch;
    this.showCollisionBoxes = params.showCollisionBoxes;
}

WorkerTile.prototype.parse = function(data, layerFamilies, actor, rawTileData, callback) {

    this.status = 'parsing';
    this.data = data;

    this.collisionBoxArray = new CollisionBoxArray();
    var collisionTile = new CollisionTile(this.angle, this.pitch, this.collisionBoxArray);
    var featureIndex = new FeatureIndex(this.coord, this.overscaling, collisionTile, data.layers);
    var sourceLayerCoder = new DictionaryCoder(data.layers ? Object.keys(data.layers).sort() : ['_geojsonTileLayer']);

    var stats = { _total: 0 };

    var tile = this;
    var bucketsById = {};
    var bucketsBySourceLayer = {};
    var i;
    var layer;
    var sourceLayerId;
    var bucket;

    // Map non-ref layers to buckets.
    var bucketIndex = 0;
    for (var layerId in layerFamilies) {
        layer = layerFamilies[layerId][0];

        if (layer.source !== this.source) continue;
        if (layer.ref) continue;
        if (layer.minzoom && this.zoom < layer.minzoom) continue;
        if (layer.maxzoom && this.zoom >= layer.maxzoom) continue;
        if (layer.layout && layer.layout.visibility === 'none') continue;
        if (data.layers && !data.layers[layer.sourceLayer]) continue;

        bucket = Bucket.create({
            layer: layer,
            index: bucketIndex++,
            childLayers: layerFamilies[layerId],
            zoom: this.zoom,
            overscaling: this.overscaling,
            showCollisionBoxes: this.showCollisionBoxes,
            collisionBoxArray: this.collisionBoxArray,
            sourceLayerIndex: sourceLayerCoder.encode(layer.sourceLayer || '_geojsonTileLayer')
        });
        bucket.createFilter();

        bucketsById[layer.id] = bucket;

        if (data.layers) { // vectortile
            sourceLayerId = layer.sourceLayer;
            bucketsBySourceLayer[sourceLayerId] = bucketsBySourceLayer[sourceLayerId] || {};
            bucketsBySourceLayer[sourceLayerId][layer.id] = bucket;
        }
    }

    // read each layer, and sort its features into buckets
    if (data.layers) { // vectortile
        for (sourceLayerId in bucketsBySourceLayer) {
            layer = data.layers[sourceLayerId];
            if (layer) {
                sortLayerIntoBuckets(layer, bucketsBySourceLayer[sourceLayerId]);
            }
        }
    } else { // geojson
        sortLayerIntoBuckets(data, bucketsById);
    }

    function sortLayerIntoBuckets(layer, buckets) {
        for (var i = 0; i < layer.length; i++) {
            var feature = layer.feature(i);
            feature.index = i;
            for (var id in buckets) {
                if (buckets[id].filter(feature))
                    buckets[id].features.push(feature);
            }
        }
    }

    var buckets = [],
        symbolBuckets = this.symbolBuckets = [],
        otherBuckets = [];

    featureIndex.bucketLayerIDs = {};

    for (var id in bucketsById) {
        bucket = bucketsById[id];
        if (bucket.features.length === 0) continue;

        featureIndex.bucketLayerIDs[bucket.index] = bucket.childLayers.map(getLayerId);

        buckets.push(bucket);

        if (bucket.type === 'symbol')
            symbolBuckets.push(bucket);
        else
            otherBuckets.push(bucket);
    }

    var icons = {};
    var stacks = {};
    var deps = 0;


    if (symbolBuckets.length > 0) {

        // Get dependencies for symbol buckets
        for (i = symbolBuckets.length - 1; i >= 0; i--) {
            symbolBuckets[i].updateIcons(icons);
            symbolBuckets[i].updateFont(stacks);
        }

        for (var fontName in stacks) {
            stacks[fontName] = Object.keys(stacks[fontName]).map(Number);
        }
        icons = Object.keys(icons);

        actor.send('get glyphs', {uid: this.uid, stacks: stacks}, function(err, newStacks) {
            stacks = newStacks;
            gotDependency(err);
        });

        if (icons.length) {
            actor.send('get icons', {icons: icons}, function(err, newIcons) {
                icons = newIcons;
                gotDependency(err);
            });
        } else {
            gotDependency();
        }
    }

    // immediately parse non-symbol buckets (they have no dependencies)
    for (i = otherBuckets.length - 1; i >= 0; i--) {
        parseBucket(this, otherBuckets[i]);
    }

    if (symbolBuckets.length === 0)
        return done();

    function gotDependency(err) {
        if (err) return callback(err);
        deps++;
        if (deps === 2) {
            // all symbol bucket dependencies fetched; parse them in proper order
            for (var i = symbolBuckets.length - 1; i >= 0; i--) {
                parseBucket(tile, symbolBuckets[i]);
            }
            done();
        }
    }

    function parseBucket(tile, bucket) {
        var now = Date.now();
        bucket.populateBuffers(collisionTile, stacks, icons);
        var time = Date.now() - now;


        if (bucket.type !== 'symbol') {
            for (var i = 0; i < bucket.features.length; i++) {
                var feature = bucket.features[i];
                featureIndex.insert(feature, feature.index, bucket.sourceLayerIndex, bucket.index);
            }
        }

        bucket.features = null;

        stats._total += time;
        stats[bucket.id] = (stats[bucket.id] || 0) + time;
    }

    function done() {
        tile.status = 'done';

        if (tile.redoPlacementAfterDone) {
            tile.redoPlacement(tile.angle, tile.pitch, null);
            tile.redoPlacementAfterDone = false;
        }

        var featureIndex_ = featureIndex.serialize();
        var collisionTile_ = collisionTile.serialize();
        var collisionBoxArray = tile.collisionBoxArray.serialize();
        var transferables = [rawTileData].concat(featureIndex_.transferables).concat(collisionTile_.transferables);

        var nonEmptyBuckets = buckets.filter(isBucketEmpty);

        callback(null, {
            buckets: nonEmptyBuckets.map(serializeBucket),
            bucketStats: stats, // TODO put this in a separate message?
            featureIndex: featureIndex_.data,
            collisionTile: collisionTile_.data,
            collisionBoxArray: collisionBoxArray,
            rawTileData: rawTileData
        }, getTransferables(nonEmptyBuckets).concat(transferables));
    }
};

WorkerTile.prototype.redoPlacement = function(angle, pitch, showCollisionBoxes) {
    if (this.status !== 'done') {
        this.redoPlacementAfterDone = true;
        this.angle = angle;
        return {};
    }

    var collisionTile = new CollisionTile(angle, pitch, this.collisionBoxArray);

    var buckets = this.symbolBuckets;

    for (var i = buckets.length - 1; i >= 0; i--) {
        buckets[i].placeFeatures(collisionTile, showCollisionBoxes);
    }

    var collisionTile_ = collisionTile.serialize();

    var nonEmptyBuckets = buckets.filter(isBucketEmpty);

    return {
        result: {
            buckets: nonEmptyBuckets.map(serializeBucket),
            collisionTile: collisionTile_.data
        },
        transferables: getTransferables(nonEmptyBuckets).concat(collisionTile_.transferables)
    };
};

function isBucketEmpty(bucket) {
    for (var programName in bucket.arrayGroups) {
        var programArrayGroups = bucket.arrayGroups[programName];
        for (var k = 0; k < programArrayGroups.length; k++) {
            var programArrayGroup = programArrayGroups[k];
            for (var layoutOrPaint in programArrayGroup) {
                var arrays = programArrayGroup[layoutOrPaint];
                for (var bufferName in arrays) {
                    if (arrays[bufferName].length > 0) return true;
                }
            }
        }
    }
    return false;
}

function serializeBucket(bucket) {
    return bucket.serialize();
}

function getTransferables(buckets) {
    var transferables = [];
    for (var i in buckets) {
        var bucket = buckets[i];
        for (var programName in bucket.arrayGroups) {
            var programArrayGroups = bucket.arrayGroups[programName];
            for (var k = 0; k < programArrayGroups.length; k++) {
                var programArrayGroup = programArrayGroups[k];
                for (var layoutOrPaint in programArrayGroup) {
                    var arrays = programArrayGroup[layoutOrPaint];
                    for (var bufferName in arrays) {
                        transferables.push(arrays[bufferName].arrayBuffer);
                    }
                }
            }
        }
    }
    return transferables;
}

function getLayerId(layer) {
    return layer.id;
}

},{"../data/bucket":15,"../data/feature_index":21,"../symbol/collision_box":74,"../symbol/collision_tile":76,"../util/dictionary_coder":108}],55:[function(require,module,exports){
'use strict';

module.exports = AnimationLoop;

function AnimationLoop() {
    this.n = 0;
    this.times = [];
}

// Are all animations done?
AnimationLoop.prototype.stopped = function() {
    this.times = this.times.filter(function(t) {
        return t.time >= (new Date()).getTime();
    });
    return !this.times.length;
};

// Add a new animation that will run t milliseconds
// Returns an id that can be used to cancel it layer
AnimationLoop.prototype.set = function(t) {
    this.times.push({ id: this.n, time: t + (new Date()).getTime() });
    return this.n++;
};

// Cancel an animation
AnimationLoop.prototype.cancel = function(n) {
    this.times = this.times.filter(function(t) {
        return t.id !== n;
    });
};

},{}],56:[function(require,module,exports){
'use strict';

var Evented = require('../util/evented');
var ajax = require('../util/ajax');
var browser = require('../util/browser');
var normalizeURL = require('../util/mapbox').normalizeSpriteURL;

module.exports = ImageSprite;

function ImageSprite(base) {
    this.base = base;
    this.retina = browser.devicePixelRatio > 1;

    var format = this.retina ? '@2x' : '';

    ajax.getJSON(normalizeURL(base, format, '.json'), function(err, data) {
        if (err) {
            this.fire('error', {error: err});
            return;
        }

        this.data = data;
        if (this.img) this.fire('load');
    }.bind(this));

    ajax.getImage(normalizeURL(base, format, '.png'), function(err, img) {
        if (err) {
            this.fire('error', {error: err});
            return;
        }

        // premultiply the sprite
        var data = img.getData();
        var newdata = img.data = new Uint8Array(data.length);
        for (var i = 0; i < data.length; i += 4) {
            var alpha = data[i + 3] / 255;
            newdata[i + 0] = data[i + 0] * alpha;
            newdata[i + 1] = data[i + 1] * alpha;
            newdata[i + 2] = data[i + 2] * alpha;
            newdata[i + 3] = data[i + 3];
        }

        this.img = img;
        if (this.data) this.fire('load');
    }.bind(this));
}

ImageSprite.prototype = Object.create(Evented);

ImageSprite.prototype.toJSON = function() {
    return this.base;
};

ImageSprite.prototype.loaded = function() {
    return !!(this.data && this.img);
};

ImageSprite.prototype.resize = function(/*gl*/) {
    if (browser.devicePixelRatio > 1 !== this.retina) {
        var newSprite = new ImageSprite(this.base);
        newSprite.on('load', function() {
            this.img = newSprite.img;
            this.data = newSprite.data;
            this.retina = newSprite.retina;
        }.bind(this));
    }
};

function SpritePosition() {}
SpritePosition.prototype = { x: 0, y: 0, width: 0, height: 0, pixelRatio: 1, sdf: false };

ImageSprite.prototype.getSpritePosition = function(name) {
    if (!this.loaded()) return new SpritePosition();

    var pos = this.data && this.data[name];
    if (pos && this.img) return pos;

    return new SpritePosition();
};

},{"../util/ajax":102,"../util/browser":103,"../util/evented":109,"../util/mapbox":114}],57:[function(require,module,exports){
'use strict';

var parseCSSColor = require('csscolorparser').parseCSSColor;
var util = require('../util/util');

var colorCache = {};

function parseColor(input) {

    if (colorCache[input]) {
        return colorCache[input];

    // RGBA array
    } else if (Array.isArray(input)) {
        return input;

    // GL function
    } else if (input && input.stops) {
        return util.extend({}, input, {
            stops: input.stops.map(parseFunctionStopColor)
        });

    // Color string
    } else if (typeof input === 'string') {
        var parsedColor = parseCSSColor(input);
        if (!parsedColor) { throw new Error('Invalid color ' + input); }

        var output = colorDowngrade(parsedColor);
        colorCache[input] = output;
        return output;

    } else {
        throw new Error('Invalid color ' + input);
    }

}

function parseFunctionStopColor(stop) {
    return [stop[0], parseColor(stop[1])];
}

function colorDowngrade(color) {
    return [color[0] / 255, color[1] / 255, color[2] / 255, color[3] / 1];
}

module.exports = parseColor;

},{"../util/util":117,"csscolorparser":119}],58:[function(require,module,exports){
'use strict';

var Evented = require('../util/evented');
var StyleLayer = require('./style_layer');
var ImageSprite = require('./image_sprite');
var GlyphSource = require('../symbol/glyph_source');
var SpriteAtlas = require('../symbol/sprite_atlas');
var LineAtlas = require('../render/line_atlas');
var util = require('../util/util');
var ajax = require('../util/ajax');
var normalizeURL = require('../util/mapbox').normalizeStyleURL;
var browser = require('../util/browser');
var Dispatcher = require('../util/dispatcher');
var AnimationLoop = require('./animation_loop');
var validateStyle = require('./validate_style');
var Source = require('../source/source');
var styleSpec = require('./style_spec');
var StyleFunction = require('./style_function');

module.exports = Style;

function Style(stylesheet, animationLoop) {
    this.animationLoop = animationLoop || new AnimationLoop();
    this.dispatcher = new Dispatcher(Math.max(browser.hardwareConcurrency - 1, 1), this);
    this.spriteAtlas = new SpriteAtlas(512, 512);
    this.lineAtlas = new LineAtlas(256, 512);

    this._layers = {};
    this._order  = [];
    this._groups = [];
    this.sources = {};
    this.zoomHistory = {};

    util.bindAll([
        '_forwardSourceEvent',
        '_forwardTileEvent',
        '_forwardLayerEvent',
        '_redoPlacement'
    ], this);

    this._resetUpdates();

    var loaded = function(err, stylesheet) {
        if (err) {
            this.fire('error', {error: err});
            return;
        }

        if (validateStyle.emitErrors(this, validateStyle(stylesheet))) return;

        this._loaded = true;
        this.stylesheet = stylesheet;

        this.updateClasses();

        var sources = stylesheet.sources;
        for (var id in sources) {
            this.addSource(id, sources[id]);
        }

        if (stylesheet.sprite) {
            this.sprite = new ImageSprite(stylesheet.sprite);
            this.sprite.on('load', this.fire.bind(this, 'change'));
        }

        this.glyphSource = new GlyphSource(stylesheet.glyphs);
        this._resolve();
        this.fire('load');
    }.bind(this);

    if (typeof stylesheet === 'string') {
        ajax.getJSON(normalizeURL(stylesheet), loaded);
    } else {
        browser.frame(loaded.bind(this, null, stylesheet));
    }

    this.on('source.load', function(event) {
        var source = event.source;
        if (source && source.vectorLayerIds) {
            for (var layerId in this._layers) {
                var layer = this._layers[layerId];
                if (layer.source === source.id) {
                    this._validateLayer(layer);
                }
            }
        }
    });
}

Style.prototype = util.inherit(Evented, {
    _loaded: false,

    _validateLayer: function(layer) {
        var source = this.sources[layer.source];

        if (!layer.sourceLayer) return;
        if (!source) return;
        if (!source.vectorLayerIds) return;

        if (source.vectorLayerIds.indexOf(layer.sourceLayer) === -1) {
            this.fire('error', {
                error: new Error(
                    'Source layer "' + layer.sourceLayer + '" ' +
                    'does not exist on source "' + source.id + '" ' +
                    'as specified by style layer "' + layer.id + '"'
                )
            });
        }
    },

    loaded: function() {
        if (!this._loaded)
            return false;

        for (var id in this.sources)
            if (!this.sources[id].loaded())
                return false;

        if (this.sprite && !this.sprite.loaded())
            return false;

        return true;
    },

    _resolve: function() {
        var layer, layerJSON;

        this._layers = {};
        this._order  = this.stylesheet.layers.map(function(layer) {
            return layer.id;
        });

        // resolve all layers WITHOUT a ref
        for (var i = 0; i < this.stylesheet.layers.length; i++) {
            layerJSON = this.stylesheet.layers[i];
            if (layerJSON.ref) continue;
            layer = StyleLayer.create(layerJSON);
            this._layers[layer.id] = layer;
            layer.on('error', this._forwardLayerEvent);
        }

        // resolve all layers WITH a ref
        for (var j = 0; j < this.stylesheet.layers.length; j++) {
            layerJSON = this.stylesheet.layers[j];
            if (!layerJSON.ref) continue;
            var refLayer = this.getLayer(layerJSON.ref);
            layer = StyleLayer.create(layerJSON, refLayer);
            this._layers[layer.id] = layer;
            layer.on('error', this._forwardLayerEvent);
        }

        this._groupLayers();
        this._updateWorkerLayers();
    },

    _groupLayers: function() {
        var group;

        this._groups = [];

        // Split into groups of consecutive top-level layers with the same source.
        for (var i = 0; i < this._order.length; ++i) {
            var layer = this._layers[this._order[i]];

            if (!group || layer.source !== group.source) {
                group = [];
                group.source = layer.source;
                this._groups.push(group);
            }

            group.push(layer);
        }
    },

    _updateWorkerLayers: function(ids) {
        this.dispatcher.broadcast(ids ? 'update layers' : 'set layers', this._serializeLayers(ids));
    },

    _serializeLayers: function(ids) {
        ids = ids || this._order;
        var serialized = [];
        var options = {includeRefProperties: true};
        for (var i = 0; i < ids.length; i++) {
            serialized.push(this._layers[ids[i]].serialize(options));
        }
        return serialized;
    },

    _applyClasses: function(classes, options) {
        if (!this._loaded) return;

        classes = classes || [];
        options = options || {transition: true};
        var transition = this.stylesheet.transition || {};

        var layers = this._updates.allPaintProps ? this._layers : this._updates.paintProps;

        for (var id in layers) {
            var layer = this._layers[id];
            var props = this._updates.paintProps[id];

            if (this._updates.allPaintProps || props.all) {
                layer.updatePaintTransitions(classes, options, transition, this.animationLoop);
            } else {
                for (var paintName in props) {
                    this._layers[id].updatePaintTransition(paintName, classes, options, transition, this.animationLoop);
                }
            }
        }
    },

    _recalculate: function(z) {
        for (var sourceId in this.sources)
            this.sources[sourceId].used = false;

        this._updateZoomHistory(z);

        this.rasterFadeDuration = 300;
        for (var layerId in this._layers) {
            var layer = this._layers[layerId];

            layer.recalculate(z, this.zoomHistory);
            if (!layer.isHidden(z) && layer.source) {
                this.sources[layer.source].used = true;
            }
        }

        var maxZoomTransitionDuration = 300;
        if (Math.floor(this.z) !== Math.floor(z)) {
            this.animationLoop.set(maxZoomTransitionDuration);
        }

        this.z = z;
        this.fire('zoom');
    },

    _updateZoomHistory: function(z) {

        var zh = this.zoomHistory;

        if (zh.lastIntegerZoom === undefined) {
            // first time
            zh.lastIntegerZoom = Math.floor(z);
            zh.lastIntegerZoomTime = 0;
            zh.lastZoom = z;
        }

        // check whether an integer zoom level as passed since the last frame
        // and if yes, record it with the time. Used for transitioning patterns.
        if (Math.floor(zh.lastZoom) < Math.floor(z)) {
            zh.lastIntegerZoom = Math.floor(z);
            zh.lastIntegerZoomTime = Date.now();

        } else if (Math.floor(zh.lastZoom) > Math.floor(z)) {
            zh.lastIntegerZoom = Math.floor(z + 1);
            zh.lastIntegerZoomTime = Date.now();
        }

        zh.lastZoom = z;
    },

    _checkLoaded: function () {
        if (!this._loaded) {
            throw new Error('Style is not done loading');
        }
    },

    /**
     * Apply queued style updates in a batch
     * @private
     */
    update: function(classes, options) {
        if (!this._updates.changed) return this;

        if (this._updates.allLayers) {
            this._groupLayers();
            this._updateWorkerLayers();
        } else {
            var updatedIds = Object.keys(this._updates.layers);
            if (updatedIds.length) {
                this._updateWorkerLayers(updatedIds);
            }
        }

        var updatedSourceIds = Object.keys(this._updates.sources);
        var i;
        for (i = 0; i < updatedSourceIds.length; i++) {
            this._reloadSource(updatedSourceIds[i]);
        }

        for (i = 0; i < this._updates.events.length; i++) {
            var args = this._updates.events[i];
            this.fire(args[0], args[1]);
        }

        this._applyClasses(classes, options);

        if (this._updates.changed) {
            this.fire('change');
        }

        this._resetUpdates();

        return this;
    },

    _resetUpdates: function() {
        this._updates = {
            events: [],
            layers: {},
            sources: {},
            paintProps: {}
        };
    },

    addSource: function(id, source) {
        this._checkLoaded();
        if (this.sources[id] !== undefined) {
            throw new Error('There is already a source with this ID');
        }
        if (!Source.is(source) && this._handleErrors(validateStyle.source, 'sources.' + id, source)) return this;

        source = Source.create(source);
        this.sources[id] = source;
        source.id = id;
        source.style = this;
        source.dispatcher = this.dispatcher;
        source
            .on('load', this._forwardSourceEvent)
            .on('error', this._forwardSourceEvent)
            .on('change', this._forwardSourceEvent)
            .on('tile.add', this._forwardTileEvent)
            .on('tile.load', this._forwardTileEvent)
            .on('tile.error', this._forwardTileEvent)
            .on('tile.remove', this._forwardTileEvent)
            .on('tile.stats', this._forwardTileEvent);

        this._updates.events.push(['source.add', {source: source}]);
        this._updates.changed = true;

        return this;
    },

    /**
     * Remove a source from this stylesheet, given its id.
     * @param {string} id id of the source to remove
     * @returns {Style} this style
     * @throws {Error} if no source is found with the given ID
     * @private
     */
    removeSource: function(id) {
        this._checkLoaded();

        if (this.sources[id] === undefined) {
            throw new Error('There is no source with this ID');
        }
        var source = this.sources[id];
        delete this.sources[id];
        source
            .off('load', this._forwardSourceEvent)
            .off('error', this._forwardSourceEvent)
            .off('change', this._forwardSourceEvent)
            .off('tile.add', this._forwardTileEvent)
            .off('tile.load', this._forwardTileEvent)
            .off('tile.error', this._forwardTileEvent)
            .off('tile.remove', this._forwardTileEvent)
            .off('tile.stats', this._forwardTileEvent);

        this._updates.events.push(['source.remove', {source: source}]);
        this._updates.changed = true;

        return this;
    },

    /**
     * Get a source by id.
     * @param {string} id id of the desired source
     * @returns {Object} source
     * @private
     */
    getSource: function(id) {
        return this.sources[id];
    },

    /**
     * Add a layer to the map style. The layer will be inserted before the layer with
     * ID `before`, or appended if `before` is omitted.
     * @param {StyleLayer|Object} layer
     * @param {string=} before  ID of an existing layer to insert before
     * @fires layer.add
     * @returns {Style} `this`
     * @private
     */
    addLayer: function(layer, before) {
        this._checkLoaded();

        if (!(layer instanceof StyleLayer)) {
            // this layer is not in the style.layers array, so we pass an impossible array index
            if (this._handleErrors(validateStyle.layer,
                    'layers.' + layer.id, layer, false, {arrayIndex: -1})) return this;

            var refLayer = layer.ref && this.getLayer(layer.ref);
            layer = StyleLayer.create(layer, refLayer);
        }
        this._validateLayer(layer);

        layer.on('error', this._forwardLayerEvent);

        this._layers[layer.id] = layer;
        this._order.splice(before ? this._order.indexOf(before) : Infinity, 0, layer.id);

        this._updates.allLayers = true;
        if (layer.source) {
            this._updates.sources[layer.source] = true;
        }
        this._updates.events.push(['layer.add', {layer: layer}]);

        return this.updateClasses(layer.id);
    },

    /**
     * Remove a layer from this stylesheet, given its id.
     * @param {string} id id of the layer to remove
     * @returns {Style} this style
     * @throws {Error} if no layer is found with the given ID
     * @private
     */
    removeLayer: function(id) {
        this._checkLoaded();

        var layer = this._layers[id];
        if (layer === undefined) {
            throw new Error('There is no layer with this ID');
        }
        for (var i in this._layers) {
            if (this._layers[i].ref === id) {
                this.removeLayer(i);
            }
        }

        layer.off('error', this._forwardLayerEvent);

        delete this._layers[id];
        this._order.splice(this._order.indexOf(id), 1);

        this._updates.allLayers = true;
        this._updates.events.push(['layer.remove', {layer: layer}]);
        this._updates.changed = true;

        return this;
    },

    /**
     * Return the style layer object with the given `id`.
     *
     * @param {string} id - id of the desired layer
     * @returns {?Object} a layer, if one with the given `id` exists
     * @private
     */
    getLayer: function(id) {
        return this._layers[id];
    },

    /**
     * If a layer has a `ref` property that makes it derive some values
     * from another layer, return that referent layer. Otherwise,
     * returns the layer itself.
     * @param {string} id the layer's id
     * @returns {Layer} the referent layer or the layer itself
     * @private
     */
    getReferentLayer: function(id) {
        var layer = this.getLayer(id);
        if (layer.ref) {
            layer = this.getLayer(layer.ref);
        }
        return layer;
    },

    setLayerZoomRange: function(layerId, minzoom, maxzoom) {
        this._checkLoaded();

        var layer = this.getReferentLayer(layerId);

        if (layer.minzoom === minzoom && layer.maxzoom === maxzoom) return this;

        if (minzoom != null) {
            layer.minzoom = minzoom;
        }
        if (maxzoom != null) {
            layer.maxzoom = maxzoom;
        }
        return this._updateLayer(layer);
    },

    setFilter: function(layerId, filter) {
        this._checkLoaded();

        var layer = this.getReferentLayer(layerId);

        if (this._handleErrors(validateStyle.filter, 'layers.' + layer.id + '.filter', filter)) return this;

        if (util.deepEqual(layer.filter, filter)) return this;
        layer.filter = util.clone(filter);

        return this._updateLayer(layer);
    },

    /**
     * Get a layer's filter object
     * @param {string} layer the layer to inspect
     * @returns {*} the layer's filter, if any
     * @private
     */
    getFilter: function(layer) {
        return this.getReferentLayer(layer).filter;
    },

    setLayoutProperty: function(layerId, name, value) {
        this._checkLoaded();

        var layer = this.getReferentLayer(layerId);

        if (util.deepEqual(layer.getLayoutProperty(name), value)) return this;

        layer.setLayoutProperty(name, value);
        return this._updateLayer(layer);
    },

    /**
     * Get a layout property's value from a given layer
     * @param {string} layer the layer to inspect
     * @param {string} name the name of the layout property
     * @returns {*} the property value
     * @private
     */
    getLayoutProperty: function(layer, name) {
        return this.getReferentLayer(layer).getLayoutProperty(name);
    },

    setPaintProperty: function(layerId, name, value, klass) {
        this._checkLoaded();

        var layer = this.getLayer(layerId);

        if (util.deepEqual(layer.getPaintProperty(name, klass), value)) return this;

        var wasFeatureConstant = layer.isPaintValueFeatureConstant(name);
        layer.setPaintProperty(name, value, klass);

        var isFeatureConstant = !(StyleFunction.isFunctionDefinition(value) && value.property !== '$zoom' && value.property !== undefined);

        if (!isFeatureConstant || !wasFeatureConstant) {
            this._updates.layers[layerId] = true;
            if (layer.source) {
                this._updates.sources[layer.source] = true;
            }
        }

        return this.updateClasses(layerId, name);
    },

    getPaintProperty: function(layer, name, klass) {
        return this.getLayer(layer).getPaintProperty(name, klass);
    },

    updateClasses: function (layerId, paintName) {
        this._updates.changed = true;
        if (!layerId) {
            this._updates.allPaintProps = true;
        } else {
            var props = this._updates.paintProps;
            if (!props[layerId]) props[layerId] = {};
            props[layerId][paintName || 'all'] = true;
        }
        return this;
    },

    serialize: function() {
        return util.filterObject({
            version: this.stylesheet.version,
            name: this.stylesheet.name,
            metadata: this.stylesheet.metadata,
            center: this.stylesheet.center,
            zoom: this.stylesheet.zoom,
            bearing: this.stylesheet.bearing,
            pitch: this.stylesheet.pitch,
            sprite: this.stylesheet.sprite,
            glyphs: this.stylesheet.glyphs,
            transition: this.stylesheet.transition,
            sources: util.mapObject(this.sources, function(source) {
                return source.serialize();
            }),
            layers: this._order.map(function(id) {
                return this._layers[id].serialize();
            }, this)
        }, function(value) { return value !== undefined; });
    },

    _updateLayer: function (layer) {
        this._updates.layers[layer.id] = true;
        if (layer.source) {
            this._updates.sources[layer.source] = true;
        }
        this._updates.changed = true;
        return this;
    },

    _flattenRenderedFeatures: function(sourceResults) {
        var features = [];
        for (var l = this._order.length - 1; l >= 0; l--) {
            var layerID = this._order[l];
            for (var s = 0; s < sourceResults.length; s++) {
                var layerFeatures = sourceResults[s][layerID];
                if (layerFeatures) {
                    for (var f = 0; f < layerFeatures.length; f++) {
                        features.push(layerFeatures[f]);
                    }
                }
            }
        }
        return features;
    },

    queryRenderedFeatures: function(queryGeometry, params, zoom, bearing) {
        if (params && params.filter) {
            this._handleErrors(validateStyle.filter, 'queryRenderedFeatures.filter', params.filter, true);
        }

        var sourceResults = [];
        for (var id in this.sources) {
            var source = this.sources[id];
            if (source.queryRenderedFeatures) {
                sourceResults.push(source.queryRenderedFeatures(queryGeometry, params, zoom, bearing));
            }
        }
        return this._flattenRenderedFeatures(sourceResults);
    },

    querySourceFeatures: function(sourceID, params) {
        if (params && params.filter) {
            this._handleErrors(validateStyle.filter, 'querySourceFeatures.filter', params.filter, true);
        }
        var source = this.getSource(sourceID);
        return source && source.querySourceFeatures ? source.querySourceFeatures(params) : [];
    },

    _handleErrors: function(validate, key, value, throws, props) {
        var action = throws ? validateStyle.throwErrors : validateStyle.emitErrors;
        var result = validate.call(validateStyle, util.extend({
            key: key,
            style: this.serialize(),
            value: value,
            styleSpec: styleSpec
        }, props));
        return action.call(validateStyle, this, result);
    },

    _remove: function() {
        this.dispatcher.remove();
    },

    _reloadSource: function(id) {
        this.sources[id].reload();
    },

    _updateSources: function(transform) {
        for (var id in this.sources) {
            this.sources[id].update(transform);
        }
    },

    _redoPlacement: function() {
        for (var id in this.sources) {
            if (this.sources[id].redoPlacement) this.sources[id].redoPlacement();
        }
    },

    _forwardSourceEvent: function(e) {
        this.fire('source.' + e.type, util.extend({source: e.target}, e));
    },

    _forwardTileEvent: function(e) {
        this.fire(e.type, util.extend({source: e.target}, e));
    },

    _forwardLayerEvent: function(e) {
        this.fire('layer.' + e.type, util.extend({layer: {id: e.target.id}}, e));
    },

    // Callbacks from web workers

    'get sprite json': function(params, callback) {
        var sprite = this.sprite;
        if (sprite.loaded()) {
            callback(null, { sprite: sprite.data, retina: sprite.retina });
        } else {
            sprite.on('load', function() {
                callback(null, { sprite: sprite.data, retina: sprite.retina });
            });
        }
    },

    'get icons': function(params, callback) {
        var sprite = this.sprite;
        var spriteAtlas = this.spriteAtlas;
        if (sprite.loaded()) {
            spriteAtlas.setSprite(sprite);
            spriteAtlas.addIcons(params.icons, callback);
        } else {
            sprite.on('load', function() {
                spriteAtlas.setSprite(sprite);
                spriteAtlas.addIcons(params.icons, callback);
            });
        }
    },

    'get glyphs': function(params, callback) {
        var stacks = params.stacks,
            remaining = Object.keys(stacks).length,
            allGlyphs = {};

        for (var fontName in stacks) {
            this.glyphSource.getSimpleGlyphs(fontName, stacks[fontName], params.uid, done);
        }

        function done(err, glyphs, fontName) {
            if (err) console.error(err);

            allGlyphs[fontName] = glyphs;
            remaining--;

            if (remaining === 0)
                callback(null, allGlyphs);
        }
    }
});

},{"../render/line_atlas":38,"../source/source":47,"../symbol/glyph_source":79,"../symbol/sprite_atlas":84,"../util/ajax":102,"../util/browser":103,"../util/dispatcher":105,"../util/evented":109,"../util/mapbox":114,"../util/util":117,"./animation_loop":55,"./image_sprite":56,"./style_function":60,"./style_layer":61,"./style_spec":68,"./validate_style":70}],59:[function(require,module,exports){
'use strict';

var MapboxGLFunction = require('./style_function');
var parseColor = require('./parse_color');
var util = require('../util/util');

module.exports = StyleDeclaration;

function StyleDeclaration(reference, value) {
    this.type = reference.type;
    this.transitionable = reference.transition;
    this.value = util.clone(value);
    this.isFunction = !!value.stops;

    // immutable representation of value. used for comparison
    this.json = JSON.stringify(this.value);

    var parsedValue = this.type === 'color' ? parseColor(this.value) : value;
    this.calculate = MapboxGLFunction[reference.function || 'piecewise-constant'](parsedValue);
    this.isFeatureConstant = this.calculate.isFeatureConstant;
    this.isZoomConstant = this.calculate.isZoomConstant;

    if (reference.function === 'piecewise-constant' && reference.transition) {
        this.calculate = transitioned(this.calculate);
    }

    if (!this.isFeatureConstant && !this.isZoomConstant) {
        this.stopZoomLevels = [];
        var interpolationAmountStops = [];
        var stops = this.value.stops;
        for (var i = 0; i < this.value.stops.length; i++) {
            var zoom = stops[i][0].zoom;
            if (this.stopZoomLevels.indexOf(zoom) < 0) {
                this.stopZoomLevels.push(zoom);
                interpolationAmountStops.push([zoom, interpolationAmountStops.length]);
            }
        }

        this.calculateInterpolationT = MapboxGLFunction.interpolated({
            stops: interpolationAmountStops,
            base: value.base
        });
    }
}

function transitioned(calculate) {
    return function(globalProperties, featureProperties) {
        var z = globalProperties.zoom;
        var zh = globalProperties.zoomHistory;
        var duration = globalProperties.duration;

        var fraction = z % 1;
        var t = Math.min((Date.now() - zh.lastIntegerZoomTime) / duration, 1);
        var fromScale = 1;
        var toScale = 1;
        var mix, from, to;

        if (z > zh.lastIntegerZoom) {
            mix = fraction + (1 - fraction) * t;
            fromScale *= 2;
            from = calculate({zoom: z - 1}, featureProperties);
            to = calculate({zoom: z}, featureProperties);
        } else {
            mix = 1 - (1 - t) * fraction;
            to = calculate({zoom: z}, featureProperties);
            from = calculate({zoom: z + 1}, featureProperties);
            fromScale /= 2;
        }

        return {
            from: from,
            fromScale: fromScale,
            to: to,
            toScale: toScale,
            t: mix
        };
    };
}

},{"../util/util":117,"./parse_color":57,"./style_function":60}],60:[function(require,module,exports){
'use strict';

var MapboxGLFunction = require('mapbox-gl-function');

exports.interpolated = function(parameters) {
    var inner = MapboxGLFunction.interpolated(parameters);
    var outer = function(globalProperties, featureProperties) {
        return inner(globalProperties && globalProperties.zoom, featureProperties || {});
    };
    outer.isFeatureConstant = inner.isFeatureConstant;
    outer.isZoomConstant = inner.isZoomConstant;
    return outer;
};

exports['piecewise-constant'] = function(parameters) {
    var inner = MapboxGLFunction['piecewise-constant'](parameters);
    var outer = function(globalProperties, featureProperties) {
        return inner(globalProperties && globalProperties.zoom, featureProperties || {});
    };
    outer.isFeatureConstant = inner.isFeatureConstant;
    outer.isZoomConstant = inner.isZoomConstant;
    return outer;
};

exports.isFunctionDefinition = MapboxGLFunction.isFunctionDefinition;

},{"mapbox-gl-function":142}],61:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var StyleTransition = require('./style_transition');
var StyleDeclaration = require('./style_declaration');
var styleSpec = require('./style_spec');
var validateStyle = require('./validate_style');
var parseColor = require('./parse_color');
var Evented = require('../util/evented');

module.exports = StyleLayer;

var TRANSITION_SUFFIX = '-transition';

StyleLayer.create = function(layer, refLayer) {
    var Classes = {
        background: require('./style_layer/background_style_layer'),
        circle: require('./style_layer/circle_style_layer'),
        fill: require('./style_layer/fill_style_layer'),
        line: require('./style_layer/line_style_layer'),
        raster: require('./style_layer/raster_style_layer'),
        symbol: require('./style_layer/symbol_style_layer')
    };
    return new Classes[(refLayer || layer).type](layer, refLayer);
};

function StyleLayer(layer, refLayer) {
    this.set(layer, refLayer);
}

StyleLayer.prototype = util.inherit(Evented, {

    set: function(layer, refLayer) {
        this.id = layer.id;
        this.ref = layer.ref;
        this.metadata = layer.metadata;
        this.type = (refLayer || layer).type;
        this.source = (refLayer || layer).source;
        this.sourceLayer = (refLayer || layer)['source-layer'];
        this.minzoom = (refLayer || layer).minzoom;
        this.maxzoom = (refLayer || layer).maxzoom;
        this.filter = (refLayer || layer).filter;

        this.paint = {};
        this.layout = {};

        this._paintSpecifications = styleSpec['paint_' + this.type];
        this._layoutSpecifications = styleSpec['layout_' + this.type];

        this._paintTransitions = {}; // {[propertyName]: StyleTransition}
        this._paintTransitionOptions = {}; // {[className]: {[propertyName]: { duration:Number, delay:Number }}}
        this._paintDeclarations = {}; // {[className]: {[propertyName]: StyleDeclaration}}
        this._layoutDeclarations = {}; // {[propertyName]: StyleDeclaration}
        this._layoutFunctions = {}; // {[propertyName]: Boolean}

        var paintName, layoutName;

        // Resolve paint declarations
        for (var key in layer) {
            var match = key.match(/^paint(?:\.(.*))?$/);
            if (match) {
                var klass = match[1] || '';
                for (paintName in layer[key]) {
                    this.setPaintProperty(paintName, layer[key][paintName], klass);
                }
            }
        }

        // Resolve layout declarations
        if (this.ref) {
            this._layoutDeclarations = refLayer._layoutDeclarations;
        } else {
            for (layoutName in layer.layout) {
                this.setLayoutProperty(layoutName, layer.layout[layoutName]);
            }
        }

        // set initial layout/paint values
        for (paintName in this._paintSpecifications) {
            this.paint[paintName] = this.getPaintValue(paintName);
        }
        for (layoutName in this._layoutSpecifications) {
            this._updateLayoutValue(layoutName);
        }
    },

    setLayoutProperty: function(name, value) {

        if (value == null) {
            delete this._layoutDeclarations[name];
        } else {
            var key = 'layers.' + this.id + '.layout.' + name;
            if (this._handleErrors(validateStyle.layoutProperty, key, name, value)) return;
            this._layoutDeclarations[name] = new StyleDeclaration(this._layoutSpecifications[name], value);
        }
        this._updateLayoutValue(name);
    },

    getLayoutProperty: function(name) {
        return (
            this._layoutDeclarations[name] &&
            this._layoutDeclarations[name].value
        );
    },

    getLayoutValue: function(name, globalProperties, featureProperties) {
        var specification = this._layoutSpecifications[name];
        var declaration = this._layoutDeclarations[name];

        if (declaration) {
            return declaration.calculate(globalProperties, featureProperties);
        } else {
            return specification.default;
        }
    },

    setPaintProperty: function(name, value, klass) {
        var validateStyleKey = 'layers.' + this.id + (klass ? '["paint.' + klass + '"].' : '.paint.') + name;

        if (util.endsWith(name, TRANSITION_SUFFIX)) {
            if (!this._paintTransitionOptions[klass || '']) {
                this._paintTransitionOptions[klass || ''] = {};
            }
            if (value === null || value === undefined) {
                delete this._paintTransitionOptions[klass || ''][name];
            } else {
                if (this._handleErrors(validateStyle.paintProperty, validateStyleKey, name, value)) return;
                this._paintTransitionOptions[klass || ''][name] = value;
            }
        } else {
            if (!this._paintDeclarations[klass || '']) {
                this._paintDeclarations[klass || ''] = {};
            }
            if (value === null || value === undefined) {
                delete this._paintDeclarations[klass || ''][name];
            } else {
                if (this._handleErrors(validateStyle.paintProperty, validateStyleKey, name, value)) return;
                this._paintDeclarations[klass || ''][name] = new StyleDeclaration(this._paintSpecifications[name], value);
            }
        }
    },

    getPaintProperty: function(name, klass) {
        klass = klass || '';
        if (util.endsWith(name, TRANSITION_SUFFIX)) {
            return (
                this._paintTransitionOptions[klass] &&
                this._paintTransitionOptions[klass][name]
            );
        } else {
            return (
                this._paintDeclarations[klass] &&
                this._paintDeclarations[klass][name] &&
                this._paintDeclarations[klass][name].value
            );
        }
    },

    getPaintValue: function(name, globalProperties, featureProperties) {
        var specification = this._paintSpecifications[name];
        var transition = this._paintTransitions[name];

        if (transition) {
            return transition.calculate(globalProperties, featureProperties);
        } else if (specification.type === 'color' && specification.default) {
            return parseColor(specification.default);
        } else {
            return specification.default;
        }
    },

    getPaintValueStopZoomLevels: function(name) {
        var transition = this._paintTransitions[name];
        if (transition) {
            return transition.declaration.stopZoomLevels;
        } else {
            return [];
        }
    },

    getPaintInterpolationT: function(name, zoom) {
        var transition = this._paintTransitions[name];
        return transition.declaration.calculateInterpolationT({ zoom: zoom });
    },

    isPaintValueFeatureConstant: function(name) {
        var transition = this._paintTransitions[name];

        if (transition) {
            return transition.declaration.isFeatureConstant;
        } else {
            return true;
        }
    },

    isPaintValueZoomConstant: function(name) {
        var transition = this._paintTransitions[name];

        if (transition) {
            return transition.declaration.isZoomConstant;
        } else {
            return true;
        }
    },


    isHidden: function(zoom) {
        if (this.minzoom && zoom < this.minzoom) return true;
        if (this.maxzoom && zoom >= this.maxzoom) return true;
        if (this.layout['visibility'] === 'none') return true;
        if (this.paint[this.type + '-opacity'] === 0) return true;
        return false;
    },

    updatePaintTransitions: function(classes, options, globalOptions, animationLoop) {
        var declarations = util.extend({}, this._paintDeclarations['']);
        for (var i = 0; i < classes.length; i++) {
            util.extend(declarations, this._paintDeclarations[classes[i]]);
        }

        var name;
        for (name in declarations) { // apply new declarations
            this._applyPaintDeclaration(name, declarations[name], options, globalOptions, animationLoop);
        }
        for (name in this._paintTransitions) {
            if (!(name in declarations)) // apply removed declarations
                this._applyPaintDeclaration(name, null, options, globalOptions, animationLoop);
        }
    },

    updatePaintTransition: function(name, classes, options, globalOptions, animationLoop) {
        var declaration = this._paintDeclarations[''][name];
        for (var i = 0; i < classes.length; i++) {
            var classPaintDeclarations = this._paintDeclarations[classes[i]];
            if (classPaintDeclarations && classPaintDeclarations[name]) {
                declaration = classPaintDeclarations[name];
            }
        }
        this._applyPaintDeclaration(name, declaration, options, globalOptions, animationLoop);
    },

    // update all zoom-dependent layout/paint values
    recalculate: function(zoom, zoomHistory) {
        for (var paintName in this._paintTransitions) {
            this.paint[paintName] = this.getPaintValue(paintName, {zoom: zoom, zoomHistory: zoomHistory});
        }
        for (var layoutName in this._layoutFunctions) {
            this.layout[layoutName] = this.getLayoutValue(layoutName, {zoom: zoom, zoomHistory: zoomHistory});
        }
    },

    serialize: function(options) {
        var output = {
            'id': this.id,
            'ref': this.ref,
            'metadata': this.metadata,
            'minzoom': this.minzoom,
            'maxzoom': this.maxzoom
        };

        for (var klass in this._paintDeclarations) {
            var key = klass === '' ? 'paint' : 'paint.' + klass;
            output[key] = util.mapObject(this._paintDeclarations[klass], getDeclarationValue);
        }

        if (!this.ref || (options && options.includeRefProperties)) {
            util.extend(output, {
                'type': this.type,
                'source': this.source,
                'source-layer': this.sourceLayer,
                'filter': this.filter,
                'layout': util.mapObject(this._layoutDeclarations, getDeclarationValue)
            });
        }

        return util.filterObject(output, function(value, key) {
            return value !== undefined && !(key === 'layout' && !Object.keys(value).length);
        });
    },

    // set paint transition based on a given paint declaration
    _applyPaintDeclaration: function (name, declaration, options, globalOptions, animationLoop) {
        var oldTransition = options.transition ? this._paintTransitions[name] : undefined;

        if (declaration === null || declaration === undefined) {
            var spec = this._paintSpecifications[name];
            declaration = new StyleDeclaration(spec, spec.default);
        }

        if (oldTransition && oldTransition.declaration.json === declaration.json) return;

        var transitionOptions = util.extend({
            duration: 300,
            delay: 0
        }, globalOptions, this.getPaintProperty(name + TRANSITION_SUFFIX));

        var newTransition = this._paintTransitions[name] =
                new StyleTransition(declaration, oldTransition, transitionOptions);

        if (!newTransition.instant()) {
            newTransition.loopID = animationLoop.set(newTransition.endTime - Date.now());
        }
        if (oldTransition) {
            animationLoop.cancel(oldTransition.loopID);
        }
    },

    // update layout value if it's constant, or mark it as zoom-dependent
    _updateLayoutValue: function(name) {
        var declaration = this._layoutDeclarations[name];

        if (declaration && declaration.isFunction) {
            this._layoutFunctions[name] = true;
        } else {
            delete this._layoutFunctions[name];
            this.layout[name] = this.getLayoutValue(name);
        }
    },

    _handleErrors: function(validate, key, name, value) {
        return validateStyle.emitErrors(this, validate.call(validateStyle, {
            key: key,
            layerType: this.type,
            objectKey: name,
            value: value,
            styleSpec: styleSpec,
            // Workaround for https://github.com/mapbox/mapbox-gl-js/issues/2407
            style: {glyphs: true, sprite: true}
        }));
    }
});

function getDeclarationValue(declaration) {
    return declaration.value;
}

},{"../util/evented":109,"../util/util":117,"./parse_color":57,"./style_declaration":59,"./style_layer/background_style_layer":62,"./style_layer/circle_style_layer":63,"./style_layer/fill_style_layer":64,"./style_layer/line_style_layer":65,"./style_layer/raster_style_layer":66,"./style_layer/symbol_style_layer":67,"./style_spec":68,"./style_transition":69,"./validate_style":70}],62:[function(require,module,exports){
'use strict';

var util = require('../../util/util');
var StyleLayer = require('../style_layer');

function BackgroundStyleLayer() {
    StyleLayer.apply(this, arguments);
}

module.exports = BackgroundStyleLayer;

BackgroundStyleLayer.prototype = util.inherit(StyleLayer, {});

},{"../../util/util":117,"../style_layer":61}],63:[function(require,module,exports){
'use strict';

var util = require('../../util/util');
var StyleLayer = require('../style_layer');

function CircleStyleLayer() {
    StyleLayer.apply(this, arguments);
}

module.exports = CircleStyleLayer;

CircleStyleLayer.prototype = util.inherit(StyleLayer, {});

},{"../../util/util":117,"../style_layer":61}],64:[function(require,module,exports){
'use strict';

var util = require('../../util/util');
var StyleLayer = require('../style_layer');

function FillStyleLayer() {
    StyleLayer.apply(this, arguments);
}

module.exports = FillStyleLayer;

FillStyleLayer.prototype = util.inherit(StyleLayer, {});

},{"../../util/util":117,"../style_layer":61}],65:[function(require,module,exports){
'use strict';

var util = require('../../util/util');
var StyleLayer = require('../style_layer');

function LineStyleLayer() {
    StyleLayer.apply(this, arguments);
}

module.exports = LineStyleLayer;

LineStyleLayer.prototype = util.inherit(StyleLayer, {

    getPaintValue: function(name, globalProperties, featureProperties) {
        var value = StyleLayer.prototype.getPaintValue.apply(this, arguments);

        // If the line is dashed, scale the dash lengths by the line
        // width at the previous round zoom level.
        if (value && name === 'line-dasharray') {
            var flooredZoom = Math.floor(globalProperties.zoom);
            if (this._flooredZoom !== flooredZoom) {
                this._flooredZoom = flooredZoom;
                this._flooredLineWidth = this.getPaintValue('line-width', globalProperties, featureProperties);
            }

            value.fromScale *= this._flooredLineWidth;
            value.toScale *= this._flooredLineWidth;
        }

        return value;
    }
});

},{"../../util/util":117,"../style_layer":61}],66:[function(require,module,exports){
'use strict';

var util = require('../../util/util');
var StyleLayer = require('../style_layer');

function RasterStyleLayer() {
    StyleLayer.apply(this, arguments);
}

module.exports = RasterStyleLayer;

RasterStyleLayer.prototype = util.inherit(StyleLayer, {});

},{"../../util/util":117,"../style_layer":61}],67:[function(require,module,exports){
'use strict';

var util = require('../../util/util');
var StyleLayer = require('../style_layer');

function SymbolStyleLayer() {
    StyleLayer.apply(this, arguments);
}

module.exports = SymbolStyleLayer;

SymbolStyleLayer.prototype = util.inherit(StyleLayer, {

    isHidden: function() {
        if (StyleLayer.prototype.isHidden.apply(this, arguments)) return true;

        var isTextHidden = this.paint['text-opacity'] === 0 || !this.layout['text-field'];
        var isIconHidden = this.paint['icon-opacity'] === 0 || !this.layout['icon-image'];
        if (isTextHidden && isIconHidden) return true;

        return false;
    },

    getLayoutValue: function(name, globalProperties, featureProperties) {
        if (name === 'text-rotation-alignment' &&
                this.getLayoutValue('symbol-placement', globalProperties, featureProperties) === 'line' &&
                !this.getLayoutProperty('text-rotation-alignment')) {
            return 'map';
        } else if (name === 'icon-rotation-alignment' &&
                this.getLayoutValue('symbol-placement', globalProperties, featureProperties) === 'line' &&
                !this.getLayoutProperty('icon-rotation-alignment')) {
            return 'map';
        } else {
            return StyleLayer.prototype.getLayoutValue.apply(this, arguments);
        }
    }

});

},{"../../util/util":117,"../style_layer":61}],68:[function(require,module,exports){
'use strict';

module.exports = require('mapbox-gl-style-spec/reference/latest');

},{"mapbox-gl-style-spec/reference/latest":165}],69:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var interpolate = require('../util/interpolate');

module.exports = StyleTransition;

/*
 * Represents a transition between two declarations
 */
function StyleTransition(declaration, oldTransition, value) {

    this.declaration = declaration;
    this.startTime = this.endTime = (new Date()).getTime();

    var type = declaration.type;
    if ((type === 'string' || type === 'array') && declaration.transitionable) {
        this.interp = interpZoomTransitioned;
    } else {
        this.interp = interpolate[type];
    }

    this.oldTransition = oldTransition;
    this.duration = value.duration || 0;
    this.delay = value.delay || 0;

    if (!this.instant()) {
        this.endTime = this.startTime + this.duration + this.delay;
        this.ease = util.easeCubicInOut;
    }

    if (oldTransition && oldTransition.endTime <= this.startTime) {
        // Old transition is done running, so we can
        // delete its reference to its old transition.

        delete oldTransition.oldTransition;
    }
}

StyleTransition.prototype.instant = function() {
    return !this.oldTransition || !this.interp || (this.duration === 0 && this.delay === 0);
};

/*
 * Return the value of the transitioning property at zoom level `z` and optional time `t`
 */
StyleTransition.prototype.calculate = function(globalProperties, featureProperties) {
    var value = this.declaration.calculate(
        util.extend({}, globalProperties, {duration: this.duration}),
        featureProperties
    );

    if (this.instant()) return value;

    var t = globalProperties.time || Date.now();

    if (t < this.endTime) {
        var oldValue = this.oldTransition.calculate(
            util.extend({}, globalProperties, {time: this.startTime}),
            featureProperties
        );
        var eased = this.ease((t - this.startTime - this.delay) / this.duration);
        value = this.interp(oldValue, value, eased);
    }

    return value;

};

function interpZoomTransitioned(from, to, t) {
    return {
        from: from.to,
        fromScale: from.toScale,
        to: to.to,
        toScale: to.toScale,
        t: t
    };
}

},{"../util/interpolate":111,"../util/util":117}],70:[function(require,module,exports){
'use strict';

module.exports = require('mapbox-gl-style-spec/lib/validate_style.min');

module.exports.emitErrors = function throwErrors(emitter, errors) {
    if (errors && errors.length) {
        for (var i = 0; i < errors.length; i++) {
            emitter.fire('error', { error: new Error(errors[i].message) });
        }
        return true;
    } else {
        return false;
    }
};

module.exports.throwErrors = function throwErrors(emitter, errors) {
    if (errors) {
        for (var i = 0; i < errors.length; i++) {
            throw new Error(errors[i].message);
        }
    }
};

},{"mapbox-gl-style-spec/lib/validate_style.min":164}],71:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = Anchor;

function Anchor(x, y, angle, segment) {
    this.x = x;
    this.y = y;
    this.angle = angle;

    if (segment !== undefined) {
        this.segment = segment;
    }
}

Anchor.prototype = Object.create(Point.prototype);

Anchor.prototype.clone = function() {
    return new Anchor(this.x, this.y, this.angle, this.segment);
};

},{"point-geometry":172}],72:[function(require,module,exports){
'use strict';

module.exports = checkMaxAngle;

/**
 * Labels placed around really sharp angles aren't readable. Check if any
 * part of the potential label has a combined angle that is too big.
 *
 * @param {Array<Point>} line
 * @param {Anchor} anchor The point on the line around which the label is anchored.
 * @param {number} labelLength The length of the label in geometry units.
 * @param {number} windowSize The check fails if the combined angles within a part of the line that is `windowSize` long is too big.
 * @param {number} maxAngle The maximum combined angle that any window along the label is allowed to have.
 *
 * @returns {boolean} whether the label should be placed
 * @private
 */
function checkMaxAngle(line, anchor, labelLength, windowSize, maxAngle) {

    // horizontal labels always pass
    if (anchor.segment === undefined) return true;

    var p = anchor;
    var index = anchor.segment + 1;
    var anchorDistance = 0;

    // move backwards along the line to the first segment the label appears on
    while (anchorDistance > -labelLength / 2) {
        index--;

        // there isn't enough room for the label after the beginning of the line
        if (index < 0) return false;

        anchorDistance -= line[index].dist(p);
        p = line[index];
    }

    anchorDistance += line[index].dist(line[index + 1]);
    index++;

    // store recent corners and their total angle difference
    var recentCorners = [];
    var recentAngleDelta = 0;

    // move forwards by the length of the label and check angles along the way
    while (anchorDistance < labelLength / 2) {
        var prev = line[index - 1];
        var current = line[index];
        var next = line[index + 1];

        // there isn't enough room for the label before the end of the line
        if (!next) return false;

        var angleDelta = prev.angleTo(current) - current.angleTo(next);
        // restrict angle to -pi..pi range
        angleDelta = Math.abs(((angleDelta + 3 * Math.PI) % (Math.PI * 2)) - Math.PI);

        recentCorners.push({
            distance: anchorDistance,
            angleDelta: angleDelta
        });
        recentAngleDelta += angleDelta;

        // remove corners that are far enough away from the list of recent anchors
        while (anchorDistance - recentCorners[0].distance > windowSize) {
            recentAngleDelta -= recentCorners.shift().angleDelta;
        }

        // the sum of angles within the window area exceeds the maximum allowed value. check fails.
        if (recentAngleDelta > maxAngle) return false;

        index++;
        anchorDistance += current.dist(next);
    }

    // no part of the line had an angle greater than the maximum allowed. check passes.
    return true;
}

},{}],73:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = clipLine;

/**
 * Returns the part of a multiline that intersects with the provided rectangular box.
 *
 * @param {Array<Array<Point>>} lines
 * @param {number} x1 the left edge of the box
 * @param {number} y1 the top edge of the box
 * @param {number} x2 the right edge of the box
 * @param {number} y2 the bottom edge of the box
 * @returns {Array<Array<Point>>} lines
 * @private
 */
function clipLine(lines, x1, y1, x2, y2) {
    var clippedLines = [];

    for (var l = 0; l < lines.length; l++) {
        var line = lines[l];
        var clippedLine;

        for (var i = 0; i < line.length - 1; i++) {
            var p0 = line[i];
            var p1 = line[i + 1];


            if (p0.x < x1 && p1.x < x1) {
                continue;
            } else if (p0.x < x1) {
                p0 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();
            } else if (p1.x < x1) {
                p1 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();
            }

            if (p0.y < y1 && p1.y < y1) {
                continue;
            } else if (p0.y < y1) {
                p0 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();
            } else if (p1.y < y1) {
                p1 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();
            }

            if (p0.x >= x2 && p1.x >= x2) {
                continue;
            } else if (p0.x >= x2) {
                p0 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();
            } else if (p1.x >= x2) {
                p1 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();
            }

            if (p0.y >= y2 && p1.y >= y2) {
                continue;
            } else if (p0.y >= y2) {
                p0 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();
            } else if (p1.y >= y2) {
                p1 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();
            }

            if (!clippedLine || !p0.equals(clippedLine[clippedLine.length - 1])) {
                clippedLine = [p0];
                clippedLines.push(clippedLine);
            }

            clippedLine.push(p1);
        }
    }

    return clippedLines;
}

},{"point-geometry":172}],74:[function(require,module,exports){
'use strict';

var StructArrayType = require('../util/struct_array');
var util = require('../util/util');
var Point = require('point-geometry');

/**
 * A collision box represents an area of the map that that is covered by a
 * label. CollisionFeature uses one or more of these collision boxes to
 * represent all the area covered by a single label. They are used to
 * prevent collisions between labels.
 *
 * A collision box actually represents a 3d volume. The first two dimensions,
 * x and y, are specified with `anchor` along with `x1`, `y1`, `x2`, `y2`.
 * The third dimension, zoom, is limited by `maxScale` which determines
 * how far in the z dimensions the box extends.
 *
 * As you zoom in on a map, all points on the map get further and further apart
 * but labels stay roughly the same size. Labels cover less real world area on
 * the map at higher zoom levels than they do at lower zoom levels. This is why
 * areas are are represented with an anchor point and offsets from that point
 * instead of just using four absolute points.
 *
 * Line labels are represented by a set of these boxes spaced out along a line.
 * When you zoom in, line labels cover less real world distance along the line
 * than they used to. Collision boxes near the edges that used to cover label
 * no longer do. If a box doesn't cover the label anymore it should be ignored
 * when doing collision checks. `maxScale` is how much you can scale the map
 * before the label isn't within the box anymore.
 * For example
 * lower zoom:
 * https://cloud.githubusercontent.com/assets/1421652/8060094/4d975f76-0e91-11e5-84b1-4edeb30a5875.png
 * slightly higher zoom:
 * https://cloud.githubusercontent.com/assets/1421652/8060061/26ae1c38-0e91-11e5-8c5a-9f380bf29f0a.png
 * In the zoomed in image the two grey boxes on either side don't cover the
 * label anymore. Their maxScale is smaller than the current scale.
 *
 *
 * @class CollisionBoxArray
 * @private
 */

var CollisionBoxArray = module.exports = new StructArrayType({
    members: [
        // the box is centered around the anchor point
        { type: 'Int16', name: 'anchorPointX' },
        { type: 'Int16', name: 'anchorPointY' },

        // distances to the edges from the anchor
        { type: 'Int16', name: 'x1' },
        { type: 'Int16', name: 'y1' },
        { type: 'Int16', name: 'x2' },
        { type: 'Int16', name: 'y2' },

        // the box is only valid for scales < maxScale.
        // The box does not block other boxes at scales >= maxScale;
        { type: 'Float32', name: 'maxScale' },

        // the index of the feature in the original vectortile
        { type: 'Uint32', name: 'featureIndex' },
        // the source layer the feature appears in
        { type: 'Uint16', name: 'sourceLayerIndex' },
        // the bucket the feature appears in
        { type: 'Uint16', name: 'bucketIndex' },

        // rotated and scaled bbox used for indexing
        { type: 'Int16', name: 'bbox0' },
        { type: 'Int16', name: 'bbox1' },
        { type: 'Int16', name: 'bbox2' },
        { type: 'Int16', name: 'bbox3' },

        { type: 'Float32', name: 'placementScale' }
    ]});

util.extendAll(CollisionBoxArray.prototype.StructType.prototype, {
    get anchorPoint() {
        return new Point(this.anchorPointX, this.anchorPointY);
    }
});

},{"../util/struct_array":115,"../util/util":117,"point-geometry":172}],75:[function(require,module,exports){
'use strict';

module.exports = CollisionFeature;

/**
 * A CollisionFeature represents the area of the tile covered by a single label.
 * It is used with CollisionTile to check if the label overlaps with any
 * previous labels. A CollisionFeature is mostly just a set of CollisionBox
 * objects.
 *
 * @class CollisionFeature
 * @param {Array<Point>} line The geometry the label is placed on.
 * @param {Anchor} anchor The point along the line around which the label is anchored.
 * @param {VectorTileFeature} feature The VectorTileFeature that this CollisionFeature was created for.
 * @param {Array<string>} layerIDs The IDs of the layers that this CollisionFeature is a part of.
 * @param {Object} shaped The text or icon shaping results.
 * @param {number} boxScale A magic number used to convert from glyph metrics units to geometry units.
 * @param {number} padding The amount of padding to add around the label edges.
 * @param {boolean} alignLine Whether the label is aligned with the line or the viewport.
 *
 * @private
 */
function CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, shaped, boxScale, padding, alignLine, straight) {

    var y1 = shaped.top * boxScale - padding;
    var y2 = shaped.bottom * boxScale + padding;
    var x1 = shaped.left * boxScale - padding;
    var x2 = shaped.right * boxScale + padding;

    this.boxStartIndex = collisionBoxArray.length;

    if (alignLine) {

        var height = y2 - y1;
        var length = x2 - x1;

        if (height > 0) {
            // set minimum box height to avoid very many small labels
            height = Math.max(10 * boxScale, height);

            if (straight) {
                // used for icon labels that are aligned with the line, but don't curve along it
                var vector = line[anchor.segment + 1].sub(line[anchor.segment])._unit()._mult(length);
                var straightLine = [anchor.sub(vector), anchor.add(vector)];
                this._addLineCollisionBoxes(collisionBoxArray, straightLine, anchor, 0, length, height, featureIndex, sourceLayerIndex, bucketIndex);
            } else {
                // used for text labels that curve along a line
                this._addLineCollisionBoxes(collisionBoxArray, line, anchor, anchor.segment, length, height, featureIndex, sourceLayerIndex, bucketIndex);
            }
        }

    } else {
        collisionBoxArray.emplaceBack(anchor.x, anchor.y, x1, y1, x2, y2, Infinity, featureIndex, sourceLayerIndex, bucketIndex,
                0, 0, 0, 0, 0);
    }

    this.boxEndIndex = collisionBoxArray.length;
}

/**
 * Create a set of CollisionBox objects for a line.
 *
 * @param {Array<Point>} line
 * @param {Anchor} anchor
 * @param {number} labelLength The length of the label in geometry units.
 * @param {Anchor} anchor The point along the line around which the label is anchored.
 * @param {VectorTileFeature} feature The VectorTileFeature that this CollisionFeature was created for.
 * @param {number} boxSize The size of the collision boxes that will be created.
 *
 * @private
 */
CollisionFeature.prototype._addLineCollisionBoxes = function(collisionBoxArray, line, anchor, segment, labelLength, boxSize, featureIndex, sourceLayerIndex, bucketIndex) {
    var step = boxSize / 2;
    var nBoxes = Math.floor(labelLength / step);

    // offset the center of the first box by half a box so that the edge of the
    // box is at the edge of the label.
    var firstBoxOffset = -boxSize / 2;

    var bboxes = this.boxes;

    var p = anchor;
    var index = segment + 1;
    var anchorDistance = firstBoxOffset;

    // move backwards along the line to the first segment the label appears on
    do {
        index--;

        // there isn't enough room for the label after the beginning of the line
        // checkMaxAngle should have already caught this
        if (index < 0) return bboxes;

        anchorDistance -= line[index].dist(p);
        p = line[index];
    } while (anchorDistance > -labelLength / 2);

    var segmentLength = line[index].dist(line[index + 1]);

    for (var i = 0; i < nBoxes; i++) {
        // the distance the box will be from the anchor
        var boxDistanceToAnchor = -labelLength / 2 + i * step;

        // the box is not on the current segment. Move to the next segment.
        while (anchorDistance + segmentLength < boxDistanceToAnchor) {
            anchorDistance += segmentLength;
            index++;

            // There isn't enough room before the end of the line.
            if (index + 1 >= line.length) return bboxes;

            segmentLength = line[index].dist(line[index + 1]);
        }

        // the distance the box will be from the beginning of the segment
        var segmentBoxDistance = boxDistanceToAnchor - anchorDistance;

        var p0 = line[index];
        var p1 = line[index + 1];
        var boxAnchorPoint = p1.sub(p0)._unit()._mult(segmentBoxDistance)._add(p0)._round();

        var distanceToInnerEdge = Math.max(Math.abs(boxDistanceToAnchor - firstBoxOffset) - step / 2, 0);
        var maxScale = labelLength / 2 / distanceToInnerEdge;

        collisionBoxArray.emplaceBack(boxAnchorPoint.x, boxAnchorPoint.y,
                -boxSize / 2, -boxSize / 2, boxSize / 2, boxSize / 2, maxScale,
                featureIndex, sourceLayerIndex, bucketIndex,
                0, 0, 0, 0, 0);
    }

    return bboxes;
};

},{}],76:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');
var EXTENT = require('../data/bucket').EXTENT;
var Grid = require('grid-index');

module.exports = CollisionTile;

/**
 * A collision tile used to prevent symbols from overlapping. It keep tracks of
 * where previous symbols have been placed and is used to check if a new
 * symbol overlaps with any previously added symbols.
 *
 * @class CollisionTile
 * @param {number} angle
 * @param {number} pitch
 * @private
 */
function CollisionTile(angle, pitch, collisionBoxArray) {
    if (typeof angle === 'object') {
        var serialized = angle;
        collisionBoxArray = pitch;
        angle = serialized.angle;
        pitch = serialized.pitch;
        this.grid = new Grid(serialized.grid);
        this.ignoredGrid = new Grid(serialized.ignoredGrid);
    } else {
        this.grid = new Grid(EXTENT, 12, 6);
        this.ignoredGrid = new Grid(EXTENT, 12, 0);
    }

    this.angle = angle;
    this.pitch = pitch;

    var sin = Math.sin(angle),
        cos = Math.cos(angle);
    this.rotationMatrix = [cos, -sin, sin, cos];
    this.reverseRotationMatrix = [cos, sin, -sin, cos];

    // Stretch boxes in y direction to account for the map tilt.
    this.yStretch = 1 / Math.cos(pitch / 180 * Math.PI);

    // The amount the map is squished depends on the y position.
    // Sort of account for this by making all boxes a bit bigger.
    this.yStretch = Math.pow(this.yStretch, 1.3);

    this.collisionBoxArray = collisionBoxArray;
    if (collisionBoxArray.length === 0) {
        // the first collisionBoxArray is passed to a CollisionTile

        // tempCollisionBox
        collisionBoxArray.emplaceBack();

        var maxInt16 = 32767;
        //left
        collisionBoxArray.emplaceBack(0, 0, 0, -maxInt16, 0, maxInt16, maxInt16,
                0, 0, 0, 0, 0, 0, 0, 0,
                0);
        // right
        collisionBoxArray.emplaceBack(EXTENT, 0, 0, -maxInt16, 0, maxInt16, maxInt16,
                0, 0, 0, 0, 0, 0, 0, 0,
                0);
        // top
        collisionBoxArray.emplaceBack(0, 0, -maxInt16, 0, maxInt16, 0, maxInt16,
                0, 0, 0, 0, 0, 0, 0, 0,
                0);
        // bottom
        collisionBoxArray.emplaceBack(0, EXTENT, -maxInt16, 0, maxInt16, 0, maxInt16,
                0, 0, 0, 0, 0, 0, 0, 0,
                0);
    }

    this.tempCollisionBox = collisionBoxArray.get(0);
    this.edges = [
        collisionBoxArray.get(1),
        collisionBoxArray.get(2),
        collisionBoxArray.get(3),
        collisionBoxArray.get(4)
    ];
}

CollisionTile.prototype.serialize = function() {
    var data = {
        angle: this.angle,
        pitch: this.pitch,
        grid: this.grid.toArrayBuffer(),
        ignoredGrid: this.ignoredGrid.toArrayBuffer()
    };
    return {
        data: data,
        transferables: [data.grid, data.ignoredGrid]
    };
};

CollisionTile.prototype.minScale = 0.25;
CollisionTile.prototype.maxScale = 2;


/**
 * Find the scale at which the collisionFeature can be shown without
 * overlapping with other features.
 *
 * @param {CollisionFeature} collisionFeature
 * @returns {number} placementScale
 * @private
 */
CollisionTile.prototype.placeCollisionFeature = function(collisionFeature, allowOverlap, avoidEdges) {

    var collisionBoxArray = this.collisionBoxArray;
    var minPlacementScale = this.minScale;
    var rotationMatrix = this.rotationMatrix;
    var yStretch = this.yStretch;

    for (var b = collisionFeature.boxStartIndex; b < collisionFeature.boxEndIndex; b++) {

        var box = collisionBoxArray.get(b);

        var anchorPoint = box.anchorPoint._matMult(rotationMatrix);
        var x = anchorPoint.x;
        var y = anchorPoint.y;

        var x1 = x + box.x1;
        var y1 = y + box.y1 * yStretch;
        var x2 = x + box.x2;
        var y2 = y + box.y2 * yStretch;

        box.bbox0 = x1;
        box.bbox1 = y1;
        box.bbox2 = x2;
        box.bbox3 = y2;

        if (!allowOverlap) {
            var blockingBoxes = this.grid.query(x1, y1, x2, y2);

            for (var i = 0; i < blockingBoxes.length; i++) {
                var blocking = collisionBoxArray.get(blockingBoxes[i]);
                var blockingAnchorPoint = blocking.anchorPoint._matMult(rotationMatrix);

                minPlacementScale = this.getPlacementScale(minPlacementScale, anchorPoint, box, blockingAnchorPoint, blocking);
                if (minPlacementScale >= this.maxScale) {
                    return minPlacementScale;
                }
            }
        }

        if (avoidEdges) {
            var rotatedCollisionBox;

            if (this.angle) {
                var reverseRotationMatrix = this.reverseRotationMatrix;
                var tl = new Point(box.x1, box.y1).matMult(reverseRotationMatrix);
                var tr = new Point(box.x2, box.y1).matMult(reverseRotationMatrix);
                var bl = new Point(box.x1, box.y2).matMult(reverseRotationMatrix);
                var br = new Point(box.x2, box.y2).matMult(reverseRotationMatrix);

                rotatedCollisionBox = this.tempCollisionBox;
                rotatedCollisionBox.anchorPointX = box.anchorPoint.x;
                rotatedCollisionBox.anchorPointY = box.anchorPoint.y;
                rotatedCollisionBox.x1 = Math.min(tl.x, tr.x, bl.x, br.x);
                rotatedCollisionBox.y1 = Math.min(tl.y, tr.x, bl.x, br.x);
                rotatedCollisionBox.x2 = Math.max(tl.x, tr.x, bl.x, br.x);
                rotatedCollisionBox.y2 = Math.max(tl.y, tr.x, bl.x, br.x);
                rotatedCollisionBox.maxScale = box.maxScale;
            } else {
                rotatedCollisionBox = box;
            }

            for (var k = 0; k < this.edges.length; k++) {
                var edgeBox = this.edges[k];
                minPlacementScale = this.getPlacementScale(minPlacementScale, box.anchorPoint, rotatedCollisionBox, edgeBox.anchorPoint, edgeBox);
                if (minPlacementScale >= this.maxScale) {
                    return minPlacementScale;
                }
            }
        }
    }

    return minPlacementScale;
};

CollisionTile.prototype.queryRenderedSymbols = function(minX, minY, maxX, maxY, scale) {
    var sourceLayerFeatures = {};
    var result = [];

    var collisionBoxArray = this.collisionBoxArray;
    var rotationMatrix = this.rotationMatrix;
    var anchorPoint = new Point(minX, minY)._matMult(rotationMatrix);

    var queryBox = this.tempCollisionBox;
    queryBox.anchorX = anchorPoint.x;
    queryBox.anchorY = anchorPoint.y;
    queryBox.x1 = 0;
    queryBox.y1 = 0;
    queryBox.x2 = maxX - minX;
    queryBox.y2 = maxY - minY;
    queryBox.maxScale = scale;

    // maxScale is stored using a Float32. Convert `scale` to the stored Float32 value.
    scale = queryBox.maxScale;

    var searchBox = [
        anchorPoint.x + queryBox.x1 / scale,
        anchorPoint.y + queryBox.y1 / scale * this.yStretch,
        anchorPoint.x + queryBox.x2 / scale,
        anchorPoint.y + queryBox.y2 / scale * this.yStretch
    ];

    var blockingBoxKeys = this.grid.query(searchBox[0], searchBox[1], searchBox[2], searchBox[3]);
    var blockingBoxKeys2 = this.ignoredGrid.query(searchBox[0], searchBox[1], searchBox[2], searchBox[3]);
    for (var k = 0; k < blockingBoxKeys2.length; k++) {
        blockingBoxKeys.push(blockingBoxKeys2[k]);
    }

    for (var i = 0; i < blockingBoxKeys.length; i++) {
        var blocking = collisionBoxArray.get(blockingBoxKeys[i]);

        var sourceLayer = blocking.sourceLayerIndex;
        var featureIndex = blocking.featureIndex;
        if (sourceLayerFeatures[sourceLayer] === undefined) {
            sourceLayerFeatures[sourceLayer] = {};
        }

        if (!sourceLayerFeatures[sourceLayer][featureIndex]) {
            var blockingAnchorPoint = blocking.anchorPoint.matMult(rotationMatrix);
            var minPlacementScale = this.getPlacementScale(this.minScale, anchorPoint, queryBox, blockingAnchorPoint, blocking);
            if (minPlacementScale >= scale) {
                sourceLayerFeatures[sourceLayer][featureIndex] = true;
                result.push(blockingBoxKeys[i]);
            }
        }
    }

    return result;
};

CollisionTile.prototype.getPlacementScale = function(minPlacementScale, anchorPoint, box, blockingAnchorPoint, blocking) {

    // Find the lowest scale at which the two boxes can fit side by side without overlapping.
    // Original algorithm:
    var anchorDiffX = anchorPoint.x - blockingAnchorPoint.x;
    var anchorDiffY = anchorPoint.y - blockingAnchorPoint.y;
    var s1 = (blocking.x1 - box.x2) / anchorDiffX; // scale at which new box is to the left of old box
    var s2 = (blocking.x2 - box.x1) / anchorDiffX; // scale at which new box is to the right of old box
    var s3 = (blocking.y1 - box.y2) * this.yStretch / anchorDiffY; // scale at which new box is to the top of old box
    var s4 = (blocking.y2 - box.y1) * this.yStretch / anchorDiffY; // scale at which new box is to the bottom of old box

    if (isNaN(s1) || isNaN(s2)) s1 = s2 = 1;
    if (isNaN(s3) || isNaN(s4)) s3 = s4 = 1;

    var collisionFreeScale = Math.min(Math.max(s1, s2), Math.max(s3, s4));
    var blockingMaxScale = blocking.maxScale;
    var boxMaxScale = box.maxScale;

    if (collisionFreeScale > blockingMaxScale) {
        // After a box's maxScale the label has shrunk enough that the box is no longer needed to cover it,
        // so unblock the new box at the scale that the old box disappears.
        collisionFreeScale = blockingMaxScale;
    }

    if (collisionFreeScale > boxMaxScale) {
        // If the box can only be shown after it is visible, then the box can never be shown.
        // But the label can be shown after this box is not visible.
        collisionFreeScale = boxMaxScale;
    }

    if (collisionFreeScale > minPlacementScale &&
            collisionFreeScale >= blocking.placementScale) {
        // If this collision occurs at a lower scale than previously found collisions
        // and the collision occurs while the other label is visible

        // this this is the lowest scale at which the label won't collide with anything
        minPlacementScale = collisionFreeScale;
    }

    return minPlacementScale;
};


/**
 * Remember this collisionFeature and what scale it was placed at to block
 * later features from overlapping with it.
 *
 * @param {CollisionFeature} collisionFeature
 * @param {number} minPlacementScale
 * @private
 */
CollisionTile.prototype.insertCollisionFeature = function(collisionFeature, minPlacementScale, ignorePlacement) {

    var grid = ignorePlacement ? this.ignoredGrid : this.grid;
    var collisionBoxArray = this.collisionBoxArray;

    for (var k = collisionFeature.boxStartIndex; k < collisionFeature.boxEndIndex; k++) {
        var box = collisionBoxArray.get(k);
        box.placementScale = minPlacementScale;
        if (minPlacementScale < this.maxScale) {
            grid.insert(k, box.bbox0, box.bbox1, box.bbox2, box.bbox3);
        }
    }
};

},{"../data/bucket":15,"grid-index":141,"point-geometry":172}],77:[function(require,module,exports){
'use strict';

var interpolate = require('../util/interpolate');
var Anchor = require('../symbol/anchor');
var checkMaxAngle = require('./check_max_angle');

module.exports = getAnchors;

function getAnchors(line, spacing, maxAngle, shapedText, shapedIcon, glyphSize, boxScale, overscaling, tileExtent) {

    // Resample a line to get anchor points for labels and check that each
    // potential label passes text-max-angle check and has enough froom to fit
    // on the line.

    var angleWindowSize = shapedText ?
        3 / 5 * glyphSize * boxScale :
        0;

    var labelLength = Math.max(
        shapedText ? shapedText.right - shapedText.left : 0,
        shapedIcon ? shapedIcon.right - shapedIcon.left : 0);

    // Is the line continued from outside the tile boundary?
    var isLineContinued = line[0].x === 0 || line[0].x === tileExtent || line[0].y === 0 || line[0].y === tileExtent;

    // Is the label long, relative to the spacing?
    // If so, adjust the spacing so there is always a minimum space of `spacing / 4` between label edges.
    if (spacing - labelLength * boxScale  < spacing / 4) {
        spacing = labelLength * boxScale + spacing / 4;
    }

    // Offset the first anchor by:
    // Either half the label length plus a fixed extra offset if the line is not continued
    // Or half the spacing if the line is continued.

    // For non-continued lines, add a bit of fixed extra offset to avoid collisions at T intersections.
    var fixedExtraOffset = glyphSize * 2;

    var offset = !isLineContinued ?
        ((labelLength / 2 + fixedExtraOffset) * boxScale * overscaling) % spacing :
        (spacing / 2 * overscaling) % spacing;

    return resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength * boxScale, isLineContinued, false, tileExtent);
}


function resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, placeAtMiddle, tileExtent) {

    var halfLabelLength = labelLength / 2;
    var lineLength = 0;
    for (var k = 0; k < line.length - 1; k++) {
        lineLength += line[k].dist(line[k + 1]);
    }

    var distance = 0,
        markedDistance = offset - spacing;

    var anchors = [];

    for (var i = 0; i < line.length - 1; i++) {

        var a = line[i],
            b = line[i + 1];

        var segmentDist = a.dist(b),
            angle = b.angleTo(a);

        while (markedDistance + spacing < distance + segmentDist) {
            markedDistance += spacing;

            var t = (markedDistance - distance) / segmentDist,
                x = interpolate(a.x, b.x, t),
                y = interpolate(a.y, b.y, t);

            // Check that the point is within the tile boundaries and that
            // the label would fit before the beginning and end of the line
            // if placed at this point.
            if (x >= 0 && x < tileExtent && y >= 0 && y < tileExtent &&
                    markedDistance - halfLabelLength >= 0 &&
                    markedDistance + halfLabelLength <= lineLength) {
                var anchor = new Anchor(x, y, angle, i)._round();

                if (!angleWindowSize || checkMaxAngle(line, anchor, labelLength, angleWindowSize, maxAngle)) {
                    anchors.push(anchor);
                }
            }
        }

        distance += segmentDist;
    }

    if (!placeAtMiddle && !anchors.length && !isLineContinued) {
        // The first attempt at finding anchors at which labels can be placed failed.
        // Try again, but this time just try placing one anchor at the middle of the line.
        // This has the most effect for short lines in overscaled tiles, since the
        // initial offset used in overscaled tiles is calculated to align labels with positions in
        // parent tiles instead of placing the label as close to the beginning as possible.
        anchors = resample(line, distance / 2, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, true, tileExtent);
    }

    return anchors;
}

},{"../symbol/anchor":71,"../util/interpolate":111,"./check_max_angle":72}],78:[function(require,module,exports){
'use strict';

var ShelfPack = require('shelf-pack');

module.exports = GlyphAtlas;
function GlyphAtlas(width, height) {
    this.width = width;
    this.height = height;

    this.bin = new ShelfPack(width, height);
    this.index = {};
    this.ids = {};
    this.data = new Uint8Array(width * height);
}

GlyphAtlas.prototype.getGlyphs = function() {
    var glyphs = {},
        split,
        name,
        id;

    for (var key in this.ids) {
        split = key.split('#');
        name = split[0];
        id = split[1];

        if (!glyphs[name]) glyphs[name] = [];
        glyphs[name].push(id);
    }

    return glyphs;
};

GlyphAtlas.prototype.getRects = function() {
    var rects = {},
        split,
        name,
        id;

    for (var key in this.ids) {
        split = key.split('#');
        name = split[0];
        id = split[1];

        if (!rects[name]) rects[name] = {};
        rects[name][id] = this.index[key];
    }

    return rects;
};


GlyphAtlas.prototype.addGlyph = function(id, name, glyph, buffer) {
    if (!glyph) {
        // console.warn('missing glyph', code, String.fromCharCode(code));
        return null;
    }
    var key = name + "#" + glyph.id;

    // The glyph is already in this texture.
    if (this.index[key]) {
        if (this.ids[key].indexOf(id) < 0) {
            this.ids[key].push(id);
        }
        return this.index[key];
    }

    // The glyph bitmap has zero width.
    if (!glyph.bitmap) {
        return null;
    }

    var bufferedWidth = glyph.width + buffer * 2;
    var bufferedHeight = glyph.height + buffer * 2;

    // Add a 1px border around every image.
    var padding = 1;
    var packWidth = bufferedWidth + 2 * padding;
    var packHeight = bufferedHeight + 2 * padding;

    // Increase to next number divisible by 4, but at least 1.
    // This is so we can scale down the texture coordinates and pack them
    // into 2 bytes rather than 4 bytes.
    packWidth += (4 - packWidth % 4);
    packHeight += (4 - packHeight % 4);

    var rect = this.bin.packOne(packWidth, packHeight);
    if (!rect) {
        this.resize();
        rect = this.bin.packOne(packWidth, packHeight);
    }
    if (!rect) {
        console.warn('glyph bitmap overflow');
        return null;
    }

    this.index[key] = rect;
    this.ids[key] = [id];

    var target = this.data;
    var source = glyph.bitmap;
    for (var y = 0; y < bufferedHeight; y++) {
        var y1 = this.width * (rect.y + y + padding) + rect.x + padding;
        var y2 = bufferedWidth * y;
        for (var x = 0; x < bufferedWidth; x++) {
            target[y1 + x] = source[y2 + x];
        }
    }

    this.dirty = true;

    return rect;
};

GlyphAtlas.prototype.resize = function() {
    var origw = this.width,
        origh = this.height;

    // For now, don't grow the atlas beyond 1024x1024 because of how
    // texture coords pack into unsigned byte in symbol bucket.
    if (origw > 512 || origh > 512) return;

    if (this.texture) {
        if (this.gl) {
            this.gl.deleteTexture(this.texture);
        }
        this.texture = null;
    }

    this.width *= 2;
    this.height *= 2;
    this.bin.resize(this.width, this.height);

    var buf = new ArrayBuffer(this.width * this.height),
        src, dst;
    for (var i = 0; i < origh; i++) {
        src = new Uint8Array(this.data.buffer, origh * i, origw);
        dst = new Uint8Array(buf, origh * i * 2, origw);
        dst.set(src);
    }
    this.data = new Uint8Array(buf);
};

GlyphAtlas.prototype.bind = function(gl) {
    this.gl = gl;
    if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, this.width, this.height, 0, gl.ALPHA, gl.UNSIGNED_BYTE, null);

    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
    }
};

GlyphAtlas.prototype.updateTexture = function(gl) {
    this.bind(gl);
    if (this.dirty) {
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.ALPHA, gl.UNSIGNED_BYTE, this.data);
        this.dirty = false;
    }
};

},{"shelf-pack":174}],79:[function(require,module,exports){
'use strict';

var normalizeURL = require('../util/mapbox').normalizeGlyphsURL;
var getArrayBuffer = require('../util/ajax').getArrayBuffer;
var Glyphs = require('../util/glyphs');
var GlyphAtlas = require('../symbol/glyph_atlas');
var Protobuf = require('pbf');

module.exports = GlyphSource;

/**
 * A glyph source has a URL from which to load new glyphs and manages
 * GlyphAtlases in which to store glyphs used by the requested fontstacks
 * and ranges.
 *
 * @param {string} url glyph template url
 * @private
 */
function GlyphSource(url) {
    this.url = url && normalizeURL(url);
    this.atlases = {};
    this.stacks = {};
    this.loading = {};
}

GlyphSource.prototype.getSimpleGlyphs = function(fontstack, glyphIDs, uid, callback) {
    if (this.stacks[fontstack] === undefined) {
        this.stacks[fontstack] = {};
    }
    if (this.atlases[fontstack] === undefined) {
        this.atlases[fontstack] = new GlyphAtlas(128, 128);
    }

    var glyphs = {};
    var stack = this.stacks[fontstack];
    var atlas = this.atlases[fontstack];

    // the number of pixels the sdf bitmaps are padded by
    var buffer = 3;

    var missing = {};
    var remaining = 0;
    var range;

    for (var i = 0; i < glyphIDs.length; i++) {
        var glyphID = glyphIDs[i];
        range = Math.floor(glyphID / 256);

        if (stack[range]) {
            var glyph = stack[range].glyphs[glyphID];
            var rect  = atlas.addGlyph(uid, fontstack, glyph, buffer);
            if (glyph) glyphs[glyphID] = new SimpleGlyph(glyph, rect, buffer);
        } else {
            if (missing[range] === undefined) {
                missing[range] = [];
                remaining++;
            }
            missing[range].push(glyphID);
        }
    }

    if (!remaining) callback(undefined, glyphs, fontstack);

    var onRangeLoaded = function(err, range, data) {
        // TODO not be silent about errors
        if (!err) {
            var stack = this.stacks[fontstack][range] = data.stacks[0];
            for (var i = 0; i < missing[range].length; i++) {
                var glyphID = missing[range][i];
                var glyph = stack.glyphs[glyphID];
                var rect  = atlas.addGlyph(uid, fontstack, glyph, buffer);
                if (glyph) glyphs[glyphID] = new SimpleGlyph(glyph, rect, buffer);
            }
        }
        remaining--;
        if (!remaining) callback(undefined, glyphs, fontstack);
    }.bind(this);

    for (var r in missing) {
        this.loadRange(fontstack, r, onRangeLoaded);
    }
};

// A simplified representation of the glyph containing only the properties needed for shaping.
function SimpleGlyph(glyph, rect, buffer) {
    var padding = 1;
    this.advance = glyph.advance;
    this.left = glyph.left - buffer - padding;
    this.top = glyph.top + buffer + padding;
    this.rect = rect;
}

GlyphSource.prototype.loadRange = function(fontstack, range, callback) {
    if (range * 256 > 65535) return callback('glyphs > 65535 not supported');

    if (this.loading[fontstack] === undefined) {
        this.loading[fontstack] = {};
    }
    var loading = this.loading[fontstack];

    if (loading[range]) {
        loading[range].push(callback);
    } else {
        loading[range] = [callback];

        var rangeName = (range * 256) + '-' + (range * 256 + 255);
        var url = glyphUrl(fontstack, rangeName, this.url);

        getArrayBuffer(url, function(err, data) {
            var glyphs = !err && new Glyphs(new Protobuf(new Uint8Array(data)));
            for (var i = 0; i < loading[range].length; i++) {
                loading[range][i](err, range, glyphs);
            }
            delete loading[range];
        });
    }
};

GlyphSource.prototype.getGlyphAtlas = function(fontstack) {
    return this.atlases[fontstack];
};

/**
 * Use CNAME sharding to load a specific glyph range over a randomized
 * but consistent subdomain.
 * @param {string} fontstack comma-joined fonts
 * @param {string} range comma-joined range
 * @param {url} url templated url
 * @param {string} [subdomains=abc] subdomains as a string where each letter is one.
 * @returns {string} a url to load that section of glyphs
 * @private
 */
function glyphUrl(fontstack, range, url, subdomains) {
    subdomains = subdomains || 'abc';

    return url
        .replace('{s}', subdomains[fontstack.length % subdomains.length])
        .replace('{fontstack}', fontstack)
        .replace('{range}', range);
}

},{"../symbol/glyph_atlas":78,"../util/ajax":102,"../util/glyphs":110,"../util/mapbox":114,"pbf":170}],80:[function(require,module,exports){
'use strict';

module.exports = function (features, textFeatures, geometries) {

    var leftIndex = {},
        rightIndex = {},
        mergedFeatures = [],
        mergedGeom = [],
        mergedTexts = [],
        mergedIndex = 0,
        k;

    function add(k) {
        mergedFeatures.push(features[k]);
        mergedGeom.push(geometries[k]);
        mergedTexts.push(textFeatures[k]);
        mergedIndex++;
    }

    function mergeFromRight(leftKey, rightKey, geom) {
        var i = rightIndex[leftKey];
        delete rightIndex[leftKey];
        rightIndex[rightKey] = i;

        mergedGeom[i][0].pop();
        mergedGeom[i][0] = mergedGeom[i][0].concat(geom[0]);
        return i;
    }

    function mergeFromLeft(leftKey, rightKey, geom) {
        var i = leftIndex[rightKey];
        delete leftIndex[rightKey];
        leftIndex[leftKey] = i;

        mergedGeom[i][0].shift();
        mergedGeom[i][0] = geom[0].concat(mergedGeom[i][0]);
        return i;
    }

    function getKey(text, geom, onRight) {
        var point = onRight ? geom[0][geom[0].length - 1] : geom[0][0];
        return text + ':' + point.x + ':' + point.y;
    }

    for (k = 0; k < features.length; k++) {
        var geom = geometries[k],
            text = textFeatures[k];

        if (!text) {
            add(k);
            continue;
        }

        var leftKey = getKey(text, geom),
            rightKey = getKey(text, geom, true);

        if ((leftKey in rightIndex) && (rightKey in leftIndex) && (rightIndex[leftKey] !== leftIndex[rightKey])) {
            // found lines with the same text adjacent to both ends of the current line, merge all three
            var j = mergeFromLeft(leftKey, rightKey, geom);
            var i = mergeFromRight(leftKey, rightKey, mergedGeom[j]);

            delete leftIndex[leftKey];
            delete rightIndex[rightKey];

            rightIndex[getKey(text, mergedGeom[i], true)] = i;
            mergedGeom[j] = null;

        } else if (leftKey in rightIndex) {
            // found mergeable line adjacent to the start of the current line, merge
            mergeFromRight(leftKey, rightKey, geom);

        } else if (rightKey in leftIndex) {
            // found mergeable line adjacent to the end of the current line, merge
            mergeFromLeft(leftKey, rightKey, geom);

        } else {
            // no adjacent lines, add as a new item
            add(k);
            leftIndex[leftKey] = mergedIndex - 1;
            rightIndex[rightKey] = mergedIndex - 1;
        }
    }

    return {
        features: mergedFeatures,
        textFeatures: mergedTexts,
        geometries: mergedGeom
    };
};

},{}],81:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = {
    getIconQuads: getIconQuads,
    getGlyphQuads: getGlyphQuads
};

var minScale = 0.5; // underscale by 1 zoom level

/**
 * A textured quad for rendering a single icon or glyph.
 *
 * The zoom range the glyph can be shown is defined by minScale and maxScale.
 *
 * @param {Point} anchorPoint the point the symbol is anchored around
 * @param {Point} tl The offset of the top left corner from the anchor.
 * @param {Point} tr The offset of the top right corner from the anchor.
 * @param {Point} bl The offset of the bottom left corner from the anchor.
 * @param {Point} br The offset of the bottom right corner from the anchor.
 * @param {Object} tex The texture coordinates.
 * @param {number} angle The angle of the label at it's center, not the angle of this quad.
 * @param {number} minScale The minimum scale, relative to the tile's intended scale, that the glyph can be shown at.
 * @param {number} maxScale The maximum scale, relative to the tile's intended scale, that the glyph can be shown at.
 *
 * @class SymbolQuad
 * @private
 */
function SymbolQuad(anchorPoint, tl, tr, bl, br, tex, angle, minScale, maxScale) {
    this.anchorPoint = anchorPoint;
    this.tl = tl;
    this.tr = tr;
    this.bl = bl;
    this.br = br;
    this.tex = tex;
    this.angle = angle;
    this.minScale = minScale;
    this.maxScale = maxScale;
}

/**
 * Create the quads used for rendering an icon.
 *
 * @param {Anchor} anchor
 * @param {PositionedIcon} shapedIcon
 * @param {number} boxScale A magic number for converting glyph metric units to geometry units.
 * @param {Array<Array<Point>>} line
 * @param {LayoutProperties} layout
 * @param {boolean} alongLine Whether the icon should be placed along the line.
 * @returns {Array<SymbolQuad>}
 * @private
 */
function getIconQuads(anchor, shapedIcon, boxScale, line, layout, alongLine) {

    var rect = shapedIcon.image.rect;

    var border = 1;
    var left = shapedIcon.left - border;
    var right = left + rect.w / shapedIcon.image.pixelRatio;
    var top = shapedIcon.top - border;
    var bottom = top + rect.h / shapedIcon.image.pixelRatio;
    var tl = new Point(left, top);
    var tr = new Point(right, top);
    var br = new Point(right, bottom);
    var bl = new Point(left, bottom);

    var angle = layout['icon-rotate'] * Math.PI / 180;
    if (alongLine) {
        var prev = line[anchor.segment];
        if (anchor.y === prev.y && anchor.x === prev.x && anchor.segment + 1 < line.length) {
            var next = line[anchor.segment + 1];
            angle += Math.atan2(anchor.y - next.y, anchor.x - next.x) + Math.PI;
        } else {
            angle += Math.atan2(anchor.y - prev.y, anchor.x - prev.x);
        }
    }

    if (angle) {
        var sin = Math.sin(angle),
            cos = Math.cos(angle),
            matrix = [cos, -sin, sin, cos];

        tl = tl.matMult(matrix);
        tr = tr.matMult(matrix);
        bl = bl.matMult(matrix);
        br = br.matMult(matrix);
    }

    return [new SymbolQuad(new Point(anchor.x, anchor.y), tl, tr, bl, br, shapedIcon.image.rect, 0, minScale, Infinity)];
}

/**
 * Create the quads used for rendering a text label.
 *
 * @param {Anchor} anchor
 * @param {Shaping} shaping
 * @param {number} boxScale A magic number for converting from glyph metric units to geometry units.
 * @param {Array<Array<Point>>} line
 * @param {LayoutProperties} layout
 * @param {boolean} alongLine Whether the label should be placed along the line.
 * @returns {Array<SymbolQuad>}
 * @private
 */
function getGlyphQuads(anchor, shaping, boxScale, line, layout, alongLine) {

    var textRotate = layout['text-rotate'] * Math.PI / 180;
    var keepUpright = layout['text-keep-upright'];

    var positionedGlyphs = shaping.positionedGlyphs;
    var quads = [];

    for (var k = 0; k < positionedGlyphs.length; k++) {
        var positionedGlyph = positionedGlyphs[k];
        var glyph = positionedGlyph.glyph;
        var rect = glyph.rect;

        if (!rect) continue;

        var centerX = (positionedGlyph.x + glyph.advance / 2) * boxScale;

        var glyphInstances;
        var labelMinScale = minScale;
        if (alongLine) {
            glyphInstances = [];
            labelMinScale = getSegmentGlyphs(glyphInstances, anchor, centerX, line, anchor.segment, true);
            if (keepUpright) {
                labelMinScale = Math.min(labelMinScale, getSegmentGlyphs(glyphInstances, anchor, centerX, line, anchor.segment, false));
            }

        } else {
            glyphInstances = [{
                anchorPoint: new Point(anchor.x, anchor.y),
                offset: 0,
                angle: 0,
                maxScale: Infinity,
                minScale: minScale
            }];
        }

        var x1 = positionedGlyph.x + glyph.left,
            y1 = positionedGlyph.y - glyph.top,
            x2 = x1 + rect.w,
            y2 = y1 + rect.h,

            otl = new Point(x1, y1),
            otr = new Point(x2, y1),
            obl = new Point(x1, y2),
            obr = new Point(x2, y2);

        for (var i = 0; i < glyphInstances.length; i++) {

            var instance = glyphInstances[i],
                tl = otl,
                tr = otr,
                bl = obl,
                br = obr,
                angle = instance.angle + textRotate;

            if (angle) {
                var sin = Math.sin(angle),
                    cos = Math.cos(angle),
                    matrix = [cos, -sin, sin, cos];

                tl = tl.matMult(matrix);
                tr = tr.matMult(matrix);
                bl = bl.matMult(matrix);
                br = br.matMult(matrix);
            }

            // Prevent label from extending past the end of the line
            var glyphMinScale = Math.max(instance.minScale, labelMinScale);

            var glyphAngle = (anchor.angle + textRotate + instance.offset + 2 * Math.PI) % (2 * Math.PI);
            quads.push(new SymbolQuad(instance.anchorPoint, tl, tr, bl, br, rect, glyphAngle, glyphMinScale, instance.maxScale));

        }
    }

    return quads;
}

/**
 * We can only render glyph quads that slide along a straight line. To draw
 * curved lines we need an instance of a glyph for each segment it appears on.
 * This creates all the instances of a glyph that are necessary to render a label.
 *
 * We need a
 * @param {Array<Object>} glyphInstances An empty array that glyphInstances are added to.
 * @param {Anchor} anchor
 * @param {number} offset The glyph's offset from the center of the label.
 * @param {Array<Point>} line
 * @param {number} segment The index of the segment of the line on which the anchor exists.
 * @param {boolean} forward If true get the glyphs that come later on the line, otherwise get the glyphs that come earlier.
 *
 * @returns {Array<Object>} glyphInstances
 * @private
 */
function getSegmentGlyphs(glyphs, anchor, offset, line, segment, forward) {
    var upsideDown = !forward;

    if (offset < 0) forward = !forward;

    if (forward) segment++;

    var newAnchorPoint = new Point(anchor.x, anchor.y);
    var end = line[segment];
    var prevScale = Infinity;

    offset = Math.abs(offset);

    var placementScale = minScale;

    while (true) {
        var distance = newAnchorPoint.dist(end);
        var scale = offset / distance;

        // Get the angle of the line segment
        var angle = Math.atan2(end.y - newAnchorPoint.y, end.x - newAnchorPoint.x);
        if (!forward) angle += Math.PI;
        if (upsideDown) angle += Math.PI;

        glyphs.push({
            anchorPoint: newAnchorPoint,
            offset: upsideDown ? Math.PI : 0,
            minScale: scale,
            maxScale: prevScale,
            angle: (angle + 2 * Math.PI) % (2 * Math.PI)
        });

        if (scale <= placementScale) break;

        newAnchorPoint = end;

        // skip duplicate nodes
        while (newAnchorPoint.equals(end)) {
            segment += forward ? 1 : -1;
            end = line[segment];
            if (!end) {
                return scale;
            }
        }

        var unit = end.sub(newAnchorPoint)._unit();
        newAnchorPoint = newAnchorPoint.sub(unit._mult(distance));

        prevScale = scale;
    }

    return placementScale;
}

},{"point-geometry":172}],82:[function(require,module,exports){
'use strict';

var resolveTokens = require('../util/token');

module.exports = resolveText;

/**
 * For an array of features determine what glyphs need to be loaded
 * and apply any text preprocessing. The remaining users of text should
 * use the `textFeatures` key returned by this function rather than accessing
 * feature text directly.
 * @private
 */
function resolveText(features, layoutProperties, codepoints) {
    var textFeatures = [];

    for (var i = 0, fl = features.length; i < fl; i++) {
        var text = resolveTokens(features[i].properties, layoutProperties['text-field']);
        if (!text) {
            textFeatures[i] = null;
            continue;
        }
        text = text.toString();

        var transform = layoutProperties['text-transform'];
        if (transform === 'uppercase') {
            text = text.toLocaleUpperCase();
        } else if (transform === 'lowercase') {
            text = text.toLocaleLowerCase();
        }

        for (var j = 0; j < text.length; j++) {
            codepoints[text.charCodeAt(j)] = true;
        }

        // Track indexes of features with text.
        textFeatures[i] = text;
    }

    return textFeatures;
}

},{"../util/token":116}],83:[function(require,module,exports){
'use strict';

module.exports = {
    shapeText: shapeText,
    shapeIcon: shapeIcon
};


// The position of a glyph relative to the text's anchor point.
function PositionedGlyph(codePoint, x, y, glyph) {
    this.codePoint = codePoint;
    this.x = x;
    this.y = y;
    this.glyph = glyph;
}

// A collection of positioned glyphs and some metadata
function Shaping(positionedGlyphs, text, top, bottom, left, right) {
    this.positionedGlyphs = positionedGlyphs;
    this.text = text;
    this.top = top;
    this.bottom = bottom;
    this.left = left;
    this.right = right;
}

function shapeText(text, glyphs, maxWidth, lineHeight, horizontalAlign, verticalAlign, justify, spacing, translate) {

    var positionedGlyphs = [];
    var shaping = new Shaping(positionedGlyphs, text, translate[1], translate[1], translate[0], translate[0]);

    // the y offset *should* be part of the font metadata
    var yOffset = -17;

    var x = 0;
    var y = yOffset;

    for (var i = 0; i < text.length; i++) {
        var codePoint = text.charCodeAt(i);
        var glyph = glyphs[codePoint];

        if (!glyph) continue;

        positionedGlyphs.push(new PositionedGlyph(codePoint, x, y, glyph));
        x += glyph.advance + spacing;
    }

    if (!positionedGlyphs.length) return false;

    linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify, translate);

    return shaping;
}

var invisible = {
    0x20:   true, // space
    0x200b: true  // zero-width space
};

var breakable = {
    0x20:   true, // space
    0x26:   true, // ampersand
    0x2b:   true, // plus sign
    0x2d:   true, // hyphen-minus
    0x2f:   true, // solidus
    0xad:   true, // soft hyphen
    0xb7:   true, // middle dot
    0x200b: true, // zero-width space
    0x2010: true, // hyphen
    0x2013: true  // en dash
};

function linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify, translate) {
    var lastSafeBreak = null;

    var lengthBeforeCurrentLine = 0;
    var lineStartIndex = 0;
    var line = 0;

    var maxLineLength = 0;

    var positionedGlyphs = shaping.positionedGlyphs;

    if (maxWidth) {
        for (var i = 0; i < positionedGlyphs.length; i++) {
            var positionedGlyph = positionedGlyphs[i];

            positionedGlyph.x -= lengthBeforeCurrentLine;
            positionedGlyph.y += lineHeight * line;

            if (positionedGlyph.x > maxWidth && lastSafeBreak !== null) {

                var lineLength = positionedGlyphs[lastSafeBreak + 1].x;
                maxLineLength = Math.max(lineLength, maxLineLength);

                for (var k = lastSafeBreak + 1; k <= i; k++) {
                    positionedGlyphs[k].y += lineHeight;
                    positionedGlyphs[k].x -= lineLength;
                }

                if (justify) {
                    // Collapse invisible characters.
                    var lineEnd = lastSafeBreak;
                    if (invisible[positionedGlyphs[lastSafeBreak].codePoint]) {
                        lineEnd--;
                    }

                    justifyLine(positionedGlyphs, glyphs, lineStartIndex, lineEnd, justify);
                }

                lineStartIndex = lastSafeBreak + 1;
                lastSafeBreak = null;
                lengthBeforeCurrentLine += lineLength;
                line++;
            }

            if (breakable[positionedGlyph.codePoint]) {
                lastSafeBreak = i;
            }
        }
    }

    var lastPositionedGlyph = positionedGlyphs[positionedGlyphs.length - 1];
    var lastLineLength = lastPositionedGlyph.x + glyphs[lastPositionedGlyph.codePoint].advance;
    maxLineLength = Math.max(maxLineLength, lastLineLength);

    var height = (line + 1) * lineHeight;

    justifyLine(positionedGlyphs, glyphs, lineStartIndex, positionedGlyphs.length - 1, justify);
    align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line, translate);

    // Calculate the bounding box
    shaping.top += -verticalAlign * height;
    shaping.bottom = shaping.top + height;
    shaping.left += -horizontalAlign * maxLineLength;
    shaping.right = shaping.left + maxLineLength;
}

function justifyLine(positionedGlyphs, glyphs, start, end, justify) {
    var lastAdvance = glyphs[positionedGlyphs[end].codePoint].advance;
    var lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;

    for (var j = start; j <= end; j++) {
        positionedGlyphs[j].x -= lineIndent;
    }

}

function align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line, translate) {
    var shiftX = (justify - horizontalAlign) * maxLineLength + translate[0];
    var shiftY = (-verticalAlign * (line + 1) + 0.5) * lineHeight + translate[1];

    for (var j = 0; j < positionedGlyphs.length; j++) {
        positionedGlyphs[j].x += shiftX;
        positionedGlyphs[j].y += shiftY;
    }
}


function shapeIcon(image, layout) {
    if (!image || !image.rect) return null;

    var dx = layout['icon-offset'][0];
    var dy = layout['icon-offset'][1];
    var x1 = dx - image.width / 2;
    var x2 = x1 + image.width;
    var y1 = dy - image.height / 2;
    var y2 = y1 + image.height;

    return new PositionedIcon(image, y1, y2, x1, x2);
}

function PositionedIcon(image, top, bottom, left, right) {
    this.image = image;
    this.top = top;
    this.bottom = bottom;
    this.left = left;
    this.right = right;
}

},{}],84:[function(require,module,exports){
'use strict';

var ShelfPack = require('shelf-pack');
var browser = require('../util/browser');

module.exports = SpriteAtlas;
function SpriteAtlas(width, height) {
    this.width = width;
    this.height = height;

    this.bin = new ShelfPack(width, height);
    this.images = {};
    this.data = false;
    this.texture = 0; // WebGL ID
    this.filter = 0; // WebGL ID
    this.pixelRatio = 1;
    this.dirty = true;
}

function copyBitmap(src, srcStride, srcX, srcY, dst, dstStride, dstX, dstY, width, height, wrap) {
    var srcI = srcY * srcStride + srcX;
    var dstI = dstY * dstStride + dstX;
    var x, y;

    if (wrap) {
        // add 1 pixel wrapped padding on each side of the image
        dstI -= dstStride;
        for (y = -1; y <= height; y++, srcI = ((y + height) % height + srcY) * srcStride + srcX, dstI += dstStride) {
            for (x = -1; x <= width; x++) {
                dst[dstI + x] = src[srcI + ((x + width) % width)];
            }
        }

    } else {
        for (y = 0; y < height; y++, srcI += srcStride, dstI += dstStride) {
            for (x = 0; x < width; x++) {
                dst[dstI + x] = src[srcI + x];
            }
        }
    }
}

SpriteAtlas.prototype.allocateImage = function(pixelWidth, pixelHeight) {

    pixelWidth = pixelWidth / this.pixelRatio;
    pixelHeight = pixelHeight / this.pixelRatio;

    // Increase to next number divisible by 4, but at least 1.
    // This is so we can scale down the texture coordinates and pack them
    // into 2 bytes rather than 4 bytes.
    // Pad icons to prevent them from polluting neighbours during linear interpolation
    var padding = 2;
    var packWidth = pixelWidth + padding + (4 - (pixelWidth + padding) % 4);
    var packHeight = pixelHeight + padding + (4 - (pixelHeight + padding) % 4);// + 4;

    var rect = this.bin.packOne(packWidth, packHeight);
    if (!rect) {
        console.warn('SpriteAtlas out of space.');
        return null;
    }

    return rect;
};

SpriteAtlas.prototype.getImage = function(name, wrap) {
    if (this.images[name]) {
        return this.images[name];
    }

    if (!this.sprite) {
        return null;
    }

    var pos = this.sprite.getSpritePosition(name);
    if (!pos.width || !pos.height) {
        return null;
    }

    var rect = this.allocateImage(pos.width, pos.height);
    if (!rect) {
        return null;
    }

    var image = new AtlasImage(rect, pos.width / pos.pixelRatio, pos.height / pos.pixelRatio, pos.sdf, pos.pixelRatio / this.pixelRatio);
    this.images[name] = image;

    this.copy(rect, pos, wrap);

    return image;
};


// Return position of a repeating fill pattern.
SpriteAtlas.prototype.getPosition = function(name, repeating) {
    var image = this.getImage(name, repeating);
    var rect = image && image.rect;

    if (!rect) {
        return null;
    }

    var width = image.width * image.pixelRatio;
    var height = image.height * image.pixelRatio;
    var padding = 1;

    return {
        size: [image.width, image.height],
        tl: [(rect.x + padding)         / this.width, (rect.y + padding)          / this.height],
        br: [(rect.x + padding + width) / this.width, (rect.y + padding + height) / this.height]
    };
};


SpriteAtlas.prototype.allocate = function() {
    if (!this.data) {
        var w = Math.floor(this.width * this.pixelRatio);
        var h = Math.floor(this.height * this.pixelRatio);
        this.data = new Uint32Array(w * h);
        for (var i = 0; i < this.data.length; i++) {
            this.data[i] = 0;
        }
    }
};


SpriteAtlas.prototype.copy = function(dst, src, wrap) {
    if (!this.sprite.img.data) return;
    var srcImg = new Uint32Array(this.sprite.img.data.buffer);

    this.allocate();
    var dstImg = this.data;

    var padding = 1;

    copyBitmap(
        /* source buffer */  srcImg,
        /* source stride */  this.sprite.img.width,
        /* source x */       src.x,
        /* source y */       src.y,
        /* dest buffer */    dstImg,
        /* dest stride */    this.width * this.pixelRatio,
        /* dest x */         (dst.x + padding) * this.pixelRatio,
        /* dest y */         (dst.y + padding) * this.pixelRatio,
        /* icon dimension */ src.width,
        /* icon dimension */ src.height,
        /* wrap */ wrap
    );

    this.dirty = true;
};

SpriteAtlas.prototype.setSprite = function(sprite) {
    if (sprite) {
        this.pixelRatio = browser.devicePixelRatio > 1 ? 2 : 1;

        if (this.canvas) {
            this.canvas.width = this.width * this.pixelRatio;
            this.canvas.height = this.height * this.pixelRatio;
        }
    }
    this.sprite = sprite;
};

SpriteAtlas.prototype.addIcons = function(icons, callback) {
    for (var i = 0; i < icons.length; i++) {
        this.getImage(icons[i]);
    }

    callback(null, this.images);
};

SpriteAtlas.prototype.bind = function(gl, linear) {
    var first = false;
    if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        first = true;
    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
    }

    var filterVal = linear ? gl.LINEAR : gl.NEAREST;
    if (filterVal !== this.filter) {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterVal);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterVal);
        this.filter = filterVal;
    }

    if (this.dirty) {
        this.allocate();

        if (first) {
            gl.texImage2D(
                gl.TEXTURE_2D, // enum target
                0, // ind level
                gl.RGBA, // ind internalformat
                this.width * this.pixelRatio, // GLsizei width
                this.height * this.pixelRatio, // GLsizei height
                0, // ind border
                gl.RGBA, // enum format
                gl.UNSIGNED_BYTE, // enum type
                new Uint8Array(this.data.buffer) // Object data
            );
        } else {
            gl.texSubImage2D(
                gl.TEXTURE_2D, // enum target
                0, // int level
                0, // int xoffset
                0, // int yoffset
                this.width * this.pixelRatio, // long width
                this.height * this.pixelRatio, // long height
                gl.RGBA, // enum format
                gl.UNSIGNED_BYTE, // enum type
                new Uint8Array(this.data.buffer) // Object pixels
            );
        }

        this.dirty = false;
    }
};

function AtlasImage(rect, width, height, sdf, pixelRatio) {
    this.rect = rect;
    this.width = width;
    this.height = height;
    this.sdf = sdf;
    this.pixelRatio = pixelRatio;
}

},{"../util/browser":103,"shelf-pack":174}],85:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var interpolate = require('../util/interpolate');
var browser = require('../util/browser');
var LngLat = require('../geo/lng_lat');
var LngLatBounds = require('../geo/lng_lat_bounds');
var Point = require('point-geometry');

/**
 * Options common to Map#jumpTo, Map#easeTo, and Map#flyTo, controlling the destination
 * location, zoom level, bearing and pitch. All properties are options; unspecified
 * options will default to the current value for that property.
 *
 * @typedef {Object} CameraOptions
 * @property {LngLat} center Map center
 * @property {number} zoom Map zoom level
 * @property {number} bearing Map rotation bearing in degrees counter-clockwise from north
 * @property {number} pitch Map angle in degrees at which the camera is looking at the ground
 * @property {LngLat} around If zooming, the zoom center (defaults to map center)
 */

/**
 * Options common to map movement methods that involve animation, such as Map#panBy and
 * Map#easeTo, controlling the duration of the animation and easing function. All properties
 * are optional.
 *
 * @typedef {Object} AnimationOptions
 * @property {number} duration Number in milliseconds
 * @property {Function} easing
 * @property {Array} offset point, origin of movement relative to map center
 * @property {boolean} animate When set to false, no animation happens
 */

var Camera = module.exports = function() {};

util.extend(Camera.prototype, /** @lends Map.prototype */{
    /**
     * Get the current view geographical point.
     * @returns {LngLat}
     */
    getCenter: function() { return this.transform.center; },

    /**
     * Sets a map location. Equivalent to `jumpTo({center: center})`.
     *
     * @param {LngLat} center Map center to jump to
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     * @example
     * map.setCenter([-74, 38]);
     */
    setCenter: function(center, eventData) {
        this.jumpTo({center: center}, eventData);
        return this;
    },

    /**
     * Pan by a certain number of pixels
     *
     * @param {Array<number>} offset [x, y]
     * @param {AnimationOptions} [options]
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    panBy: function(offset, options, eventData) {
        this.panTo(this.transform.center,
            util.extend({offset: Point.convert(offset).mult(-1)}, options), eventData);
        return this;
    },

    /**
     * Pan to a certain location with easing
     *
     * @param {LngLat} lnglat Location to pan to
     * @param {AnimationOptions} [options]
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    panTo: function(lnglat, options, eventData) {
        return this.easeTo(util.extend({
            center: lnglat
        }, options), eventData);
    },


    /**
     * Get the current zoom
     * @returns {number}
     */
    getZoom: function() { return this.transform.zoom; },

    /**
     * Sets a map zoom. Equivalent to `jumpTo({zoom: zoom})`.
     *
     * @param {number} zoom Map zoom level
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires moveend
     * @fires zoomend
     * @returns {Map} `this`
     * @example
     * // zoom the map to 5
     * map.setZoom(5);
     */
    setZoom: function(zoom, eventData) {
        this.jumpTo({zoom: zoom}, eventData);
        return this;
    },

    /**
     * Zooms to a certain zoom level with easing.
     *
     * @param {number} zoom
     * @param {AnimationOptions} [options]
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires moveend
     * @fires zoomend
     * @returns {Map} `this`
     */
    zoomTo: function(zoom, options, eventData) {
        return this.easeTo(util.extend({
            zoom: zoom
        }, options), eventData);
    },

    /**
     * Zoom in by 1 level
     *
     * @param {AnimationOptions} [options]
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires moveend
     * @fires zoomend
     * @returns {Map} `this`
     */
    zoomIn: function(options, eventData) {
        this.zoomTo(this.getZoom() + 1, options, eventData);
        return this;
    },

    /**
     * Zoom out by 1 level
     *
     * @param {AnimationOptions} [options]
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires moveend
     * @fires zoomend
     * @returns {Map} `this`
     */
    zoomOut: function(options, eventData) {
        this.zoomTo(this.getZoom() - 1, options, eventData);
        return this;
    },


    /**
     * Get the current bearing in degrees
     * @returns {number}
     */
    getBearing: function() { return this.transform.bearing; },

    /**
     * Sets a map rotation. Equivalent to `jumpTo({bearing: bearing})`.
     *
     * @param {number} bearing Map rotation bearing in degrees counter-clockwise from north
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     * @example
     * // rotate the map to 90 degrees
     * map.setBearing(90);
     */
    setBearing: function(bearing, eventData) {
        this.jumpTo({bearing: bearing}, eventData);
        return this;
    },

    /**
     * Rotate bearing by a certain number of degrees with easing
     *
     * @param {number} bearing
     * @param {AnimationOptions} [options]
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    rotateTo: function(bearing, options, eventData) {
        return this.easeTo(util.extend({
            bearing: bearing
        }, options), eventData);
    },

    /**
     * Sets map bearing to 0 (north) with easing
     *
     * @param {AnimationOptions} [options]
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    resetNorth: function(options, eventData) {
        this.rotateTo(0, util.extend({duration: 1000}, options), eventData);
        return this;
    },

    /**
     * Animates map bearing to 0 (north) if it's already close to it.
     *
     * @param {AnimationOptions} [options]
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    snapToNorth: function(options, eventData) {
        if (Math.abs(this.getBearing()) < this.options.bearingSnap) {
            return this.resetNorth(options, eventData);
        }
        return this;
    },

    /**
     * Get the current angle in degrees
     * @returns {number}
     */
    getPitch: function() { return this.transform.pitch; },

    /**
     * Sets a map angle. Equivalent to `jumpTo({pitch: pitch})`.
     *
     * @param {number} pitch The angle at which the camera is looking at the ground
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    setPitch: function(pitch, eventData) {
        this.jumpTo({pitch: pitch}, eventData);
        return this;
    },


    /**
     * Zoom to contain certain geographical bounds
     *
     * @param {LngLatBounds|Array<Array<number>>} bounds [[minLng, minLat], [maxLng, maxLat]]
     * @param {Object} options
     * @param {boolean} [options.linear] When true, the map transitions to the new camera using
     *     {@link #Map.easeTo}. When false, the map transitions using {@link #Map.flyTo}. See
     *     {@link #Map.flyTo} for information on options specific to that animation transition.
     * @param {Function} options.easing
     * @param {number} options.padding how much padding there is around the given bounds on each side in pixels
     * @param {number} options.maxZoom The resulting zoom level will be at most
     *     this value.
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    fitBounds: function(bounds, options, eventData) {

        options = util.extend({
            padding: 0,
            offset: [0, 0],
            maxZoom: Infinity
        }, options);

        bounds = LngLatBounds.convert(bounds);

        var offset = Point.convert(options.offset),
            tr = this.transform,
            nw = tr.project(bounds.getNorthWest()),
            se = tr.project(bounds.getSouthEast()),
            size = se.sub(nw),
            scaleX = (tr.width - options.padding * 2 - Math.abs(offset.x) * 2) / size.x,
            scaleY = (tr.height - options.padding * 2 - Math.abs(offset.y) * 2) / size.y;

        options.center = tr.unproject(nw.add(se).div(2));
        options.zoom = Math.min(tr.scaleZoom(tr.scale * Math.min(scaleX, scaleY)), options.maxZoom);
        options.bearing = 0;

        return options.linear ?
            this.easeTo(options, eventData) :
            this.flyTo(options, eventData);
    },

    /**
     * Change any combination of center, zoom, bearing, and pitch, without
     * a transition. The map will retain the current values for any options
     * not included in `options`.
     *
     * @param {CameraOptions} options map view options
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires rotate
     * @fires pitch
     * @fires zoomend
     * @fires moveend
     * @returns {Map} `this`
     */
    jumpTo: function(options, eventData) {
        this.stop();

        var tr = this.transform,
            zoomChanged = false,
            bearingChanged = false,
            pitchChanged = false;

        if ('zoom' in options && tr.zoom !== +options.zoom) {
            zoomChanged = true;
            tr.zoom = +options.zoom;
        }

        if ('center' in options) {
            tr.center = LngLat.convert(options.center);
        }

        if ('bearing' in options && tr.bearing !== +options.bearing) {
            bearingChanged = true;
            tr.bearing = +options.bearing;
        }

        if ('pitch' in options && tr.pitch !== +options.pitch) {
            pitchChanged = true;
            tr.pitch = +options.pitch;
        }

        this.fire('movestart', eventData)
            .fire('move', eventData);

        if (zoomChanged) {
            this.fire('zoomstart', eventData)
                .fire('zoom', eventData)
                .fire('zoomend', eventData);
        }

        if (bearingChanged) {
            this.fire('rotate', eventData);
        }

        if (pitchChanged) {
            this.fire('pitch', eventData);
        }

        return this.fire('moveend', eventData);
    },

    /**
     * Change any combination of center, zoom, bearing, and pitch, with a smooth animation
     * between old and new values. The map will retain the current values for any options
     * not included in `options`.
     *
     * @param {CameraOptions|AnimationOptions} options map view and animation options
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires rotate
     * @fires pitch
     * @fires zoomend
     * @fires moveend
     * @returns {Map} `this`
     */
    easeTo: function(options, eventData) {
        this.stop();

        options = util.extend({
            offset: [0, 0],
            duration: 500,
            easing: util.ease
        }, options);

        var tr = this.transform,
            offset = Point.convert(options.offset),
            startZoom = this.getZoom(),
            startBearing = this.getBearing(),
            startPitch = this.getPitch(),

            zoom = 'zoom' in options ? +options.zoom : startZoom,
            bearing = 'bearing' in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing,
            pitch = 'pitch' in options ? +options.pitch : startPitch,

            toLngLat,
            toPoint;

        if ('center' in options) {
            toLngLat = LngLat.convert(options.center);
            toPoint = tr.centerPoint.add(offset);
        } else if ('around' in options) {
            toLngLat = LngLat.convert(options.around);
            toPoint = tr.locationPoint(toLngLat);
        } else {
            toPoint = tr.centerPoint.add(offset);
            toLngLat = tr.pointLocation(toPoint);
        }

        var fromPoint = tr.locationPoint(toLngLat);

        if (options.animate === false) options.duration = 0;

        this.zooming = (zoom !== startZoom);
        this.rotating = (startBearing !== bearing);
        this.pitching = (pitch !== startPitch);

        if (!options.noMoveStart) {
            this.fire('movestart', eventData);
        }
        if (this.zooming) {
            this.fire('zoomstart', eventData);
        }

        clearTimeout(this._onEaseEnd);

        this._ease(function (k) {
            if (this.zooming) {
                tr.zoom = interpolate(startZoom, zoom, k);
            }

            if (this.rotating) {
                tr.bearing = interpolate(startBearing, bearing, k);
            }

            if (this.pitching) {
                tr.pitch = interpolate(startPitch, pitch, k);
            }

            tr.setLocationAtPoint(toLngLat, fromPoint.add(toPoint.sub(fromPoint)._mult(k)));

            this.fire('move', eventData);
            if (this.zooming) {
                this.fire('zoom', eventData);
            }
            if (this.rotating) {
                this.fire('rotate', eventData);
            }
            if (this.pitching) {
                this.fire('pitch', eventData);
            }
        }, function() {
            if (options.delayEndEvents) {
                this._onEaseEnd = setTimeout(this._easeToEnd.bind(this, eventData), options.delayEndEvents);
            } else {
                this._easeToEnd(eventData);
            }
        }.bind(this), options);

        return this;
    },

    _easeToEnd: function(eventData) {
        if (this.zooming) {
            this.fire('zoomend', eventData);
        }
        this.fire('moveend', eventData);

        this.zooming = false;
        this.rotating = false;
        this.pitching = false;
    },

    /**
     * Change any combination of center, zoom, bearing, and pitch, animated along a curve that
     * evokes flight. The transition animation seamlessly incorporates zooming and panning to help
     * the user find his or her bearings even after traversing a great distance.
     *
     * @param {CameraOptions|AnimationOptions} options map view and animation options
     * @param {number} [options.curve=1.42] Relative amount of zooming that takes place along the
     *     flight path. A high value maximizes zooming for an exaggerated animation, while a low
     *     value minimizes zooming for something closer to {@link #Map.easeTo}. 1.42 is the average
     *     value selected by participants in the user study in
     *     [van Wijk (2003)](https://www.win.tue.nl/~vanwijk/zoompan.pdf). A value of
     *     `Math.pow(6, 0.25)` would be equivalent to the root mean squared average velocity. A
     *     value of 1 would produce a circular motion.
     * @param {number} [options.minZoom] Zero-based zoom level at the peak of the flight path. If
     *     `options.curve` is specified, this option is ignored.
     * @param {number} [options.speed=1.2] Average speed of the animation. A speed of 1.2 means that
     *     the map appears to move along the flight path by 1.2 times `options.curve` screenfuls every
     *     second. A _screenful_ is the visible span in pixels. It does not correspond to a fixed
     *     physical distance but rather varies by zoom level.
     * @param {number} [options.screenSpeed] Average speed of the animation, measured in screenfuls
     *     per second, assuming a linear timing curve. If `options.speed` is specified, this option
     *     is ignored.
     * @param {Function} [options.easing] Transition timing curve
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires rotate
     * @fires pitch
     * @fires zoomend
     * @fires moveend
     * @returns {this}
     * @example
     * // fly with default options to null island
     * map.flyTo({center: [0, 0], zoom: 9});
     * // using flyTo options
     * map.flyTo({
     *   center: [0, 0],
     *   zoom: 9,
     *   speed: 0.2,
     *   curve: 1,
     *   easing: function(t) {
     *     return t;
     *   }
     * });
     */
    flyTo: function(options, eventData) {
        // This method implements an “optimal path” animation, as detailed in:
        //
        // Van Wijk, Jarke J.; Nuij, Wim A. A. “Smooth and efficient zooming and panning.” INFOVIS
        //   ’03. pp. 15–22. <https://www.win.tue.nl/~vanwijk/zoompan.pdf#page=5>.
        //
        // Where applicable, local variable documentation begins with the associated variable or
        // function in van Wijk (2003).

        this.stop();

        options = util.extend({
            offset: [0, 0],
            speed: 1.2,
            curve: 1.42,
            easing: util.ease
        }, options);

        var tr = this.transform,
            offset = Point.convert(options.offset),
            startZoom = this.getZoom(),
            startBearing = this.getBearing(),
            startPitch = this.getPitch();

        var center = 'center' in options ? LngLat.convert(options.center) : this.getCenter();
        var zoom = 'zoom' in options ?  +options.zoom : startZoom;
        var bearing = 'bearing' in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing;
        var pitch = 'pitch' in options ? +options.pitch : startPitch;

        // If a path crossing the antimeridian would be shorter, extend the final coordinate so that
        // interpolating between the two endpoints will cross it.
        if (Math.abs(tr.center.lng) + Math.abs(center.lng) > 180) {
            if (tr.center.lng > 0 && center.lng < 0) {
                center.lng += 360;
            } else if (tr.center.lng < 0 && center.lng > 0) {
                center.lng -= 360;
            }
        }

        var scale = tr.zoomScale(zoom - startZoom),
            from = tr.point,
            to = 'center' in options ? tr.project(center).sub(offset.div(scale)) : from;

        var startWorldSize = tr.worldSize,
            rho = options.curve,

            // w₀: Initial visible span, measured in pixels at the initial scale.
            w0 = Math.max(tr.width, tr.height),
            // w₁: Final visible span, measured in pixels with respect to the initial scale.
            w1 = w0 / scale,
            // Length of the flight path as projected onto the ground plane, measured in pixels from
            // the world image origin at the initial scale.
            u1 = to.sub(from).mag();

        if ('minZoom' in options) {
            var minZoom = util.clamp(Math.min(options.minZoom, startZoom, zoom), tr.minZoom, tr.maxZoom);
            // w<sub>m</sub>: Maximum visible span, measured in pixels with respect to the initial
            // scale.
            var wMax = w0 / tr.zoomScale(minZoom - startZoom);
            rho = Math.sqrt(wMax / u1 * 2);
        }

        // ρ²
        var rho2 = rho * rho;

        /**
         * rᵢ: Returns the zoom-out factor at one end of the animation.
         *
         * @param i 0 for the ascent or 1 for the descent.
         * @private
         */
        function r(i) {
            var b = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1);
            return Math.log(Math.sqrt(b * b + 1) - b);
        }

        function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
        function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
        function tanh(n) { return sinh(n) / cosh(n); }

        // r₀: Zoom-out factor during ascent.
        var r0 = r(0),
            /**
             * w(s): Returns the visible span on the ground, measured in pixels with respect to the
             * initial scale.
             *
             * Assumes an angular field of view of 2 arctan ½ ≈ 53°.
             * @private
             */
            w = function (s) { return (cosh(r0) / cosh(r0 + rho * s)); },
            /**
             * u(s): Returns the distance along the flight path as projected onto the ground plane,
             * measured in pixels from the world image origin at the initial scale.
             * @private
             */
            u = function (s) { return w0 * ((cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2) / u1; },
            // S: Total length of the flight path, measured in ρ-screenfuls.
            S = (r(1) - r0) / rho;

        // When u₀ = u₁, the optimal path doesn’t require both ascent and descent.
        if (Math.abs(u1) < 0.000001) {
            // Perform a more or less instantaneous transition if the path is too short.
            if (Math.abs(w0 - w1) < 0.000001) return this.easeTo(options);

            var k = w1 < w0 ? -1 : 1;
            S = Math.abs(Math.log(w1 / w0)) / rho;

            u = function() { return 0; };
            w = function(s) { return Math.exp(k * rho * s); };
        }

        if ('duration' in options) {
            options.duration = +options.duration;
        } else {
            var V = 'screenSpeed' in options ? +options.screenSpeed / rho : +options.speed;
            options.duration = 1000 * S / V;
        }

        this.zooming = true;
        if (startBearing !== bearing) this.rotating = true;
        if (startPitch !== pitch) this.pitching = true;

        this.fire('movestart', eventData);
        this.fire('zoomstart', eventData);

        this._ease(function (k) {
            // s: The distance traveled along the flight path, measured in ρ-screenfuls.
            var s = k * S,
                us = u(s);

            tr.zoom = startZoom + tr.scaleZoom(1 / w(s));
            tr.center = tr.unproject(from.add(to.sub(from).mult(us)), startWorldSize);

            if (this.rotating) {
                tr.bearing = interpolate(startBearing, bearing, k);
            }
            if (this.pitching) {
                tr.pitch = interpolate(startPitch, pitch, k);
            }

            this.fire('move', eventData);
            this.fire('zoom', eventData);
            if (this.rotating) {
                this.fire('rotate', eventData);
            }
            if (this.pitching) {
                this.fire('pitch', eventData);
            }
        }, function() {
            this.fire('zoomend', eventData);
            this.fire('moveend', eventData);
            this.zooming = false;
            this.rotating = false;
            this.pitching = false;
        }, options);

        return this;
    },

    isEasing: function() {
        return !!this._abortFn;
    },

    /**
     * Stop current animation
     *
     * @returns {Map} `this`
     */
    stop: function() {
        if (this._abortFn) {
            this._abortFn();
            this._finishEase();
        }
        return this;
    },

    _ease: function(frame, finish, options) {
        this._finishFn = finish;
        this._abortFn = browser.timed(function (t) {
            frame.call(this, options.easing(t));
            if (t === 1) {
                this._finishEase();
            }
        }, options.animate === false ? 0 : options.duration, this);
    },

    _finishEase: function() {
        delete this._abortFn;
        // The finish function might emit events which trigger new eases, which
        // set a new _finishFn. Ensure we don't delete it unintentionally.
        var finish = this._finishFn;
        delete this._finishFn;
        finish.call(this);
    },

    // convert bearing so that it's numerically close to the current one so that it interpolates properly
    _normalizeBearing: function(bearing, currentBearing) {
        bearing = util.wrap(bearing, -180, 180);
        var diff = Math.abs(bearing - currentBearing);
        if (Math.abs(bearing - 360 - currentBearing) < diff) bearing -= 360;
        if (Math.abs(bearing + 360 - currentBearing) < diff) bearing += 360;
        return bearing;
    },

    _updateEasing: function(duration, zoom, bezier) {
        var easing;

        if (this.ease) {
            var ease = this.ease,
                t = (Date.now() - ease.start) / ease.duration,
                speed = ease.easing(t + 0.01) - ease.easing(t),

                // Quick hack to make new bezier that is continuous with last
                x = 0.27 / Math.sqrt(speed * speed + 0.0001) * 0.01,
                y = Math.sqrt(0.27 * 0.27 - x * x);

            easing = util.bezier(x, y, 0.25, 1);
        } else {
            easing = bezier ? util.bezier.apply(util, bezier) : util.ease;
        }

        // store information on current easing
        this.ease = {
            start: (new Date()).getTime(),
            to: Math.pow(2, zoom),
            duration: duration,
            easing: easing
        };

        return easing;
    }
});

/**
 * Pitch event. This event is emitted whenever the map's pitch changes.
 *
 * @event pitch
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

},{"../geo/lng_lat":24,"../geo/lng_lat_bounds":25,"../util/browser":103,"../util/interpolate":111,"../util/util":117,"point-geometry":172}],86:[function(require,module,exports){
'use strict';

var Control = require('./control');
var DOM = require('../../util/dom');
var util = require('../../util/util');

module.exports = Attribution;

/**
 * Creates an attribution control
 * @class Attribution
 * @param {Object} [options]
 * @param {string} [options.position='bottom-right'] A string indicating the control's position on the map. Options are `top-right`, `top-left`, `bottom-right`, `bottom-left`
 * @example
 * var map = new mapboxgl.Map({attributionControl: false})
 *     .addControl(new mapboxgl.Attribution({position: 'top-left'}));
 */
function Attribution(options) {
    util.setOptions(this, options);
}

Attribution.createAttributionString = function(sources) {
    var attributions = [];

    for (var id in sources) {
        var source = sources[id];
        if (source.attribution && attributions.indexOf(source.attribution) < 0) {
            attributions.push(source.attribution);
        }
    }

    // remove any entries that are substrings of another entry.
    // first sort by length so that substrings come first
    attributions.sort(function (a, b) { return a.length - b.length; });
    attributions = attributions.filter(function (attrib, i) {
        for (var j = i + 1; j < attributions.length; j++) {
            if (attributions[j].indexOf(attrib) >= 0) { return false; }
        }
        return true;
    });

    return attributions.join(' | ');
};

Attribution.prototype = util.inherit(Control, {
    options: {
        position: 'bottom-right'
    },

    onAdd: function(map) {
        var className = 'mapboxgl-ctrl-attrib',
            container = this._container = DOM.create('div', className, map.getContainer());

        this._update();
        map.on('source.load', this._update.bind(this));
        map.on('source.change', this._update.bind(this));
        map.on('source.remove', this._update.bind(this));
        map.on('moveend', this._updateEditLink.bind(this));

        return container;
    },

    _update: function() {
        if (this._map.style) {
            this._container.innerHTML = Attribution.createAttributionString(this._map.style.sources);
        }

        this._editLink = this._container.getElementsByClassName('mapbox-improve-map')[0];
        this._updateEditLink();
    },

    _updateEditLink: function() {
        if (this._editLink) {
            var center = this._map.getCenter();
            this._editLink.href = 'https://www.mapbox.com/map-feedback/#/' +
                    center.lng + '/' + center.lat + '/' + Math.round(this._map.getZoom() + 1);
        }
    }
});

},{"../../util/dom":106,"../../util/util":117,"./control":87}],87:[function(require,module,exports){
'use strict';

module.exports = Control;

/**
 * A base class for map-related interface elements.
 *
 * @class Control
 */
function Control() {}

Control.prototype = {
    /**
     * Add this control to the map, returning the control itself
     * for chaining. This will insert the control's DOM element into
     * the map's DOM element if the control has a `position` specified.
     *
     * @param {Map} map
     * @returns {Control} `this`
     */
    addTo: function(map) {
        this._map = map;
        var container = this._container = this.onAdd(map);
        if (this.options && this.options.position) {
            var pos = this.options.position;
            var corner = map._controlCorners[pos];
            container.className += ' mapboxgl-ctrl';
            if (pos.indexOf('bottom') !== -1) {
                corner.insertBefore(container, corner.firstChild);
            } else {
                corner.appendChild(container);
            }
        }

        return this;
    },

    /**
     * Remove this control from the map it has been added to.
     *
     * @returns {Control} `this`
     */
    remove: function() {
        this._container.parentNode.removeChild(this._container);
        if (this.onRemove) this.onRemove(this._map);
        this._map = null;
        return this;
    }
};

},{}],88:[function(require,module,exports){
'use strict';

var Control = require('./control');
var browser = require('../../util/browser');
var DOM = require('../../util/dom');
var util = require('../../util/util');

module.exports = Geolocate;

var geoOptions = { enableHighAccuracy: false, timeout: 6000 /* 6sec */ };


/**
 * Creates a geolocation control
 * @class Geolocate
 * @param {Object} [options]
 * @param {string} [options.position='top-right'] A string indicating the control's position on the map. Options are `top-right`, `top-left`, `bottom-right`, `bottom-left`
 * @example
 * map.addControl(new mapboxgl.Geolocate({position: 'top-left'})); // position is optional
 */
function Geolocate(options) {
    util.setOptions(this, options);
}

Geolocate.prototype = util.inherit(Control, {
    options: {
        position: 'top-right'
    },

    onAdd: function(map) {
        var className = 'mapboxgl-ctrl';

        var container = this._container = DOM.create('div', className + '-group', map.getContainer());
        if (!browser.supportsGeolocation) return container;

        this._container.addEventListener('contextmenu', this._onContextMenu.bind(this));

        this._geolocateButton = DOM.create('button', (className + '-icon ' + className + '-geolocate'), this._container);
        this._geolocateButton.addEventListener('click', this._onClickGeolocate.bind(this));
        return container;
    },

    _onContextMenu: function(e) {
        e.preventDefault();
    },

    _onClickGeolocate: function() {
        navigator.geolocation.getCurrentPosition(this._success.bind(this), this._error.bind(this), geoOptions);

        // This timeout ensures that we still call finish() even if
        // the user declines to share their location in Firefox
        this._timeoutId = setTimeout(this._finish.bind(this), 10000 /* 10sec */);
    },

    _success: function(position) {
        this._map.jumpTo({
            center: [position.coords.longitude, position.coords.latitude],
            zoom: 17,
            bearing: 0,
            pitch: 0
        });
        this._finish();
    },

    _error: function() {
        this._finish();
    },

    _finish: function() {
        if (this._timeoutId) { clearTimeout(this._timeoutId); }
        this._timeoutId = undefined;
    }

});


},{"../../util/browser":103,"../../util/dom":106,"../../util/util":117,"./control":87}],89:[function(require,module,exports){
'use strict';

var Control = require('./control');
var DOM = require('../../util/dom');
var util = require('../../util/util');

module.exports = Navigation;

/**
 * Creates a navigation control with zoom buttons and a compass
 * @class Navigation
 * @param {Object} [options]
 * @param {string} [options.position='top-right'] A string indicating the control's position on the map. Options are `top-right`, `top-left`, `bottom-right`, `bottom-left`
 * @example
 * map.addControl(new mapboxgl.Navigation({position: 'top-left'})); // position is optional
 */
function Navigation(options) {
    util.setOptions(this, options);
}

Navigation.prototype = util.inherit(Control, {
    options: {
        position: 'top-right'
    },

    onAdd: function(map) {
        var className = 'mapboxgl-ctrl';

        var container = this._container = DOM.create('div', className + '-group', map.getContainer());
        this._container.addEventListener('contextmenu', this._onContextMenu.bind(this));

        this._zoomInButton = this._createButton(className + '-icon ' + className + '-zoom-in', map.zoomIn.bind(map));
        this._zoomOutButton = this._createButton(className + '-icon ' + className + '-zoom-out', map.zoomOut.bind(map));
        this._compass = this._createButton(className + '-icon ' + className + '-compass', map.resetNorth.bind(map));

        this._compassArrow = DOM.create('div', 'arrow', this._compass);

        this._compass.addEventListener('mousedown', this._onCompassDown.bind(this));
        this._onCompassMove = this._onCompassMove.bind(this);
        this._onCompassUp = this._onCompassUp.bind(this);

        map.on('rotate', this._rotateCompassArrow.bind(this));
        this._rotateCompassArrow();

        this._el = map.getCanvasContainer();

        return container;
    },

    _onContextMenu: function(e) {
        e.preventDefault();
    },

    _onCompassDown: function(e) {
        if (e.button !== 0) return;

        DOM.disableDrag();
        document.addEventListener('mousemove', this._onCompassMove);
        document.addEventListener('mouseup', this._onCompassUp);

        this._el.dispatchEvent(copyMouseEvent(e));
        e.stopPropagation();
    },

    _onCompassMove: function(e) {
        if (e.button !== 0) return;

        this._el.dispatchEvent(copyMouseEvent(e));
        e.stopPropagation();
    },

    _onCompassUp: function(e) {
        if (e.button !== 0) return;

        document.removeEventListener('mousemove', this._onCompassMove);
        document.removeEventListener('mouseup', this._onCompassUp);
        DOM.enableDrag();

        this._el.dispatchEvent(copyMouseEvent(e));
        e.stopPropagation();
    },

    _createButton: function(className, fn) {
        var a = DOM.create('button', className, this._container);
        a.addEventListener('click', function() { fn(); });
        return a;
    },

    _rotateCompassArrow: function() {
        var rotate = 'rotate(' + (this._map.transform.angle * (180 / Math.PI)) + 'deg)';
        this._compassArrow.style.transform = rotate;
    }
});


function copyMouseEvent(e) {
    return new MouseEvent(e.type, {
        button: 2,    // right click
        buttons: 2,   // right click
        bubbles: true,
        cancelable: true,
        detail: e.detail,
        view: e.view,
        screenX: e.screenX,
        screenY: e.screenY,
        clientX: e.clientX,
        clientY: e.clientY,
        movementX: e.movementX,
        movementY: e.movementY,
        ctrlKey: e.ctrlKey,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        metaKey: e.metaKey
    });
}


},{"../../util/dom":106,"../../util/util":117,"./control":87}],90:[function(require,module,exports){
'use strict';

var DOM = require('../../util/dom'),
    LngLatBounds = require('../../geo/lng_lat_bounds'),
    util = require('../../util/util');

module.exports = BoxZoomHandler;

/**
 * The `BoxZoomHandler` allows a user to zoom the map to fit a bounding box.
 * The bounding box is defined by holding `shift` while dragging the cursor.
 * @class BoxZoomHandler
 */
function BoxZoomHandler(map) {
    this._map = map;
    this._el = map.getCanvasContainer();
    this._container = map.getContainer();

    util.bindHandlers(this);
}

BoxZoomHandler.prototype = {

    _enabled: false,
    _active: false,

    /**
     * Returns the current enabled/disabled state of the "box zoom" interaction.
     * @returns {boolean} enabled state
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Returns true if the "box zoom" interaction is currently active, i.e. currently being used.
     * @returns {boolean} active state
     */
    isActive: function () {
        return this._active;
    },

    /**
     * Enable the "box zoom" interaction.
     * @example
     *   map.boxZoom.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._el.addEventListener('mousedown', this._onMouseDown, false);
        this._enabled = true;
    },

    /**
     * Disable the "box zoom" interaction.
     * @example
     *   map.boxZoom.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._el.removeEventListener('mousedown', this._onMouseDown);
        this._enabled = false;
    },

    _onMouseDown: function (e) {
        if (!(e.shiftKey && e.button === 0)) return;

        document.addEventListener('mousemove', this._onMouseMove, false);
        document.addEventListener('keydown', this._onKeyDown, false);
        document.addEventListener('mouseup', this._onMouseUp, false);

        DOM.disableDrag();
        this._startPos = DOM.mousePos(this._el, e);
        this._active = true;
    },

    _onMouseMove: function (e) {
        var p0 = this._startPos,
            p1 = DOM.mousePos(this._el, e);

        if (!this._box) {
            this._box = DOM.create('div', 'mapboxgl-boxzoom', this._container);
            this._container.classList.add('mapboxgl-crosshair');
            this._fireEvent('boxzoomstart', e);
        }

        var minX = Math.min(p0.x, p1.x),
            maxX = Math.max(p0.x, p1.x),
            minY = Math.min(p0.y, p1.y),
            maxY = Math.max(p0.y, p1.y);

        DOM.setTransform(this._box, 'translate(' + minX + 'px,' + minY + 'px)');

        this._box.style.width = (maxX - minX) + 'px';
        this._box.style.height = (maxY - minY) + 'px';
    },

    _onMouseUp: function (e) {
        if (e.button !== 0) return;

        var p0 = this._startPos,
            p1 = DOM.mousePos(this._el, e),
            bounds = new LngLatBounds(this._map.unproject(p0), this._map.unproject(p1));

        this._finish();

        if (p0.x === p1.x && p0.y === p1.y) {
            this._fireEvent('boxzoomcancel', e);
        } else {
            this._map
                .fitBounds(bounds, {linear: true})
                .fire('boxzoomend', { originalEvent: e, boxZoomBounds: bounds });
        }
    },

    _onKeyDown: function (e) {
        if (e.keyCode === 27) {
            this._finish();
            this._fireEvent('boxzoomcancel', e);
        }
    },

    _finish: function () {
        this._active = false;

        document.removeEventListener('mousemove', this._onMouseMove, false);
        document.removeEventListener('keydown', this._onKeyDown, false);
        document.removeEventListener('mouseup', this._onMouseUp, false);

        this._container.classList.remove('mapboxgl-crosshair');

        if (this._box) {
            this._box.parentNode.removeChild(this._box);
            this._box = null;
        }

        DOM.enableDrag();
    },

    _fireEvent: function (type, e) {
        return this._map.fire(type, { originalEvent: e });
    }
};


/**
 * Boxzoom start event. This event is emitted at the start of a box zoom interaction.
 *
 * @event boxzoomstart
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

/**
 * Boxzoom end event. This event is emitted at the end of a box zoom interaction
 *
 * @event boxzoomend
 * @memberof Map
 * @instance
 * @type {Object}
 * @property {Event} originalEvent the original DOM event
 * @property {LngLatBounds} boxZoomBounds the bounds of the box zoom target
 */

/**
 * Boxzoom cancel event.  This event is emitted when the user cancels a box zoom interaction,
 *   or when the box zoom does not meet the minimum size threshold.
 *
 * @event boxzoomcancel
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

},{"../../geo/lng_lat_bounds":25,"../../util/dom":106,"../../util/util":117}],91:[function(require,module,exports){
'use strict';

module.exports = DoubleClickZoomHandler;

/**
 * The `DoubleClickZoomHandler` allows a user to zoom the map around point by
 * double clicking.
 * @class DoubleClickZoomHandler
 */
function DoubleClickZoomHandler(map) {
    this._map = map;
    this._onDblClick = this._onDblClick.bind(this);
}

DoubleClickZoomHandler.prototype = {

    _enabled: false,

    /**
     * Returns the current enabled/disabled state of the "double click to zoom" interaction.
     * @returns {boolean} enabled state
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Enable the "double click to zoom" interaction.
     * @example
     * map.doubleClickZoom.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._map.on('dblclick', this._onDblClick);
        this._enabled = true;
    },

    /**
     * Disable the "double click to zoom" interaction.
     * @example
     * map.doubleClickZoom.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._map.off('dblclick', this._onDblClick);
        this._enabled = false;
    },

    _onDblClick: function (e) {
        this._map.zoomTo(this._map.getZoom() +
            (e.originalEvent.shiftKey ? -1 : 1), {around: e.lngLat});
    }
};

},{}],92:[function(require,module,exports){
'use strict';

var DOM = require('../../util/dom'),
    util = require('../../util/util');

module.exports = DragPanHandler;

var inertiaLinearity = 0.3,
    inertiaEasing = util.bezier(0, 0, inertiaLinearity, 1),
    inertiaMaxSpeed = 1400, // px/s
    inertiaDeceleration = 2500; // px/s^2


/**
 * The `DragPanHandler` allows a user to pan the map by clicking and dragging
 * the cursor.
 * @class DragPanHandler
 */
function DragPanHandler(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    util.bindHandlers(this);
}

DragPanHandler.prototype = {

    _enabled: false,
    _active: false,

    /**
     * Returns the current enabled/disabled state of the "drag to pan" interaction.
     * @returns {boolean} enabled state
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Returns true if the "drag to pan" interaction is currently active, i.e. currently being used.
     * @returns {boolean} active state
     */
    isActive: function () {
        return this._active;
    },

    /**
     * Enable the "drag to pan" interaction.
     * @example
     * map.dragPan.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._el.addEventListener('mousedown', this._onDown);
        this._el.addEventListener('touchstart', this._onDown);
        this._enabled = true;
    },

    /**
     * Disable the "drag to pan" interaction.
     * @example
     * map.dragPan.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._el.removeEventListener('mousedown', this._onDown);
        this._el.removeEventListener('touchstart', this._onDown);
        this._enabled = false;
    },

    _onDown: function (e) {
        if (this._ignoreEvent(e)) return;
        if (this.isActive()) return;

        if (e.touches) {
            document.addEventListener('touchmove', this._onMove);
            document.addEventListener('touchend', this._onTouchEnd);
        } else {
            document.addEventListener('mousemove', this._onMove);
            document.addEventListener('mouseup', this._onMouseUp);
        }

        this._active = false;
        this._startPos = this._pos = DOM.mousePos(this._el, e);
        this._inertia = [[Date.now(), this._pos]];
    },

    _onMove: function (e) {
        if (this._ignoreEvent(e)) return;

        if (!this.isActive()) {
            this._active = true;
            this._fireEvent('dragstart', e);
            this._fireEvent('movestart', e);
        }

        var pos = DOM.mousePos(this._el, e),
            map = this._map;

        map.stop();
        this._drainInertiaBuffer();
        this._inertia.push([Date.now(), pos]);

        map.transform.setLocationAtPoint(map.transform.pointLocation(this._pos), pos);

        this._fireEvent('drag', e);
        this._fireEvent('move', e);

        this._pos = pos;

        e.preventDefault();
    },

    _onUp: function (e) {
        if (!this.isActive()) return;

        this._active = false;
        this._fireEvent('dragend', e);
        this._drainInertiaBuffer();

        var finish = function() {
            this._fireEvent('moveend', e);
        }.bind(this);

        var inertia = this._inertia;
        if (inertia.length < 2) {
            finish();
            return;
        }

        var last = inertia[inertia.length - 1],
            first = inertia[0],
            flingOffset = last[1].sub(first[1]),
            flingDuration = (last[0] - first[0]) / 1000;

        if (flingDuration === 0 || last[1].equals(first[1])) {
            finish();
            return;
        }

        // calculate px/s velocity & adjust for increased initial animation speed when easing out
        var velocity = flingOffset.mult(inertiaLinearity / flingDuration),
            speed = velocity.mag(); // px/s

        if (speed > inertiaMaxSpeed) {
            speed = inertiaMaxSpeed;
            velocity._unit()._mult(speed);
        }

        var duration = speed / (inertiaDeceleration * inertiaLinearity),
            offset = velocity.mult(-duration / 2);

        this._map.panBy(offset, {
            duration: duration * 1000,
            easing: inertiaEasing,
            noMoveStart: true
        }, { originalEvent: e });
    },

    _onMouseUp: function (e) {
        if (this._ignoreEvent(e)) return;
        this._onUp(e);
        document.removeEventListener('mousemove', this._onMove);
        document.removeEventListener('mouseup', this._onMouseUp);
    },

    _onTouchEnd: function (e) {
        if (this._ignoreEvent(e)) return;
        this._onUp(e);
        document.removeEventListener('touchmove', this._onMove);
        document.removeEventListener('touchend', this._onTouchEnd);
    },

    _fireEvent: function (type, e) {
        return this._map.fire(type, { originalEvent: e });
    },

    _ignoreEvent: function (e) {
        var map = this._map;

        if (map.boxZoom && map.boxZoom.isActive()) return true;
        if (map.dragRotate && map.dragRotate.isActive()) return true;
        if (e.touches) {
            return (e.touches.length > 1);
        } else {
            if (e.ctrlKey) return true;
            var buttons = 1,  // left button
                button = 0;   // left button
            return (e.type === 'mousemove' ? e.buttons & buttons === 0 : e.button !== button);
        }
    },

    _drainInertiaBuffer: function () {
        var inertia = this._inertia,
            now = Date.now(),
            cutoff = 160;   // msec

        while (inertia.length > 0 && now - inertia[0][0] > cutoff) inertia.shift();
    }
};


/**
 * Drag start event. This event is emitted at the start of a user-initiated pan interaction.
 *
 * @event dragstart
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

/**
 * Drag event. This event is emitted repeatedly during a user-initiated pan interaction.
 *
 * @event drag
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

/**
 * Drag end event. This event is emitted at the end of a user-initiated pan interaction.
 *
 * @event dragend
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

},{"../../util/dom":106,"../../util/util":117}],93:[function(require,module,exports){
'use strict';

var DOM = require('../../util/dom'),
    Point = require('point-geometry'),
    util = require('../../util/util');

module.exports = DragRotateHandler;

var inertiaLinearity = 0.25,
    inertiaEasing = util.bezier(0, 0, inertiaLinearity, 1),
    inertiaMaxSpeed = 180, // deg/s
    inertiaDeceleration = 720; // deg/s^2


/**
 * The `DragRotateHandler` allows a user to rotate the map by clicking and
 * dragging the cursor while holding the right mouse button or the `ctrl` key.
 * @class DragRotateHandler
 */
function DragRotateHandler(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    util.bindHandlers(this);
}

DragRotateHandler.prototype = {

    _enabled: false,
    _active: false,

    /**
     * Returns the current enabled/disabled state of the "drag to rotate" interaction.
     * @returns {boolean} enabled state
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Returns true if the "drag to rotate" interaction is currently active, i.e. currently being used.
     * @returns {boolean} active state
     */
    isActive: function () {
        return this._active;
    },

    /**
     * Enable the "drag to rotate" interaction.
     * @example
     * map.dragRotate.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._el.addEventListener('mousedown', this._onDown);
        this._enabled = true;
    },

    /**
     * Disable the "drag to rotate" interaction.
     * @example
     * map.dragRotate.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._el.removeEventListener('mousedown', this._onDown);
        this._enabled = false;
    },

    _onDown: function (e) {
        if (this._ignoreEvent(e)) return;
        if (this.isActive()) return;

        document.addEventListener('mousemove', this._onMove);
        document.addEventListener('mouseup', this._onUp);

        this._active = false;
        this._inertia = [[Date.now(), this._map.getBearing()]];
        this._startPos = this._pos = DOM.mousePos(this._el, e);
        this._center = this._map.transform.centerPoint;  // Center of rotation

        // If the first click was too close to the center, move the center of rotation by 200 pixels
        // in the direction of the click.
        var startToCenter = this._startPos.sub(this._center),
            startToCenterDist = startToCenter.mag();

        if (startToCenterDist < 200) {
            this._center = this._startPos.add(new Point(-200, 0)._rotate(startToCenter.angle()));
        }

        e.preventDefault();
    },

    _onMove: function (e) {
        if (this._ignoreEvent(e)) return;

        if (!this.isActive()) {
            this._active = true;
            this._fireEvent('rotatestart', e);
            this._fireEvent('movestart', e);
        }

        var map = this._map;
        map.stop();

        var p1 = this._pos,
            p2 = DOM.mousePos(this._el, e),
            center = this._center,
            bearingDiff = p1.sub(center).angleWith(p2.sub(center)) / Math.PI * 180,
            bearing = map.getBearing() - bearingDiff,
            inertia = this._inertia,
            last = inertia[inertia.length - 1];

        this._drainInertiaBuffer();
        inertia.push([Date.now(), map._normalizeBearing(bearing, last[1])]);

        map.transform.bearing = bearing;

        this._fireEvent('rotate', e);
        this._fireEvent('move', e);

        this._pos = p2;
    },

    _onUp: function (e) {
        if (this._ignoreEvent(e)) return;
        document.removeEventListener('mousemove', this._onMove);
        document.removeEventListener('mouseup', this._onUp);

        if (!this.isActive()) return;

        this._active = false;
        this._fireEvent('rotateend', e);
        this._drainInertiaBuffer();

        var map = this._map,
            mapBearing = map.getBearing(),
            inertia = this._inertia;

        var finish = function() {
            if (Math.abs(mapBearing) < map.options.bearingSnap) {
                map.resetNorth({noMoveStart: true}, { originalEvent: e });
            } else {
                this._fireEvent('moveend', e);
            }
        }.bind(this);

        if (inertia.length < 2) {
            finish();
            return;
        }

        var first = inertia[0],
            last = inertia[inertia.length - 1],
            previous = inertia[inertia.length - 2],
            bearing = map._normalizeBearing(mapBearing, previous[1]),
            flingDiff = last[1] - first[1],
            sign = flingDiff < 0 ? -1 : 1,
            flingDuration = (last[0] - first[0]) / 1000;

        if (flingDiff === 0 || flingDuration === 0) {
            finish();
            return;
        }

        var speed = Math.abs(flingDiff * (inertiaLinearity / flingDuration));  // deg/s
        if (speed > inertiaMaxSpeed) {
            speed = inertiaMaxSpeed;
        }

        var duration = speed / (inertiaDeceleration * inertiaLinearity),
            offset = sign * speed * (duration / 2);

        bearing += offset;

        if (Math.abs(map._normalizeBearing(bearing, 0)) < map.options.bearingSnap) {
            bearing = map._normalizeBearing(0, bearing);
        }

        map.rotateTo(bearing, {
            duration: duration * 1000,
            easing: inertiaEasing,
            noMoveStart: true
        }, { originalEvent: e });
    },

    _fireEvent: function (type, e) {
        return this._map.fire(type, { originalEvent: e });
    },

    _ignoreEvent: function (e) {
        var map = this._map;

        if (map.boxZoom && map.boxZoom.isActive()) return true;
        if (map.dragPan && map.dragPan.isActive()) return true;
        if (e.touches) {
            return (e.touches.length > 1);
        } else {
            var buttons = (e.ctrlKey ? 1 : 2),  // ? ctrl+left button : right button
                button = (e.ctrlKey ? 0 : 2);   // ? ctrl+left button : right button
            return (e.type === 'mousemove' ? e.buttons & buttons === 0 : e.button !== button);
        }
    },

    _drainInertiaBuffer: function () {
        var inertia = this._inertia,
            now = Date.now(),
            cutoff = 160;   //msec

        while (inertia.length > 0 && now - inertia[0][0] > cutoff)
            inertia.shift();
    }

};


/**
 * Rotate start event. This event is emitted at the start of a user-initiated rotate interaction.
 *
 * @event rotatestart
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

/**
 * Rotate event. This event is emitted repeatedly during a user-initiated rotate interaction.
 *
 * @event rotate
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

/**
 * Rotate end event. This event is emitted at the end of a user-initiated rotate interaction.
 *
 * @event rotateend
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

},{"../../util/dom":106,"../../util/util":117,"point-geometry":172}],94:[function(require,module,exports){
'use strict';

module.exports = KeyboardHandler;


var panDelta = 80,
    rotateDelta = 2,
    pitchDelta = 5;

/**
 * The `KeyboardHandler` allows a user to zoom, rotate, and pan the map using
 * following keyboard shortcuts:
 *  * `=` / `+`: increase zoom level by 1
 *  * `Shift-=` / `Shift-+`: increase zoom level by 2
 *  * `-`: decrease zoom level by 1
 *  * `Shift--`: decrease zoom level by 2
 *  * Arrow keys: pan by 80 pixels
 *  * `Shift+⇢`: increase rotation by 2 degrees
 *  * `Shift+⇠`: decrease rotation by 2 degrees
 *  * `Shift+⇡`: increase pitch by 5 degrees
 *  * `Shift+⇣`: decrease pitch by 5 degrees
 * @class KeyboardHandler
 */
function KeyboardHandler(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    this._onKeyDown = this._onKeyDown.bind(this);
}

KeyboardHandler.prototype = {

    _enabled: false,

    /**
     * Returns the current enabled/disabled state of keyboard interaction.
     * @returns {boolean} enabled state
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Enable the ability to interact with the map using keyboard input.
     * @example
     * map.keyboard.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._el.addEventListener('keydown', this._onKeyDown, false);
        this._enabled = true;
    },

    /**
     * Disable the ability to interact with the map using keyboard input.
     * @example
     * map.keyboard.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._el.removeEventListener('keydown', this._onKeyDown);
        this._enabled = false;
    },

    _onKeyDown: function (e) {
        if (e.altKey || e.ctrlKey || e.metaKey) return;

        var map = this._map,
            eventData = { originalEvent: e };

        switch (e.keyCode) {
        case 61:
        case 107:
        case 171:
        case 187:
            map.zoomTo(Math.round(map.getZoom()) + (e.shiftKey ? 2 : 1), eventData);
            break;

        case 189:
        case 109:
        case 173:
            map.zoomTo(Math.round(map.getZoom()) - (e.shiftKey ? 2 : 1), eventData);
            break;

        case 37:
            if (e.shiftKey) {
                map.easeTo({ bearing: map.getBearing() - rotateDelta }, eventData);
            } else {
                e.preventDefault();
                map.panBy([-panDelta, 0], eventData);
            }
            break;

        case 39:
            if (e.shiftKey) {
                map.easeTo({ bearing: map.getBearing() + rotateDelta }, eventData);
            } else {
                e.preventDefault();
                map.panBy([panDelta, 0], eventData);
            }
            break;

        case 38:
            if (e.shiftKey) {
                map.easeTo({ pitch: map.getPitch() + pitchDelta }, eventData);
            } else {
                e.preventDefault();
                map.panBy([0, -panDelta], eventData);
            }
            break;

        case 40:
            if (e.shiftKey) {
                map.easeTo({ pitch: Math.max(map.getPitch() - pitchDelta, 0) }, eventData);
            } else {
                e.preventDefault();
                map.panBy([0, panDelta], eventData);
            }
            break;
        }
    }
};

},{}],95:[function(require,module,exports){
'use strict';

var DOM = require('../../util/dom'),
    browser = require('../../util/browser'),
    util = require('../../util/util');

module.exports = ScrollZoomHandler;


var ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '',
    firefox = ua.indexOf('firefox') !== -1,
    safari = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') === -1;


/**
 * The `ScrollZoomHandler` allows a user to zoom the map by scrolling.
 * @class ScrollZoomHandler
 */
function ScrollZoomHandler(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    util.bindHandlers(this);
}

ScrollZoomHandler.prototype = {

    _enabled: false,

    /**
     * Returns the current enabled/disabled state of the "scroll to zoom" interaction.
     * @returns {boolean} enabled state
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Enable the "scroll to zoom" interaction.
     * @example
     *   map.scrollZoom.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._el.addEventListener('wheel', this._onWheel, false);
        this._el.addEventListener('mousewheel', this._onWheel, false);
        this._enabled = true;
    },

    /**
     * Disable the "scroll to zoom" interaction.
     * @example
     *   map.scrollZoom.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._el.removeEventListener('wheel', this._onWheel);
        this._el.removeEventListener('mousewheel', this._onWheel);
        this._enabled = false;
    },

    _onWheel: function (e) {
        var value;

        if (e.type === 'wheel') {
            value = e.deltaY;
            // Firefox doubles the values on retina screens...
            if (firefox && e.deltaMode === window.WheelEvent.DOM_DELTA_PIXEL) value /= browser.devicePixelRatio;
            if (e.deltaMode === window.WheelEvent.DOM_DELTA_LINE) value *= 40;

        } else if (e.type === 'mousewheel') {
            value = -e.wheelDeltaY;
            if (safari) value = value / 3;
        }

        var now = browser.now(),
            timeDelta = now - (this._time || 0);

        this._pos = DOM.mousePos(this._el, e);
        this._time = now;

        if (value !== 0 && (value % 4.000244140625) === 0) {
            // This one is definitely a mouse wheel event.
            this._type = 'wheel';
            // Normalize this value to match trackpad.
            value = Math.floor(value / 4);

        } else if (value !== 0 && Math.abs(value) < 4) {
            // This one is definitely a trackpad event because it is so small.
            this._type = 'trackpad';

        } else if (timeDelta > 400) {
            // This is likely a new scroll action.
            this._type = null;
            this._lastValue = value;

            // Start a timeout in case this was a singular event, and dely it by up to 40ms.
            this._timeout = setTimeout(this._onTimeout, 40);

        } else if (!this._type) {
            // This is a repeating event, but we don't know the type of event just yet.
            // If the delta per time is small, we assume it's a fast trackpad; otherwise we switch into wheel mode.
            this._type = (Math.abs(timeDelta * value) < 200) ? 'trackpad' : 'wheel';

            // Make sure our delayed event isn't fired again, because we accumulate
            // the previous event (which was less than 40ms ago) into this event.
            if (this._timeout) {
                clearTimeout(this._timeout);
                this._timeout = null;
                value += this._lastValue;
            }
        }

        // Slow down zoom if shift key is held for more precise zooming
        if (e.shiftKey && value) value = value / 4;

        // Only fire the callback if we actually know what type of scrolling device the user uses.
        if (this._type) this._zoom(-value, e);

        e.preventDefault();
    },

    _onTimeout: function () {
        this._type = 'wheel';
        this._zoom(-this._lastValue);
    },

    _zoom: function (delta, e) {
        if (delta === 0) return;
        var map = this._map;

        // Scale by sigmoid of scroll wheel delta.
        var scale = 2 / (1 + Math.exp(-Math.abs(delta / 100)));
        if (delta < 0 && scale !== 0) scale = 1 / scale;

        var fromScale = map.ease ? map.ease.to : map.transform.scale,
            targetZoom = map.transform.scaleZoom(fromScale * scale);

        map.zoomTo(targetZoom, {
            duration: 0,
            around: map.unproject(this._pos),
            delayEndEvents: 200
        }, { originalEvent: e });
    }
};


/**
 * Zoom start event. This event is emitted just before the map begins a transition from one
 * zoom level to another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
 *
 * @event zoomstart
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data, if fired interactively
 */

/**
 * Zoom event. This event is emitted repeatedly during animated transitions from one zoom level to
 * another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
 *
 * @event zoom
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data, if fired interactively
 */

/**
 * Zoom end event. This event is emitted just after the map completes a transition from one
 * zoom level to another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
 *
 * @event zoomend
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data, if fired interactively
 */

},{"../../util/browser":103,"../../util/dom":106,"../../util/util":117}],96:[function(require,module,exports){
'use strict';

var DOM = require('../../util/dom'),
    util = require('../../util/util');

module.exports = TouchZoomRotateHandler;

var inertiaLinearity = 0.15,
    inertiaEasing = util.bezier(0, 0, inertiaLinearity, 1),
    inertiaDeceleration = 12, // scale / s^2
    inertiaMaxSpeed = 2.5, // scale / s
    significantScaleThreshold = 0.15,
    significantRotateThreshold = 4;


/**
 * The `TouchZoomRotateHandler` allows a user to zoom and rotate the map by
 * pinching on a touchscreen.
 * @class TouchZoomRotateHandler
 */
function TouchZoomRotateHandler(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    util.bindHandlers(this);
}

TouchZoomRotateHandler.prototype = {

    _enabled: false,

    /**
     * Returns the current enabled/disabled state of the "pinch to rotate and zoom" interaction.
     * @returns {boolean} enabled state
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Enable the "pinch to rotate and zoom" interaction.
     * @example
     *   map.touchZoomRotate.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._el.addEventListener('touchstart', this._onStart, false);
        this._enabled = true;
    },

    /**
     * Disable the "pinch to rotate and zoom" interaction.
     * @example
     *   map.touchZoomRotate.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._el.removeEventListener('touchstart', this._onStart);
        this._enabled = false;
    },

    /**
     * Disable the "pinch to rotate" interaction, leaving the "pinch to zoom"
     * interaction enabled.
     * @example
     *   map.touchZoomRotate.disableRotation();
     */
    disableRotation: function() {
        this._rotationDisabled = true;
    },

    /**
     * Enable the "pinch to rotate" interaction, undoing a call to
     * `disableRotation`.
     * @example
     *   map.touchZoomRotate.enable();
     *   map.touchZoomRotate.enableRotation();
     */
    enableRotation: function() {
        this._rotationDisabled = false;
    },

    _onStart: function (e) {
        if (e.touches.length !== 2) return;

        var p0 = DOM.mousePos(this._el, e.touches[0]),
            p1 = DOM.mousePos(this._el, e.touches[1]);

        this._startVec = p0.sub(p1);
        this._startScale = this._map.transform.scale;
        this._startBearing = this._map.transform.bearing;
        this._gestureIntent = undefined;
        this._inertia = [];

        document.addEventListener('touchmove', this._onMove, false);
        document.addEventListener('touchend', this._onEnd, false);
    },

    _onMove: function (e) {
        if (e.touches.length !== 2) return;

        var p0 = DOM.mousePos(this._el, e.touches[0]),
            p1 = DOM.mousePos(this._el, e.touches[1]),
            p = p0.add(p1).div(2),
            vec = p0.sub(p1),
            scale = vec.mag() / this._startVec.mag(),
            bearing = this._rotationDisabled ? 0 : vec.angleWith(this._startVec) * 180 / Math.PI,
            map = this._map;

        // Determine 'intent' by whichever threshold is surpassed first,
        // then keep that state for the duration of this gesture.
        if (!this._gestureIntent) {
            var scalingSignificantly = (Math.abs(1 - scale) > significantScaleThreshold),
                rotatingSignificantly = (Math.abs(bearing) > significantRotateThreshold);

            if (rotatingSignificantly) {
                this._gestureIntent = 'rotate';
            } else if (scalingSignificantly) {
                this._gestureIntent = 'zoom';
            }

            if (this._gestureIntent) {
                this._startVec = vec;
                this._startScale = map.transform.scale;
                this._startBearing = map.transform.bearing;
            }

        } else {
            var param = { duration: 0, around: map.unproject(p) };

            if (this._gestureIntent === 'rotate') {
                param.bearing = this._startBearing + bearing;
            }
            if (this._gestureIntent === 'zoom' || this._gestureIntent === 'rotate') {
                param.zoom = map.transform.scaleZoom(this._startScale * scale);
            }

            map.stop();
            this._drainInertiaBuffer();
            this._inertia.push([Date.now(), scale, p]);

            map.easeTo(param, { originalEvent: e });
        }

        e.preventDefault();
    },

    _onEnd: function (e) {
        document.removeEventListener('touchmove', this._onMove);
        document.removeEventListener('touchend', this._onEnd);
        this._drainInertiaBuffer();

        var inertia = this._inertia,
            map = this._map;

        if (inertia.length < 2) {
            map.snapToNorth({}, { originalEvent: e });
            return;
        }

        var last = inertia[inertia.length - 1],
            first = inertia[0],
            lastScale = map.transform.scaleZoom(this._startScale * last[1]),
            firstScale = map.transform.scaleZoom(this._startScale * first[1]),
            scaleOffset = lastScale - firstScale,
            scaleDuration = (last[0] - first[0]) / 1000,
            p = last[2];

        if (scaleDuration === 0 || lastScale === firstScale) {
            map.snapToNorth({}, { originalEvent: e });
            return;
        }

        // calculate scale/s speed and adjust for increased initial animation speed when easing
        var speed = scaleOffset * inertiaLinearity / scaleDuration; // scale/s

        if (Math.abs(speed) > inertiaMaxSpeed) {
            if (speed > 0) {
                speed = inertiaMaxSpeed;
            } else {
                speed = -inertiaMaxSpeed;
            }
        }

        var duration = Math.abs(speed / (inertiaDeceleration * inertiaLinearity)) * 1000,
            targetScale = lastScale + speed * duration / 2000;

        if (targetScale < 0) {
            targetScale = 0;
        }

        map.easeTo({
            zoom: targetScale,
            duration: duration,
            easing: inertiaEasing,
            around: map.unproject(p)
        }, { originalEvent: e });
    },

    _drainInertiaBuffer: function() {
        var inertia = this._inertia,
            now = Date.now(),
            cutoff = 160; // msec

        while (inertia.length > 2 && now - inertia[0][0] > cutoff) inertia.shift();
    }
};

},{"../../util/dom":106,"../../util/util":117}],97:[function(require,module,exports){
'use strict';

/*
 * Adds the map's position to its page's location hash.
 * Passed as an option to the map object.
 *
 * @class mapboxgl.Hash
 * @returns {Hash} `this`
 */
module.exports = Hash;

var util = require('../util/util');

function Hash() {
    util.bindAll([
        '_onHashChange',
        '_updateHash'
    ], this);
}

Hash.prototype = {
    /*
     * Map element to listen for coordinate changes
     *
     * @param {Object} map
     * @returns {Hash} `this`
     */
    addTo: function(map) {
        this._map = map;
        window.addEventListener('hashchange', this._onHashChange, false);
        this._map.on('moveend', this._updateHash);
        return this;
    },

    /*
     * Removes hash
     *
     * @returns {Popup} `this`
     */
    remove: function() {
        window.removeEventListener('hashchange', this._onHashChange, false);
        this._map.off('moveend', this._updateHash);
        delete this._map;
        return this;
    },

    _onHashChange: function() {
        var loc = location.hash.replace('#', '').split('/');
        if (loc.length >= 3) {
            this._map.jumpTo({
                center: [+loc[2], +loc[1]],
                zoom: +loc[0],
                bearing: +(loc[3] || 0)
            });
            return true;
        }
        return false;
    },

    _updateHash: function() {
        var center = this._map.getCenter(),
            zoom = this._map.getZoom(),
            bearing = this._map.getBearing(),
            precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2)),

            hash = '#' + (Math.round(zoom * 100) / 100) +
                '/' + center.lat.toFixed(precision) +
                '/' + center.lng.toFixed(precision) +
                (bearing ? '/' + (Math.round(bearing * 10) / 10) : '');

        window.history.replaceState('', '', hash);
    }
};

},{"../util/util":117}],98:[function(require,module,exports){
'use strict';

var handlers = {
    scrollZoom: require('./handler/scroll_zoom'),
    boxZoom: require('./handler/box_zoom'),
    dragRotate: require('./handler/drag_rotate'),
    dragPan: require('./handler/drag_pan'),
    keyboard: require('./handler/keyboard'),
    doubleClickZoom: require('./handler/dblclick_zoom'),
    touchZoomRotate: require('./handler/touch_zoom_rotate')
};

var DOM = require('../util/dom'),
    util = require('../util/util'),
    Point = require('point-geometry');

module.exports = Interaction;

function Interaction(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    for (var name in handlers) {
        map[name] = new handlers[name](map);
    }

    util.bindHandlers(this);
}

Interaction.prototype = {
    enable: function () {
        var options = this._map.options,
            el = this._el;

        for (var name in handlers) {
            if (options[name]) this._map[name].enable();
        }

        el.addEventListener('mousedown', this._onMouseDown, false);
        el.addEventListener('mouseup', this._onMouseUp, false);
        el.addEventListener('mousemove', this._onMouseMove, false);
        el.addEventListener('touchstart', this._onTouchStart, false);
        el.addEventListener('touchend', this._onTouchEnd, false);
        el.addEventListener('touchmove', this._onTouchMove, false);
        el.addEventListener('touchcancel', this._onTouchCancel, false);
        el.addEventListener('click', this._onClick, false);
        el.addEventListener('dblclick', this._onDblClick, false);
        el.addEventListener('contextmenu', this._onContextMenu, false);
    },

    disable: function () {
        var options = this._map.options,
            el = this._el;

        for (var name in handlers) {
            if (options[name]) this._map[name].disable();
        }

        el.removeEventListener('mousedown', this._onMouseDown);
        el.removeEventListener('mouseup', this._onMouseUp);
        el.removeEventListener('mousemove', this._onMouseMove);
        el.removeEventListener('touchstart', this._onTouchStart);
        el.removeEventListener('touchend', this._onTouchEnd);
        el.removeEventListener('touchmove', this._onTouchMove);
        el.removeEventListener('touchcancel', this._onTouchCancel);
        el.removeEventListener('click', this._onClick);
        el.removeEventListener('dblclick', this._onDblClick);
        el.removeEventListener('contextmenu', this._onContextMenu);
    },

    _onMouseDown: function (e) {
        this._map.stop();
        this._startPos = DOM.mousePos(this._el, e);
        this._fireMouseEvent('mousedown', e);
    },

    _onMouseUp: function (e) {
        var map = this._map,
            rotating = map.dragRotate && map.dragRotate.isActive();

        if (this._contextMenuEvent && !rotating) {
            this._fireMouseEvent('contextmenu', this._contextMenuEvent);
        }

        this._contextMenuEvent = null;
        this._fireMouseEvent('mouseup', e);
    },

    _onMouseMove: function (e) {
        var map = this._map,
            el = this._el;

        if (map.dragPan && map.dragPan.isActive()) return;
        if (map.dragRotate && map.dragRotate.isActive()) return;

        var target = e.toElement || e.target;
        while (target && target !== el) target = target.parentNode;
        if (target !== el) return;

        this._fireMouseEvent('mousemove', e);
    },

    _onTouchStart: function (e) {
        this._map.stop();
        this._fireTouchEvent('touchstart', e);

        if (!e.touches || e.touches.length > 1) return;

        if (!this._tapped) {
            this._tapped = setTimeout(this._onTouchTimeout, 300);

        } else {
            clearTimeout(this._tapped);
            this._tapped = null;
            this._fireMouseEvent('dblclick', e);
        }
    },

    _onTouchMove: function (e) {
        this._fireTouchEvent('touchmove', e);
    },

    _onTouchEnd: function (e) {
        this._fireTouchEvent('touchend', e);
    },

    _onTouchCancel: function (e) {
        this._fireTouchEvent('touchcancel', e);
    },

    _onTouchTimeout: function () {
        this._tapped = null;
    },

    _onClick: function (e) {
        var pos = DOM.mousePos(this._el, e);

        if (pos.equals(this._startPos)) {
            this._fireMouseEvent('click', e);
        }
    },

    _onDblClick: function (e) {
        this._fireMouseEvent('dblclick', e);
        e.preventDefault();
    },

    _onContextMenu: function (e) {
        this._contextMenuEvent = e;
        e.preventDefault();
    },

    _fireMouseEvent: function (type, e) {
        var pos = DOM.mousePos(this._el, e);

        return this._map.fire(type, {
            lngLat: this._map.unproject(pos),
            point: pos,
            originalEvent: e
        });
    },

    _fireTouchEvent: function (type, e) {
        var touches = DOM.touchPos(this._el, e),
            singular = touches.reduce(function (prev, curr, i, arr) {
                return prev.add(curr.div(arr.length));
            }, new Point(0, 0));

        return this._map.fire(type, {
            lngLat: this._map.unproject(singular),
            point: singular,
            lngLats: touches.map(function(t) { return this._map.unproject(t); }, this),
            points: touches,
            originalEvent: e
        });
    }
};


/**
 * When an event [fires]{@link #Evented.fire} as a result of a
 * user interaction, the event will be called with an EventData
 * object containing the original DOM event along with coordinates of
 * the event target.
 *
 * @typedef {Object} EventData
 * @property {Event} originalEvent The original DOM event
 * @property {Point} point The pixel location of the event
 * @property {LngLat} lngLat The geographic location of the event
 * @example
 * map.on('click', function(data) {
 *   var e = data && data.originalEvent;
 *   console.log('got click ' + (e ? 'button = ' + e.button : ''));
 * });
 */

/**
 * Mouse down event.
 *
 * @event mousedown
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data: a [mousedown event](https://developer.mozilla.org/en-US/docs/Web/Events/mousedown)
 */

/**
 * Mouse up event.
 *
 * @event mouseup
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data: a [mouseup event](https://developer.mozilla.org/en-US/docs/Web/Events/mouseup)
 */

/**
 * Mouse move event.
 *
 * @event mousemove
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data: a [mousemouse event](https://developer.mozilla.org/en-US/docs/Web/Events/mousemove)
 */

/**
 * Touch start event.
 *
 * @event touchstart
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data: a [touchstart event](https://developer.mozilla.org/en-US/docs/Web/Events/touchstart).
 */

/**
 * Touch end event.
 *
 * @event touchend
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data: a [touchcancel event](https://developer.mozilla.org/en-US/docs/Web/Events/touchcancel).
 */

/**
 * Touch move event.
 *
 * @event touchmove
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data: a [touchmove event](https://developer.mozilla.org/en-US/docs/Web/Events/touchmove).
 */

/**
 * Touch cancel event.
 *
 * @event touchcancel
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data: a [touchcancel event](https://developer.mozilla.org/en-US/docs/Web/Events/touchcancel).
 */

/**
 * Click event.
 *
 * @event click
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data: a [click event](https://developer.mozilla.org/en-US/docs/Web/Events/click)
 */

/**
 * Double click event.
 *
 * @event dblclick
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

/**
 * Context menu event.
 *
 * @event contextmenu
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data, if available
 */

/**
 * Load event. This event is emitted immediately after all necessary resources have been downloaded
 * and the first visually complete rendering has occurred.
 *
 * @event load
 * @memberof Map
 * @instance
 * @type {Object}
 */

/**
 * Move start event. This event is emitted just before the map begins a transition from one
 * view to another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
 *
 * @event movestart
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data, if fired interactively
 */

/**
 * Move event. This event is emitted repeatedly during animated transitions from one view to
 * another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
 *
 * @event move
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data, if fired interactively
 */

/**
 * Move end event. This event is emitted just after the map completes a transition from one
 * view to another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
 *
 * @event moveend
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data, if fired interactively
 */

},{"../util/dom":106,"../util/util":117,"./handler/box_zoom":90,"./handler/dblclick_zoom":91,"./handler/drag_pan":92,"./handler/drag_rotate":93,"./handler/keyboard":94,"./handler/scroll_zoom":95,"./handler/touch_zoom_rotate":96,"point-geometry":172}],99:[function(require,module,exports){
'use strict';

var Canvas = require('../util/canvas');
var util = require('../util/util');
var browser = require('../util/browser');
var Evented = require('../util/evented');
var DOM = require('../util/dom');

var Style = require('../style/style');
var AnimationLoop = require('../style/animation_loop');
var Painter = require('../render/painter');

var Transform = require('../geo/transform');
var Hash = require('./hash');

var Interaction = require('./interaction');

var Camera = require('./camera');
var LngLat = require('../geo/lng_lat');
var LngLatBounds = require('../geo/lng_lat_bounds');
var Point = require('point-geometry');
var Attribution = require('./control/attribution');

var defaultMinZoom = 0;
var defaultMaxZoom = 20;

/**
 * Creates a map instance. This is usually the beginning of your map:
 * you tell Mapbox GL JS where to put the map by specifying a `container`
 * option, and the map's style with `style` and other attributes of the map,
 * and in return Mapbox GL JS initializes the map on your page and returns
 * a map variable that lets you programmatically call methods on the map.
 * @class Map
 * @param {Object} options
 * @param {string|Element} options.container HTML element to initialize the map in (or element id as string)
 * @param {number} [options.minZoom=0] Minimum zoom of the map
 * @param {number} [options.maxZoom=20] Maximum zoom of the map
 * @param {Object|string} [options.style] Map style. This must be an an object conforming to the schema described in the [style reference](https://mapbox.com/mapbox-gl-style-spec/), or a URL to a JSON style. To load a style from the Mapbox API, you can use a URL of the form `mapbox://styles/:owner/:style`, where `:owner` is your Mapbox account name and `:style` is the style ID. Or you can use one of the predefined Mapbox styles:
 *   * `mapbox://styles/mapbox/basic-v8` - Simple and flexible starting template.
 *   * `mapbox://styles/mapbox/bright-v8` - Template for complex custom basemaps.
 *   * `mapbox://styles/mapbox/streets-v8` - A ready-to-use basemap, perfect for minor customization or incorporating your own data.
 *   * `mapbox://styles/mapbox/light-v8` - Subtle light backdrop for data vizualizations.
 *   * `mapbox://styles/mapbox/dark-v8` - Subtle dark backdrop for data vizualizations.
 * @param {boolean} [options.hash=false] If `true`, the map will track and update the page URL according to map position
 * @param {boolean} [options.interactive=true] If `false`, no mouse, touch, or keyboard listeners are attached to the map, so it will not respond to input
 * @param {number} [options.bearingSnap=7] Snap to north threshold in degrees.
 * @param {Array} [options.classes] Style class names with which to initialize the map
 * @param {boolean} [options.attributionControl=true] If `true`, an attribution control will be added to the map.
 * @param {boolean} [options.failIfMajorPerformanceCaveat=false] If `true`, map creation will fail if the implementation determines that the performance of the created WebGL context would be dramatically lower than expected.
 * @param {boolean} [options.preserveDrawingBuffer=false] If `true`, The maps canvas can be exported to a PNG using `map.getCanvas().toDataURL();`. This is false by default as a performance optimization.
 * @param {LngLatBounds|Array<Array<number>>} [options.maxBounds] If set, the map is constrained to the given bounds.
 * @param {boolean} [options.scrollZoom=true] If `true`, enable the "scroll to zoom" interaction (see `ScrollZoomHandler`)
 * @param {boolean} [options.boxZoom=true] If `true`, enable the "box zoom" interaction (see `BoxZoomHandler`)
 * @param {boolean} [options.dragRotate=true] If `true`, enable the "drag to rotate" interaction (see `DragRotateHandler`).
 * @param {boolean} [options.dragPan=true] If `true`, enable the "drag to pan" interaction (see `DragPanHandler`).
 * @param {boolean} [options.keyboard=true] If `true`, enable keyboard shortcuts (see `KeyboardHandler`).
 * @param {boolean} [options.doubleClickZoom=true] If `true`, enable the "double click to zoom" interaction (see `DoubleClickZoomHandler`).
 * @param {boolean} [options.touchZoomRotate=true] If `true`, enable the "pinch to rotate and zoom" interaction (see `TouchZoomRotateHandler`).
 * @example
 * var map = new mapboxgl.Map({
 *   container: 'map',
 *   center: [-122.420679, 37.772537],
 *   zoom: 13,
 *   style: style_object,
 *   hash: true
 * });
 */
var Map = module.exports = function(options) {

    options = util.inherit(this.options, options);
    this._interactive = options.interactive;
    this._failIfMajorPerformanceCaveat = options.failIfMajorPerformanceCaveat;
    this._preserveDrawingBuffer = options.preserveDrawingBuffer;

    if (typeof options.container === 'string') {
        this._container = document.getElementById(options.container);
    } else {
        this._container = options.container;
    }

    this.animationLoop = new AnimationLoop();
    this.transform = new Transform(options.minZoom, options.maxZoom);

    if (options.maxBounds) {
        this.setMaxBounds(options.maxBounds);
    }

    util.bindAll([
        '_forwardStyleEvent',
        '_forwardSourceEvent',
        '_forwardLayerEvent',
        '_forwardTileEvent',
        '_onStyleLoad',
        '_onStyleChange',
        '_onSourceAdd',
        '_onSourceRemove',
        '_onSourceUpdate',
        '_onWindowResize',
        'onError',
        '_update',
        '_render'
    ], this);

    this._setupContainer();
    this._setupPainter();

    this.on('move', this._update.bind(this, false));
    this.on('zoom', this._update.bind(this, true));
    this.on('moveend', function() {
        this.animationLoop.set(300); // text fading
        this._rerender();
    }.bind(this));

    if (typeof window !== 'undefined') {
        window.addEventListener('resize', this._onWindowResize, false);
    }

    this.interaction = new Interaction(this);

    if (options.interactive) {
        this.interaction.enable();
    }

    this._hash = options.hash && (new Hash()).addTo(this);
    // don't set position from options if set through hash
    if (!this._hash || !this._hash._onHashChange()) {
        this.jumpTo(options);
    }

    this.stacks = {};
    this._classes = [];

    this.resize();

    if (options.classes) this.setClasses(options.classes);
    if (options.style) this.setStyle(options.style);
    if (options.attributionControl) this.addControl(new Attribution(options.attributionControl));

    this.on('style.error', this.onError);
    this.on('source.error', this.onError);
    this.on('tile.error', this.onError);
    this.on('layer.error', this.onError);
};

util.extend(Map.prototype, Evented);
util.extend(Map.prototype, Camera.prototype);
util.extend(Map.prototype, /** @lends Map.prototype */{

    options: {
        center: [0, 0],
        zoom: 0,
        bearing: 0,
        pitch: 0,

        minZoom: defaultMinZoom,
        maxZoom: defaultMaxZoom,

        interactive: true,

        scrollZoom: true,
        boxZoom: true,
        dragRotate: true,
        dragPan: true,
        keyboard: true,
        doubleClickZoom: true,
        touchZoomRotate: true,

        bearingSnap: 7,

        hash: false,

        attributionControl: true,

        failIfMajorPerformanceCaveat: false,
        preserveDrawingBuffer: false
    },

    /**
     * Adds a control to the map, calling `control.addTo(this)`.
     *
     * @param {Control} control
     * @returns {Map} `this`
     */
    addControl: function(control) {
        control.addTo(this);
        return this;
    },

    /**
     * Adds a style class to a map.
     *
     * @param {string} klass name of style class
     * @param {StyleOptions} [options]
     * @fires change
     * @returns {Map} `this`
     */
    addClass: function(klass, options) {
        if (this._classes.indexOf(klass) >= 0 || klass === '') return this;
        this._classes.push(klass);
        this._classOptions = options;

        if (this.style) this.style.updateClasses();
        return this._update(true);
    },

    /**
     * Removes a style class from a map.
     *
     * @param {string} klass name of style class
     * @param {StyleOptions} [options]
     * @fires change
     * @returns {Map} `this`
     */
    removeClass: function(klass, options) {
        var i = this._classes.indexOf(klass);
        if (i < 0 || klass === '') return this;
        this._classes.splice(i, 1);
        this._classOptions = options;

        if (this.style) this.style.updateClasses();
        return this._update(true);
    },

    /**
     * Helper method to add more than one class.
     *
     * @param {Array<string>} klasses An array of class names
     * @param {StyleOptions} [options]
     * @fires change
     * @returns {Map} `this`
     */
    setClasses: function(klasses, options) {
        var uniqueClasses = {};
        for (var i = 0; i < klasses.length; i++) {
            if (klasses[i] !== '') uniqueClasses[klasses[i]] = true;
        }
        this._classes = Object.keys(uniqueClasses);
        this._classOptions = options;

        if (this.style) this.style.updateClasses();
        return this._update(true);
    },

    /**
     * Check whether a style class is active.
     *
     * @param {string} klass Name of style class
     * @returns {boolean}
     */
    hasClass: function(klass) {
        return this._classes.indexOf(klass) >= 0;
    },

    /**
     * Return an array of the current active style classes.
     *
     * @returns {boolean}
     */
    getClasses: function() {
        return this._classes;
    },

    /**
     * Detect the map's new width and height and resize it. Given
     * the `container` of the map specified in the Map constructor,
     * this reads the new width from the DOM: so this method is often
     * called after the map's container is resized by another script
     * or the map is shown after being initially hidden with CSS.
     *
     * @returns {Map} `this`
     */
    resize: function() {
        var width = 0, height = 0;

        if (this._container) {
            width = this._container.offsetWidth || 400;
            height = this._container.offsetHeight || 300;
        }

        this._canvas.resize(width, height);
        this.transform.resize(width, height);
        this.painter.resize(width, height);

        return this
            .fire('movestart')
            .fire('move')
            .fire('resize')
            .fire('moveend');
    },

    /**
     * Get the map's geographical bounds.
     *
     * @returns {LngLatBounds}
     */
    getBounds: function() {
        var bounds = new LngLatBounds(
            this.transform.pointLocation(new Point(0, 0)),
            this.transform.pointLocation(this.transform.size));

        if (this.transform.angle || this.transform.pitch) {
            bounds.extend(this.transform.pointLocation(new Point(this.transform.size.x, 0)));
            bounds.extend(this.transform.pointLocation(new Point(0, this.transform.size.y)));
        }

        return bounds;
    },

    /**
     * Set constraint on the map's geographical bounds. Pan or zoom operations that would result in
     * displaying regions that fall outside of the bounds instead result in displaying the map at the
     * closest point and/or zoom level of the requested operation that is within the max bounds.
     *
     * @param {LngLatBounds | Array<Array<number>> | null | undefined} lnglatbounds Desired max bounds of the map. If null or undefined, function removes any bounds constraints on the map.
     * @returns {Map} `this`
     */
    setMaxBounds: function (lnglatbounds) {
        if (lnglatbounds) {
            var b = LngLatBounds.convert(lnglatbounds);
            this.transform.lngRange = [b.getWest(), b.getEast()];
            this.transform.latRange = [b.getSouth(), b.getNorth()];
            this.transform._constrain();
            this._update();
        } else if (lnglatbounds === null || lnglatbounds === undefined) {
            this.transform.lngRange = [];
            this.transform.latRange = [];
            this._update();
        }
        return this;

    },
    /**
     * Set the map's minimum zoom level, and zooms map to that level if it is
     * currently below it. If no parameter provided, unsets the current
     * minimum zoom (sets it to 0)
     *
     * @param {number} minZoom Minimum zoom level. Must be between 0 and 20.
     * @returns {Map} `this
     */
    setMinZoom: function(minZoom) {

        minZoom = minZoom === null || minZoom === undefined ? defaultMinZoom : minZoom;

        if (minZoom >= defaultMinZoom && minZoom <= this.transform.maxZoom) {
            this.transform.minZoom = minZoom;
            this._update();

            if (this.getZoom() < minZoom) this.setZoom(minZoom);

            return this;

        } else throw new Error('minZoom must be between ' + defaultMinZoom + ' and the current maxZoom, inclusive');
    },

    /**
     * Set the map's maximum zoom level, and zooms map to that level if it is
     * currently above it. If no parameter provided, unsets the current
     * maximum zoom (sets it to 20)
     * @param {number} maxZoom Maximum zoom level. Must be between 0 and 20.
     * @returns {Map} `this`
     */
    setMaxZoom: function(maxZoom) {

        maxZoom = maxZoom === null || maxZoom === undefined ? defaultMaxZoom : maxZoom;

        if (maxZoom >= this.transform.minZoom && maxZoom <= defaultMaxZoom) {
            this.transform.maxZoom = maxZoom;
            this._update();

            if (this.getZoom() > maxZoom) this.setZoom(maxZoom);

            return this;

        } else throw new Error('maxZoom must be between the current minZoom and ' + defaultMaxZoom + ', inclusive');
    },
    /**
     * Get pixel coordinates relative to the map container, given a geographical
     * location.
     *
     * @param {LngLat} lnglat
     * @returns {Object} `x` and `y` coordinates
     */
    project: function(lnglat) {
        return this.transform.locationPoint(LngLat.convert(lnglat));
    },

    /**
     * Get geographical coordinates, given pixel coordinates.
     *
     * @param {Array<number>} point [x, y] pixel coordinates
     * @returns {LngLat}
     */
    unproject: function(point) {
        return this.transform.pointLocation(Point.convert(point));
    },

    /**
     * Query rendered features within a point or rectangle.
     *
     * @param {Point|Array<number>|Array<Point>|Array<Array<number>>} [pointOrBox] Either [x, y] pixel coordinates of a point, or [[x1, y1], [x2, y2]] pixel coordinates of opposite corners of bounding rectangle. Optional: use entire viewport if omitted.
     * @param {Object} params
     * @param {Array<string>} [params.layers] Only query features from layers with these layer IDs.
     * @param {Array} [params.filter] A mapbox-gl-style-spec filter.
     *
     * @returns {Array<Object>} features - An array of [GeoJSON](http://geojson.org/) features
     * matching the query parameters. The GeoJSON properties of each feature are taken from
     * the original source. Each feature object also contains a top-level `layer`
     * property whose value is an object representing the style layer to which the
     * feature belongs. Layout and paint properties in this object contain values
     * which are fully evaluated for the given zoom level and feature.
     *
     * @example
     * var features = map.queryRenderedFeatures([20, 35], { layers: ['my-layer-name'] });
     *
     * @example
     * var features = map.queryRenderedFeatures([[10, 20], [30, 50]], { layers: ['my-layer-name'] });
     */
    queryRenderedFeatures: function(pointOrBox, params) {
        if (!(pointOrBox instanceof Point || Array.isArray(pointOrBox))) {
            params = pointOrBox;
            pointOrBox = undefined;
        }
        var queryGeometry = this._makeQueryGeometry(pointOrBox);
        return this.style.queryRenderedFeatures(queryGeometry, params, this.transform.zoom, this.transform.angle);
    },

    _makeQueryGeometry: function(pointOrBox) {
        if (pointOrBox === undefined) {
            // bounds was omitted: use full viewport
            pointOrBox = [
                Point.convert([0, 0]),
                Point.convert([this.transform.width, this.transform.height])
            ];
        }

        var queryGeometry;
        var isPoint = pointOrBox instanceof Point || typeof pointOrBox[0] === 'number';

        if (isPoint) {
            var point = Point.convert(pointOrBox);
            queryGeometry = [point];
        } else {
            var box = [Point.convert(pointOrBox[0]), Point.convert(pointOrBox[1])];
            queryGeometry = [
                box[0],
                new Point(box[1].x, box[0].y),
                box[1],
                new Point(box[0].x, box[1].y),
                box[0]
            ];
        }

        queryGeometry = queryGeometry.map(function(p) {
            return this.transform.pointCoordinate(p);
        }.bind(this));

        return queryGeometry;
    },

    /**
     * Get data from vector tiles as an array of GeoJSON Features.
     *
     * @param {string} sourceID source ID
     * @param {Object} params
     * @param {string} [params.sourceLayer] The name of the vector tile layer to get features from.
     * @param {Array} [params.filter] A mapbox-gl-style-spec filter.
     *
     * @returns {Array<Object>} features - An array of [GeoJSON](http://geojson.org/) features matching the query parameters. The GeoJSON properties of each feature are taken from the original source. Each feature object also contains a top-level `layer` property whose value is an object representing the style layer to which the feature belongs. Layout and paint properties in this object contain values which are fully evaluated for the given zoom level and feature.
     */
    querySourceFeatures: function(sourceID, params) {
        return this.style.querySourceFeatures(sourceID, params);
    },

    /**
     * Replaces the map's style object with a new value. Unlike the `style`
     * option in the Map constructor, this method only accepts an object
     * of a new style, not a URL string.
     *
     * @param {Object} style A style object formatted as JSON
     * @returns {Map} `this`
     */
    setStyle: function(style) {
        if (this.style) {
            this.style
                .off('load', this._onStyleLoad)
                .off('error', this._forwardStyleEvent)
                .off('change', this._onStyleChange)
                .off('source.add', this._onSourceAdd)
                .off('source.remove', this._onSourceRemove)
                .off('source.load', this._onSourceUpdate)
                .off('source.error', this._forwardSourceEvent)
                .off('source.change', this._onSourceUpdate)
                .off('layer.add', this._forwardLayerEvent)
                .off('layer.remove', this._forwardLayerEvent)
                .off('layer.error', this._forwardLayerEvent)
                .off('tile.add', this._forwardTileEvent)
                .off('tile.remove', this._forwardTileEvent)
                .off('tile.load', this._update)
                .off('tile.error', this._forwardTileEvent)
                .off('tile.stats', this._forwardTileEvent)
                ._remove();

            this.off('rotate', this.style._redoPlacement);
            this.off('pitch', this.style._redoPlacement);
        }

        if (!style) {
            this.style = null;
            return this;
        } else if (style instanceof Style) {
            this.style = style;
        } else {
            this.style = new Style(style, this.animationLoop);
        }

        this.style
            .on('load', this._onStyleLoad)
            .on('error', this._forwardStyleEvent)
            .on('change', this._onStyleChange)
            .on('source.add', this._onSourceAdd)
            .on('source.remove', this._onSourceRemove)
            .on('source.load', this._onSourceUpdate)
            .on('source.error', this._forwardSourceEvent)
            .on('source.change', this._onSourceUpdate)
            .on('layer.add', this._forwardLayerEvent)
            .on('layer.remove', this._forwardLayerEvent)
            .on('layer.error', this._forwardLayerEvent)
            .on('tile.add', this._forwardTileEvent)
            .on('tile.remove', this._forwardTileEvent)
            .on('tile.load', this._update)
            .on('tile.error', this._forwardTileEvent)
            .on('tile.stats', this._forwardTileEvent);

        this.on('rotate', this.style._redoPlacement);
        this.on('pitch', this.style._redoPlacement);

        return this;
    },

    /**
     * Get a style object that can be used to recreate the map's style.
     *
     * @returns {Object} style
     */
    getStyle: function() {
        return this.style.serialize();
    },

    /**
     * Add a source to the map style.
     *
     * @param {string} id ID of the source. Must not be used by any existing source.
     * @param {Object} source source specification, following the
     * [Mapbox GL Style Reference](https://www.mapbox.com/mapbox-gl-style-spec/#sources)
     * @fires source.add
     * @returns {Map} `this`
     */
    addSource: function(id, source) {
        this.style.addSource(id, source);
        this._update(true);
        return this;
    },

    /**
     * Remove an existing source from the map style.
     *
     * @param {string} id ID of the source to remove
     * @fires source.remove
     * @returns {Map} `this`
     */
    removeSource: function(id) {
        this.style.removeSource(id);
        this._update(true);
        return this;
    },

    /**
     * Return the style source object with the given `id`.
     *
     * @param {string} id source ID
     * @returns {Object}
     */
    getSource: function(id) {
        return this.style.getSource(id);
    },

    /**
     * Add a layer to the map style. The layer will be inserted before the layer with
     * ID `before`, or appended if `before` is omitted.
     * @param {StyleLayer|Object} layer
     * @param {string=} before  ID of an existing layer to insert before
     * @fires layer.add
     * @returns {Map} `this`
     */
    addLayer: function(layer, before) {
        this.style.addLayer(layer, before);
        this._update(true);
        return this;
    },

    /**
     * Remove the layer with the given `id` from the map. Any layers which refer to the
     * specified layer via a `ref` property are also removed.
     *
     * @param {string} id layer id
     * @throws {Error} if no layer with the given `id` exists
     * @fires layer.remove
     * @returns {Map} `this`
     */
    removeLayer: function(id) {
        this.style.removeLayer(id);
        this._update(true);
        return this;
    },

    /**
     * Return the style layer object with the given `id`.
     *
     * @param {string} id layer id
     * @returns {?Object} a layer, if one with the given `id` exists
     */
    getLayer: function(id) {
        return this.style.getLayer(id);
    },

    /**
     * Set the filter for a given style layer.
     *
     * @param {string} layer ID of a layer
     * @param {Array} filter filter specification, as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#types-filter)
     * @returns {Map} `this`
     * @example
     * map.setFilter('my-layer', ['==', 'name', 'USA']);
     */
    setFilter: function(layer, filter) {
        this.style.setFilter(layer, filter);
        this._update(true);
        return this;
    },

    /**
     * Set the zoom extent for a given style layer.
     *
     * @param {string} layerId ID of a layer
     * @param {number} minzoom minimum zoom extent
     * @param {number} maxzoom maximum zoom extent
     * @returns {Map} `this`
     * @example
     * map.setLayerZoomRange('my-layer', 2, 5);
     */
    setLayerZoomRange: function(layerId, minzoom, maxzoom) {
        this.style.setLayerZoomRange(layerId, minzoom, maxzoom);
        this._update(true);
        return this;
    },

    /**
     * Get the filter for a given style layer.
     *
     * @param {string} layer ID of a layer
     * @returns {Array} filter specification, as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#filter)
     */
    getFilter: function(layer) {
        return this.style.getFilter(layer);
    },

    /**
     * Set the value of a paint property in a given style layer.
     *
     * @param {string} layer ID of a layer
     * @param {string} name name of a paint property
     * @param {*} value value for the paint propery; must have the type appropriate for the property as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/)
     * @param {string=} klass optional class specifier for the property
     * @returns {Map} `this`
     * @example
     * map.setPaintProperty('my-layer', 'fill-color', '#faafee');
     */
    setPaintProperty: function(layer, name, value, klass) {
        this.style.setPaintProperty(layer, name, value, klass);
        this._update(true);
        return this;
    },

    /**
     * Get the value of a paint property in a given style layer.
     *
     * @param {string} layer ID of a layer
     * @param {string} name name of a paint property
     * @param {string=} klass optional class specifier for the property
     * @returns {*} value for the paint propery
     */
    getPaintProperty: function(layer, name, klass) {
        return this.style.getPaintProperty(layer, name, klass);
    },

    /**
     * Set the value of a layout property in a given style layer.
     *
     * @param {string} layer ID of a layer
     * @param {string} name name of a layout property
     * @param {*} value value for the layout propery; must have the type appropriate for the property as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/)
     * @returns {Map} `this`
     * @example
     * map.setLayoutProperty('my-layer', 'visibility', 'none');
     */
    setLayoutProperty: function(layer, name, value) {
        this.style.setLayoutProperty(layer, name, value);
        this._update(true);
        return this;
    },

    /**
     * Get the value of a layout property in a given style layer.
     *
     * @param {string} layer ID of a layer
     * @param {string} name name of a layout property
     * @param {string=} klass optional class specifier for the property
     * @returns {*} value for the layout propery
     */
    getLayoutProperty: function(layer, name) {
        return this.style.getLayoutProperty(layer, name);
    },

    /**
     * Get the Map's container as an HTML element
     * @returns {HTMLElement} container
     */
    getContainer: function() {
        return this._container;
    },

    /**
     * Get the container for the map `canvas` element.
     *
     * If you want to add non-GL overlays to the map, you should append them to this element. This
     * is the element to which event bindings for map interactivity such as panning and zooming are
     * attached. It will receive bubbled events for child elements such as the `canvas`, but not for
     * map controls.
     *
     * @returns {HTMLElement} container
     */
    getCanvasContainer: function() {
        return this._canvasContainer;
    },

    /**
     * Get the Map's canvas as an HTML canvas
     * @returns {HTMLElement} canvas
     */
    getCanvas: function() {
        return this._canvas.getElement();
    },

    _setupContainer: function() {
        var container = this._container;
        container.classList.add('mapboxgl-map');

        var canvasContainer = this._canvasContainer = DOM.create('div', 'mapboxgl-canvas-container', container);
        if (this._interactive) {
            canvasContainer.classList.add('mapboxgl-interactive');
        }
        this._canvas = new Canvas(this, canvasContainer);

        var controlContainer = this._controlContainer = DOM.create('div', 'mapboxgl-control-container', container);
        var corners = this._controlCorners = {};
        ['top-left', 'top-right', 'bottom-left', 'bottom-right'].forEach(function (pos) {
            corners[pos] = DOM.create('div', 'mapboxgl-ctrl-' + pos, controlContainer);
        });
    },

    _setupPainter: function() {
        var gl = this._canvas.getWebGLContext({
            failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
            preserveDrawingBuffer: this._preserveDrawingBuffer
        });

        if (!gl) {
            console.error('Failed to initialize WebGL');
            return;
        }

        this.painter = new Painter(gl, this.transform);
    },

    /**
     * WebGL Context Lost event.
     *
     * @event webglcontextlost
     * @memberof Map
     * @instance
     * @type {Object}
     * @property {Event} originalEvent the original DOM event
     */
    _contextLost: function(event) {
        event.preventDefault();
        if (this._frameId) {
            browser.cancelFrame(this._frameId);
        }
        this.fire("webglcontextlost", {originalEvent: event});
    },

    /**
     * WebGL Context Restored event.
     *
     * @event webglcontextrestored
     * @memberof Map
     * @instance
     * @type {Object}
     */
    _contextRestored: function(event) {
        this._setupPainter();
        this.resize();
        this._update();
        this.fire("webglcontextrestored", {originalEvent: event});
    },

    /**
     * Is this map fully loaded? If the style isn't loaded
     * or it has a change to the sources or style that isn't
     * propagated to its style, return false.
     *
     * @returns {boolean} whether the map is loaded
     */
    loaded: function() {
        if (this._styleDirty || this._sourcesDirty)
            return false;
        if (!this.style || !this.style.loaded())
            return false;
        return true;
    },

    /**
     * Update this map's style and sources, and re-render the map.
     *
     * @param {boolean} updateStyle mark the map's style for reprocessing as
     * well as its sources
     * @returns {Map} this
     * @private
     */
    _update: function(updateStyle) {
        if (!this.style) return this;

        this._styleDirty = this._styleDirty || updateStyle;
        this._sourcesDirty = true;

        this._rerender();

        return this;
    },

    /**
     * Call when a (re-)render of the map is required, e.g. when the
     * user panned or zoomed,f or new data is available.
     * @returns {Map} this
     * @private
     */
    _render: function() {
        if (this.style && this._styleDirty) {
            this._styleDirty = false;
            this.style.update(this._classes, this._classOptions);
            this._classOptions = null;
            this.style._recalculate(this.transform.zoom);
        }

        if (this.style && this._sourcesDirty) {
            this._sourcesDirty = false;
            this.style._updateSources(this.transform);
        }

        this.painter.render(this.style, {
            debug: this.showTileBoundaries,
            showOverdrawInspector: this._showOverdrawInspector,
            vertices: this.vertices,
            rotating: this.rotating,
            zooming: this.zooming
        });

        this.fire('render');

        if (this.loaded() && !this._loaded) {
            this._loaded = true;
            this.fire('load');
        }

        this._frameId = null;

        if (!this.animationLoop.stopped()) {
            this._styleDirty = true;
        }

        if (this._sourcesDirty || this._repaint || !this.animationLoop.stopped()) {
            this._rerender();
        }

        return this;
    },

    /**
     * Destroys the map's underlying resources, including web workers and DOM elements. Afterwards,
     * you must not call any further methods on this Map instance.
     *
     * @returns {undefined}
     */
    remove: function() {
        if (this._hash) this._hash.remove();
        browser.cancelFrame(this._frameId);
        this.setStyle(null);
        if (typeof window !== 'undefined') {
            window.removeEventListener('resize', this._onWindowResize, false);
        }
        removeNode(this._canvasContainer);
        removeNode(this._controlContainer);
        this._container.classList.remove('mapboxgl-map');
    },

    /**
     * A default error handler for `style.error`, `source.error`, `layer.error`,
     * and `tile.error` events.
     * It logs the error via `console.error`.
     *
     * @example
     * // Disable the default error handler
     * map.off('style.error', map.onError);
     * map.off('source.error', map.onError);
     * map.off('tile.error', map.onError);
     * map.off('layer.error', map.onError);
     */
    onError: function(e) {
        console.error(e.error);
    },

    _rerender: function() {
        if (this.style && !this._frameId) {
            this._frameId = browser.frame(this._render);
        }
    },

    _forwardStyleEvent: function(e) {
        this.fire('style.' + e.type, util.extend({style: e.target}, e));
    },

    _forwardSourceEvent: function(e) {
        this.fire(e.type, util.extend({style: e.target}, e));
    },

    _forwardLayerEvent: function(e) {
        this.fire(e.type, util.extend({style: e.target}, e));
    },

    _forwardTileEvent: function(e) {
        this.fire(e.type, util.extend({style: e.target}, e));
    },

    _onStyleLoad: function(e) {
        if (this.transform.unmodified) {
            this.jumpTo(this.style.stylesheet);
        }
        this.style.update(this._classes, {transition: false});
        this._forwardStyleEvent(e);
    },

    _onStyleChange: function(e) {
        this._update(true);
        this._forwardStyleEvent(e);
    },

    _onSourceAdd: function(e) {
        var source = e.source;
        if (source.onAdd)
            source.onAdd(this);
        this._forwardSourceEvent(e);
    },

    _onSourceRemove: function(e) {
        var source = e.source;
        if (source.onRemove)
            source.onRemove(this);
        this._forwardSourceEvent(e);
    },

    _onSourceUpdate: function(e) {
        this._update();
        this._forwardSourceEvent(e);
    },

    _onWindowResize: function() {
        this.stop().resize()._update();
    }
});

util.extendAll(Map.prototype, /** @lends Map.prototype */{

    /**
     * Draw an outline around each rendered tile for debugging.
     *
     * @name showTileBoundaries
     * @type {boolean}
     */
    _showTileBoundaries: false,
    get showTileBoundaries() { return this._showTileBoundaries; },
    set showTileBoundaries(value) {
        if (this._showTileBoundaries === value) return;
        this._showTileBoundaries = value;
        this._update();
    },

    /**
     * Draw boxes around all symbols in the data source, showing which were
     * rendered and which were hidden due to collisions with other symbols for
     * style debugging.
     *
     * @name showCollisionBoxes
     * @type {boolean}
     */
    _showCollisionBoxes: false,
    get showCollisionBoxes() { return this._showCollisionBoxes; },
    set showCollisionBoxes(value) {
        if (this._showCollisionBoxes === value) return;
        this._showCollisionBoxes = value;
        this.style._redoPlacement();
    },

    /*
     * Show how many times each fragment has been shaded. White fragments have
     * been shaded 8 or more times. Black fragments have been shaded 0 times.
     *
     * @name showOverdraw
     * @type {boolean}
     */
    _showOverdrawInspector: false,
    get showOverdrawInspector() { return this._showOverdrawInspector; },
    set showOverdrawInspector(value) {
        if (this._showOverdrawInspector === value) return;
        this._showOverdrawInspector = value;
        this._update();
    },

    /**
     * Enable continuous repaint to analyze performance.
     *
     * @name repaint
     * @type {boolean}
     */
    _repaint: false,
    get repaint() { return this._repaint; },
    set repaint(value) { this._repaint = value; this._update(); },

    // show vertices
    _vertices: false,
    get vertices() { return this._vertices; },
    set vertices(value) { this._vertices = value; this._update(); }
});

function removeNode(node) {
    if (node.parentNode) {
        node.parentNode.removeChild(node);
    }
}

/**
 * Options common to Map#addClass, Map#removeClass, and Map#setClasses, controlling
 * whether or not to smoothly transition property changes triggered by the class change.
 *
 * @typedef {Object} StyleOptions
 * @property {boolean} transition
 */

 /**
  * This event is fired whenever the map is drawn to the screen because of
  *
  *  - a change in map position, zoom, pitch, or bearing
  *  - a change to the map style
  *  - a change to a GeoJSON source
  *  - a vector tile, GeoJSON file, glyph, or sprite being loaded
  *
  * @event render
  * @memberof Map
  * @instance
  */

},{"../geo/lng_lat":24,"../geo/lng_lat_bounds":25,"../geo/transform":26,"../render/painter":39,"../style/animation_loop":55,"../style/style":58,"../util/browser":103,"../util/canvas":104,"../util/dom":106,"../util/evented":109,"../util/util":117,"./camera":85,"./control/attribution":86,"./hash":97,"./interaction":98,"point-geometry":172}],100:[function(require,module,exports){
'use strict';

module.exports = Popup;

var util = require('../util/util');
var Evented = require('../util/evented');
var DOM = require('../util/dom');
var LngLat = require('../geo/lng_lat');

/**
 * Creates a popup component
 * @class Popup
 * @param {Object} options
 * @param {boolean} options.closeButton whether to show a close button in the
 * top right corner of the popup.
 * @param {boolean} options.closeOnClick whether to close the popup when the
 * map is clicked.
 * @param {string} options.anchor - One of "top", "bottom", "left", "right", "top-left",
 * "top-right", "bottom-left", or "bottom-right", describing where the popup's anchor
 * relative to the coordinate set via `setLngLat`.
 * @example
 * var tooltip = new mapboxgl.Popup()
 *   .setLngLat(e.lngLat)
 *   .setHTML("<h1>Hello World!</h1>")
 *   .addTo(map);
 */
function Popup(options) {
    util.setOptions(this, options);
    util.bindAll([
        '_update',
        '_onClickClose'],
        this);
}

Popup.prototype = util.inherit(Evented, /** @lends Popup.prototype */{
    options: {
        closeButton: true,
        closeOnClick: true
    },

    /**
     * Attaches the popup to a map
     * @param {Map} map
     * @returns {Popup} `this`
     */
    addTo: function(map) {
        this._map = map;
        this._map.on('move', this._update);
        if (this.options.closeOnClick) {
            this._map.on('click', this._onClickClose);
        }
        this._update();
        return this;
    },

    /**
     * Removes the popup from a map
     * @example
     * var popup = new mapboxgl.Popup().addTo(map);
     * popup.remove();
     * @returns {Popup} `this`
     */
    remove: function() {
        if (this._content && this._content.parentNode) {
            this._content.parentNode.removeChild(this._content);
        }

        if (this._container) {
            this._container.parentNode.removeChild(this._container);
            delete this._container;
        }

        if (this._map) {
            this._map.off('move', this._update);
            this._map.off('click', this._onClickClose);
            delete this._map;
        }

        return this;
    },

    /**
     * Get the popup's geographical location
     * @returns {LngLat}
     */
    getLngLat: function() {
        return this._lngLat;
    },

    /**
     * Set the popup's geographical position and move it.
     * @param {LngLat} lnglat
     * @returns {Popup} `this`
     */
    setLngLat: function(lnglat) {
        this._lngLat = LngLat.convert(lnglat);
        this._update();
        return this;
    },

    /**
     * Fill a popup element with text only content. This creates a text node
     * in the DOM, so it cannot end up appending raw HTML. Use this method
     * if you want an added level of security against XSS if the popup
     * content is user-provided.
     * @param {string} text
     * @returns {Popup} `this`
     * @example
     * var tooltip = new mapboxgl.Popup()
     *   .setLngLat(e.lngLat)
     *   .setText('Hello, world!')
     *   .addTo(map);
     */
    setText: function(text) {
        return this.setDOMContent(document.createTextNode(text));
    },

    /**
     * Fill a popup element with HTML content, provided as a string.
     * @param {string} html
     * @returns {Popup} `this`
     */
    setHTML: function(html) {
        var frag = document.createDocumentFragment();
        var temp = document.createElement('body'), child;
        temp.innerHTML = html;
        while (true) {
            child = temp.firstChild;
            if (!child) break;
            frag.appendChild(child);
        }

        return this.setDOMContent(frag);
    },

    /**
     * Fill a popup element with DOM content
     * @param {Node} htmlNode Popup content as a DOM node
     * @returns {Popup} `this`
     * @example
     * // create an element with the popup content
     * var div = document.createElement('div');
     * div.innerHTML = 'Hello, world!';
     * var tooltip = new mapboxgl.Popup()
     *   .setLngLat(e.lngLat)
     *   .setDOMContent(div)
     *   .addTo(map);
     */
    setDOMContent: function(htmlNode) {
        this._createContent();
        this._content.appendChild(htmlNode);
        this._update();
        return this;
    },

    _createContent: function() {
        if (this._content && this._content.parentNode) {
            this._content.parentNode.removeChild(this._content);
        }

        this._content = DOM.create('div', 'mapboxgl-popup-content', this._container);

        if (this.options.closeButton) {
            this._closeButton = DOM.create('button', 'mapboxgl-popup-close-button', this._content);
            this._closeButton.innerHTML = '&#215;';
            this._closeButton.addEventListener('click', this._onClickClose);
        }
    },

    _update: function() {
        if (!this._map || !this._lngLat || !this._content) { return; }

        if (!this._container) {
            this._container = DOM.create('div', 'mapboxgl-popup', this._map.getContainer());
            this._tip       = DOM.create('div', 'mapboxgl-popup-tip', this._container);
            this._container.appendChild(this._content);
        }

        var pos = this._map.project(this._lngLat).round(),
            anchor = this.options.anchor;

        if (!anchor) {
            var width = this._container.offsetWidth,
                height = this._container.offsetHeight;

            if (pos.y < height) {
                anchor = ['top'];
            } else if (pos.y > this._map.transform.height - height) {
                anchor = ['bottom'];
            } else {
                anchor = [];
            }

            if (pos.x < width / 2) {
                anchor.push('left');
            } else if (pos.x > this._map.transform.width - width / 2) {
                anchor.push('right');
            }

            if (anchor.length === 0) {
                anchor = 'bottom';
            } else {
                anchor = anchor.join('-');
            }
        }

        var anchorTranslate = {
            'top': 'translate(-50%,0)',
            'top-left': 'translate(0,0)',
            'top-right': 'translate(-100%,0)',
            'bottom': 'translate(-50%,-100%)',
            'bottom-left': 'translate(0,-100%)',
            'bottom-right': 'translate(-100%,-100%)',
            'left': 'translate(0,-50%)',
            'right': 'translate(-100%,-50%)'
        };

        var classList = this._container.classList;
        for (var key in anchorTranslate) {
            classList.remove('mapboxgl-popup-anchor-' + key);
        }
        classList.add('mapboxgl-popup-anchor-' + anchor);

        DOM.setTransform(this._container, anchorTranslate[anchor] + ' translate(' + pos.x + 'px,' + pos.y + 'px)');
    },

    _onClickClose: function() {
        this.remove();
    }
});

},{"../geo/lng_lat":24,"../util/dom":106,"../util/evented":109,"../util/util":117}],101:[function(require,module,exports){
'use strict';

module.exports = Actor;

/**
 * An implementation of the [Actor design pattern](http://en.wikipedia.org/wiki/Actor_model)
 * that maintains the relationship between asynchronous tasks and the objects
 * that spin them off - in this case, tasks like parsing parts of styles,
 * owned by the styles
 *
 * @param {WebWorker} target
 * @param {WebWorker} parent
 * @private
 */
function Actor(target, parent) {
    this.target = target;
    this.parent = parent;
    this.callbacks = {};
    this.callbackID = 0;
    this.receive = this.receive.bind(this);
    this.target.addEventListener('message', this.receive, false);
}

Actor.prototype.receive = function(message) {
    var data = message.data,
        callback;

    if (data.type === '<response>') {
        callback = this.callbacks[data.id];
        delete this.callbacks[data.id];
        callback(data.error || null, data.data);
    } else if (typeof data.id !== 'undefined') {
        var id = data.id;
        this.parent[data.type](data.data, function(err, data, buffers) {
            this.postMessage({
                type: '<response>',
                id: String(id),
                error: err ? String(err) : null,
                data: data
            }, buffers);
        }.bind(this));
    } else {
        this.parent[data.type](data.data);
    }
};

Actor.prototype.send = function(type, data, callback, buffers) {
    var id = null;
    if (callback) this.callbacks[id = this.callbackID++] = callback;
    this.postMessage({ type: type, id: String(id), data: data }, buffers);
};

/**
 * Wrapped postMessage API that abstracts around IE's lack of
 * `transferList` support.
 *
 * @param {Object} message
 * @param {Object} transferList
 * @private
 */
Actor.prototype.postMessage = function(message, transferList) {
    this.target.postMessage(message, transferList);
};

},{}],102:[function(require,module,exports){
'use strict';

exports.getJSON = function(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.setRequestHeader('Accept', 'application/json');
    xhr.onerror = function(e) {
        callback(e);
    };
    xhr.onload = function() {
        if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
            var data;
            try {
                data = JSON.parse(xhr.response);
            } catch (err) {
                return callback(err);
            }
            callback(null, data);
        } else {
            callback(new Error(xhr.statusText));
        }
    };
    xhr.send();
    return xhr;
};

exports.getArrayBuffer = function(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onerror = function(e) {
        callback(e);
    };
    xhr.onload = function() {
        if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
            callback(null, xhr.response);
        } else {
            callback(new Error(xhr.statusText));
        }
    };
    xhr.send();
    return xhr;
};

function sameOrigin(url) {
    var a = document.createElement('a');
    a.href = url;
    return a.protocol === document.location.protocol && a.host === document.location.host;
}

exports.getImage = function(url, callback) {
    return exports.getArrayBuffer(url, function(err, imgData) {
        if (err) return callback(err);
        var img = new Image();
        img.onload = function() {
            callback(null, img);
            (window.URL || window.webkitURL).revokeObjectURL(img.src);
        };
        var blob = new Blob([new Uint8Array(imgData)], { type: 'image/png' });
        img.src = (window.URL || window.webkitURL).createObjectURL(blob);
        img.getData = function() {
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            context.drawImage(img, 0, 0);
            return context.getImageData(0, 0, img.width, img.height).data;
        };
        return img;
    });
};

exports.getVideo = function(urls, callback) {
    var video = document.createElement('video');
    video.onloadstart = function() {
        callback(null, video);
    };
    for (var i = 0; i < urls.length; i++) {
        var s = document.createElement('source');
        if (!sameOrigin(urls[i])) {
            video.crossOrigin = 'Anonymous';
        }
        s.src = urls[i];
        video.appendChild(s);
    }
    video.getData = function() { return video; };
    return video;
};

},{}],103:[function(require,module,exports){
'use strict';

/**
 * Unlike js/util/browser.js, this code is written with the expectation
 * of a browser environment with a global 'window' object
 * @module browser
 * @private
 */

/**
 * Provides a function that outputs milliseconds: either performance.now()
 * or a fallback to Date.now()
 */
module.exports.now = (function() {
    if (window.performance &&
        window.performance.now) {
        return window.performance.now.bind(window.performance);
    } else {
        return Date.now.bind(Date);
    }
}());

var frame = window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.msRequestAnimationFrame;

exports.frame = function(fn) {
    return frame(fn);
};

var cancel = window.cancelAnimationFrame ||
    window.mozCancelAnimationFrame ||
    window.webkitCancelAnimationFrame ||
    window.msCancelAnimationFrame;

exports.cancelFrame = function(id) {
    cancel(id);
};

exports.timed = function (fn, dur, ctx) {
    if (!dur) {
        fn.call(ctx, 1);
        return null;
    }

    var abort = false,
        start = module.exports.now();

    function tick(now) {
        if (abort) return;
        now = module.exports.now();

        if (now >= start + dur) {
            fn.call(ctx, 1);
        } else {
            fn.call(ctx, (now - start) / dur);
            exports.frame(tick);
        }
    }

    exports.frame(tick);

    return function() { abort = true; };
};

/**
 * Test if the current browser supports Mapbox GL JS
 * @param {Object} options
 * @param {boolean} [options.failIfMajorPerformanceCaveat=false] Return `false`
 *   if the performance of Mapbox GL JS would be dramatically worse than
 *   expected (i.e. a software renderer would be used)
 * @return {boolean}
 */
exports.supported = require('mapbox-gl-js-supported');

exports.hardwareConcurrency = navigator.hardwareConcurrency || 8;

Object.defineProperty(exports, 'devicePixelRatio', {
    get: function() { return window.devicePixelRatio; }
});

exports.supportsWebp = false;

var webpImgTest = document.createElement('img');
webpImgTest.onload = function() {
    exports.supportsWebp = true;
};
webpImgTest.src = 'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=';

exports.supportsGeolocation = !!navigator.geolocation;

},{"mapbox-gl-js-supported":143}],104:[function(require,module,exports){
'use strict';

var util = require('../util');
var isSupported = require('mapbox-gl-js-supported');

module.exports = Canvas;

function Canvas(parent, container) {
    this.canvas = document.createElement('canvas');

    if (parent && container) {
        this.canvas.style.position = 'absolute';
        this.canvas.classList.add('mapboxgl-canvas');
        this.canvas.addEventListener('webglcontextlost', parent._contextLost.bind(parent), false);
        this.canvas.addEventListener('webglcontextrestored', parent._contextRestored.bind(parent), false);
        this.canvas.setAttribute('tabindex', 0);
        container.appendChild(this.canvas);
    }
}

Canvas.prototype.resize = function(width, height) {
    var pixelRatio = window.devicePixelRatio || 1;

    // Request the required canvas size taking the pixelratio into account.
    this.canvas.width = pixelRatio * width;
    this.canvas.height = pixelRatio * height;

    // Maintain the same canvas size, potentially downscaling it for HiDPI displays
    this.canvas.style.width = width + 'px';
    this.canvas.style.height = height + 'px';
};

Canvas.prototype.getWebGLContext = function(attributes) {
    attributes = util.extend({}, attributes, isSupported.webGLContextAttributes);

    return this.canvas.getContext('webgl', attributes) ||
        this.canvas.getContext('experimental-webgl', attributes);
};

Canvas.prototype.getElement = function() {
    return this.canvas;
};

},{"../util":117,"mapbox-gl-js-supported":143}],105:[function(require,module,exports){
'use strict';

var Actor = require('../actor');
var WebWorkify = require('webworkify');

module.exports = Dispatcher;

function Dispatcher(length, parent) {
    this.actors = [];
    this.currentActor = 0;
    for (var i = 0; i < length; i++) {
        var worker = new WebWorkify(require('../../source/worker'));
        var actor = new Actor(worker, parent);
        actor.name = "Worker " + i;
        this.actors.push(actor);
    }
}

Dispatcher.prototype = {
    broadcast: function(type, data) {
        for (var i = 0; i < this.actors.length; i++) {
            this.actors[i].send(type, data);
        }
    },

    send: function(type, data, callback, targetID, buffers) {
        if (typeof targetID !== 'number' || isNaN(targetID)) {
            // Use round robin to send requests to web workers.
            targetID = this.currentActor = (this.currentActor + 1) % this.actors.length;
        }

        this.actors[targetID].send(type, data, callback, buffers);
        return targetID;
    },

    remove: function() {
        for (var i = 0; i < this.actors.length; i++) {
            this.actors[i].target.terminate();
        }
        this.actors = [];
    }
};

},{"../../source/worker":53,"../actor":101,"webworkify":188}],106:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

exports.create = function (tagName, className, container) {
    var el = document.createElement(tagName);
    if (className) el.className = className;
    if (container) container.appendChild(el);
    return el;
};

var docStyle = document.documentElement.style;

function testProp(props) {
    for (var i = 0; i < props.length; i++) {
        if (props[i] in docStyle) {
            return props[i];
        }
    }
}

var selectProp = testProp(['userSelect', 'MozUserSelect', 'WebkitUserSelect', 'msUserSelect']),
    userSelect;
exports.disableDrag = function () {
    if (selectProp) {
        userSelect = docStyle[selectProp];
        docStyle[selectProp] = 'none';
    }
};
exports.enableDrag = function () {
    if (selectProp) {
        docStyle[selectProp] = userSelect;
    }
};

var transformProp = testProp(['transform', 'WebkitTransform']);
exports.setTransform = function(el, value) {
    el.style[transformProp] = value;
};

// Suppress the next click, but only if it's immediate.
function suppressClick(e) {
    e.preventDefault();
    e.stopPropagation();
    window.removeEventListener('click', suppressClick, true);
}
exports.suppressClick = function() {
    window.addEventListener('click', suppressClick, true);
    window.setTimeout(function() {
        window.removeEventListener('click', suppressClick, true);
    }, 0);
};

exports.mousePos = function (el, e) {
    var rect = el.getBoundingClientRect();
    e = e.touches ? e.touches[0] : e;
    return new Point(
        e.clientX - rect.left - el.clientLeft,
        e.clientY - rect.top - el.clientTop
    );
};

exports.touchPos = function (el, e) {
    var rect = el.getBoundingClientRect(),
        points = [];
    for (var i = 0; i < e.touches.length; i++) {
        points.push(new Point(
            e.touches[i].clientX - rect.left - el.clientLeft,
            e.touches[i].clientY - rect.top - el.clientTop
        ));
    }
    return points;
};

},{"point-geometry":172}],107:[function(require,module,exports){
'use strict';

module.exports = {
    API_URL: 'https://api.mapbox.com',
    REQUIRE_ACCESS_TOKEN: true
};

},{}],108:[function(require,module,exports){
'use strict';

var assert = require('assert');

module.exports = DictionaryCoder;

function DictionaryCoder(strings) {
    this._stringToNumber = {};
    this._numberToString = [];
    for (var i = 0; i < strings.length; i++) {
        var string = strings[i];
        this._stringToNumber[string] = i;
        this._numberToString[i] = string;
    }
}

DictionaryCoder.prototype.encode = function(string) {
    assert(string in this._stringToNumber);
    return this._stringToNumber[string];
};

DictionaryCoder.prototype.decode = function(n) {
    assert(n < this._numberToString.length);
    return this._numberToString[n];
};

},{"assert":9}],109:[function(require,module,exports){
'use strict';

var util = require('./util');

/**
 * Methods mixed in to other classes for event capabilities.
 * @mixin Evented
 */
var Evented = {

    /**
     * Subscribe to a specified event with a listener function the latter gets the data object that was passed to `fire` and additionally `target` and `type` properties
     *
     * @param {string} type Event type
     * @param {Function} listener Function to be called when the event is fired
     * @returns {Object} `this`
     */
    on: function(type, listener) {
        this._events = this._events || {};
        this._events[type] = this._events[type] || [];
        this._events[type].push(listener);

        return this;
    },

    /**
     * Remove a event listener
     *
     * @param {string} [type] Event type. If none is specified, remove all listeners
     * @param {Function} [listener] Function to be called when the event is fired. If none is specified all listeners are removed
     * @returns {Object} `this`
     */
    off: function(type, listener) {
        if (!type) {
            // clear all listeners if no arguments specified
            delete this._events;
            return this;
        }

        if (!this.listens(type)) return this;

        if (listener) {
            var idx = this._events[type].indexOf(listener);
            if (idx >= 0) {
                this._events[type].splice(idx, 1);
            }
            if (!this._events[type].length) {
                delete this._events[type];
            }
        } else {
            delete this._events[type];
        }

        return this;
    },

    /**
     * Call a function once when an event has fired
     *
     * @param {string} type Event type.
     * @param {Function} listener Function to be called once when the event is fired
     * @returns {Object} `this`
     */
    once: function(type, listener) {
        var wrapper = function(data) {
            this.off(type, wrapper);
            listener.call(this, data);
        }.bind(this);
        this.on(type, wrapper);
        return this;
    },

    /**
     * Fire event of a given string type with the given data object
     *
     * @param {string} type Event type
     * @param {Object} [data] Optional data passed to the event receiver (e.g. {@link #EventData})
     * @returns {Object} `this`
     */
    fire: function(type, data) {
        if (!this.listens(type)) return this;

        data = util.extend({}, data);
        util.extend(data, {type: type, target: this});

        // make sure adding/removing listeners inside other listeners won't cause infinite loop
        var listeners = this._events[type].slice();

        for (var i = 0; i < listeners.length; i++) {
            listeners[i].call(this, data);
        }

        return this;
    },

    /**
     * Check if an event is registered to a type
     * @param {string} type Event type
     * @returns {boolean} `true` if there is at least one registered listener for events of type `type`
     */
    listens: function(type) {
        return !!(this._events && this._events[type]);
    }
};

module.exports = Evented;

},{"./util":117}],110:[function(require,module,exports){
'use strict';

module.exports = Glyphs;

function Glyphs(pbf, end) {
    this.stacks = pbf.readFields(readFontstacks, [], end);
}

function readFontstacks(tag, stacks, pbf) {
    if (tag === 1) {
        var fontstack = pbf.readMessage(readFontstack, {glyphs: {}});
        stacks.push(fontstack);
    }
}

function readFontstack(tag, fontstack, pbf) {
    if (tag === 1) fontstack.name = pbf.readString();
    else if (tag === 2) fontstack.range = pbf.readString();
    else if (tag === 3) {
        var glyph = pbf.readMessage(readGlyph, {});
        fontstack.glyphs[glyph.id] = glyph;
    }
}

function readGlyph(tag, glyph, pbf) {
    if (tag === 1) glyph.id = pbf.readVarint();
    else if (tag === 2) glyph.bitmap = pbf.readBytes();
    else if (tag === 3) glyph.width = pbf.readVarint();
    else if (tag === 4) glyph.height = pbf.readVarint();
    else if (tag === 5) glyph.left = pbf.readSVarint();
    else if (tag === 6) glyph.top = pbf.readSVarint();
    else if (tag === 7) glyph.advance = pbf.readVarint();
}

},{}],111:[function(require,module,exports){
'use strict';

module.exports = interpolate;

function interpolate(a, b, t) {
    return (a * (1 - t)) + (b * t);
}

interpolate.number = interpolate;

interpolate.vec2 = function(from, to, t) {
    return [
        interpolate(from[0], to[0], t),
        interpolate(from[1], to[1], t)
    ];
};

/*
 * Interpolate between two colors given as 4-element arrays.
 *
 * @param {Color} from
 * @param {Color} to
 * @param {number} t interpolation factor between 0 and 1
 * @returns {Color} interpolated color
 */
interpolate.color = function(from, to, t) {
    return [
        interpolate(from[0], to[0], t),
        interpolate(from[1], to[1], t),
        interpolate(from[2], to[2], t),
        interpolate(from[3], to[3], t)
    ];
};

interpolate.array = function(from, to, t) {
    return from.map(function(d, i) {
        return interpolate(d, to[i], t);
    });
};

},{}],112:[function(require,module,exports){
'use strict';

module.exports = {
    multiPolygonIntersectsBufferedMultiPoint: multiPolygonIntersectsBufferedMultiPoint,
    multiPolygonIntersectsMultiPolygon: multiPolygonIntersectsMultiPolygon,
    multiPolygonIntersectsBufferedMultiLine: multiPolygonIntersectsBufferedMultiLine
};

function multiPolygonIntersectsBufferedMultiPoint(multiPolygon, rings, radius) {
    for (var j = 0; j < multiPolygon.length; j++) {
        var polygon = multiPolygon[j];
        for (var i = 0; i < rings.length; i++) {
            var ring = rings[i];
            for (var k = 0; k < ring.length; k++) {
                var point = ring[k];
                if (polygonContainsPoint(polygon, point)) return true;
                if (pointIntersectsBufferedLine(point, polygon, radius)) return true;
            }
        }
    }
    return false;
}

function multiPolygonIntersectsMultiPolygon(multiPolygonA, multiPolygonB) {

    if (multiPolygonA.length === 1 && multiPolygonA[0].length === 1) {
        return multiPolygonContainsPoint(multiPolygonB, multiPolygonA[0][0]);
    }

    for (var m = 0; m < multiPolygonB.length; m++) {
        var ring = multiPolygonB[m];
        for (var n = 0; n < ring.length; n++) {
            if (multiPolygonContainsPoint(multiPolygonA, ring[n])) return true;
        }
    }

    for (var j = 0; j < multiPolygonA.length; j++) {
        var polygon = multiPolygonA[j];
        for (var i = 0; i < polygon.length; i++) {
            if (multiPolygonContainsPoint(multiPolygonB, polygon[i])) return true;
        }

        for (var k = 0; k < multiPolygonB.length; k++) {
            if (lineIntersectsLine(polygon, multiPolygonB[k])) return true;
        }
    }

    return false;
}

function multiPolygonIntersectsBufferedMultiLine(multiPolygon, multiLine, radius) {
    for (var i = 0; i < multiLine.length; i++) {
        var line = multiLine[i];

        for (var j = 0; j < multiPolygon.length; j++) {
            var polygon = multiPolygon[j];

            if (polygon.length >= 3) {
                for (var k = 0; k < line.length; k++) {
                    if (polygonContainsPoint(polygon, line[k])) return true;
                }
            }

            if (lineIntersectsBufferedLine(polygon, line, radius)) return true;
        }
    }
    return false;
}

function lineIntersectsBufferedLine(lineA, lineB, radius) {

    if (lineA.length > 1) {
        if (lineIntersectsLine(lineA, lineB)) return true;

        // Check whether any point in either line is within radius of the other line
        for (var j = 0; j < lineB.length; j++) {
            if (pointIntersectsBufferedLine(lineB[j], lineA, radius)) return true;
        }
    }

    for (var k = 0; k < lineA.length; k++) {
        if (pointIntersectsBufferedLine(lineA[k], lineB, radius)) return true;
    }

    return false;
}

function lineIntersectsLine(lineA, lineB) {
    for (var i = 0; i < lineA.length - 1; i++) {
        var a0 = lineA[i];
        var a1 = lineA[i + 1];
        for (var j = 0; j < lineB.length - 1; j++) {
            var b0 = lineB[j];
            var b1 = lineB[j + 1];
            if (lineSegmentIntersectsLineSegment(a0, a1, b0, b1)) return true;
        }
    }
    return false;
}


// http://bryceboe.com/2006/10/23/line-segment-intersection-algorithm/
function isCounterClockwise(a, b, c) {
    return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);
}

function lineSegmentIntersectsLineSegment(a0, a1, b0, b1) {
    return isCounterClockwise(a0, b0, b1) !== isCounterClockwise(a1, b0, b1) &&
        isCounterClockwise(a0, a1, b0) !== isCounterClockwise(a0, a1, b1);
}

function pointIntersectsBufferedLine(p, line, radius) {
    var radiusSquared = radius * radius;

    if (line.length === 1) return p.distSqr(line[0]) < radiusSquared;

    for (var i = 1; i < line.length; i++) {
        // Find line segments that have a distance <= radius^2 to p
        // In that case, we treat the line as "containing point p".
        var v = line[i - 1], w = line[i];
        if (distToSegmentSquared(p, v, w) < radiusSquared) return true;
    }
    return false;
}

// Code from http://stackoverflow.com/a/1501725/331379.
function distToSegmentSquared(p, v, w) {
    var l2 = v.distSqr(w);
    if (l2 === 0) return p.distSqr(v);
    var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    if (t < 0) return p.distSqr(v);
    if (t > 1) return p.distSqr(w);
    return p.distSqr(w.sub(v)._mult(t)._add(v));
}

// point in polygon ray casting algorithm
function multiPolygonContainsPoint(rings, p) {
    var c = false,
        ring, p1, p2;

    for (var k = 0; k < rings.length; k++) {
        ring = rings[k];
        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
            p1 = ring[i];
            p2 = ring[j];
            if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
                c = !c;
            }
        }
    }
    return c;
}

function polygonContainsPoint(ring, p) {
    var c = false;
    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        var p1 = ring[i];
        var p2 = ring[j];
        if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
            c = !c;
        }
    }
    return c;
}

},{}],113:[function(require,module,exports){
'use strict';

module.exports = LRUCache;

/**
 * A [least-recently-used cache](http://en.wikipedia.org/wiki/Cache_algorithms)
 * with hash lookup made possible by keeping a list of keys in parallel to
 * an array of dictionary of values
 *
 * @param {number} max number of permitted values
 * @param {Function} onRemove callback called with items when they expire
 * @private
 */
function LRUCache(max, onRemove) {
    this.max = max;
    this.onRemove = onRemove;
    this.reset();
}

/**
 * Clear the cache
 *
 * @returns {LRUCache} this cache
 * @private
 */
LRUCache.prototype.reset = function() {
    for (var key in this.data) {
        this.onRemove(this.data[key]);
    }

    this.data = {};
    this.order = [];

    return this;
};

/**
 * Add a key, value combination to the cache, trimming its size if this pushes
 * it over max length.
 *
 * @param {string} key lookup key for the item
 * @param {*} data any value
 *
 * @returns {LRUCache} this cache
 * @private
 */
LRUCache.prototype.add = function(key, data) {

    if (this.has(key)) {
        this.order.splice(this.order.indexOf(key), 1);
        this.data[key] = data;
        this.order.push(key);

    } else {
        this.data[key] = data;
        this.order.push(key);

        if (this.order.length > this.max) {
            var removedData = this.get(this.order[0]);
            if (removedData) this.onRemove(removedData);
        }
    }

    return this;
};

/**
 * Determine whether the value attached to `key` is present
 *
 * @param {string} key the key to be looked-up
 * @returns {boolean} whether the cache has this value
 * @private
 */
LRUCache.prototype.has = function(key) {
    return key in this.data;
};

/**
 * List all keys in the cache
 *
 * @returns {Array<string>} an array of keys in this cache.
 * @private
 */
LRUCache.prototype.keys = function() {
    return this.order;
};

/**
 * Get the value attached to a specific key. If the key is not found,
 * returns `null`
 *
 * @param {string} key the key to look up
 * @returns {*} the data, or null if it isn't found
 * @private
 */
LRUCache.prototype.get = function(key) {
    if (!this.has(key)) { return null; }

    var data = this.data[key];

    delete this.data[key];
    this.order.splice(this.order.indexOf(key), 1);

    return data;
};

/**
 * Change the max size of the cache.
 *
 * @param {number} max the max size of the cache
 * @returns {LRUCache} this cache
 * @private
 */
LRUCache.prototype.setMaxSize = function(max) {
    this.max = max;

    while (this.order.length > this.max) {
        var removedData = this.get(this.order[0]);
        if (removedData) this.onRemove(removedData);
    }

    return this;
};

},{}],114:[function(require,module,exports){
'use strict';

var config = require('./config');
var browser = require('./browser');

function normalizeURL(url, pathPrefix, accessToken) {
    accessToken = accessToken || config.ACCESS_TOKEN;

    if (!accessToken && config.REQUIRE_ACCESS_TOKEN) {
        throw new Error('An API access token is required to use Mapbox GL. ' +
            'See https://www.mapbox.com/developers/api/#access-tokens');
    }

    url = url.replace(/^mapbox:\/\//, config.API_URL + pathPrefix);
    url += url.indexOf('?') !== -1 ? '&access_token=' : '?access_token=';

    if (config.REQUIRE_ACCESS_TOKEN) {
        if (accessToken[0] === 's') {
            throw new Error('Use a public access token (pk.*) with Mapbox GL JS, not a secret access token (sk.*). ' +
                'See https://www.mapbox.com/developers/api/#access-tokens');
        }

        url += accessToken;
    }

    return url;
}

module.exports.normalizeStyleURL = function(url, accessToken) {
    if (!url.match(/^mapbox:\/\/styles\//))
        return url;

    var split = url.split('/');
    var user = split[3];
    var style = split[4];
    var draft = split[5] ? '/draft' : '';
    return normalizeURL('mapbox://' + user + '/' + style + draft, '/styles/v1/', accessToken);
};

module.exports.normalizeSourceURL = function(url, accessToken) {
    if (!url.match(/^mapbox:\/\//))
        return url;

    // TileJSON requests need a secure flag appended to their URLs so
    // that the server knows to send SSL-ified resource references.
    return normalizeURL(url + '.json', '/v4/', accessToken) + '&secure';
};

module.exports.normalizeGlyphsURL = function(url, accessToken) {
    if (!url.match(/^mapbox:\/\//))
        return url;

    var user = url.split('/')[3];
    return normalizeURL('mapbox://' + user + '/{fontstack}/{range}.pbf', '/fonts/v1/', accessToken);
};

module.exports.normalizeSpriteURL = function(url, format, ext, accessToken) {
    if (!url.match(/^mapbox:\/\/sprites\//))
        return url + format + ext;

    var split = url.split('/');
    var user = split[3];
    var style = split[4];
    var draft = split[5] ? '/draft' : '';
    return normalizeURL('mapbox://' + user + '/' + style + draft + '/sprite' + format + ext, '/styles/v1/', accessToken);
};

module.exports.normalizeTileURL = function(url, sourceUrl, tileSize) {
    if (!sourceUrl || !sourceUrl.match(/^mapbox:\/\//))
        return url;

    // The v4 mapbox tile API supports 512x512 image tiles only when @2x
    // is appended to the tile URL. If `tileSize: 512` is specified for
    // a Mapbox raster source force the @2x suffix even if a non hidpi
    // device.
    url = url.replace(/([?&]access_token=)tk\.[^&]+/, '$1' + config.ACCESS_TOKEN);
    var extension = browser.supportsWebp ? 'webp' : '$1';
    return url.replace(/\.((?:png|jpg)\d*)(?=$|\?)/, browser.devicePixelRatio >= 2 || tileSize === 512 ? '@2x.' + extension : '.' + extension);
};

},{"./browser":103,"./config":107}],115:[function(require,module,exports){
'use strict';

// Note: all "sizes" are measured in bytes

var assert = require('assert');

module.exports = StructArrayType;

var viewTypes = {
    'Int8': Int8Array,
    'Uint8': Uint8Array,
    'Uint8Clamped': Uint8ClampedArray,
    'Int16': Int16Array,
    'Uint16': Uint16Array,
    'Int32': Int32Array,
    'Uint32': Uint32Array,
    'Float32': Float32Array,
    'Float64': Float64Array
};

/**
 * @typedef StructMember
 * @private
 * @property {string} name
 * @property {string} type
 * @property {number} components
 */

var structArrayTypeCache = {};

/**
 * `StructArrayType` is used to create new `StructArray` types.
 *
 * `StructArray` provides an abstraction over `ArrayBuffer` and `TypedArray` making it behave like
 * an array of typed structs. A StructArray is comprised of elements. Each element has a set of
 * members that are defined when the `StructArrayType` is created.
 *
 * StructArrays useful for creating large arrays that:
 * - can be transferred from workers as a Transferable object
 * - can be copied cheaply
 * - use less memory for lower-precision members
 * - can be used as buffers in WebGL.
 *
 * @class StructArrayType
 * @param {Array.<StructMember>}
 * @param options
 * @param {number} options.alignment Use `4` to align members to 4 byte boundaries. Default is 1.
 *
 * @example
 *
 * var PointArrayType = new StructArrayType({
 *  members: [
 *      { type: 'Int16', name: 'x' },
 *      { type: 'Int16', name: 'y' }
 *  ]});
 *
 *  var pointArray = new PointArrayType();
 *  pointArray.emplaceBack(10, 15);
 *  pointArray.emplaceBack(20, 35);
 *
 *  point = pointArray.get(0);
 *  assert(point.x === 10);
 *  assert(point.y === 15);
 *
 * @private
 */
function StructArrayType(options) {

    var key = JSON.stringify(options);
    if (structArrayTypeCache[key]) {
        return structArrayTypeCache[key];
    }

    if (options.alignment === undefined) options.alignment = 1;

    function StructType() {
        Struct.apply(this, arguments);
    }

    StructType.prototype = Object.create(Struct.prototype);

    var offset = 0;
    var maxSize = 0;
    var usedTypes = ['Uint8'];

    StructType.prototype.members = options.members.map(function(member) {
        member = {
            name: member.name,
            type: member.type,
            components: member.components || 1
        };

        assert(member.name.length);
        assert(member.type in viewTypes);

        if (usedTypes.indexOf(member.type) < 0) usedTypes.push(member.type);

        var typeSize = sizeOf(member.type);
        maxSize = Math.max(maxSize, typeSize);
        member.offset = offset = align(offset, Math.max(options.alignment, typeSize));

        for (var c = 0; c < member.components; c++) {
            Object.defineProperty(StructType.prototype, member.name + (member.components === 1 ? '' : c), {
                get: createGetter(member, c),
                set: createSetter(member, c)
            });
        }

        offset += typeSize * member.components;

        return member;
    });

    StructType.prototype.alignment = options.alignment;
    StructType.prototype.size = align(offset, Math.max(maxSize, options.alignment));

    function StructArrayType() {
        StructArray.apply(this, arguments);
        this.members = StructType.prototype.members;
    }

    StructArrayType.serialize = serializeStructArrayType;

    StructArrayType.prototype = Object.create(StructArray.prototype);
    StructArrayType.prototype.StructType = StructType;
    StructArrayType.prototype.bytesPerElement = StructType.prototype.size;
    StructArrayType.prototype.emplaceBack = createEmplaceBack(StructType.prototype.members, StructType.prototype.size);
    StructArrayType.prototype._usedTypes = usedTypes;


    structArrayTypeCache[key] = StructArrayType;

    return StructArrayType;
}

/**
 * Serialize the StructArray type. This serializes the *type* not an instance of the type.
 * @private
 */
function serializeStructArrayType() {
    return {
        members: this.prototype.StructType.prototype.members,
        alignment: this.prototype.StructType.prototype.alignment,
        bytesPerElement: this.prototype.bytesPerElement
    };
}


function align(offset, size) {
    return Math.ceil(offset / size) * size;
}

function sizeOf(type) {
    return viewTypes[type].BYTES_PER_ELEMENT;
}

function getArrayViewName(type) {
    return type.toLowerCase();
}


/*
 * > I saw major perf gains by shortening the source of these generated methods (i.e. renaming
 * > elementIndex to i) (likely due to v8 inlining heuristics).
 * - lucaswoj
 */
function createEmplaceBack(members, bytesPerElement) {
    var usedTypeSizes = [];
    var argNames = [];
    var body = '' +
    'var i = this.length;\n' +
    'this.resize(this.length + 1);\n';

    for (var m = 0; m < members.length; m++) {
        var member = members[m];
        var size = sizeOf(member.type);

        if (usedTypeSizes.indexOf(size) < 0) {
            usedTypeSizes.push(size);
            body += 'var o' + size.toFixed(0) + ' = i * ' + (bytesPerElement / size).toFixed(0) + ';\n';
        }

        for (var c = 0; c < member.components; c++) {
            var argName = 'v' + argNames.length;
            var index = 'o' + size.toFixed(0) + ' + ' + (member.offset / size + c).toFixed(0);
            body += 'this.' + getArrayViewName(member.type) + '[' + index + '] = ' + argName + ';\n';
            argNames.push(argName);
        }
    }

    body += 'return i;';

    return new Function(argNames, body);
}

function createMemberComponentString(member, component) {
    var elementOffset = 'this._pos' + sizeOf(member.type).toFixed(0);
    var componentOffset = (member.offset / sizeOf(member.type) + component).toFixed(0);
    var index = elementOffset + ' + ' + componentOffset;
    return 'this._structArray.' + getArrayViewName(member.type) + '[' + index + ']';

}

function createGetter(member, c) {
    return new Function([], 'return ' + createMemberComponentString(member, c) + ';');
}

function createSetter(member, c) {
    return new Function(['x'], createMemberComponentString(member, c) + ' = x;');
}

/**
 * @class Struct
 * @param {StructArray} structArray The StructArray the struct is stored in
 * @param {number} index The index of the struct in the StructArray.
 * @private
 */
function Struct(structArray, index) {
    this._structArray = structArray;
    this._pos1 = index * this.size;
    this._pos2 = this._pos1 / 2;
    this._pos4 = this._pos1 / 4;
    this._pos8 = this._pos1 / 8;
}

/**
 * @class StructArray
 * The StructArray class is inherited by the custom StructArrayType classes created with
 * `new StructArrayType(members, options)`.
 * @private
 */
function StructArray(serialized) {
    if (serialized !== undefined) {
    // Create from an serialized StructArray
        this.arrayBuffer = serialized.arrayBuffer;
        this.length = serialized.length;
        this.capacity = this.arrayBuffer.byteLength / this.bytesPerElement;
        this._refreshViews();

    // Create a new StructArray
    } else {
        this.capacity = -1;
        this.resize(0);
    }
}

/**
 * @property {number}
 * @private
 * @readonly
 */
StructArray.prototype.DEFAULT_CAPACITY = 128;

/**
 * @property {number}
 * @private
 * @readonly
 */
StructArray.prototype.RESIZE_MULTIPLIER = 5;

/**
 * Serialize this StructArray instance
 * @private
 */
StructArray.prototype.serialize = function() {
    this.trim();
    return {
        length: this.length,
        arrayBuffer: this.arrayBuffer
    };
};

/**
 * Return the Struct at the given location in the array.
 * @private
 * @param {number} index The index of the element.
 */
StructArray.prototype.get = function(index) {
    return new this.StructType(this, index);
};

/**
 * Resize the array to discard unused capacity.
 * @private
 */
StructArray.prototype.trim = function() {
    if (this.length !== this.capacity) {
        this.capacity = this.length;
        this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement);
        this._refreshViews();
    }
};

/**
 * Resize the array.
 * If `n` is greater than the current length then additional elements with undefined values are added.
 * If `n` is less than the current length then the array will be reduced to the first `n` elements.
 * @param {number} n The new size of the array.
 */
StructArray.prototype.resize = function(n) {
    this.length = n;
    if (n > this.capacity) {
        this.capacity = Math.max(n, Math.floor(this.capacity * this.RESIZE_MULTIPLIER), this.DEFAULT_CAPACITY);
        this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);

        var oldUint8Array = this.uint8;
        this._refreshViews();
        if (oldUint8Array) this.uint8.set(oldUint8Array);
    }
};

/**
 * Create TypedArray views for the current ArrayBuffer.
 * @private
 */
StructArray.prototype._refreshViews = function() {
    for (var t = 0; t < this._usedTypes.length; t++) {
        var type = this._usedTypes[t];
        this[getArrayViewName(type)] = new viewTypes[type](this.arrayBuffer);
    }
};

},{"assert":9}],116:[function(require,module,exports){
'use strict';

module.exports = resolveTokens;

/**
 * Replace tokens in a string template with values in an object
 *
 * @param {Object} properties a key/value relationship between tokens and replacements
 * @param {string} text the template string
 * @returns {string} the template with tokens replaced
 * @private
 */
function resolveTokens(properties, text) {
    return text.replace(/{([^{}()\[\]<>$=:;.,^]+)}/g, function(match, key) {
        return key in properties ? properties[key] : '';
    });
}

},{}],117:[function(require,module,exports){
'use strict';

var UnitBezier = require('unitbezier');
var Coordinate = require('../geo/coordinate');

/**
 * Given a value `t` that varies between 0 and 1, return
 * an interpolation function that eases between 0 and 1 in a pleasing
 * cubic in-out fashion.
 *
 * @param {number} t input
 * @returns {number} input
 * @private
 */
exports.easeCubicInOut = function (t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t,
        t3 = t2 * t;
    return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
};

/**
 * Given given (x, y), (x1, y1) control points for a bezier curve,
 * return a function that interpolates along that curve.
 *
 * @param {number} p1x control point 1 x coordinate
 * @param {number} p1y control point 1 y coordinate
 * @param {number} p2x control point 2 x coordinate
 * @param {number} p2y control point 2 y coordinate
 * @returns {Function} interpolator: receives number value, returns
 * number value.
 * @private
 */
exports.bezier = function(p1x, p1y, p2x, p2y) {
    var bezier = new UnitBezier(p1x, p1y, p2x, p2y);
    return function(t) {
        return bezier.solve(t);
    };
};

/**
 * A default bezier-curve powered easing function with
 * control points (0.25, 0.1) and (0.25, 1)
 *
 * @param {number} t
 * @returns {number} output
 * @private
 */
exports.ease = exports.bezier(0.25, 0.1, 0.25, 1);

/**
 * Given a four-element array of numbers that represents a color in
 * RGBA, return a version for which the RGB components are multiplied
 * by the A (alpha) component
 *
 * @param {Array<number>} color color array
 * @returns {Array<number>} premultiplied color array
 * @private
 */
exports.premultiply = function (color) {
    if (!color) return null;
    var opacity = color[3];
    return [
        color[0] * opacity,
        color[1] * opacity,
        color[2] * opacity,
        opacity
    ];
};

/**
 * constrain n to the given range via min + max
 *
 * @param {number} n value
 * @param {number} min the minimum value to be returned
 * @param {number} max the maximum value to be returned
 * @returns {number} the clamped value
 * @private
 */
exports.clamp = function (n, min, max) {
    return Math.min(max, Math.max(min, n));
};

/*
 * constrain n to the given range, excluding the minimum, via modular arithmetic
 * @param {number} n value
 * @param {number} min the minimum value to be returned, exclusive
 * @param {number} max the maximum value to be returned, inclusive
 * @returns {number} constrained number
 * @private
 */
exports.wrap = function (n, min, max) {
    var d = max - min;
    var w = ((n - min) % d + d) % d + min;
    return (w === min) ? max : w;
};

/*
 * return the first non-null and non-undefined argument to this function.
 * @returns {*} argument
 * @private
 */
exports.coalesce = function() {
    for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (arg !== null && arg !== undefined)
            return arg;
    }
};

/*
 * Call an asynchronous function on an array of arguments,
 * calling `callback` with the completed results of all calls.
 *
 * @param {Array<*>} array input to each call of the async function.
 * @param {Function} fn an async function with signature (data, callback)
 * @param {Function} callback a callback run after all async work is done.
 * called with an array, containing the results of each async call.
 * @returns {undefined}
 * @private
 */
exports.asyncAll = function (array, fn, callback) {
    if (!array.length) { return callback(null, []); }
    var remaining = array.length;
    var results = new Array(array.length);
    var error = null;
    array.forEach(function (item, i) {
        fn(item, function (err, result) {
            if (err) error = err;
            results[i] = result;
            if (--remaining === 0) callback(error, results);
        });
    });
};

/*
 * Compute the difference between the keys in one object and the keys
 * in another object.
 *
 * @param {Object} obj
 * @param {Object} other
 * @returns {Array<string>} keys difference
 * @private
 */
exports.keysDifference = function (obj, other) {
    var difference = [];
    for (var i in obj) {
        if (!(i in other)) {
            difference.push(i);
        }
    }
    return difference;
};

/**
 * Given a destination object and optionally many source objects,
 * copy all properties from the source objects into the destination.
 * The last source object given overrides properties from previous
 * source objects.
 * @param {Object} dest destination object
 * @param {...Object} sources sources from which properties are pulled
 * @returns {Object} dest
 * @private
 */
exports.extend = function (dest) {
    for (var i = 1; i < arguments.length; i++) {
        var src = arguments[i];
        for (var k in src) {
            dest[k] = src[k];
        }
    }
    return dest;
};

/**
 * Extend a destination object with all properties of the src object,
 * using defineProperty instead of simple assignment.
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 * @private
 */
exports.extendAll = function (dest, src) {
    for (var i in src) {
        Object.defineProperty(dest, i, Object.getOwnPropertyDescriptor(src, i));
    }
    return dest;
};

/**
 * Extend a parent's prototype with all properties in a properties
 * object.
 *
 * @param {Object} parent
 * @param {Object} props
 * @returns {Object}
 * @private
 */
exports.inherit = function (parent, props) {
    var parentProto = typeof parent === 'function' ? parent.prototype : parent,
        proto = Object.create(parentProto);
    exports.extendAll(proto, props);
    return proto;
};

/**
 * Given an object and a number of properties as strings, return version
 * of that object with only those properties.
 *
 * @param {Object} src the object
 * @param {Array<string>} properties an array of property names chosen
 * to appear on the resulting object.
 * @returns {Object} object with limited properties.
 * @example
 * var foo = { name: 'Charlie', age: 10 };
 * var justName = pick(foo, ['name']);
 * // justName = { name: 'Charlie' }
 * @private
 */
exports.pick = function (src, properties) {
    var result = {};
    for (var i = 0; i < properties.length; i++) {
        var k = properties[i];
        if (k in src) {
            result[k] = src[k];
        }
    }
    return result;
};

var id = 1;

/**
 * Return a unique numeric id, starting at 1 and incrementing with
 * each call.
 *
 * @returns {number} unique numeric id.
 * @private
 */
exports.uniqueId = function () {
    return id++;
};

/**
 * Create a version of `fn` that is only called `time` milliseconds
 * after its last invocation
 *
 * @param {Function} fn the function to be debounced
 * @param {number} time millseconds after which the function will be invoked
 * @returns {Function} debounced function
 * @private
 */
exports.debounce = function(fn, time) {
    var timer, args;

    return function() {
        args = arguments;
        clearTimeout(timer);

        timer = setTimeout(function() {
            fn.apply(null, args);
        }, time);
    };
};

/**
 * Given an array of member function names as strings, replace all of them
 * with bound versions that will always refer to `context` as `this`. This
 * is useful for classes where otherwise event bindings would reassign
 * `this` to the evented object or some other value: this lets you ensure
 * the `this` value always.
 *
 * @param {Array<string>} fns list of member function names
 * @param {*} context the context value
 * @returns {undefined} changes functions in-place
 * @example
 * function MyClass() {
 *   bindAll(['ontimer'], this);
 *   this.name = 'Tom';
 * }
 * MyClass.prototype.ontimer = function() {
 *   alert(this.name);
 * };
 * var myClass = new MyClass();
 * setTimeout(myClass.ontimer, 100);
 * @private
 */
exports.bindAll = function(fns, context) {
    fns.forEach(function(fn) {
        context[fn] = context[fn].bind(context);
    });
};

/**
 * Given a class, bind all of the methods that look like handlers: that
 * begin with _on, and bind them to the class.
 *
 * @param {Object} context an object with methods
 * @private
 */
exports.bindHandlers = function(context) {
    for (var i in context) {
        if (typeof context[i] === 'function' && i.indexOf('_on') === 0) {
            context[i] = context[i].bind(context);
        }
    }
};

/**
 * Set the 'options' property on `obj` with properties
 * from the `options` argument. Properties in the `options`
 * object will override existing properties.
 *
 * @param {Object} obj destination object
 * @param {Object} options object of override options
 * @returns {Object} derived options object.
 * @private
 */
exports.setOptions = function(obj, options) {
    if (!obj.hasOwnProperty('options')) {
        obj.options = obj.options ? Object.create(obj.options) : {};
    }
    for (var i in options) {
        obj.options[i] = options[i];
    }
    return obj.options;
};

/**
 * Given a list of coordinates, get their center as a coordinate.
 * @param {Array<Coordinate>} coords
 * @returns {Coordinate} centerpoint
 * @private
 */
exports.getCoordinatesCenter = function(coords) {
    var minX = Infinity;
    var minY = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;

    for (var i = 0; i < coords.length; i++) {
        minX = Math.min(minX, coords[i].column);
        minY = Math.min(minY, coords[i].row);
        maxX = Math.max(maxX, coords[i].column);
        maxY = Math.max(maxY, coords[i].row);
    }

    var dx = maxX - minX;
    var dy = maxY - minY;
    var dMax = Math.max(dx, dy);
    return new Coordinate((minX + maxX) / 2, (minY + maxY) / 2, 0)
        .zoomTo(Math.floor(-Math.log(dMax) / Math.LN2));
};

/**
 * Determine if a string ends with a particular substring
 * @param {string} string
 * @param {string} suffix
 * @returns {boolean}
 * @private
 */
exports.endsWith = function(string, suffix) {
    return string.indexOf(suffix, string.length - suffix.length) !== -1;
};

/**
 * Determine if a string starts with a particular substring
 * @param {string} string
 * @param {string} prefix
 * @returns {boolean}
 * @private
 */
exports.startsWith = function(string, prefix) {
    return string.indexOf(prefix) === 0;
};

/**
 * Create an object by mapping all the values of an existing object while
 * preserving their keys.
 * @param {Object} input
 * @param {Function} iterator
 * @returns {Object}
 * @private
 */
exports.mapObject = function(input, iterator, context) {
    var output = {};
    for (var key in input) {
        output[key] = iterator.call(context || this, input[key], key, input);
    }
    return output;
};

/**
 * Create an object by filtering out values of an existing object
 * @param {Object} input
 * @param {Function} iterator
 * @returns {Object}
 * @private
 */
exports.filterObject = function(input, iterator, context) {
    var output = {};
    for (var key in input) {
        if (iterator.call(context || this, input[key], key, input)) {
            output[key] = input[key];
        }
    }
    return output;
};

/**
 * Deeply compares two object literals.
 * @param {Object} obj1
 * @param {Object} obj2
 * @returns {boolean}
 * @private
 */
exports.deepEqual = function deepEqual(a, b) {
    if (Array.isArray(a)) {
        if (!Array.isArray(b) || a.length !== b.length) return false;
        for (var i = 0; i < a.length; i++) {
            if (!deepEqual(a[i], b[i])) return false;
        }
        return true;
    }
    if (typeof a === 'object') {
        if (!(typeof b === 'object')) return false;
        var keys = Object.keys(a);
        if (keys.length !== Object.keys(b).length) return false;
        for (var key in a) {
            if (!deepEqual(a[key], b[key])) return false;
        }
        return true;
    }
    return a === b;
};

/**
 * Deeply clones two objects.
 * @param {Object} obj1
 * @param {Object} obj2
 * @returns {boolean}
 * @private
 */
exports.clone = function deepEqual(input) {
    if (Array.isArray(input)) {
        return input.map(exports.clone);
    } else if (typeof input === 'object') {
        return exports.mapObject(input, exports.clone);
    } else {
        return input;
    }
};

/**
 * Check if two arrays have at least one common element.
 * @param {Array} a
 * @param {Array} b
 * @returns {boolean}
 * @private
 */
exports.arraysIntersect = function(a, b) {
    for (var l = 0; l < a.length; l++) {
        if (b.indexOf(a[l]) >= 0) return true;
    }
    return false;
};

},{"../geo/coordinate":23,"unitbezier":180}],118:[function(require,module,exports){
'use strict';

var VectorTileFeature = require('vector-tile').VectorTileFeature;

module.exports = Feature;

function Feature(vectorTileFeature, z, x, y) {
    this._vectorTileFeature = vectorTileFeature;
    vectorTileFeature._z = z;
    vectorTileFeature._x = x;
    vectorTileFeature._y = y;

    this.properties = vectorTileFeature.properties;

    if (vectorTileFeature._id) {
        this.id = vectorTileFeature._id;
    }
}

Feature.prototype = {
    type: "Feature",

    get geometry() {
        if (this._geometry === undefined) {
            var feature = this._vectorTileFeature;
            var coords = projectCoords(
                feature.loadGeometry(),
                feature.extent,
                feature._z, feature._x, feature._y);

            var type = VectorTileFeature.types[feature.type];

            if (type === 'Point' && coords.length === 1) {
                coords = coords[0][0];
            } else if (type === 'Point') {
                coords = coords[0];
                type = 'MultiPoint';
            } else if (type === 'LineString' && coords.length === 1) {
                coords = coords[0];
            } else if (type === 'LineString') {
                type = 'MultiLineString';
            }

            this._geometry = {
                type: type,
                coordinates: coords
            };

            this._vectorTileFeature = null;
        }
        return this._geometry;
    },

    set geometry(g) {
        this._geometry = g;
    },

    toJSON: function() {
        var json = {};
        for (var i in this) {
            if (i === '_geometry' || i === '_vectorTileFeature') continue;
            json[i] = this[i];
        }
        return json;
    }
};

function projectCoords(coords, extent, z, x, y) {
    var size = extent * Math.pow(2, z),
        x0 = extent * x,
        y0 = extent * y;
    for (var i = 0; i < coords.length; i++) {
        var line = coords[i];
        for (var j = 0; j < line.length; j++) {
            var p = line[j];
            var y2 = 180 - (p.y + y0) * 360 / size;
            line[j] = [
                (p.x + x0) * 360 / size - 180,
                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
            ];
        }
    }
    return coords;
}

},{"vector-tile":181}],119:[function(require,module,exports){
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
  "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
  "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
  "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
  "beige": [245,245,220,1], "bisque": [255,228,196,1],
  "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
  "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
  "brown": [165,42,42,1], "burlywood": [222,184,135,1],
  "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
  "chocolate": [210,105,30,1], "coral": [255,127,80,1],
  "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
  "crimson": [220,20,60,1], "cyan": [0,255,255,1],
  "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
  "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
  "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
  "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
  "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
  "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
  "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
  "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
  "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
  "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
  "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
  "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
  "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
  "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
  "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
  "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
  "gray": [128,128,128,1], "green": [0,128,0,1],
  "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
  "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
  "indianred": [205,92,92,1], "indigo": [75,0,130,1],
  "ivory": [255,255,240,1], "khaki": [240,230,140,1],
  "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
  "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
  "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
  "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
  "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
  "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
  "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
  "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
  "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
  "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
  "limegreen": [50,205,50,1], "linen": [250,240,230,1],
  "magenta": [255,0,255,1], "maroon": [128,0,0,1],
  "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
  "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
  "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
  "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
  "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
  "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
  "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
  "navy": [0,0,128,1], "oldlace": [253,245,230,1],
  "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
  "orange": [255,165,0,1], "orangered": [255,69,0,1],
  "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
  "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
  "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
  "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
  "pink": [255,192,203,1], "plum": [221,160,221,1],
  "powderblue": [176,224,230,1], "purple": [128,0,128,1],
  "red": [255,0,0,1], "rosybrown": [188,143,143,1],
  "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
  "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
  "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
  "sienna": [160,82,45,1], "silver": [192,192,192,1],
  "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
  "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
  "snow": [255,250,250,1], "springgreen": [0,255,127,1],
  "steelblue": [70,130,180,1], "tan": [210,180,140,1],
  "teal": [0,128,128,1], "thistle": [216,191,216,1],
  "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
  "violet": [238,130,238,1], "wheat": [245,222,179,1],
  "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
  "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]}

function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parse_css_int(str) {  // int or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_byte(parseFloat(str) / 100 * 255);
  return clamp_css_byte(parseInt(str));
}

function parse_css_float(str) {  // float or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_float(parseFloat(str) / 100);
  return clamp_css_float(parseFloat(str));
}

function css_hue_to_rgb(m1, m2, h) {
  if (h < 0) h += 1;
  else if (h > 1) h -= 1;

  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
  if (h * 2 < 1) return m2;
  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
  return m1;
}

function parseCSSColor(css_str) {
  // Remove all whitespace, not compliant, but should just be more accepting.
  var str = css_str.replace(/ /g, '').toLowerCase();

  // Color keywords (and transparent) lookup.
  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

  // #abc and #abc123 syntax.
  if (str[0] === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
              (iv & 0xf0) | ((iv & 0xf0) >> 4),
              (iv & 0xf) | ((iv & 0xf) << 4),
              1];
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
      return [(iv & 0xff0000) >> 16,
              (iv & 0xff00) >> 8,
              iv & 0xff,
              1];
    }

    return null;
  }

  var op = str.indexOf('('), ep = str.indexOf(')');
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op+1, ep-(op+1)).split(',');
    var alpha = 1;  // To allow case fallthrough.
    switch (fname) {
      case 'rgba':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'rgb':
        if (params.length !== 3) return null;
        return [parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha];
      case 'hsla':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'hsl':
        if (params.length !== 3) return null;
        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
        // NOTE(deanm): According to the CSS spec s/l should only be
        // percentages, but we don't bother and let float or percentage.
        var s = parse_css_float(params[1]);
        var l = parse_css_float(params[2]);
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var m1 = l * 2 - m2;
        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                alpha];
      default:
        return null;
    }
  }

  return null;
}

try { exports.parseCSSColor = parseCSSColor } catch(e) { }

},{}],120:[function(require,module,exports){
'use strict';

module.exports = createFilter;

var types = ['Unknown', 'Point', 'LineString', 'Polygon'];

/**
 * Given a filter expressed as nested arrays, return a new function
 * that evaluates whether a given feature (with a .properties or .tags property)
 * passes its test.
 *
 * @param {Array} filter mapbox gl filter
 * @returns {Function} filter-evaluating function
 */
function createFilter(filter) {
    return new Function('f', 'var p = (f && f.properties || {}); return ' + compile(filter));
}

function compile(filter) {
    if (!filter) return 'true';
    var op = filter[0];
    if (filter.length <= 1) return op === 'any' ? 'false' : 'true';
    var str =
        op === '==' ? compileComparisonOp(filter[1], filter[2], '===', false) :
        op === '!=' ? compileComparisonOp(filter[1], filter[2], '!==', false) :
        op === '<' ||
        op === '>' ||
        op === '<=' ||
        op === '>=' ? compileComparisonOp(filter[1], filter[2], op, true) :
        op === 'any' ? compileLogicalOp(filter.slice(1), '||') :
        op === 'all' ? compileLogicalOp(filter.slice(1), '&&') :
        op === 'none' ? compileNegation(compileLogicalOp(filter.slice(1), '||')) :
        op === 'in' ? compileInOp(filter[1], filter.slice(2)) :
        op === '!in' ? compileNegation(compileInOp(filter[1], filter.slice(2))) :
        op === 'has' ? compileHasOp(filter[1]) :
        op === '!has' ? compileNegation(compileHasOp([filter[1]])) :
        'true';
    return '(' + str + ')';
}

function compilePropertyReference(property) {
    return property === '$type' ? 'f.type' : 'p[' + JSON.stringify(property) + ']';
}

function compileComparisonOp(property, value, op, checkType) {
    var left = compilePropertyReference(property);
    var right = property === '$type' ? types.indexOf(value) : JSON.stringify(value);
    return (checkType ? 'typeof ' + left + '=== typeof ' + right + '&&' : '') + left + op + right;
}

function compileLogicalOp(expressions, op) {
    return expressions.map(compile).join(op);
}

function compileInOp(property, values) {
    if (property === '$type') values = values.map(function(value) { return types.indexOf(value); });
    var left = JSON.stringify(values.sort(compare));
    var right = compilePropertyReference(property);

    if (values.length <= 200) return left + '.indexOf(' + right + ') !== -1';

    return 'function(v, a, i, j) {' +
        'while (i <= j) { var m = (i + j) >> 1;' +
        '    if (a[m] === v) return true; if (a[m] > v) j = m - 1; else i = m + 1;' +
        '}' +
    'return false; }(' + right + ', ' + left + ',0,' + (values.length - 1) + ')';
}

function compileHasOp(property) {
    return JSON.stringify(property) + ' in p';
}

function compileNegation(expression) {
    return '!(' + expression + ')';
}

// Comparison function to sort numbers and strings
function compare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

},{}],121:[function(require,module,exports){
var geojsonArea = require('geojson-area');

module.exports = rewind;

function rewind(gj, outer) {
    switch ((gj && gj.type) || null) {
        case 'FeatureCollection':
            gj.features = gj.features.map(curryOuter(rewind, outer));
            return gj;
        case 'Feature':
            gj.geometry = rewind(gj.geometry, outer);
            return gj;
        case 'Polygon':
        case 'MultiPolygon':
            return correct(gj, outer);
        default:
            return gj;
    }
}

function curryOuter(a, b) {
    return function(_) { return a(_, b); };
}

function correct(_, outer) {
    if (_.type === 'Polygon') {
        _.coordinates = correctRings(_.coordinates, outer);
    } else if (_.type === 'MultiPolygon') {
        _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));
    }
    return _;
}

function correctRings(_, outer) {
    outer = !!outer;
    _[0] = wind(_[0], !outer);
    for (var i = 1; i < _.length; i++) {
        _[i] = wind(_[i], outer);
    }
    return _;
}

function wind(_, dir) {
    return cw(_) === dir ? _ : _.reverse();
}

function cw(_) {
    return geojsonArea.ring(_) >= 0;
}

},{"geojson-area":122}],122:[function(require,module,exports){
var wgs84 = require('wgs84');

module.exports.geometry = geometry;
module.exports.ring = ringArea;

function geometry(_) {
    if (_.type === 'Polygon') return polygonArea(_.coordinates);
    else if (_.type === 'MultiPolygon') {
        var area = 0;
        for (var i = 0; i < _.coordinates.length; i++) {
            area += polygonArea(_.coordinates[i]);
        }
        return area;
    } else {
        return null;
    }
}

function polygonArea(coords) {
    var area = 0;
    if (coords && coords.length > 0) {
        area += Math.abs(ringArea(coords[0]));
        for (var i = 1; i < coords.length; i++) {
            area -= Math.abs(ringArea(coords[i]));
        }
    }
    return area;
}

/**
 * Calculate the approximate area of the polygon were it projected onto
 *     the earth.  Note that this area will be positive if ring is oriented
 *     clockwise, otherwise it will be negative.
 *
 * Reference:
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
 *
 * Returns:
 * {float} The approximate signed geodesic area of the polygon in square
 *     meters.
 */

function ringArea(coords) {
    var area = 0;

    if (coords.length > 2) {
        var p1, p2;
        for (var i = 0; i < coords.length - 1; i++) {
            p1 = coords[i];
            p2 = coords[i + 1];
            area += rad(p2[0] - p1[0]) * (2 + Math.sin(rad(p1[1])) + Math.sin(rad(p2[1])));
        }

        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
    }

    return area;
}

function rad(_) {
    return _ * Math.PI / 180;
}

},{"wgs84":123}],123:[function(require,module,exports){
module.exports.RADIUS = 6378137;
module.exports.FLATTENING = 1/298.257223563;
module.exports.POLAR_RADIUS = 6356752.3142;

},{}],124:[function(require,module,exports){
'use strict';

module.exports = clip;

/* clip features between two axis-parallel lines:
 *     |        |
 *  ___|___     |     /
 * /   |   \____|____/
 *     |        |
 */

function clip(features, scale, k1, k2, axis, intersect, minAll, maxAll) {

    k1 /= scale;
    k2 /= scale;

    if (minAll >= k1 && maxAll <= k2) return features; // trivial accept
    else if (minAll > k2 || maxAll < k1) return null; // trivial reject

    var clipped = [];

    for (var i = 0; i < features.length; i++) {

        var feature = features[i],
            geometry = feature.geometry,
            type = feature.type,
            min, max;

        min = feature.min[axis];
        max = feature.max[axis];

        if (min >= k1 && max <= k2) { // trivial accept
            clipped.push(feature);
            continue;
        } else if (min > k2 || max < k1) continue; // trivial reject

        var slices = type === 1 ?
                clipPoints(geometry, k1, k2, axis) :
                clipGeometry(geometry, k1, k2, axis, intersect, type === 3);

        if (slices.length) {
            // if a feature got clipped, it will likely get clipped on the next zoom level as well,
            // so there's no need to recalculate bboxes
            clipped.push({
                geometry: slices,
                type: type,
                tags: features[i].tags || null,
                min: feature.min,
                max: feature.max
            });
        }
    }

    return clipped.length ? clipped : null;
}

function clipPoints(geometry, k1, k2, axis) {
    var slice = [];

    for (var i = 0; i < geometry.length; i++) {
        var a = geometry[i],
            ak = a[axis];

        if (ak >= k1 && ak <= k2) slice.push(a);
    }
    return slice;
}

function clipGeometry(geometry, k1, k2, axis, intersect, closed) {

    var slices = [];

    for (var i = 0; i < geometry.length; i++) {

        var ak = 0,
            bk = 0,
            b = null,
            points = geometry[i],
            area = points.area,
            dist = points.dist,
            len = points.length,
            a, j, last;

        var slice = [];

        for (j = 0; j < len - 1; j++) {
            a = b || points[j];
            b = points[j + 1];
            ak = bk || a[axis];
            bk = b[axis];

            if (ak < k1) {

                if ((bk > k2)) { // ---|-----|-->
                    slice.push(intersect(a, b, k1), intersect(a, b, k2));
                    if (!closed) slice = newSlice(slices, slice, area, dist);

                } else if (bk >= k1) slice.push(intersect(a, b, k1)); // ---|-->  |

            } else if (ak > k2) {

                if ((bk < k1)) { // <--|-----|---
                    slice.push(intersect(a, b, k2), intersect(a, b, k1));
                    if (!closed) slice = newSlice(slices, slice, area, dist);

                } else if (bk <= k2) slice.push(intersect(a, b, k2)); // |  <--|---

            } else {

                slice.push(a);

                if (bk < k1) { // <--|---  |
                    slice.push(intersect(a, b, k1));
                    if (!closed) slice = newSlice(slices, slice, area, dist);

                } else if (bk > k2) { // |  ---|-->
                    slice.push(intersect(a, b, k2));
                    if (!closed) slice = newSlice(slices, slice, area, dist);
                }
                // | --> |
            }
        }

        // add the last point
        a = points[len - 1];
        ak = a[axis];
        if (ak >= k1 && ak <= k2) slice.push(a);

        // close the polygon if its endpoints are not the same after clipping

        last = slice[slice.length - 1];
        if (closed && last && (slice[0][0] !== last[0] || slice[0][1] !== last[1])) slice.push(slice[0]);

        // add the final slice
        newSlice(slices, slice, area, dist);
    }

    return slices;
}

function newSlice(slices, slice, area, dist) {
    if (slice.length) {
        // we don't recalculate the area/length of the unclipped geometry because the case where it goes
        // below the visibility threshold as a result of clipping is rare, so we avoid doing unnecessary work
        slice.area = area;
        slice.dist = dist;

        slices.push(slice);
    }
    return [];
}

},{}],125:[function(require,module,exports){
'use strict';

module.exports = convert;

var simplify = require('./simplify');

// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data

function convert(data, tolerance) {
    var features = [];

    if (data.type === 'FeatureCollection') {
        for (var i = 0; i < data.features.length; i++) {
            convertFeature(features, data.features[i], tolerance);
        }
    } else if (data.type === 'Feature') {
        convertFeature(features, data, tolerance);

    } else {
        // single geometry or a geometry collection
        convertFeature(features, {geometry: data}, tolerance);
    }
    return features;
}

function convertFeature(features, feature, tolerance) {
    var geom = feature.geometry,
        type = geom.type,
        coords = geom.coordinates,
        tags = feature.properties,
        i, j, rings;

    if (type === 'Point') {
        features.push(create(tags, 1, [projectPoint(coords)]));

    } else if (type === 'MultiPoint') {
        features.push(create(tags, 1, project(coords)));

    } else if (type === 'LineString') {
        features.push(create(tags, 2, [project(coords, tolerance)]));

    } else if (type === 'MultiLineString' || type === 'Polygon') {
        rings = [];
        for (i = 0; i < coords.length; i++) {
            rings.push(project(coords[i], tolerance));
        }
        features.push(create(tags, type === 'Polygon' ? 3 : 2, rings));

    } else if (type === 'MultiPolygon') {
        rings = [];
        for (i = 0; i < coords.length; i++) {
            for (j = 0; j < coords[i].length; j++) {
                rings.push(project(coords[i][j], tolerance));
            }
        }
        features.push(create(tags, 3, rings));

    } else if (type === 'GeometryCollection') {
        for (i = 0; i < geom.geometries.length; i++) {
            convertFeature(features, {
                geometry: geom.geometries[i],
                properties: tags
            }, tolerance);
        }

    } else {
        throw new Error('Input data is not a valid GeoJSON object.');
    }
}

function create(tags, type, geometry) {
    var feature = {
        geometry: geometry,
        type: type,
        tags: tags || null,
        min: [2, 1], // initial bbox values;
        max: [-1, 0]  // note that coords are usually in [0..1] range
    };
    calcBBox(feature);
    return feature;
}

function project(lonlats, tolerance) {
    var projected = [];
    for (var i = 0; i < lonlats.length; i++) {
        projected.push(projectPoint(lonlats[i]));
    }
    if (tolerance) {
        simplify(projected, tolerance);
        calcSize(projected);
    }
    return projected;
}

function projectPoint(p) {
    var sin = Math.sin(p[1] * Math.PI / 180),
        x = (p[0] / 360 + 0.5),
        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);

    y = y < -1 ? -1 :
        y > 1 ? 1 : y;

    return [x, y, 0];
}

// calculate area and length of the poly
function calcSize(points) {
    var area = 0,
        dist = 0;

    for (var i = 0, a, b; i < points.length - 1; i++) {
        a = b || points[i];
        b = points[i + 1];

        area += a[0] * b[1] - b[0] * a[1];

        // use Manhattan distance instead of Euclidian one to avoid expensive square root computation
        dist += Math.abs(b[0] - a[0]) + Math.abs(b[1] - a[1]);
    }
    points.area = Math.abs(area / 2);
    points.dist = dist;
}

// calculate the feature bounding box for faster clipping later
function calcBBox(feature) {
    var geometry = feature.geometry,
        min = feature.min,
        max = feature.max;

    if (feature.type === 1) calcRingBBox(min, max, geometry);
    else for (var i = 0; i < geometry.length; i++) calcRingBBox(min, max, geometry[i]);

    return feature;
}

function calcRingBBox(min, max, points) {
    for (var i = 0, p; i < points.length; i++) {
        p = points[i];
        min[0] = Math.min(p[0], min[0]);
        max[0] = Math.max(p[0], max[0]);
        min[1] = Math.min(p[1], min[1]);
        max[1] = Math.max(p[1], max[1]);
    }
}

},{"./simplify":127}],126:[function(require,module,exports){
'use strict';

module.exports = geojsonvt;

var convert = require('./convert'),     // GeoJSON conversion and preprocessing
    transform = require('./transform'), // coordinate transformation
    clip = require('./clip'),           // stripe clipping algorithm
    wrap = require('./wrap'),           // date line processing
    createTile = require('./tile');     // final simplified tile generation


function geojsonvt(data, options) {
    return new GeoJSONVT(data, options);
}

function GeoJSONVT(data, options) {
    options = this.options = extend(Object.create(this.options), options);

    var debug = options.debug;

    if (debug) console.time('preprocess data');

    var z2 = 1 << options.maxZoom, // 2^z
        features = convert(data, options.tolerance / (z2 * options.extent));

    this.tiles = {};
    this.tileCoords = [];

    if (debug) {
        console.timeEnd('preprocess data');
        console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);
        console.time('generate tiles');
        this.stats = {};
        this.total = 0;
    }

    features = wrap(features, options.buffer / options.extent, intersectX);

    // start slicing from the top tile down
    if (features.length) this.splitTile(features, 0, 0, 0);

    if (debug) {
        if (features.length) console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints);
        console.timeEnd('generate tiles');
        console.log('tiles generated:', this.total, JSON.stringify(this.stats));
    }
}

GeoJSONVT.prototype.options = {
    maxZoom: 14,            // max zoom to preserve detail on
    indexMaxZoom: 5,        // max zoom in the tile index
    indexMaxPoints: 100000, // max number of points per tile in the tile index
    solidChildren: false,   // whether to tile solid square tiles further
    tolerance: 3,           // simplification tolerance (higher means simpler)
    extent: 4096,           // tile extent
    buffer: 64,             // tile buffer on each side
    debug: 0                // logging level (0, 1 or 2)
};

GeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {

    var stack = [features, z, x, y],
        options = this.options,
        debug = options.debug,
        solid = null;

    // avoid recursion by using a processing queue
    while (stack.length) {
        y = stack.pop();
        x = stack.pop();
        z = stack.pop();
        features = stack.pop();

        var z2 = 1 << z,
            id = toID(z, x, y),
            tile = this.tiles[id],
            tileTolerance = z === options.maxZoom ? 0 : options.tolerance / (z2 * options.extent);

        if (!tile) {
            if (debug > 1) console.time('creation');

            tile = this.tiles[id] = createTile(features, z2, x, y, tileTolerance, z === options.maxZoom);
            this.tileCoords.push({z: z, x: x, y: y});

            if (debug) {
                if (debug > 1) {
                    console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',
                        z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);
                    console.timeEnd('creation');
                }
                var key = 'z' + z;
                this.stats[key] = (this.stats[key] || 0) + 1;
                this.total++;
            }
        }

        // save reference to original geometry in tile so that we can drill down later if we stop now
        tile.source = features;

        // if it's the first-pass tiling
        if (!cz) {
            // stop tiling if we reached max zoom, or if the tile is too simple
            if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) continue;

        // if a drilldown to a specific tile
        } else {
            // stop tiling if we reached base zoom or our target tile zoom
            if (z === options.maxZoom || z === cz) continue;

            // stop tiling if it's not an ancestor of the target tile
            var m = 1 << (cz - z);
            if (x !== Math.floor(cx / m) || y !== Math.floor(cy / m)) continue;
        }

        // stop tiling if the tile is solid clipped square
        if (!options.solidChildren && isClippedSquare(tile, options.extent, options.buffer)) {
            if (cz) solid = z; // and remember the zoom if we're drilling down
            continue;
        }

        // if we slice further down, no need to keep source geometry
        tile.source = null;

        if (debug > 1) console.time('clipping');

        // values we'll use for clipping
        var k1 = 0.5 * options.buffer / options.extent,
            k2 = 0.5 - k1,
            k3 = 0.5 + k1,
            k4 = 1 + k1,
            tl, bl, tr, br, left, right;

        tl = bl = tr = br = null;

        left  = clip(features, z2, x - k1, x + k3, 0, intersectX, tile.min[0], tile.max[0]);
        right = clip(features, z2, x + k2, x + k4, 0, intersectX, tile.min[0], tile.max[0]);

        if (left) {
            tl = clip(left, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
            bl = clip(left, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
        }

        if (right) {
            tr = clip(right, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
            br = clip(right, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
        }

        if (debug > 1) console.timeEnd('clipping');

        if (tl) stack.push(tl, z + 1, x * 2,     y * 2);
        if (bl) stack.push(bl, z + 1, x * 2,     y * 2 + 1);
        if (tr) stack.push(tr, z + 1, x * 2 + 1, y * 2);
        if (br) stack.push(br, z + 1, x * 2 + 1, y * 2 + 1);
    }

    return solid;
};

GeoJSONVT.prototype.getTile = function (z, x, y) {
    var options = this.options,
        extent = options.extent,
        debug = options.debug;

    var z2 = 1 << z;
    x = ((x % z2) + z2) % z2; // wrap tile x coordinate

    var id = toID(z, x, y);
    if (this.tiles[id]) return transform.tile(this.tiles[id], extent);

    if (debug > 1) console.log('drilling down to z%d-%d-%d', z, x, y);

    var z0 = z,
        x0 = x,
        y0 = y,
        parent;

    while (!parent && z0 > 0) {
        z0--;
        x0 = Math.floor(x0 / 2);
        y0 = Math.floor(y0 / 2);
        parent = this.tiles[toID(z0, x0, y0)];
    }

    if (!parent || !parent.source) return null;

    // if we found a parent tile containing the original geometry, we can drill down from it
    if (debug > 1) console.log('found parent tile z%d-%d-%d', z0, x0, y0);

    // it parent tile is a solid clipped square, return it instead since it's identical
    if (isClippedSquare(parent, extent, options.buffer)) return transform.tile(parent, extent);

    if (debug > 1) console.time('drilling down');
    var solid = this.splitTile(parent.source, z0, x0, y0, z, x, y);
    if (debug > 1) console.timeEnd('drilling down');

    // one of the parent tiles was a solid clipped square
    if (solid !== null) {
        var m = 1 << (z - solid);
        id = toID(solid, Math.floor(x / m), Math.floor(y / m));
    }

    return this.tiles[id] ? transform.tile(this.tiles[id], extent) : null;
};

function toID(z, x, y) {
    return (((1 << z) * y + x) * 32) + z;
}

function intersectX(a, b, x) {
    return [x, (x - a[0]) * (b[1] - a[1]) / (b[0] - a[0]) + a[1], 1];
}
function intersectY(a, b, y) {
    return [(y - a[1]) * (b[0] - a[0]) / (b[1] - a[1]) + a[0], y, 1];
}

function extend(dest, src) {
    for (var i in src) dest[i] = src[i];
    return dest;
}

// checks whether a tile is a whole-area fill after clipping; if it is, there's no sense slicing it further
function isClippedSquare(tile, extent, buffer) {

    var features = tile.source;
    if (features.length !== 1) return false;

    var feature = features[0];
    if (feature.type !== 3 || feature.geometry.length > 1) return false;

    var len = feature.geometry[0].length;
    if (len !== 5) return false;

    for (var i = 0; i < len; i++) {
        var p = transform.point(feature.geometry[0][i], extent, tile.z2, tile.x, tile.y);
        if ((p[0] !== -buffer && p[0] !== extent + buffer) ||
            (p[1] !== -buffer && p[1] !== extent + buffer)) return false;
    }

    return true;
}

},{"./clip":124,"./convert":125,"./tile":128,"./transform":129,"./wrap":130}],127:[function(require,module,exports){
'use strict';

module.exports = simplify;

// calculate simplification data using optimized Douglas-Peucker algorithm

function simplify(points, tolerance) {

    var sqTolerance = tolerance * tolerance,
        len = points.length,
        first = 0,
        last = len - 1,
        stack = [],
        i, maxSqDist, sqDist, index;

    // always retain the endpoints (1 is the max value)
    points[first][2] = 1;
    points[last][2] = 1;

    // avoid recursion by using a stack
    while (last) {

        maxSqDist = 0;

        for (i = first + 1; i < last; i++) {
            sqDist = getSqSegDist(points[i], points[first], points[last]);

            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }

        if (maxSqDist > sqTolerance) {
            points[index][2] = maxSqDist; // save the point importance in squared pixels as a z coordinate
            stack.push(first);
            stack.push(index);
            first = index;

        } else {
            last = stack.pop();
            first = stack.pop();
        }
    }
}

// square distance from a point to a segment
function getSqSegDist(p, a, b) {

    var x = a[0], y = a[1],
        bx = b[0], by = b[1],
        px = p[0], py = p[1],
        dx = bx - x,
        dy = by - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = bx;
            y = by;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = px - x;
    dy = py - y;

    return dx * dx + dy * dy;
}

},{}],128:[function(require,module,exports){
'use strict';

module.exports = createTile;

function createTile(features, z2, tx, ty, tolerance, noSimplify) {
    var tile = {
        features: [],
        numPoints: 0,
        numSimplified: 0,
        numFeatures: 0,
        source: null,
        x: tx,
        y: ty,
        z2: z2,
        transformed: false,
        min: [2, 1],
        max: [-1, 0]
    };
    for (var i = 0; i < features.length; i++) {
        tile.numFeatures++;
        addFeature(tile, features[i], tolerance, noSimplify);

        var min = features[i].min,
            max = features[i].max;

        if (min[0] < tile.min[0]) tile.min[0] = min[0];
        if (min[1] < tile.min[1]) tile.min[1] = min[1];
        if (max[0] > tile.max[0]) tile.max[0] = max[0];
        if (max[1] > tile.max[1]) tile.max[1] = max[1];
    }
    return tile;
}

function addFeature(tile, feature, tolerance, noSimplify) {

    var geom = feature.geometry,
        type = feature.type,
        simplified = [],
        sqTolerance = tolerance * tolerance,
        i, j, ring, p;

    if (type === 1) {
        for (i = 0; i < geom.length; i++) {
            simplified.push(geom[i]);
            tile.numPoints++;
            tile.numSimplified++;
        }

    } else {

        // simplify and transform projected coordinates for tile geometry
        for (i = 0; i < geom.length; i++) {
            ring = geom[i];

            // filter out tiny polylines & polygons
            if (!noSimplify && ((type === 2 && ring.dist < tolerance) ||
                                (type === 3 && ring.area < sqTolerance))) {
                tile.numPoints += ring.length;
                continue;
            }

            var simplifiedRing = [];

            for (j = 0; j < ring.length; j++) {
                p = ring[j];
                // keep points with importance > tolerance
                if (noSimplify || p[2] > sqTolerance) {
                    simplifiedRing.push(p);
                    tile.numSimplified++;
                }
                tile.numPoints++;
            }

            simplified.push(simplifiedRing);
        }
    }

    if (simplified.length) {
        tile.features.push({
            geometry: simplified,
            type: type,
            tags: feature.tags || null
        });
    }
}

},{}],129:[function(require,module,exports){
'use strict';

exports.tile = transformTile;
exports.point = transformPoint;

// Transforms the coordinates of each feature in the given tile from
// mercator-projected space into (extent x extent) tile space.
function transformTile(tile, extent) {
    if (tile.transformed) return tile;

    var z2 = tile.z2,
        tx = tile.x,
        ty = tile.y,
        i, j, k;

    for (i = 0; i < tile.features.length; i++) {
        var feature = tile.features[i],
            geom = feature.geometry,
            type = feature.type;

        if (type === 1) {
            for (j = 0; j < geom.length; j++) geom[j] = transformPoint(geom[j], extent, z2, tx, ty);

        } else {
            for (j = 0; j < geom.length; j++) {
                var ring = geom[j];
                for (k = 0; k < ring.length; k++) ring[k] = transformPoint(ring[k], extent, z2, tx, ty);
            }
        }
    }

    tile.transformed = true;

    return tile;
}

function transformPoint(p, extent, z2, tx, ty) {
    var x = Math.round(extent * (p[0] * z2 - tx)),
        y = Math.round(extent * (p[1] * z2 - ty));
    return [x, y];
}

},{}],130:[function(require,module,exports){
'use strict';

var clip = require('./clip');

module.exports = wrap;

function wrap(features, buffer, intersectX) {
    var merged = features,
        left  = clip(features, 1, -1 - buffer, buffer,     0, intersectX, -1, 2), // left world copy
        right = clip(features, 1,  1 - buffer, 2 + buffer, 0, intersectX, -1, 2); // right world copy

    if (left || right) {
        merged = clip(features, 1, -buffer, 1 + buffer, 0, intersectX, -1, 2); // center world copy

        if (left) merged = shiftFeatureCoords(left, 1).concat(merged); // merge left into center
        if (right) merged = merged.concat(shiftFeatureCoords(right, -1)); // merge right into center
    }

    return merged;
}

function shiftFeatureCoords(features, offset) {
    var newFeatures = [];

    for (var i = 0; i < features.length; i++) {
        var feature = features[i],
            type = feature.type;

        var newGeometry;

        if (type === 1) {
            newGeometry = shiftCoords(feature.geometry, offset);
        } else {
            newGeometry = [];
            for (var j = 0; j < feature.geometry.length; j++) {
                newGeometry.push(shiftCoords(feature.geometry[j], offset));
            }
        }

        newFeatures.push({
            geometry: newGeometry,
            type: type,
            tags: feature.tags,
            min: [feature.min[0] + offset, feature.min[1]],
            max: [feature.max[0] + offset, feature.max[1]]
        });
    }

    return newFeatures;
}

function shiftCoords(points, offset) {
    var newPoints = [];
    newPoints.area = points.area;
    newPoints.dist = points.dist;

    for (var i = 0; i < points.length; i++) {
        newPoints.push([points[i][0] + offset, points[i][1], points[i][2]]);
    }
    return newPoints;
}

},{"./clip":124}],131:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.2
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER

exports.glMatrix = require("./gl-matrix/common.js");
exports.mat2 = require("./gl-matrix/mat2.js");
exports.mat2d = require("./gl-matrix/mat2d.js");
exports.mat3 = require("./gl-matrix/mat3.js");
exports.mat4 = require("./gl-matrix/mat4.js");
exports.quat = require("./gl-matrix/quat.js");
exports.vec2 = require("./gl-matrix/vec2.js");
exports.vec3 = require("./gl-matrix/vec3.js");
exports.vec4 = require("./gl-matrix/vec4.js");
},{"./gl-matrix/common.js":132,"./gl-matrix/mat2.js":133,"./gl-matrix/mat2d.js":134,"./gl-matrix/mat3.js":135,"./gl-matrix/mat4.js":136,"./gl-matrix/quat.js":137,"./gl-matrix/vec2.js":138,"./gl-matrix/vec3.js":139,"./gl-matrix/vec4.js":140}],132:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

// Configuration Constants
glMatrix.EPSILON = 0.000001;
glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
glMatrix.RANDOM = Math.random;
glMatrix.ENABLE_SIMD = false;

// Capability detection
glMatrix.SIMD_AVAILABLE = (glMatrix.ARRAY_TYPE === Float32Array) && ('SIMD' in this);
glMatrix.USE_SIMD = glMatrix.ENABLE_SIMD && glMatrix.SIMD_AVAILABLE;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    glMatrix.ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less 
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 * 
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
glMatrix.equals = function(a, b) {
	return Math.abs(a - b) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}

module.exports = glMatrix;

},{}],133:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x2 Matrix
 * @name mat2
 */
var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
mat2.fromValues = function(m00, m01, m10, m11) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
};

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
mat2.set = function(out, m00, m01, m10, m11) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
};


/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.fromRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
mat2.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link mat2.subtract}
 * @function
 */
mat2.sub = mat2.subtract;

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
mat2.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
mat2.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

module.exports = mat2;

},{"./common.js":132}],134:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */
var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
mat2d.fromValues = function(a, b, c, d, tx, ty) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
mat2d.set = function(out, a, b, c, d, tx, ty) {
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
mat2d.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
mat2d.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    return out;
};

/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
mat2d.sub = mat2d.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
mat2d.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    return out;
};

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
mat2d.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2d.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2d.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)));
};

module.exports = mat2d;

},{"./common.js":132}],135:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3x3 Matrix
 * @name mat3
 */
var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
mat3.fromValues = function(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
mat3.set = function(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
mat3.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);

    out[0] = c;
    out[1] = s;
    out[2] = 0;

    out[3] = -s;
    out[4] = c;
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
mat3.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;

    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
};

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
mat3.sub = mat3.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
mat3.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
};

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
mat3.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    return out;
};

/*
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && 
           a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
           a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = a[6], b7 = b[7], b8 = b[8];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
};


module.exports = mat3;

},{"./common.js":132}],136:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4x4 Matrix
 * @name mat4
 */
var mat4 = {
  scalar: {},
  SIMD: {},
};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
mat4.fromValues = function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
mat4.set = function(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }

    return out;
};

/**
 * Transpose the values of a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.transpose = function(out, a) {
    var a0, a1, a2, a3,
        tmp01, tmp23,
        out0, out1, out2, out3;

    a0 = SIMD.Float32x4.load(a, 0);
    a1 = SIMD.Float32x4.load(a, 4);
    a2 = SIMD.Float32x4.load(a, 8);
    a3 = SIMD.Float32x4.load(a, 12);

    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
    out0  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
    out1  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
    SIMD.Float32x4.store(out, 0,  out0);
    SIMD.Float32x4.store(out, 4,  out1);

    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
    out2  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
    out3  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
    SIMD.Float32x4.store(out, 8,  out2);
    SIMD.Float32x4.store(out, 12, out3);

    return out;
};

/**
 * Transpse a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = glMatrix.USE_SIMD ? mat4.SIMD.transpose : mat4.scalar.transpose;

/**
 * Inverts a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Inverts a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.invert = function(out, a) {
  var row0, row1, row2, row3,
      tmp1,
      minor0, minor1, minor2, minor3,
      det,
      a0 = SIMD.Float32x4.load(a, 0),
      a1 = SIMD.Float32x4.load(a, 4),
      a2 = SIMD.Float32x4.load(a, 8),
      a3 = SIMD.Float32x4.load(a, 12);

  // Compute matrix adjugate
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

  tmp1   = SIMD.Float32x4.mul(row2, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.mul(row1, tmp1);
  minor1 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row1, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
  minor3 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
  minor2 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row0, row1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

  // Compute matrix determinant
  det   = SIMD.Float32x4.mul(row0, minor0);
  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 2, 3, 0, 1), det);
  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 1, 0, 3, 2), det);
  tmp1  = SIMD.Float32x4.reciprocalApproximation(det);
  det   = SIMD.Float32x4.sub(
               SIMD.Float32x4.add(tmp1, tmp1),
               SIMD.Float32x4.mul(det, SIMD.Float32x4.mul(tmp1, tmp1)));
  det   = SIMD.Float32x4.swizzle(det, 0, 0, 0, 0);
  if (!det) {
      return null;
  }

  // Compute matrix inverse
  SIMD.Float32x4.store(out, 0,  SIMD.Float32x4.mul(det, minor0));
  SIMD.Float32x4.store(out, 4,  SIMD.Float32x4.mul(det, minor1));
  SIMD.Float32x4.store(out, 8,  SIMD.Float32x4.mul(det, minor2));
  SIMD.Float32x4.store(out, 12, SIMD.Float32x4.mul(det, minor3));
  return out;
}

/**
 * Inverts a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = glMatrix.USE_SIMD ? mat4.SIMD.invert : mat4.scalar.invert;

/**
 * Calculates the adjugate of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the adjugate of a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.adjoint = function(out, a) {
  var a0, a1, a2, a3;
  var row0, row1, row2, row3;
  var tmp1;
  var minor0, minor1, minor2, minor3;

  var a0 = SIMD.Float32x4.load(a, 0);
  var a1 = SIMD.Float32x4.load(a, 4);
  var a2 = SIMD.Float32x4.load(a, 8);
  var a3 = SIMD.Float32x4.load(a, 12);

  // Transpose the source matrix.  Sort of.  Not a true transpose operation
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);

  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

  tmp1   = SIMD.Float32x4.mul(row2, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.mul(row1, tmp1);
  minor1 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row1, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
  minor3 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
  minor2 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row0, row1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

  SIMD.Float32x4.store(out, 0,  minor0);
  SIMD.Float32x4.store(out, 4,  minor1);
  SIMD.Float32x4.store(out, 8,  minor2);
  SIMD.Float32x4.store(out, 12, minor3);
  return out;
};

/**
 * Calculates the adjugate of a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
 mat4.adjoint = glMatrix.USE_SIMD ? mat4.SIMD.adjoint : mat4.scalar.adjoint;

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's explicitly using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand, must be a Float32Array
 * @param {mat4} b the second operand, must be a Float32Array
 * @returns {mat4} out
 */
mat4.SIMD.multiply = function (out, a, b) {
    var a0 = SIMD.Float32x4.load(a, 0);
    var a1 = SIMD.Float32x4.load(a, 4);
    var a2 = SIMD.Float32x4.load(a, 8);
    var a3 = SIMD.Float32x4.load(a, 12);

    var b0 = SIMD.Float32x4.load(b, 0);
    var out0 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 2, 2, 2, 2), a2),
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 0, out0);

    var b1 = SIMD.Float32x4.load(b, 4);
    var out1 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 2, 2, 2, 2), a2),
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 4, out1);

    var b2 = SIMD.Float32x4.load(b, 8);
    var out2 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 2, 2, 2, 2), a2),
                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 8, out2);

    var b3 = SIMD.Float32x4.load(b, 12);
    var out3 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 1, 1, 1, 1), a1),
                        SIMD.Float32x4.add(
                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 2, 2, 2, 2), a2),
                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 12, out3);

    return out;
};

/**
 * Multiplies two mat4's explicitly not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.scalar.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Multiplies two mat4's using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = glMatrix.USE_SIMD ? mat4.SIMD.multiply : mat4.scalar.multiply;

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.scalar.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Translates a mat4 by the given vector using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.SIMD.translate = function (out, a, v) {
    var a0 = SIMD.Float32x4.load(a, 0),
        a1 = SIMD.Float32x4.load(a, 4),
        a2 = SIMD.Float32x4.load(a, 8),
        a3 = SIMD.Float32x4.load(a, 12),
        vec = SIMD.Float32x4(v[0], v[1], v[2] , 0);

    if (a !== out) {
        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
        out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
        out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
    }

    a0 = SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0));
    a1 = SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1));
    a2 = SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2));

    var t0 = SIMD.Float32x4.add(a0, SIMD.Float32x4.add(a1, SIMD.Float32x4.add(a2, a3)));
    SIMD.Float32x4.store(out, 12, t0);

    return out;
};

/**
 * Translates a mat4 by the given vector using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = glMatrix.USE_SIMD ? mat4.SIMD.translate : mat4.scalar.translate;

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scalar.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.SIMD.scale = function(out, a, v) {
    var a0, a1, a2;
    var vec = SIMD.Float32x4(v[0], v[1], v[2], 0);

    a0 = SIMD.Float32x4.load(a, 0);
    SIMD.Float32x4.store(
        out, 0, SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0)));

    a1 = SIMD.Float32x4.load(a, 4);
    SIMD.Float32x4.store(
        out, 4, SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1)));

    a2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(
        out, 8, SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2)));

    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 */
mat4.scale = glMatrix.USE_SIMD ? mat4.SIMD.scale : mat4.scalar.scale;

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateX = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
      out[0]  = a[0];
      out[1]  = a[1];
      out[2]  = a[2];
      out[3]  = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_1 = SIMD.Float32x4.load(a, 4);
    var a_2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(out, 4,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_2, s)));
    SIMD.Float32x4.store(out, 8,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_2, c), SIMD.Float32x4.mul(a_1, s)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis using SIMD if availabe and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = glMatrix.USE_SIMD ? mat4.SIMD.rotateX : mat4.scalar.rotateX;

/**
 * Rotates a matrix by the given angle around the Y axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateY = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_0 = SIMD.Float32x4.load(a, 0);
    var a_2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(out, 0,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_2, s)));
    SIMD.Float32x4.store(out, 8,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, s), SIMD.Float32x4.mul(a_2, c)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis if SIMD available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
 mat4.rotateY = glMatrix.USE_SIMD ? mat4.SIMD.rotateY : mat4.scalar.rotateY;

/**
 * Rotates a matrix by the given angle around the Z axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateZ = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_0 = SIMD.Float32x4.load(a, 0);
    var a_1 = SIMD.Float32x4.load(a, 4);
    SIMD.Float32x4.store(out, 0,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_1, s)));
    SIMD.Float32x4.store(out, 4,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_0, s)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis if SIMD available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
 mat4.rotateZ = glMatrix.USE_SIMD ? mat4.SIMD.rotateZ : mat4.scalar.rotateZ;

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
mat4.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.fromRotation = function(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromXRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = 1;
    out[1]  = 0;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromYRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = 0;
    out[2]  = -s;
    out[3]  = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromZRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = s;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
mat4.getTranslation = function (out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
};

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
mat4.getRotation = function (out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat[0] + mat[5] + mat[10];
  var S = 0;

  if (trace > 0) { 
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S; 
    out[2] = (mat[1] - mat[4]) / S; 
  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) { 
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S; 
    out[2] = (mat[8] + mat[2]) / S; 
  } else if (mat[5] > mat[10]) { 
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S; 
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S; 
  } else { 
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScale = function (out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2,
        sx = s[0],
        sy = s[1],
        sz = s[2];

    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
  // Quaternion math
  var x = q[0], y = q[1], z = q[2], w = q[3],
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,

      xx = x * x2,
      xy = x * y2,
      xz = x * z2,
      yy = y * y2,
      yz = y * z2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2,

      sx = s[0],
      sy = s[1],
      sz = s[2],

      ox = o[0],
      oy = o[1],
      oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
};

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
        Math.abs(eyey - centery) < glMatrix.EPSILON &&
        Math.abs(eyez - centerz) < glMatrix.EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
};

/**
 * Alias for {@link mat4.subtract}
 * @function
 */
mat4.sub = mat4.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
mat4.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
};

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
mat4.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    out[9] = a[9] + (b[9] * scale);
    out[10] = a[10] + (b[10] * scale);
    out[11] = a[11] + (b[11] * scale);
    out[12] = a[12] + (b[12] * scale);
    out[13] = a[13] + (b[13] * scale);
    out[14] = a[14] + (b[14] * scale);
    out[15] = a[15] + (b[15] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && 
           a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && 
           a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
           a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.equals = function (a, b) {
    var a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3],
        a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7], 
        a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11], 
        a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];

    var b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3],
        b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7], 
        b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11], 
        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
            Math.abs(a9 - b9) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
            Math.abs(a10 - b10) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
            Math.abs(a11 - b11) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
            Math.abs(a12 - b12) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
            Math.abs(a13 - b13) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
            Math.abs(a14 - b14) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
            Math.abs(a15 - b15) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
};



module.exports = mat4;

},{"./common.js":132}],137:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");
var mat3 = require("./mat3.js");
var vec3 = require("./vec3.js");
var vec4 = require("./vec4.js");

/**
 * @class Quaternion
 * @name quat
 */
var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
quat.getAxisAngle = function(out_axis, q) {
    var rad = Math.acos(q[3]) * 2.0;
    var s = Math.sin(rad / 2.0);
    if (s != 0.0) {
        out_axis[0] = q[0] / s;
        out_axis[1] = q[1] / s;
        out_axis[2] = q[2] / s;
    } else {
        // If s is zero, return any axis (no rotation - axis does not matter)
        out_axis[0] = 1;
        out_axis[1] = 0;
        out_axis[2] = 0;
    }
    return rad;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
quat.sqlerp = (function () {
  var temp1 = quat.create();
  var temp2 = quat.create();
  
  return function (out, a, b, c, d, t) {
    quat.slerp(temp1, a, d, t);
    quat.slerp(temp2, b, c, t);
    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
    
    return out;
  };
}());

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[5]-m[7])*fRoot;
        out[1] = (m[6]-m[2])*fRoot;
        out[2] = (m[1]-m[3])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.exactEquals = vec4.exactEquals;

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.equals = vec4.equals;

module.exports = quat;

},{"./common.js":132,"./mat3.js":135,"./vec3.js":139,"./vec4.js":140}],138:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */
var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
vec2.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
vec2.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
vec2.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
vec2.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
};

module.exports = vec2;

},{"./common.js":132}],139:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */
var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
vec3.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
};

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
vec3.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
};

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
vec3.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
vec3.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.hermite = function (out, a, b, c, d, t) {
  var factorTimes2 = t * t,
      factor1 = factorTimes2 * (2 * t - 3) + 1,
      factor2 = factorTimes2 * (t - 2) + t,
      factor3 = factorTimes2 * (t - 1),
      factor4 = factorTimes2 * (3 - 2 * t);
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.bezier = function (out, a, b, c, d, t) {
  var inverseFactor = 1 - t,
      inverseFactorTimesTwo = inverseFactor * inverseFactor,
      factorTimes2 = t * t,
      factor1 = inverseFactorTimesTwo * inverseFactor,
      factor2 = 3 * t * inverseFactorTimesTwo,
      factor3 = 3 * factorTimes2 * inverseFactor,
      factor4 = factorTimes2 * t;
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    var z = (glMatrix.RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
vec3.angle = function(a, b) {
   
    var tempA = vec3.fromValues(a[0], a[1], a[2]);
    var tempB = vec3.fromValues(b[0], b[1], b[2]);
 
    vec3.normalize(tempA, tempA);
    vec3.normalize(tempB, tempB);
 
    var cosine = vec3.dot(tempA, tempB);

    if(cosine > 1.0){
        return 0;
    } else {
        return Math.acos(cosine);
    }     
};

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
};

module.exports = vec3;

},{"./common.js":132}],140:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */
var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
vec4.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
};

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
vec4.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
};

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
vec4.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
vec4.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = x * len;
        out[1] = y * len;
        out[2] = z * len;
        out[3] = w * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = glMatrix.RANDOM();
    out[1] = glMatrix.RANDOM();
    out[2] = glMatrix.RANDOM();
    out[3] = glMatrix.RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

module.exports = vec4;

},{"./common.js":132}],141:[function(require,module,exports){
'use strict';

module.exports = GridIndex;

var NUM_PARAMS = 3;

function GridIndex(extent, n, padding) {
    var cells = this.cells = [];

    if (extent instanceof ArrayBuffer) {
        this.arrayBuffer = extent;
        var array = new Int32Array(this.arrayBuffer);
        extent = array[0];
        n = array[1];
        padding = array[2];

        this.d = n + 2 * padding;
        for (var k = 0; k < this.d * this.d; k++) {
            var start = array[NUM_PARAMS + k];
            var end = array[NUM_PARAMS + k + 1];
            cells.push(start === end ?
                    null :
                    array.subarray(start, end));
        }
        var keysOffset = array[NUM_PARAMS + cells.length];
        var bboxesOffset = array[NUM_PARAMS + cells.length + 1];
        this.keys = array.subarray(keysOffset, bboxesOffset);
        this.bboxes = array.subarray(bboxesOffset);

        this.insert = this._insertReadonly;

    } else {
        this.d = n + 2 * padding;
        for (var i = 0; i < this.d * this.d; i++) {
            cells.push([]);
        }
        this.keys = [];
        this.bboxes = [];
    }

    this.n = n;
    this.extent = extent;
    this.padding = padding;
    this.scale = n / extent;
    this.uid = 0;

    var p = (padding / n) * extent;
    this.min = -p;
    this.max = extent + p;
}


GridIndex.prototype.insert = function(key, x1, y1, x2, y2) {
    this._forEachCell(x1, y1, x2, y2, this._insertCell, this.uid++);
    this.keys.push(key);
    this.bboxes.push(x1);
    this.bboxes.push(y1);
    this.bboxes.push(x2);
    this.bboxes.push(y2);
};

GridIndex.prototype._insertReadonly = function() {
    throw 'Cannot insert into a GridIndex created from an ArrayBuffer.';
};

GridIndex.prototype._insertCell = function(x1, y1, x2, y2, cellIndex, uid) {
    this.cells[cellIndex].push(uid);
};

GridIndex.prototype.query = function(x1, y1, x2, y2) {
    var min = this.min;
    var max = this.max;
    if (x1 <= min && y1 <= min && max <= x2 && max <= y2) {
        return this.keys.slice();

    } else {
        var result = [];
        var seenUids = {};
        this._forEachCell(x1, y1, x2, y2, this._queryCell, result, seenUids);
        return result;
    }
};

GridIndex.prototype._queryCell = function(x1, y1, x2, y2, cellIndex, result, seenUids) {
    var cell = this.cells[cellIndex];
    if (cell !== null) {
        var keys = this.keys;
        var bboxes = this.bboxes;
        for (var u = 0; u < cell.length; u++) {
            var uid = cell[u];
            if (seenUids[uid] === undefined) {
                var offset = uid * 4;
                if ((x1 <= bboxes[offset + 2]) &&
                    (y1 <= bboxes[offset + 3]) &&
                    (x2 >= bboxes[offset + 0]) &&
                    (y2 >= bboxes[offset + 1])) {
                    seenUids[uid] = true;
                    result.push(keys[uid]);
                } else {
                    seenUids[uid] = false;
                }
            }
        }
    }
};

GridIndex.prototype._forEachCell = function(x1, y1, x2, y2, fn, arg1, arg2) {
    var cx1 = this._convertToCellCoord(x1);
    var cy1 = this._convertToCellCoord(y1);
    var cx2 = this._convertToCellCoord(x2);
    var cy2 = this._convertToCellCoord(y2);
    for (var x = cx1; x <= cx2; x++) {
        for (var y = cy1; y <= cy2; y++) {
            var cellIndex = this.d * y + x;
            if (fn.call(this, x1, y1, x2, y2, cellIndex, arg1, arg2)) return;
        }
    }
};

GridIndex.prototype._convertToCellCoord = function(x) {
    return Math.max(0, Math.min(this.d - 1, Math.floor(x * this.scale) + this.padding));
};

GridIndex.prototype.toArrayBuffer = function() {
    if (this.arrayBuffer) return this.arrayBuffer;

    var cells = this.cells;

    var metadataLength = NUM_PARAMS + this.cells.length + 1 + 1;
    var totalCellLength = 0;
    for (var i = 0; i < this.cells.length; i++) {
        totalCellLength += this.cells[i].length;
    }

    var array = new Int32Array(metadataLength + totalCellLength + this.keys.length + this.bboxes.length);
    array[0] = this.extent;
    array[1] = this.n;
    array[2] = this.padding;

    var offset = metadataLength;
    for (var k = 0; k < cells.length; k++) {
        var cell = cells[k];
        array[NUM_PARAMS + k] = offset;
        array.set(cell, offset);
        offset += cell.length;
    }

    array[NUM_PARAMS + cells.length] = offset;
    array.set(this.keys, offset);
    offset += this.keys.length;

    array[NUM_PARAMS + cells.length + 1] = offset;
    array.set(this.bboxes, offset);
    offset += this.bboxes.length;

    return array.buffer;
};

},{}],142:[function(require,module,exports){
'use strict';

function createFunction(parameters, defaultType) {
    var fun;

    if (!isFunctionDefinition(parameters)) {
        fun = function() { return parameters; };
        fun.isFeatureConstant = true;
        fun.isZoomConstant = true;

    } else {
        var zoomAndFeatureDependent = typeof parameters.stops[0][0] === 'object';
        var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
        var zoomDependent = zoomAndFeatureDependent || !featureDependent;
        var type = parameters.type || defaultType || 'exponential';

        var innerFun;
        if (type === 'exponential') {
            innerFun = evaluateExponentialFunction;
        } else if (type === 'interval') {
            innerFun = evaluateIntervalFunction;
        } else if (type === 'categorical') {
            innerFun = evaluateCategoricalFunction;
        } else {
            throw new Error('Unknown function type "' + type + '"');
        }

        if (zoomAndFeatureDependent) {
            var featureFunctions = {};
            var featureFunctionStops = [];
            for (var s = 0; s < parameters.stops.length; s++) {
                var stop = parameters.stops[s];
                if (featureFunctions[stop[0].zoom] === undefined) {
                    featureFunctions[stop[0].zoom] = {
                        zoom: stop[0].zoom,
                        type: parameters.type,
                        property: parameters.property,
                        stops: []
                    };
                }
                featureFunctions[stop[0].zoom].stops.push([stop[0].value, stop[1]]);
            }

            for (var z in featureFunctions) {
                featureFunctionStops.push([featureFunctions[z].zoom, createFunction(featureFunctions[z])]);
            }
            fun = function(zoom, feature) {
                return evaluateExponentialFunction({ stops: featureFunctionStops, base: parameters.base }, zoom)(zoom, feature);
            };
            fun.isFeatureConstant = false;
            fun.isZoomConstant = false;

        } else if (zoomDependent) {
            fun = function(zoom) {
                return innerFun(parameters, zoom);
            };
            fun.isFeatureConstant = true;
            fun.isZoomConstant = false;
        } else {
            fun = function(zoom, feature) {
                return innerFun(parameters, feature[parameters.property]);
            };
            fun.isFeatureConstant = false;
            fun.isZoomConstant = true;
        }
    }

    return fun;
}

function evaluateCategoricalFunction(parameters, input) {
    for (var i = 0; i < parameters.stops.length; i++) {
        if (input === parameters.stops[i][0]) {
            return parameters.stops[i][1];
        }
    }
    return parameters.stops[0][1];
}

function evaluateIntervalFunction(parameters, input) {
    for (var i = 0; i < parameters.stops.length; i++) {
        if (input < parameters.stops[i][0]) break;
    }
    return parameters.stops[Math.max(i - 1, 0)][1];
}

function evaluateExponentialFunction(parameters, input) {
    var base = parameters.base !== undefined ? parameters.base : 1;

    var i = 0;
    while (true) {
        if (i >= parameters.stops.length) break;
        else if (input <= parameters.stops[i][0]) break;
        else i++;
    }

    if (i === 0) {
        return parameters.stops[i][1];

    } else if (i === parameters.stops.length) {
        return parameters.stops[i - 1][1];

    } else {
        return interpolate(
            input,
            base,
            parameters.stops[i - 1][0],
            parameters.stops[i][0],
            parameters.stops[i - 1][1],
            parameters.stops[i][1]
        );
    }
}


function interpolate(input, base, inputLower, inputUpper, outputLower, outputUpper) {
    if (typeof outputLower === 'function') {
        return function() {
            var evaluatedLower = outputLower.apply(undefined, arguments);
            var evaluatedUpper = outputUpper.apply(undefined, arguments);
            return interpolate(input, base, inputLower, inputUpper, evaluatedLower, evaluatedUpper);
        };
    } else if (outputLower.length) {
        return interpolateArray(input, base, inputLower, inputUpper, outputLower, outputUpper);
    } else {
        return interpolateNumber(input, base, inputLower, inputUpper, outputLower, outputUpper);
    }
}

function interpolateNumber(input, base, inputLower, inputUpper, outputLower, outputUpper) {
    var difference =  inputUpper - inputLower;
    var progress = input - inputLower;

    var ratio;
    if (base === 1) {
        ratio = progress / difference;
    } else {
        ratio = (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
    }

    return (outputLower * (1 - ratio)) + (outputUpper * ratio);
}

function interpolateArray(input, base, inputLower, inputUpper, outputLower, outputUpper) {
    var output = [];
    for (var i = 0; i < outputLower.length; i++) {
        output[i] = interpolateNumber(input, base, inputLower, inputUpper, outputLower[i], outputUpper[i]);
    }
    return output;
}

function isFunctionDefinition(value) {
    return typeof value === 'object' && value.stops;
}


module.exports.isFunctionDefinition = isFunctionDefinition;

module.exports.interpolated = function(parameters) {
    return createFunction(parameters, 'exponential');
};

module.exports['piecewise-constant'] = function(parameters) {
    return createFunction(parameters, 'interval');
};

},{}],143:[function(require,module,exports){
'use strict';

if (typeof module !== 'undefined' && module.exports) {
    module.exports = isSupported;
} else if (window) {
    window.mapboxgl = window.mapboxgl || {};
    window.mapboxgl.supported = isSupported;
}

/**
 * Test whether the current browser supports Mapbox GL JS
 * @param {Object} options
 * @param {boolean} [options.failIfMajorPerformanceCaveat=false] Return `false`
 *   if the performance of Mapbox GL JS would be dramatically worse than
 *   expected (i.e. a software renderer is would be used)
 * @return {boolean}
 */
function isSupported(options) {
    return !!(
        isBrowser() &&
        isArraySupported() &&
        isFunctionSupported() &&
        isObjectSupported() &&
        isJSONSupported() &&
        isWorkerSupported() &&
        isWebGLSupportedCached(options && options.failIfMajorPerformanceCaveat)
    );
}

function isBrowser() {
    return typeof window !== 'undefined' && typeof document !== 'undefined';
}

function isArraySupported() {
    return (
        Array.prototype &&
        Array.prototype.every &&
        Array.prototype.filter &&
        Array.prototype.forEach &&
        Array.prototype.indexOf &&
        Array.prototype.lastIndexOf &&
        Array.prototype.map &&
        Array.prototype.some &&
        Array.prototype.reduce &&
        Array.prototype.reduceRight &&
        Array.isArray
    );
}

function isFunctionSupported() {
    return Function.prototype && Function.prototype.bind;
}

function isObjectSupported() {
    return (
        Object.keys &&
        Object.create &&
        Object.getPrototypeOf &&
        Object.getOwnPropertyNames &&
        Object.isSealed &&
        Object.isFrozen &&
        Object.isExtensible &&
        Object.getOwnPropertyDescriptor &&
        Object.defineProperty &&
        Object.defineProperties &&
        Object.seal &&
        Object.freeze &&
        Object.preventExtensions
    );
}

function isJSONSupported() {
    return 'JSON' in window && 'parse' in JSON && 'stringify' in JSON;
}

function isWorkerSupported() {
    return 'Worker' in window;
}

var isWebGLSupportedCache = {};
function isWebGLSupportedCached(failIfMajorPerformanceCaveat) {

    if (isWebGLSupportedCache[failIfMajorPerformanceCaveat] === undefined) {
        isWebGLSupportedCache[failIfMajorPerformanceCaveat] = isWebGLSupported(failIfMajorPerformanceCaveat);
    }

    return isWebGLSupportedCache[failIfMajorPerformanceCaveat];
}

isSupported.webGLContextAttributes = {
    antialias: false,
    alpha: true,
    stencil: true,
    depth: true
};

function isWebGLSupported(failIfMajorPerformanceCaveat) {

    var canvas = document.createElement('canvas');

    var attributes = Object.create(isSupported.webGLContextAttributes);
    attributes.failIfMajorPerformanceCaveat = failIfMajorPerformanceCaveat;

    if (canvas.probablySupportsContext) {
        return (
            canvas.probablySupportsContext('webgl', attributes) ||
            canvas.probablySupportsContext('experimental-webgl', attributes)
        );

    } else if (canvas.supportsContext) {
        return (
            canvas.supportsContext('webgl', attributes) ||
            canvas.supportsContext('experimental-webgl', attributes)
        );

    } else {
        return (
            canvas.getContext('webgl', attributes) ||
            canvas.getContext('experimental-webgl', attributes)
        );
    }
}

},{}],144:[function(require,module,exports){
'use strict';

var format = require('util').format;

function ValidationError(key, value /*, message, ...*/) {
    this.message = (
        (key ? key + ': ' : '') +
        format.apply(format, Array.prototype.slice.call(arguments, 2))
    );

    if (value !== null && value !== undefined && value.__line__) {
        this.line = value.__line__;
    }
}

module.exports = ValidationError;

},{"util":14}],145:[function(require,module,exports){
'use strict';

module.exports = function (output) {
    for (var i = 1; i < arguments.length; i++) {
        var input = arguments[i];
        for (var k in input) {
            output[k] = input[k];
        }
    }
    return output;
};

},{}],146:[function(require,module,exports){
'use strict';

module.exports = function getType(val) {
    if (val instanceof Number) {
        return 'number';
    } else if (val instanceof String) {
        return 'string';
    } else if (val instanceof Boolean) {
        return 'boolean';
    } else if (Array.isArray(val)) {
        return 'array';
    } else if (val === null) {
        return 'null';
    } else {
        return typeof val;
    }
};

},{}],147:[function(require,module,exports){
'use strict';

// Turn jsonlint-lines-primitives objects into primitive objects
module.exports = function unbundle(value) {
    if (value instanceof Number || value instanceof String || value instanceof Boolean) {
        return value.valueOf();
    } else {
        return value;
    }
};

},{}],148:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');
var extend = require('../util/extend');

// Main recursive validation function. Tracks:
//
// - key: string representing location of validation in style tree. Used only
//   for more informative error reporting.
// - value: current value from style being evaluated. May be anything from a
//   high level object that needs to be descended into deeper or a simple
//   scalar value.
// - valueSpec: current spec being evaluated. Tracks value.

module.exports = function validate(options) {

    var validateFunction = require('./validate_function');
    var validateObject = require('./validate_object');
    var VALIDATORS = {
        '*': function() {
            return [];
        },
        'array': require('./validate_array'),
        'boolean': require('./validate_boolean'),
        'number': require('./validate_number'),
        'color': require('./validate_color'),
        'constants': require('./validate_constants'),
        'enum': require('./validate_enum'),
        'filter': require('./validate_filter'),
        'function': require('./validate_function'),
        'layer': require('./validate_layer'),
        'object': require('./validate_object'),
        'source': require('./validate_source'),
        'string': require('./validate_string')
    };

    var value = options.value;
    var valueSpec = options.valueSpec;
    var key = options.key;
    var styleSpec = options.styleSpec;
    var style = options.style;

    if (getType(value) === 'string' && value[0] === '@') {
        if (styleSpec.$version > 7) {
            return [new ValidationError(key, value, 'constants have been deprecated as of v8')];
        }
        if (!(value in style.constants)) {
            return [new ValidationError(key, value, 'constant "%s" not found', value)];
        }
        options = extend({}, options, { value: style.constants[value] });
    }

    if (valueSpec.function && getType(value) === 'object') {
        return validateFunction(options);

    } else if (valueSpec.type && VALIDATORS[valueSpec.type]) {
        return VALIDATORS[valueSpec.type](options);

    } else {
        return validateObject(extend({}, options, {
            valueSpec: valueSpec.type ? styleSpec[valueSpec.type] : valueSpec
        }));
    }
};

},{"../error/validation_error":144,"../util/extend":145,"../util/get_type":146,"./validate_array":149,"./validate_boolean":150,"./validate_color":151,"./validate_constants":152,"./validate_enum":153,"./validate_filter":154,"./validate_function":155,"./validate_layer":157,"./validate_number":159,"./validate_object":160,"./validate_source":162,"./validate_string":163}],149:[function(require,module,exports){
'use strict';

var getType = require('../util/get_type');
var validate = require('./validate');
var ValidationError = require('../error/validation_error');

module.exports = function validateArray(options) {
    var array = options.value;
    var arraySpec = options.valueSpec;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var key = options.key;
    var validateArrayElement = options.arrayElementValidator || validate;

    if (getType(array) !== 'array') {
        return [new ValidationError(key, array, 'array expected, %s found', getType(array))];
    }

    if (arraySpec.length && array.length !== arraySpec.length) {
        return [new ValidationError(key, array, 'array length %d expected, length %d found', arraySpec.length, array.length)];
    }

    if (arraySpec['min-length'] && array.length < arraySpec['min-length']) {
        return [new ValidationError(key, array, 'array length at least %d expected, length %d found', arraySpec['min-length'], array.length)];
    }

    var arrayElementSpec = {
        "type": arraySpec.value
    };

    if (styleSpec.$version < 7) {
        arrayElementSpec.function = arraySpec.function;
    }

    if (getType(arraySpec.value) === 'object') {
        arrayElementSpec = arraySpec.value;
    }

    var errors = [];
    for (var i = 0; i < array.length; i++) {
        errors = errors.concat(validateArrayElement({
            array: array,
            arrayIndex: i,
            value: array[i],
            valueSpec: arrayElementSpec,
            style: style,
            styleSpec: styleSpec,
            key: key + '[' + i + ']'
        }));
    }
    return errors;
};

},{"../error/validation_error":144,"../util/get_type":146,"./validate":148}],150:[function(require,module,exports){
'use strict';

var getType = require('../util/get_type');
var ValidationError = require('../error/validation_error');

module.exports = function validateBoolean(options) {
    var value = options.value;
    var key = options.key;
    var type = getType(value);

    if (type !== 'boolean') {
        return [new ValidationError(key, value, 'boolean expected, %s found', type)];
    }

    return [];
};

},{"../error/validation_error":144,"../util/get_type":146}],151:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');
var parseCSSColor = require('csscolorparser').parseCSSColor;

module.exports = function validateColor(options) {
    var key = options.key;
    var value = options.value;
    var type = getType(value);

    if (type !== 'string') {
        return [new ValidationError(key, value, 'color expected, %s found', type)];
    }

    if (parseCSSColor(value) === null) {
        return [new ValidationError(key, value, 'color expected, "%s" found', value)];
    }

    return [];
};

},{"../error/validation_error":144,"../util/get_type":146,"csscolorparser":119}],152:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');

module.exports = function validateConstants(options) {
    var key = options.key;
    var constants = options.value;
    var styleSpec = options.styleSpec;

    if (styleSpec.$version > 7) {
        if (constants) {
            return [new ValidationError(key, constants, 'constants have been deprecated as of v8')];
        } else {
            return [];
        }
    } else {
        var type = getType(constants);
        if (type !== 'object') {
            return [new ValidationError(key, constants, 'object expected, %s found', type)];
        }

        var errors = [];
        for (var constantName in constants) {
            if (constantName[0] !== '@') {
                errors.push(new ValidationError(key + '.' + constantName, constants[constantName], 'constants must start with "@"'));
            }
        }
        return errors;
    }

};

},{"../error/validation_error":144,"../util/get_type":146}],153:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var unbundle = require('../util/unbundle_jsonlint');

module.exports = function validateEnum(options) {
    var key = options.key;
    var value = options.value;
    var valueSpec = options.valueSpec;
    var errors = [];

    if (valueSpec.values.indexOf(unbundle(value)) === -1) {
        errors.push(new ValidationError(key, value, 'expected one of [%s], %s found', valueSpec.values.join(', '), value));
    }
    return errors;
};

},{"../error/validation_error":144,"../util/unbundle_jsonlint":147}],154:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var validateEnum = require('./validate_enum');
var getType = require('../util/get_type');
var unbundle = require('../util/unbundle_jsonlint');

module.exports = function validateFilter(options) {
    var value = options.value;
    var key = options.key;
    var styleSpec = options.styleSpec;
    var type;

    var errors = [];

    if (getType(value) !== 'array') {
        return [new ValidationError(key, value, 'array expected, %s found', getType(value))];
    }

    if (value.length < 1) {
        return [new ValidationError(key, value, 'filter array must have at least 1 element')];
    }

    errors = errors.concat(validateEnum({
        key: key + '[0]',
        value: value[0],
        valueSpec: styleSpec.filter_operator,
        style: options.style,
        styleSpec: options.styleSpec
    }));

    switch (unbundle(value[0])) {
        case '<':
        case '<=':
        case '>':
        case '>=':
            if (value.length >= 2 && value[1] == '$type') {
                errors.push(new ValidationError(key, value, '"$type" cannot be use with operator "%s"', value[0]));
            }
        /* falls through */
        case '==':
        case '!=':
            if (value.length != 3) {
                errors.push(new ValidationError(key, value, 'filter array for operator "%s" must have 3 elements', value[0]));
            }
        /* falls through */
        case 'in':
        case '!in':
            if (value.length >= 2) {
                type = getType(value[1]);
                if (type !== 'string') {
                    errors.push(new ValidationError(key + '[1]', value[1], 'string expected, %s found', type));
                } else if (value[1][0] === '@') {
                    errors.push(new ValidationError(key + '[1]', value[1], 'filter key cannot be a constant'));
                }
            }
            for (var i = 2; i < value.length; i++) {
                type = getType(value[i]);
                if (value[1] == '$type') {
                    errors = errors.concat(validateEnum({
                        key: key + '[' + i + ']',
                        value: value[i],
                        valueSpec: styleSpec.geometry_type,
                        style: options.style,
                        styleSpec: options.styleSpec
                    }));
                } else if (type === 'string' && value[i][0] === '@') {
                    errors.push(new ValidationError(key + '[' + i + ']', value[i], 'filter value cannot be a constant'));
                } else if (type !== 'string' && type !== 'number' && type !== 'boolean') {
                    errors.push(new ValidationError(key + '[' + i + ']', value[i], 'string, number, or boolean expected, %s found', type));
                }
            }
            break;

        case 'any':
        case 'all':
        case 'none':
            for (i = 1; i < value.length; i++) {
                errors = errors.concat(validateFilter({
                    key: key + '[' + i + ']',
                    value: value[i],
                    style: options.style,
                    styleSpec: options.styleSpec
                }));
            }
            break;

        case 'has':
        case '!has':
            type = getType(value[1]);
            if (value.length !== 2) {
                errors.push(new ValidationError(key, value, 'filter array for "%s" operator must have 2 elements', value[0]));
            } else if (type !== 'string') {
                errors.push(new ValidationError(key + '[1]', value[1], 'string expected, %s found', type));
            } else if (value[1][0] === '@') {
                errors.push(new ValidationError(key + '[1]', value[1], 'filter key cannot be a constant'));
            }
            break;

    }

    return errors;
};

},{"../error/validation_error":144,"../util/get_type":146,"../util/unbundle_jsonlint":147,"./validate_enum":153}],155:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');
var validate = require('./validate');
var validateObject = require('./validate_object');
var validateArray = require('./validate_array');
var validateNumber = require('./validate_number');

module.exports = function validateFunction(options) {
    var originalValueSpec = options.valueSpec;
    var originalValue = options.value;

    var stopKeyType;

    return validateObject({
        key: options.key,
        value: options.value,
        valueSpec: options.styleSpec.function,
        style: options.style,
        styleSpec: options.styleSpec,
        objectElementValidators: { stops: validateFunctionStops }
    });

    function validateFunctionStops(options) {
        var errors = [];
        var value = options.value;

        errors = errors.concat(validateArray({
            key: options.key,
            value: value,
            valueSpec: options.valueSpec,
            style: options.style,
            styleSpec: options.styleSpec,
            arrayElementValidator: validateFunctionStop
        }));

        if (getType(value) === 'array' && value.length === 0) {
            errors.push(new ValidationError(options.key, value, 'array must have at least one stop'));
        }

        return errors;
    }

    function validateFunctionStop(options) {
        var errors = [];
        var value = options.value;
        var key = options.key;

        if (getType(value) !== 'array') {
            return [new ValidationError(key, value, 'array expected, %s found', getType(value))];
        }

        if (value.length !== 2) {
            return [new ValidationError(key, value, 'array length %d expected, length %d found', 2, value.length)];
        }

        var type = getType(value[0]);
        if (!stopKeyType) stopKeyType = type;
        if (type !== stopKeyType) {
            return [new ValidationError(key, value, '%s stop key type must match previous stop key type %s', type, stopKeyType)];
        }

        if (type === 'object') {
            if (value[0].zoom === undefined) {
                return [new ValidationError(key, value, 'object stop key must have zoom')];
            }
            if (value[0].value === undefined) {
                return [new ValidationError(key, value, 'object stop key must have value')];
            }
            errors = errors.concat(validateObject({
                key: key + '[0]',
                value: value[0],
                valueSpec: { zoom: {} },
                style: options.style,
                styleSpec: options.styleSpec,
                objectElementValidators: { zoom: validateNumber, value: validateValue }
            }));
        } else {
            var isZoomFunction = !originalValue.property;
            errors = errors.concat((isZoomFunction ? validateNumber : validateValue)({
                key: key + '[0]',
                value: value[0],
                valueSpec: {},
                style: options.style,
                styleSpec: options.styleSpec
            }));
        }

        errors = errors.concat(validate({
            key: key + '[1]',
            value: value[1],
            valueSpec: originalValueSpec,
            style: options.style,
            styleSpec: options.styleSpec
        }));

        if (getType(value[0]) === 'number') {
            if (originalValueSpec.function === 'piecewise-constant' && value[0] % 1 !== 0) {
                errors.push(new ValidationError(key + '[0]', value[0], 'zoom level for piecewise-constant functions must be an integer'));
            }

            if (options.arrayIndex !== 0) {
                if (value[0] < options.array[options.arrayIndex - 1][0]) {
                    errors.push(new ValidationError(key + '[0]', value[0], 'array stops must appear in ascending order'));
                }
            }
        }

        return errors;
    }

    function validateValue(options) {
        var errors = [];
        var type = getType(options.value);
        if (type !== 'number' && type !== 'string' && type !== 'array') {
            errors.push(new ValidationError(options.key, options.value, 'property value must be a number, string or array'));
        }
        return errors;
    }

};

},{"../error/validation_error":144,"../util/get_type":146,"./validate":148,"./validate_array":149,"./validate_number":159,"./validate_object":160}],156:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var validateString = require('./validate_string');

module.exports = function(options) {
    var value = options.value;
    var key = options.key;

    var errors = validateString(options);
    if (errors.length) return errors;

    if (value.indexOf('{fontstack}') === -1) {
        errors.push(new ValidationError(key, value, '"glyphs" url must include a "{fontstack}" token'));
    }

    if (value.indexOf('{range}') === -1) {
        errors.push(new ValidationError(key, value, '"glyphs" url must include a "{range}" token'));
    }

    return errors;
};

},{"../error/validation_error":144,"./validate_string":163}],157:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var unbundle = require('../util/unbundle_jsonlint');
var validateObject = require('./validate_object');
var validateFilter = require('./validate_filter');
var validatePaintProperty = require('./validate_paint_property');
var validateLayoutProperty = require('./validate_layout_property');
var extend = require('../util/extend');

module.exports = function validateLayer(options) {
    var errors = [];

    var layer = options.value;
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;

    if (!layer.type && !layer.ref) {
        errors.push(new ValidationError(key, layer, 'either "type" or "ref" is required'));
    }
    var type = unbundle(layer.type);
    var ref = unbundle(layer.ref);

    if (layer.id) {
        for (var i = 0; i < options.arrayIndex; i++) {
            var otherLayer = style.layers[i];
            if (unbundle(otherLayer.id) === unbundle(layer.id)) {
                errors.push(new ValidationError(key, layer.id, 'duplicate layer id "%s", previously used at line %d', layer.id, otherLayer.id.__line__));
            }
        }
    }

    if ('ref' in layer) {
        ['type', 'source', 'source-layer', 'filter', 'layout'].forEach(function (p) {
            if (p in layer) {
                errors.push(new ValidationError(key, layer[p], '"%s" is prohibited for ref layers', p));
            }
        });

        var parent;

        style.layers.forEach(function(layer) {
            if (layer.id == ref) parent = layer;
        });

        if (!parent) {
            errors.push(new ValidationError(key, layer.ref, 'ref layer "%s" not found', ref));
        } else if (parent.ref) {
            errors.push(new ValidationError(key, layer.ref, 'ref cannot reference another ref layer'));
        } else {
            type = unbundle(parent.type);
        }
    } else if (type !== 'background') {
        if (!layer.source) {
            errors.push(new ValidationError(key, layer, 'missing required property "source"'));
        } else {
            var source = style.sources[layer.source];
            if (!source) {
                errors.push(new ValidationError(key, layer.source, 'source "%s" not found', layer.source));
            } else if (source.type == 'vector' && type == 'raster') {
                errors.push(new ValidationError(key, layer.source, 'layer "%s" requires a raster source', layer.id));
            } else if (source.type == 'raster' && type != 'raster') {
                errors.push(new ValidationError(key, layer.source, 'layer "%s" requires a vector source', layer.id));
            } else if (source.type == 'vector' && !layer['source-layer']) {
                errors.push(new ValidationError(key, layer, 'layer "%s" must specify a "source-layer"', layer.id));
            }
        }
    }

    errors = errors.concat(validateObject({
        key: key,
        value: layer,
        valueSpec: styleSpec.layer,
        style: options.style,
        styleSpec: options.styleSpec,
        objectElementValidators: {
            filter: validateFilter,
            layout: function(options) {
                return validateObject({
                    layer: layer,
                    key: options.key,
                    value: options.value,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    objectElementValidators: {
                        '*': function(options) {
                            return validateLayoutProperty(extend({layerType: type}, options));
                        }
                    }
                });
            },
            paint: function(options) {
                return validateObject({
                    layer: layer,
                    key: options.key,
                    value: options.value,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    objectElementValidators: {
                        '*': function(options) {
                            return validatePaintProperty(extend({layerType: type}, options));
                        }
                    }
                });
            }
        }
    }));

    return errors;
};

},{"../error/validation_error":144,"../util/extend":145,"../util/unbundle_jsonlint":147,"./validate_filter":154,"./validate_layout_property":158,"./validate_object":160,"./validate_paint_property":161}],158:[function(require,module,exports){
'use strict';

var validate = require('./validate');
var ValidationError = require('../error/validation_error');

module.exports = function validateLayoutProperty(options) {
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var value = options.value;
    var propertyKey = options.objectKey;
    var layerSpec = styleSpec['layout_' + options.layerType];

    if (options.valueSpec || layerSpec[propertyKey]) {
        var errors = [];

        if (options.layerType === 'symbol') {
            if (propertyKey === 'icon-image' && style && !style.sprite) {
                errors.push(new ValidationError(key, value, 'use of "icon-image" requires a style "sprite" property'));
            } else if (propertyKey === 'text-field' && style && !style.glyphs) {
                errors.push(new ValidationError(key, value, 'use of "text-field" requires a style "glyphs" property'));
            }
        }

        return errors.concat(validate({
            key: options.key,
            value: value,
            valueSpec: options.valueSpec || layerSpec[propertyKey],
            style: style,
            styleSpec: styleSpec
        }));

    } else {
        return [new ValidationError(key, value, 'unknown property "%s"', propertyKey)];
    }

};

},{"../error/validation_error":144,"./validate":148}],159:[function(require,module,exports){
'use strict';

var getType = require('../util/get_type');
var ValidationError = require('../error/validation_error');

module.exports = function validateNumber(options) {
    var key = options.key;
    var value = options.value;
    var valueSpec = options.valueSpec;
    var type = getType(value);

    if (type !== 'number') {
        return [new ValidationError(key, value, 'number expected, %s found', type)];
    }

    if ('minimum' in valueSpec && value < valueSpec.minimum) {
        return [new ValidationError(key, value, '%s is less than the minimum value %s', value, valueSpec.minimum)];
    }

    if ('maximum' in valueSpec && value > valueSpec.maximum) {
        return [new ValidationError(key, value, '%s is greater than the maximum value %s', value, valueSpec.maximum)];
    }

    return [];
};

},{"../error/validation_error":144,"../util/get_type":146}],160:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');
var validate = require('./validate');

module.exports = function validateObject(options) {
    var key = options.key;
    var object = options.value;
    var valueSpec = options.valueSpec;
    var objectElementValidators = options.objectElementValidators || {};
    var style = options.style;
    var styleSpec = options.styleSpec;
    var errors = [];

    var type = getType(object);
    if (type !== 'object') {
        return [new ValidationError(key, object, 'object expected, %s found', type)];
    }

    for (var objectKey in object) {
        var valueSpecKey = objectKey.split('.')[0]; // treat 'paint.*' as 'paint'
        var objectElementSpec = valueSpec && (valueSpec[valueSpecKey] || valueSpec['*']);
        var objectElementValidator = objectElementValidators[valueSpecKey] || objectElementValidators['*'];

        if (objectElementSpec || objectElementValidator) {
            errors = errors.concat((objectElementValidator || validate)({
                key: (key ? key + '.' : key) + objectKey,
                value: object[objectKey],
                valueSpec: objectElementSpec,
                style: style,
                styleSpec: styleSpec,
                object: object,
                objectKey: objectKey
            }));

        // tolerate root-level extra keys & arbitrary layer properties
        // TODO remove this layer-specific logic
        } else if (key !== '' && key.split('.').length !== 1) {
            errors.push(new ValidationError(key, object[objectKey], 'unknown property "%s"', objectKey));
        }
    }

    for (valueSpecKey in valueSpec) {
        if (valueSpec[valueSpecKey].required && valueSpec[valueSpecKey]['default'] === undefined && object[valueSpecKey] === undefined) {
            errors.push(new ValidationError(key, object, 'missing required property "%s"', valueSpecKey));
        }
    }

    return errors;
};

},{"../error/validation_error":144,"../util/get_type":146,"./validate":148}],161:[function(require,module,exports){
'use strict';

var validate = require('./validate');
var ValidationError = require('../error/validation_error');

module.exports = function validatePaintProperty(options) {
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var value = options.value;
    var propertyKey = options.objectKey;
    var layerSpec = styleSpec['paint_' + options.layerType];

    var transitionMatch = propertyKey.match(/^(.*)-transition$/);

    if (transitionMatch && layerSpec[transitionMatch[1]] && layerSpec[transitionMatch[1]].transition) {
        return validate({
            key: key,
            value: value,
            valueSpec: styleSpec.transition,
            style: style,
            styleSpec: styleSpec
        });

    } else if (options.valueSpec || layerSpec[propertyKey]) {
        return validate({
            key: options.key,
            value: value,
            valueSpec: options.valueSpec || layerSpec[propertyKey],
            style: style,
            styleSpec: styleSpec
        });

    } else {
        return [new ValidationError(key, value, 'unknown property "%s"', propertyKey)];
    }

};

},{"../error/validation_error":144,"./validate":148}],162:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var unbundle = require('../util/unbundle_jsonlint');
var validateObject = require('./validate_object');
var validateEnum = require('./validate_enum');

module.exports = function validateSource(options) {
    var value = options.value;
    var key = options.key;
    var styleSpec = options.styleSpec;
    var style = options.style;

    if (!value.type) {
        return [new ValidationError(key, value, '"type" is required')];
    }

    var type = unbundle(value.type);
    switch (type) {
        case 'vector':
        case 'raster':
            var errors = [];
            errors = errors.concat(validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_tile,
                style: options.style,
                styleSpec: styleSpec
            }));
            if ('url' in value) {
                for (var prop in value) {
                    if (['type', 'url', 'tileSize'].indexOf(prop) < 0) {
                        errors.push(new ValidationError(key + '.' + prop, value[prop], 'a source with a "url" property may not include a "%s" property', prop));
                    }
                }
            }
            return errors;

        case 'geojson':
            return validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_geojson,
                style: style,
                styleSpec: styleSpec
            });

        case 'video':
            return validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_video,
                style: style,
                styleSpec: styleSpec
            });

        case 'image':
            return validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_image,
                style: style,
                styleSpec: styleSpec
            });

        default:
            return validateEnum({
                key: key + '.type',
                value: value.type,
                valueSpec: {values: ['vector', 'raster', 'geojson', 'video', 'image']},
                style: style,
                styleSpec: styleSpec
            });
    }
};

},{"../error/validation_error":144,"../util/unbundle_jsonlint":147,"./validate_enum":153,"./validate_object":160}],163:[function(require,module,exports){
'use strict';

var getType = require('../util/get_type');
var ValidationError = require('../error/validation_error');

module.exports = function validateString(options) {
    var value = options.value;
    var key = options.key;
    var type = getType(value);

    if (type !== 'string') {
        return [new ValidationError(key, value, 'string expected, %s found', type)];
    }

    return [];
};

},{"../error/validation_error":144,"../util/get_type":146}],164:[function(require,module,exports){
'use strict';

var validateConstants = require('./validate/validate_constants');
var validate = require('./validate/validate');
var latestStyleSpec = require('../reference/latest.min');
var validateGlyphsURL = require('./validate/validate_glyphs_url');

/**
 * Validate a Mapbox GL style against the style specification. This entrypoint,
 * `mapbox-gl-style-spec/lib/validate_style.min`, is designed to produce as
 * small a browserify bundle as possible by omitting unnecessary functionality
 * and legacy style specifications.
 *
 * @param {Object} style The style to be validated.
 * @param {Object} [styleSpec] The style specification to validate against.
 *     If omitted, the latest style spec is used.
 * @returns {Array<ValidationError>}
 * @example
 *   var validate = require('mapbox-gl-style-spec/lib/validate_style.min');
 *   var errors = validate(style);
 */
function validateStyleMin(style, styleSpec) {
    styleSpec = styleSpec || latestStyleSpec;

    var errors = [];

    errors = errors.concat(validate({
        key: '',
        value: style,
        valueSpec: styleSpec.$root,
        styleSpec: styleSpec,
        style: style,
        objectElementValidators: {
            glyphs: validateGlyphsURL
        }
    }));

    if (styleSpec.$version > 7 && style.constants) {
        errors = errors.concat(validateConstants({
            key: 'constants',
            value: style.constants,
            style: style,
            styleSpec: styleSpec
        }));
    }

    return sortErrors(errors);
}

validateStyleMin.source = wrapCleanErrors(require('./validate/validate_source'));
validateStyleMin.layer = wrapCleanErrors(require('./validate/validate_layer'));
validateStyleMin.filter = wrapCleanErrors(require('./validate/validate_filter'));
validateStyleMin.paintProperty = wrapCleanErrors(require('./validate/validate_paint_property'));
validateStyleMin.layoutProperty = wrapCleanErrors(require('./validate/validate_layout_property'));

function sortErrors(errors) {
    return [].concat(errors).sort(function (a, b) {
        return a.line - b.line;
    });
}

function wrapCleanErrors(inner) {
    return function() {
        return sortErrors(inner.apply(this, arguments));
    };
}

module.exports = validateStyleMin;

},{"../reference/latest.min":166,"./validate/validate":148,"./validate/validate_constants":152,"./validate/validate_filter":154,"./validate/validate_glyphs_url":156,"./validate/validate_layer":157,"./validate/validate_layout_property":158,"./validate/validate_paint_property":161,"./validate/validate_source":162}],165:[function(require,module,exports){
module.exports = require('./v8.json');

},{"./v8.json":167}],166:[function(require,module,exports){
module.exports = require('./v8.min.json');

},{"./v8.min.json":168}],167:[function(require,module,exports){
module.exports={
  "$version": 8,
  "$root": {
    "version": {
      "required": true,
      "type": "enum",
      "values": [8],
      "doc": "Stylesheet version number. Must be 8.",
      "example": 8
    },
    "name": {
      "type": "string",
      "doc": "A human-readable name for the style.",
      "example": "Bright"
    },
    "metadata": {
      "type": "*",
      "doc": "Arbitrary properties useful to track with the stylesheet, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
    },
    "center": {
      "type": "array",
      "value": "number",
      "doc": "Default map center in longitude and latitude.  The style center will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
      "example": [-73.9749, 40.7736]
    },
    "zoom": {
      "type": "number",
      "doc": "Default zoom level.  The style zoom will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
      "example": 12.5
    },
    "bearing": {
      "type": "number",
      "default": 0,
      "period": 360,
      "units": "degrees",
      "doc": "Default bearing, in degrees.  The style bearing will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
      "example": 29
    },
    "pitch": {
      "type": "number",
      "default": 0,
      "units": "degrees",
      "doc": "Default pitch, in degrees. Zero is perpendicular to the surface.  The style pitch will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
      "example": 50
    },
    "sources": {
      "required": true,
      "type": "sources",
      "doc": "Data source specifications.",
      "example": {
        "mapbox-streets": {
          "type": "vector",
          "url": "mapbox://mapbox.mapbox-streets-v6"
        }
      }
    },
    "sprite": {
      "type": "string",
      "doc": "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended. This property is required if any layer uses the 'sprite-image' layout property.",
      "example": "mapbox://sprites/mapbox/bright-v8"
    },
    "glyphs": {
      "type": "string",
      "doc": "A URL template for loading signed-distance-field glyph sets in PBF format. The URL must include `{fontstack}` and `{range}` tokens. This property is required if any layer uses the 'text-field' layout property.",
      "example": "mapbox://fonts/mapbox/{fontstack}/{range}.pbf"
    },
    "transition": {
      "type": "transition",
      "doc": "A global transition definition to use as a default across properties.",
      "example": {
        "duration": 300,
        "delay": 0
      }
    },
    "layers": {
      "required": true,
      "type": "array",
      "value": "layer",
      "doc": "Layers will be drawn in the order of this array.",
      "example": [
        {
          "id": "water",
          "source": "mapbox-streets",
          "source-layer": "water",
          "type": "fill",
          "paint": {
            "fill-color": "#00ffff"
          }
        }
      ]
    }
  },
  "sources": {
    "*": {
      "type": "source",
      "doc": "Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For GeoJSON and video sources, a URL must be provided."
    }
  },
  "source": [
    "source_tile",
    "source_geojson",
    "source_video",
    "source_image"
  ],
  "source_tile": {
    "type": {
      "required": true,
      "type": "enum",
      "values": [
        "vector",
        "raster"
      ],
      "doc": "The data type of the tile source."
    },
    "url": {
      "type": "string",
      "doc": "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<mapid>`."
    },
    "tiles": {
      "type": "array",
      "value": "string",
      "doc": "An array of one or more tile source URLs, as in the TileJSON spec."
    },
    "minzoom": {
      "type": "number",
      "default": 0,
      "doc": "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    },
    "maxzoom": {
      "type": "number",
      "default": 22,
      "doc": "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    },
    "tileSize": {
      "type": "number",
      "default": 512,
      "units": "pixels",
      "doc": "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
    },
    "*": {
      "type": "*",
      "doc": "Other keys to configure the data source."
    }
  },
  "source_geojson": {
    "type": {
      "required": true,
      "type": "enum",
      "values": [
        "geojson"
      ],
      "doc": "The data type of the GeoJSON source."
    },
    "data": {
      "type": "*",
      "doc": "A URL to a GeoJSON file, or inline GeoJSON."
    },
    "maxzoom": {
      "type": "number",
      "default": 14,
      "doc": "Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels)."
    },
    "buffer": {
      "type": "number",
      "default": 64,
      "doc": "Tile buffer size on each side (higher means fewer rendering artifacts near tile edges but slower performance)."
    },
    "tolerance": {
      "type": "number",
      "default": 3,
      "doc": "Douglas-Peucker simplification tolerance (higher means simpler geometries and faster performance)."
    },
    "cluster": {
      "type": "boolean",
      "default": false,
      "doc": "If the data is a collection of point features, setting this to true clusters the points by radius into groups."
    },
    "clusterRadius": {
      "type": "number",
      "default": 400,
      "doc": "Radius of each cluster when clustering points, relative to 4096 tile."
    },
    "clusterMaxZoom": {
      "type": "number",
      "doc": "Max zoom to cluster points on. Defaults to one zoom less than maxzoom (so that last zoom features are not clustered)."
    }
  },
  "source_video": {
    "type": {
      "required": true,
      "type": "enum",
      "values": [
        "video"
      ],
      "doc": "The data type of the video source."
    },
    "urls": {
      "required": true,
      "type": "array",
      "value": "string",
      "doc": "URLs to video content in order of preferred format."
    },
    "coordinates": {
      "required": true,
      "doc": "Corners of video specified in longitude, latitude pairs.",
      "type": "array",
      "length": 4,
      "value": {
        "type": "array",
        "length": 2,
        "value": "number",
        "doc": "A single longitude, latitude pair."
      }
    }
  },
  "source_image": {
    "type": {
      "required": true,
      "type": "enum",
      "values": [
        "image"
      ],
      "doc": "The data type of the image source."
    },
    "url": {
      "required": true,
      "type": "string",
      "doc": "URL that points to an image"
    },
    "coordinates": {
      "required": true,
      "doc": "Corners of image specified in longitude, latitude pairs.",
      "type": "array",
      "length": 4,
      "value": {
        "type": "array",
        "length": 2,
        "value": "number",
        "doc": "A single longitude, latitude pair."
      }
    }
  },
  "layer": {
    "id": {
      "type": "string",
      "doc": "Unique layer name.",
      "required": true
    },
    "type": {
      "type": "enum",
      "values": [
        "fill",
        "line",
        "symbol",
        "circle",
        "raster",
        "background"
      ],
      "doc": "Rendering type of this layer."
    },
    "metadata": {
      "type": "*",
      "doc": "Arbitrary properties useful to track with the layer, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
    },
    "ref": {
      "type": "string",
      "doc": "References another layer to copy `type`, `source`, `source-layer`, `minzoom`, `maxzoom`, `filter`, and `layout` properties from. This allows the layers to share processing and be more efficient."
    },
    "source": {
      "type": "string",
      "doc": "Name of a source description to be used for this layer."
    },
    "source-layer": {
      "type": "string",
      "doc": "Layer to use from a vector tile source. Required if the source supports multiple layers."
    },
    "minzoom": {
      "type": "number",
      "minimum": 0,
      "maximum": 22,
      "doc": "The minimum zoom level on which the layer gets parsed and appears on."
    },
    "maxzoom": {
      "type": "number",
      "minimum": 0,
      "maximum": 22,
      "doc": "The maximum zoom level on which the layer gets parsed and appears on."
    },
    "interactive": {
      "type": "boolean",
      "doc": "Enable querying of feature data from this layer for interactivity.",
      "default": false
    },
    "filter": {
      "type": "filter",
      "doc": "A expression specifying conditions on source features. Only features that match the filter are displayed."
    },
    "layout": {
      "type": "layout",
      "doc": "Layout properties for the layer."
    },
    "paint": {
      "type": "paint",
      "doc": "Default paint properties for this layer."
    },
    "paint.*": {
      "type": "paint",
      "doc": "Class-specific paint properties for this layer. The class name is the part after the first dot."
    }
  },
  "layout": [
    "layout_fill",
    "layout_line",
    "layout_circle",
    "layout_symbol",
    "layout_raster",
    "layout_background"
  ],
  "layout_background": {
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "layout_fill": {
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "layout_circle": {
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "layout_line": {
    "line-cap": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "butt",
        "round",
        "square"
      ],
      "default": "butt",
      "doc": "The display of line endings."
    },
    "line-join": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "bevel",
        "round",
        "miter"
      ],
      "default": "miter",
      "doc": "The display of lines when joining."
    },
    "line-miter-limit": {
      "type": "number",
      "default": 2,
      "function": "interpolated",
      "doc": "Used to automatically convert miter joins to bevel joins for sharp angles.",
      "requires": [
        {
          "line-join": "miter"
        }
      ]
    },
    "line-round-limit": {
      "type": "number",
      "default": 1.05,
      "function": "interpolated",
      "doc": "Used to automatically convert round joins to miter joins for shallow angles.",
      "requires": [
        {
          "line-join": "round"
        }
      ]
    },
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "layout_symbol": {
    "symbol-placement": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
          "point",
          "line"
      ],
      "default": "point",
      "doc": "Label placement relative to its geometry. `line` can only be used on LineStrings and Polygons."
    },
    "symbol-spacing": {
      "type": "number",
      "default": 250,
      "minimum": 1,
      "function": "interpolated",
      "units": "pixels",
      "doc": "Distance between two symbol anchors.",
      "requires": [
        {
          "symbol-placement": "line"
        }
      ]
    },
    "symbol-avoid-edges": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer."
    },
    "icon-allow-overlap": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, the icon will be visible even if it collides with other previously drawn symbols.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-ignore-placement": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, other symbols can be visible even if they collide with the icon.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-optional": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, text will display without their corresponding icons when the icon collides with other symbols and the text does not.",
      "requires": [
        "icon-image",
        "text-field"
      ]
    },
    "icon-rotation-alignment": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "default": "viewport",
      "doc": "Orientation of icon when map is rotated.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-size": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "function": "interpolated",
      "doc": "Scale factor for icon. 1 is original size, 3 triples the size.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-image": {
      "type": "string",
      "function": "piecewise-constant",
      "doc": "A string with {tokens} replaced, referencing the data property to pull from.",
      "tokens": true
    },
    "icon-rotate": {
      "type": "number",
      "default": 0,
      "period": 360,
      "function": "interpolated",
      "units": "degrees",
      "doc": "Rotates the icon clockwise.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-padding": {
      "type": "number",
      "default": 2,
      "minimum": 0,
      "function": "interpolated",
      "units": "pixels",
      "doc": "Size of the additional area around the icon bounding box used for detecting symbol collisions.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-keep-upright": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, the icon may be flipped to prevent it from being rendered upside-down.",
      "requires": [
        "icon-image",
        {
          "icon-rotation-alignment": "map"
        },
        {
          "symbol-placement": "line"
        }
      ]
    },
    "icon-offset": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "doc": "Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up.",
      "requires": [
        "icon-image"
      ]
    },
    "text-rotation-alignment": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "default": "viewport",
      "doc": "Orientation of text when map is rotated.",
      "requires": [
        "text-field"
      ]
    },
    "text-field": {
      "type": "string",
      "function": "piecewise-constant",
      "default": "",
      "tokens": true,
      "doc": "Value to use for a text label. Feature properties are specified using tokens like {field_name}."
    },
    "text-font": {
      "type": "array",
      "value": "string",
      "function": "piecewise-constant",
      "default": ["Open Sans Regular", "Arial Unicode MS Regular"],
      "doc": "Font stack to use for displaying text.",
      "requires": [
        "text-field"
      ]
    },
    "text-size": {
      "type": "number",
      "default": 16,
      "minimum": 0,
      "units": "pixels",
      "function": "interpolated",
      "doc": "Font size.",
      "requires": [
        "text-field"
      ]
    },
    "text-max-width": {
      "type": "number",
      "default": 10,
      "minimum": 0,
      "units": "em",
      "function": "interpolated",
      "doc": "The maximum line width for text wrapping.",
      "requires": [
        "text-field"
      ]
    },
    "text-line-height": {
      "type": "number",
      "default": 1.2,
      "units": "em",
      "function": "interpolated",
      "doc": "Text leading value for multi-line text.",
      "requires": [
        "text-field"
      ]
    },
    "text-letter-spacing": {
      "type": "number",
      "default": 0,
      "units": "em",
      "function": "interpolated",
      "doc": "Text tracking amount.",
      "requires": [
        "text-field"
      ]
    },
    "text-justify": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "left",
        "center",
        "right"
      ],
      "default": "center",
      "doc": "Text justification options.",
      "requires": [
        "text-field"
      ]
    },
    "text-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "center",
        "left",
        "right",
        "top",
        "bottom",
        "top-left",
        "top-right",
        "bottom-left",
        "bottom-right"
      ],
      "default": "center",
      "doc": "Part of the text placed closest to the anchor.",
      "requires": [
        "text-field"
      ]
    },
    "text-max-angle": {
      "type": "number",
      "default": 45,
      "units": "degrees",
      "function": "interpolated",
      "doc": "Maximum angle change between adjacent characters.",
      "requires": [
        "text-field",
        {
          "symbol-placement": "line"
        }
      ]
    },
    "text-rotate": {
      "type": "number",
      "default": 0,
      "period": 360,
      "units": "degrees",
      "function": "interpolated",
      "doc": "Rotates the text clockwise.",
      "requires": [
        "text-field"
      ]
    },
    "text-padding": {
      "type": "number",
      "default": 2,
      "minimum": 0,
      "units": "pixels",
      "function": "interpolated",
      "doc": "Size of the additional area around the text bounding box used for detecting symbol collisions.",
      "requires": [
        "text-field"
      ]
    },
    "text-keep-upright": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": true,
      "doc": "If true, the text may be flipped vertically to prevent it from being rendered upside-down.",
      "requires": [
        "text-field",
        {
          "text-rotation-alignment": "map"
        },
        {
          "symbol-placement": "line"
        }
      ]
    },
    "text-transform": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "none",
        "uppercase",
        "lowercase"
      ],
      "default": "none",
      "doc": "Specifies how to capitalize text, similar to the CSS `text-transform` property.",
      "requires": [
        "text-field"
      ]
    },
    "text-offset": {
      "type": "array",
      "doc": "Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up.",
      "value": "number",
      "units": "ems",
      "function": "interpolated",
      "length": 2,
      "default": [
        0,
        0
      ],
      "requires": [
        "text-field"
      ]
    },
    "text-allow-overlap": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, the text will be visible even if it collides with other previously drawn symbols.",
      "requires": [
        "text-field"
      ]
    },
    "text-ignore-placement": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, other symbols can be visible even if they collide with the text.",
      "requires": [
        "text-field"
      ]
    },
    "text-optional": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, icons will display without their corresponding text when the text collides with other symbols and the icon does not.",
      "requires": [
        "text-field",
        "icon-image"
      ]
    },
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "layout_raster": {
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "filter": {
    "type": "array",
    "value": "*",
    "doc": "A filter selects specific features from a layer."
  },
  "filter_operator": {
    "type": "enum",
    "values": [
      "==",
      "!=",
      ">",
      ">=",
      "<",
      "<=",
      "in",
      "!in",
      "all",
      "any",
      "none",
      "has",
      "!has"
    ],
    "doc": "The filter operator."
  },
  "geometry_type": {
    "type": "enum",
    "values": [
      "Point",
      "LineString",
      "Polygon"
    ],
    "doc": "The geometry type for the filter to select."
  },
  "color_operation": {
    "type": "enum",
    "values": [
      "lighten",
      "saturate",
      "spin",
      "fade",
      "mix"
    ],
    "doc": "A color operation to apply."
  },
  "function": {
    "stops": {
      "type": "array",
      "required": true,
      "doc": "An array of stops.",
      "value": "function_stop"
    },
    "base": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "doc": "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."
    },
    "property": {
      "type": "string",
      "doc": "The name of a global property or feature property to use as the function input.",
      "default": "$zoom"
    },
    "type": {
      "type": "enum",
      "values": [
          "exponential",
          "interval",
          "categorical"
      ],
      "doc": "The interpolation strategy to use in function evaluation.",
      "default": "exponential"
    }
  },
  "function_stop": {
    "type": "array",
    "minimum": 0,
    "maximum": 22,
    "value": [
      "number",
      "color"
    ],
    "length": 2,
    "doc": "Zoom level and value pair."
  },
  "paint": [
    "paint_fill",
    "paint_line",
    "paint_circle",
    "paint_symbol",
    "paint_raster",
    "paint_background"
  ],
  "paint_fill": {
    "fill-antialias": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": true,
      "doc": "Whether or not the fill should be antialiased."
    },
    "fill-opacity": {
      "type": "number",
      "function": "interpolated",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "doc": "The opacity given to the fill color.",
      "transition": true
    },
    "fill-color": {
      "type": "color",
      "default": "#000000",
      "doc": "The color of the fill.",
      "function": "interpolated",
      "transition": true,
      "requires": [
        {
          "!": "fill-pattern"
        }
      ]
    },
    "fill-outline-color": {
      "type": "color",
      "doc": "The outline color of the fill. Matches the value of `fill-color` if unspecified.",
      "function": "interpolated",
      "transition": true,
      "requires": [
        {
          "!": "fill-pattern"
        },
        {
          "fill-antialias": true
        }
      ]
    },
    "fill-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "fill-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map",
      "requires": [
        "fill-translate"
      ]
    },
    "fill-pattern": {
      "type": "string",
      "function": "piecewise-constant",
      "transition": true,
      "doc": "Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512)."
    }
  },
  "paint_line": {
    "line-opacity": {
      "type": "number",
      "doc": "The opacity at which the line will be drawn.",
      "function": "interpolated",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "transition": true
    },
    "line-color": {
      "type": "color",
      "doc": "The color with which the line will be drawn.",
      "default": "#000000",
      "function": "interpolated",
      "transition": true,
      "requires": [
        {
          "!": "line-pattern"
        }
      ]
    },
    "line-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "line-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map",
      "requires": [
        "line-translate"
      ]
    },
    "line-width": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Stroke thickness."
    },
    "line-gap-width": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "doc": "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
      "function": "interpolated",
      "transition": true,
      "units": "pixels"
    },
    "line-offset": {
      "type": "number",
      "default": 0,
      "doc": "The line's offset perpendicular to its direction. Values may be positive or negative, where positive indicates \"rightwards\" (if you were moving in the direction of the line) and negative indicates \"leftwards.\"",
      "function": "interpolated",
      "transition": true,
      "units": "pixels"
    },
    "line-blur": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Blur applied to the line, in pixels."
    },
    "line-dasharray": {
      "type": "array",
      "value": "number",
      "function": "piecewise-constant",
      "doc": "Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width.",
      "minimum": 0,
      "transition": true,
      "units": "line widths",
      "requires": [
        {
          "!": "line-pattern"
        }
      ]
    },
    "line-pattern": {
      "type": "string",
      "function": "piecewise-constant",
      "transition": true,
      "doc": "Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512)."
    }
  },
  "paint_circle": {
    "circle-radius": {
      "type": "number",
      "default": 5,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Circle radius."
    },
    "circle-color": {
      "type": "color",
      "default": "#000000",
      "doc": "The color of the circle.",
      "function": "interpolated",
      "transition": true
    },
    "circle-blur": {
      "type": "number",
      "default": 0,
      "doc": "Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.",
      "function": "interpolated",
      "transition": true
    },
    "circle-opacity": {
      "type": "number",
      "doc": "The opacity at which the circle will be drawn.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "transition": true
    },
    "circle-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [0, 0],
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "circle-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map",
      "requires": [
        "circle-translate"
      ]
    }
  },
  "paint_symbol": {
    "icon-opacity": {
      "doc": "The opacity at which the icon will be drawn.",
      "type": "number",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "transition": true,
      "requires": [
        "icon-image"
      ]
    },
    "icon-color": {
      "type": "color",
      "default": "#000000",
      "function": "interpolated",
      "transition": true,
      "doc": "The color of the icon. This can only be used with sdf icons.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-halo-color": {
      "type": "color",
      "default": "rgba(0, 0, 0, 0)",
      "function": "interpolated",
      "transition": true,
      "doc": "The color of the icon's halo. Icon halos can only be used with sdf icons.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-halo-width": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Distance of halo to the icon outline.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-halo-blur": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Fade out the halo towards the outside.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Distance that the icon's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen).",
      "default": "map",
      "requires": [
        "icon-image",
        "icon-translate"
      ]
    },
    "text-opacity": {
      "type": "number",
      "doc": "The opacity at which the text will be drawn.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "transition": true,
      "requires": [
        "text-field"
      ]
    },
    "text-color": {
      "type": "color",
      "doc": "The color with which the text will be drawn.",
      "default": "#000000",
      "function": "interpolated",
      "transition": true,
      "requires": [
        "text-field"
      ]
    },
    "text-halo-color": {
      "type": "color",
      "default": "rgba(0, 0, 0, 0)",
      "function": "interpolated",
      "transition": true,
      "doc": "The color of the text's halo, which helps it stand out from backgrounds.",
      "requires": [
        "text-field"
      ]
    },
    "text-halo-width": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.",
      "requires": [
        "text-field"
      ]
    },
    "text-halo-blur": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "The halo's fadeout distance towards the outside.",
      "requires": [
        "text-field"
      ]
    },
    "text-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Distance that the text's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
      "requires": [
        "text-field"
      ]
    },
    "text-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen).",
      "default": "map",
      "requires": [
        "text-field",
        "text-translate"
      ]
    }
  },
  "paint_raster": {
    "raster-opacity": {
      "type": "number",
      "doc": "The opacity at which the image will be drawn.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "transition": true
    },
    "raster-hue-rotate": {
      "type": "number",
      "default": 0,
      "period": 360,
      "function": "interpolated",
      "transition": true,
      "units": "degrees",
      "doc": "Rotates hues around the color wheel."
    },
    "raster-brightness-min": {
      "type": "number",
      "function": "interpolated",
      "doc": "Increase or reduce the brightness of the image. The value is the minimum brightness.",
      "default": 0,
      "minimum": 0,
      "maximum": 1,
      "transition": true
    },
    "raster-brightness-max": {
      "type": "number",
      "function": "interpolated",
      "doc": "Increase or reduce the brightness of the image. The value is the maximum brightness.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "transition": true
    },
    "raster-saturation": {
      "type": "number",
      "doc": "Increase or reduce the saturation of the image.",
      "default": 0,
      "minimum": -1,
      "maximum": 1,
      "function": "interpolated",
      "transition": true
    },
    "raster-contrast": {
      "type": "number",
      "doc": "Increase or reduce the contrast of the image.",
      "default": 0,
      "minimum": -1,
      "maximum": 1,
      "function": "interpolated",
      "transition": true
    },
    "raster-fade-duration": {
      "type": "number",
      "default": 300,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "milliseconds",
      "doc": "Fade duration when a new tile is added."
    }
  },
  "paint_background": {
    "background-color": {
      "type": "color",
      "default": "#000000",
      "doc": "The color with which the background will be drawn.",
      "function": "interpolated",
      "transition": true,
      "requires": [
        {
          "!": "background-pattern"
        }
      ]
    },
    "background-pattern": {
      "type": "string",
      "function": "piecewise-constant",
      "transition": true,
      "doc": "Name of image in sprite to use for drawing an image background. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512)."
    },
    "background-opacity": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "doc": "The opacity at which the background will be drawn.",
      "function": "interpolated",
      "transition": true
    }
  },
  "transition": {
    "duration": {
      "type": "number",
      "default": 300,
      "minimum": 0,
      "units": "milliseconds",
      "doc": "Time allotted for transitions to complete."
    },
    "delay": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "units": "milliseconds",
      "doc": "Length of time before a transition begins."
    }
  }
}

},{}],168:[function(require,module,exports){
module.exports={"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_tile","source_geojson","source_video","source_image"],"source_tile":{"type":{"required":true,"type":"enum","values":["vector","raster"]},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":["geojson"]},"data":{"type":"*"},"maxzoom":{"type":"number","default":14},"buffer":{"type":"number","default":64},"tolerance":{"type":"number","default":3},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":400},"clusterMaxZoom":{"type":"number"}},"source_video":{"type":{"required":true,"type":"enum","values":["video"]},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":["image"]},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":["fill","line","symbol","circle","raster","background"]},"metadata":{"type":"*"},"ref":{"type":"string"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":22},"maxzoom":{"type":"number","minimum":0,"maximum":22},"interactive":{"type":"boolean","default":false},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"},"paint.*":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_symbol","layout_raster","layout_background"],"layout_background":{"visibility":{"type":"enum","function":"piecewise-constant","values":["visible","none"],"default":"visible"}},"layout_fill":{"visibility":{"type":"enum","function":"piecewise-constant","values":["visible","none"],"default":"visible"}},"layout_circle":{"visibility":{"type":"enum","function":"piecewise-constant","values":["visible","none"],"default":"visible"}},"layout_line":{"line-cap":{"type":"enum","function":"piecewise-constant","values":["butt","round","square"],"default":"butt"},"line-join":{"type":"enum","function":"piecewise-constant","values":["bevel","round","miter"],"default":"miter"},"line-miter-limit":{"type":"number","default":2,"function":"interpolated","requires":[{"line-join":"miter"}]},"line-round-limit":{"type":"number","default":1.05,"function":"interpolated","requires":[{"line-join":"round"}]},"visibility":{"type":"enum","function":"piecewise-constant","values":["visible","none"],"default":"visible"}},"layout_symbol":{"symbol-placement":{"type":"enum","function":"piecewise-constant","values":["point","line"],"default":"point"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"function":"interpolated","units":"pixels","requires":[{"symbol-placement":"line"}]},"symbol-avoid-edges":{"type":"boolean","function":"piecewise-constant","default":false},"icon-allow-overlap":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["icon-image"]},"icon-ignore-placement":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["icon-image"]},"icon-optional":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["icon-image","text-field"]},"icon-rotation-alignment":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"viewport","requires":["icon-image"]},"icon-size":{"type":"number","default":1,"minimum":0,"function":"interpolated","requires":["icon-image"]},"icon-image":{"type":"string","function":"piecewise-constant","tokens":true},"icon-rotate":{"type":"number","default":0,"period":360,"function":"interpolated","units":"degrees","requires":["icon-image"]},"icon-padding":{"type":"number","default":2,"minimum":0,"function":"interpolated","units":"pixels","requires":["icon-image"]},"icon-keep-upright":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":"line"}]},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","requires":["icon-image"]},"text-rotation-alignment":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"viewport","requires":["text-field"]},"text-field":{"type":"string","function":"piecewise-constant","default":"","tokens":true},"text-font":{"type":"array","value":"string","function":"piecewise-constant","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"]},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","function":"interpolated","requires":["text-field"]},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"em","function":"interpolated","requires":["text-field"]},"text-line-height":{"type":"number","default":1.2,"units":"em","function":"interpolated","requires":["text-field"]},"text-letter-spacing":{"type":"number","default":0,"units":"em","function":"interpolated","requires":["text-field"]},"text-justify":{"type":"enum","function":"piecewise-constant","values":["left","center","right"],"default":"center","requires":["text-field"]},"text-anchor":{"type":"enum","function":"piecewise-constant","values":["center","left","right","top","bottom","top-left","top-right","bottom-left","bottom-right"],"default":"center","requires":["text-field"]},"text-max-angle":{"type":"number","default":45,"units":"degrees","function":"interpolated","requires":["text-field",{"symbol-placement":"line"}]},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","function":"interpolated","requires":["text-field"]},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","function":"interpolated","requires":["text-field"]},"text-keep-upright":{"type":"boolean","function":"piecewise-constant","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":"line"}]},"text-transform":{"type":"enum","function":"piecewise-constant","values":["none","uppercase","lowercase"],"default":"none","requires":["text-field"]},"text-offset":{"type":"array","value":"number","units":"ems","function":"interpolated","length":2,"default":[0,0],"requires":["text-field"]},"text-allow-overlap":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["text-field"]},"text-ignore-placement":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["text-field"]},"text-optional":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["text-field","icon-image"]},"visibility":{"type":"enum","function":"piecewise-constant","values":["visible","none"],"default":"visible"}},"layout_raster":{"visibility":{"type":"enum","function":"piecewise-constant","values":["visible","none"],"default":"visible"}},"filter":{"type":"array","value":"*"},"filter_operator":{"type":"enum","values":["==","!=",">",">=","<","<=","in","!in","all","any","none","has","!has"]},"geometry_type":{"type":"enum","values":["Point","LineString","Polygon"]},"color_operation":{"type":"enum","values":["lighten","saturate","spin","fade","mix"]},"function":{"stops":{"type":"array","required":true,"value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":["exponential","interval","categorical"],"default":"exponential"}},"function_stop":{"type":"array","minimum":0,"maximum":22,"value":["number","color"],"length":2},"paint":["paint_fill","paint_line","paint_circle","paint_symbol","paint_raster","paint_background"],"paint_fill":{"fill-antialias":{"type":"boolean","function":"piecewise-constant","default":true},"fill-opacity":{"type":"number","function":"interpolated","default":1,"minimum":0,"maximum":1,"transition":true},"fill-color":{"type":"color","default":"#000000","function":"interpolated","transition":true,"requires":[{"!":"fill-pattern"}]},"fill-outline-color":{"type":"color","function":"interpolated","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}]},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","transition":true,"units":"pixels"},"fill-translate-anchor":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"map","requires":["fill-translate"]},"fill-pattern":{"type":"string","function":"piecewise-constant","transition":true}},"paint_line":{"line-opacity":{"type":"number","function":"interpolated","default":1,"minimum":0,"maximum":1,"transition":true},"line-color":{"type":"color","default":"#000000","function":"interpolated","transition":true,"requires":[{"!":"line-pattern"}]},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","transition":true,"units":"pixels"},"line-translate-anchor":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"map","requires":["line-translate"]},"line-width":{"type":"number","default":1,"minimum":0,"function":"interpolated","transition":true,"units":"pixels"},"line-gap-width":{"type":"number","default":0,"minimum":0,"function":"interpolated","transition":true,"units":"pixels"},"line-offset":{"type":"number","default":0,"function":"interpolated","transition":true,"units":"pixels"},"line-blur":{"type":"number","default":0,"minimum":0,"function":"interpolated","transition":true,"units":"pixels"},"line-dasharray":{"type":"array","value":"number","function":"piecewise-constant","minimum":0,"transition":true,"units":"line widths","requires":[{"!":"line-pattern"}]},"line-pattern":{"type":"string","function":"piecewise-constant","transition":true}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"function":"interpolated","transition":true,"units":"pixels"},"circle-color":{"type":"color","default":"#000000","function":"interpolated","transition":true},"circle-blur":{"type":"number","default":0,"function":"interpolated","transition":true},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","transition":true},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","transition":true,"units":"pixels"},"circle-translate-anchor":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"map","requires":["circle-translate"]}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","transition":true,"requires":["icon-image"]},"icon-color":{"type":"color","default":"#000000","function":"interpolated","transition":true,"requires":["icon-image"]},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","function":"interpolated","transition":true,"requires":["icon-image"]},"icon-halo-width":{"type":"number","default":0,"minimum":0,"function":"interpolated","transition":true,"units":"pixels","requires":["icon-image"]},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"function":"interpolated","transition":true,"units":"pixels","requires":["icon-image"]},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","transition":true,"units":"pixels","requires":["icon-image"]},"icon-translate-anchor":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"map","requires":["icon-image","icon-translate"]},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","transition":true,"requires":["text-field"]},"text-color":{"type":"color","default":"#000000","function":"interpolated","transition":true,"requires":["text-field"]},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","function":"interpolated","transition":true,"requires":["text-field"]},"text-halo-width":{"type":"number","default":0,"minimum":0,"function":"interpolated","transition":true,"units":"pixels","requires":["text-field"]},"text-halo-blur":{"type":"number","default":0,"minimum":0,"function":"interpolated","transition":true,"units":"pixels","requires":["text-field"]},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","transition":true,"units":"pixels","requires":["text-field"]},"text-translate-anchor":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"map","requires":["text-field","text-translate"]}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","transition":true},"raster-hue-rotate":{"type":"number","default":0,"period":360,"function":"interpolated","transition":true,"units":"degrees"},"raster-brightness-min":{"type":"number","function":"interpolated","default":0,"minimum":0,"maximum":1,"transition":true},"raster-brightness-max":{"type":"number","function":"interpolated","default":1,"minimum":0,"maximum":1,"transition":true},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"function":"interpolated","transition":true},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"function":"interpolated","transition":true},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"function":"interpolated","transition":true,"units":"milliseconds"}},"paint_background":{"background-color":{"type":"color","default":"#000000","function":"interpolated","transition":true,"requires":[{"!":"background-pattern"}]},"background-pattern":{"type":"string","function":"piecewise-constant","transition":true},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","transition":true}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}}}
},{}],169:[function(require,module,exports){
'use strict';

// lightweight Buffer shim for pbf browser build
// based on code from github.com/feross/buffer (MIT-licensed)

module.exports = Buffer;

var ieee754 = require('ieee754');

var BufferMethods;

function Buffer(length) {
    var arr;
    if (length && length.length) {
        arr = length;
        length = arr.length;
    }
    var buf = new Uint8Array(length || 0);
    if (arr) buf.set(arr);

    buf.readUInt32LE = BufferMethods.readUInt32LE;
    buf.writeUInt32LE = BufferMethods.writeUInt32LE;
    buf.readInt32LE = BufferMethods.readInt32LE;
    buf.writeInt32LE = BufferMethods.writeInt32LE;
    buf.readFloatLE = BufferMethods.readFloatLE;
    buf.writeFloatLE = BufferMethods.writeFloatLE;
    buf.readDoubleLE = BufferMethods.readDoubleLE;
    buf.writeDoubleLE = BufferMethods.writeDoubleLE;
    buf.toString = BufferMethods.toString;
    buf.write = BufferMethods.write;
    buf.slice = BufferMethods.slice;
    buf.copy = BufferMethods.copy;

    buf._isBuffer = true;
    return buf;
}

var lastStr, lastStrEncoded;

BufferMethods = {
    readUInt32LE: function(pos) {
        return ((this[pos]) |
            (this[pos + 1] << 8) |
            (this[pos + 2] << 16)) +
            (this[pos + 3] * 0x1000000);
    },

    writeUInt32LE: function(val, pos) {
        this[pos] = val;
        this[pos + 1] = (val >>> 8);
        this[pos + 2] = (val >>> 16);
        this[pos + 3] = (val >>> 24);
    },

    readInt32LE: function(pos) {
        return ((this[pos]) |
            (this[pos + 1] << 8) |
            (this[pos + 2] << 16)) +
            (this[pos + 3] << 24);
    },

    readFloatLE:  function(pos) { return ieee754.read(this, pos, true, 23, 4); },
    readDoubleLE: function(pos) { return ieee754.read(this, pos, true, 52, 8); },

    writeFloatLE:  function(val, pos) { return ieee754.write(this, val, pos, true, 23, 4); },
    writeDoubleLE: function(val, pos) { return ieee754.write(this, val, pos, true, 52, 8); },

    toString: function(encoding, start, end) {
        var str = '',
            tmp = '';

        start = start || 0;
        end = Math.min(this.length, end || this.length);

        for (var i = start; i < end; i++) {
            var ch = this[i];
            if (ch <= 0x7F) {
                str += decodeURIComponent(tmp) + String.fromCharCode(ch);
                tmp = '';
            } else {
                tmp += '%' + ch.toString(16);
            }
        }

        str += decodeURIComponent(tmp);

        return str;
    },

    write: function(str, pos) {
        var bytes = str === lastStr ? lastStrEncoded : encodeString(str);
        for (var i = 0; i < bytes.length; i++) {
            this[pos + i] = bytes[i];
        }
    },

    slice: function(start, end) {
        return this.subarray(start, end);
    },

    copy: function(buf, pos) {
        pos = pos || 0;
        for (var i = 0; i < this.length; i++) {
            buf[pos + i] = this[i];
        }
    }
};

BufferMethods.writeInt32LE = BufferMethods.writeUInt32LE;

Buffer.byteLength = function(str) {
    lastStr = str;
    lastStrEncoded = encodeString(str);
    return lastStrEncoded.length;
};

Buffer.isBuffer = function(buf) {
    return !!(buf && buf._isBuffer);
};

function encodeString(str) {
    var length = str.length,
        bytes = [];

    for (var i = 0, c, lead; i < length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {

            if (lead) {
                if (c < 0xDC00) {
                    bytes.push(0xEF, 0xBF, 0xBD);
                    lead = c;
                    continue;

                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }

            } else {
                if (c > 0xDBFF || (i + 1 === length)) bytes.push(0xEF, 0xBF, 0xBD);
                else lead = c;

                continue;
            }

        } else if (lead) {
            bytes.push(0xEF, 0xBF, 0xBD);
            lead = null;
        }

        if (c < 0x80) bytes.push(c);
        else if (c < 0x800) bytes.push(c >> 0x6 | 0xC0, c & 0x3F | 0x80);
        else if (c < 0x10000) bytes.push(c >> 0xC | 0xE0, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
        else bytes.push(c >> 0x12 | 0xF0, c >> 0xC & 0x3F | 0x80, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
    }
    return bytes;
}

},{"ieee754":171}],170:[function(require,module,exports){
(function (global){
'use strict';

module.exports = Pbf;

var Buffer = global.Buffer || require('./buffer');

function Pbf(buf) {
    this.buf = !Buffer.isBuffer(buf) ? new Buffer(buf || 0) : buf;
    this.pos = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32,
    POW_2_63 = Math.pow(2, 63);

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            var val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            readField(tag, result, this);

            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = this.buf.readUInt32LE(this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = this.buf.readInt32LE(this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = this.buf.readUInt32LE(this.pos) + this.buf.readUInt32LE(this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = this.buf.readUInt32LE(this.pos) + this.buf.readInt32LE(this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = this.buf.readFloatLE(this.pos);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = this.buf.readDoubleLE(this.pos);
        this.pos += 8;
        return val;
    },

    readVarint: function() {
        var buf = this.buf,
            val, b;

        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;

        return readVarintRemainder(val, this);
    },

    readVarint64: function() {
        var startPos = this.pos,
            val = this.readVarint();

        if (val < POW_2_63) return val;

        var pos = this.pos - 2;
        while (this.buf[pos] === 0xff) pos--;
        if (pos < startPos) pos = startPos;

        val = 0;
        for (var i = 0; i < pos - startPos + 1; i++) {
            var b = ~this.buf[startPos + i] & 0x7f;
            val += i < 4 ? b << i * 7 : b * Math.pow(2, i * 7);
        }

        return -val - 1;
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos,
            str = this.buf.toString('utf8', this.pos, end);
        this.pos = end;
        return str;
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.slice(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readVarint());
        return arr;
    },
    readPackedSVarint: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error('Unimplemented type: ' + type);
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) length *= 2;

        if (length !== this.length) {
            var buf = new Buffer(length);
            this.buf.copy(buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.slice(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        this.buf.writeUInt32LE(val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        this.buf.writeInt32LE(val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        this.buf.writeInt32LE(val & -1, this.pos);
        this.buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        this.buf.writeInt32LE(val & -1, this.pos);
        this.buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val;

        if (val > 0xfffffff) {
            writeBigVarint(val, this);
            return;
        }

        this.realloc(4);

        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] =   (val >>> 7) & 0x7f;
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        var bytes = Buffer.byteLength(str);
        this.writeVarint(bytes);
        this.realloc(bytes);
        this.buf.write(str, this.pos);
        this.pos += bytes;
    },

    writeFloat: function(val) {
        this.realloc(4);
        this.buf.writeFloatLE(val, this.pos);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        this.buf.writeDoubleLE(val, this.pos);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
    },

    writeRawMessage: function(fn, obj) {
        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        if (len >= 0x80) reallocForRawMessage(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
    },

    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },
    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },
    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },
    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },
    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },
    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },
    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },
    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },
    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function readVarintRemainder(val, pbf) {
    var buf = pbf.buf, b;

    b = buf[pbf.pos++]; val += (b & 0x7f) * 0x10000000;         if (b < 0x80) return val;
    b = buf[pbf.pos++]; val += (b & 0x7f) * 0x800000000;        if (b < 0x80) return val;
    b = buf[pbf.pos++]; val += (b & 0x7f) * 0x40000000000;      if (b < 0x80) return val;
    b = buf[pbf.pos++]; val += (b & 0x7f) * 0x2000000000000;    if (b < 0x80) return val;
    b = buf[pbf.pos++]; val += (b & 0x7f) * 0x100000000000000;  if (b < 0x80) return val;
    b = buf[pbf.pos++]; val += (b & 0x7f) * 0x8000000000000000; if (b < 0x80) return val;

    throw new Error('Expected varint not more than 10 bytes');
}

function writeBigVarint(val, pbf) {
    pbf.realloc(10);

    var maxPos = pbf.pos + 10;

    while (val >= 1) {
        if (pbf.pos >= maxPos) throw new Error('Given varint doesn\'t fit into 10 bytes');
        var b = val & 0xff;
        pbf.buf[pbf.pos++] = b | (val >= 0x80 ? 0x80 : 0);
        val /= 0x80;
    }
}

function reallocForRawMessage(startPos, len, pbf) {
    var extraLen =
        len <= 0x3fff ? 1 :
        len <= 0x1fffff ? 2 :
        len <= 0xfffffff ? 3 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

    // if 1 byte isn't enough for encoding message length, shift the data to the right
    pbf.realloc(extraLen);
    for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];
}

function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./buffer":169}],171:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],172:[function(require,module,exports){
'use strict';

module.exports = Point;

function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype = {
    clone: function() { return new Point(this.x, this.y); },

    add:     function(p) { return this.clone()._add(p);     },
    sub:     function(p) { return this.clone()._sub(p);     },
    mult:    function(k) { return this.clone()._mult(k);    },
    div:     function(k) { return this.clone()._div(k);     },
    rotate:  function(a) { return this.clone()._rotate(a);  },
    matMult: function(m) { return this.clone()._matMult(m); },
    unit:    function() { return this.clone()._unit(); },
    perp:    function() { return this.clone()._perp(); },
    round:   function() { return this.clone()._round(); },

    mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    equals: function(p) {
        return this.x === p.x &&
               this.y === p.y;
    },

    dist: function(p) {
        return Math.sqrt(this.distSqr(p));
    },

    distSqr: function(p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    angle: function() {
        return Math.atan2(this.y, this.x);
    },

    angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
    },

    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(θ) for θ.
    angleWithSep: function(x, y) {
        return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y);
    },

    _matMult: function(m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function(k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function(k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _unit: function() {
        this._div(this.mag());
        return this;
    },

    _perp: function() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

// constructs Point from an array if necessary
Point.convert = function (a) {
    if (a instanceof Point) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point(a[0], a[1]);
    }
    return a;
};

},{}],173:[function(require,module,exports){
// Copyright 2014 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)

void (function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define(factory)
  } else if (typeof exports === "object") {
    module.exports = factory()
  } else {
    root.resolveUrl = factory()
  }
}(this, function() {

  function resolveUrl(/* ...urls */) {
    var numUrls = arguments.length

    if (numUrls === 0) {
      throw new Error("resolveUrl requires at least one argument; got none.")
    }

    var base = document.createElement("base")
    base.href = arguments[0]

    if (numUrls === 1) {
      return base.href
    }

    var head = document.getElementsByTagName("head")[0]
    head.insertBefore(base, head.firstChild)

    var a = document.createElement("a")
    var resolved

    for (var index = 1; index < numUrls; index++) {
      a.href = arguments[index]
      resolved = a.href
      base.href = resolved
    }

    head.removeChild(base)

    return resolved
  }

  return resolveUrl

}));

},{}],174:[function(require,module,exports){
'use strict';

module.exports = ShelfPack;


/**
 * Create a new ShelfPack bin allocator.
 *
 * Uses the Shelf Best Height Fit algorithm from
 * http://clb.demon.fi/files/RectangleBinPack.pdf
 *
 * @class  ShelfPack
 * @param  {number}  [w=64]  Initial width of the sprite
 * @param  {number}  [h=64]  Initial width of the sprite
 * @param  {Object}  [options]
 * @param  {boolean} [options.autoResize=false]  If `true`, the sprite will automatically grow
 * @example
 * var sprite = new ShelfPack(64, 64, { autoResize: false });
 */
function ShelfPack(w, h, options) {
    options = options || {};
    this.w = w || 64;
    this.h = h || 64;
    this.autoResize = !!options.autoResize;
    this.shelves = [];
    this.stats = {};
    this.count = function(h) {
        this.stats[h] = (this.stats[h] | 0) + 1;
    };
}

/**
 * Batch pack multiple bins into the sprite.
 *
 * @param   {Array}   bins Array of requested bins - each object should have `width`, `height` (or `w`, `h`) properties
 * @param   {Object}  [options]
 * @param   {boolean} [options.inPlace=false] If `true`, the supplied bin objects will be updated inplace with `x` and `y` properties
 * @returns {Array}   Array of allocated bins - each bin is an object with `x`, `y`, `w`, `h` properties
 * @example
 * var bins = [
 *     { id: 'a', width: 12, height: 12 },
 *     { id: 'b', width: 12, height: 16 },
 *     { id: 'c', width: 12, height: 24 }
 * ];
 * var results = sprite.pack(bins, { inPlace: false });
 */
ShelfPack.prototype.pack = function(bins, options) {
    bins = [].concat(bins);
    options = options || {};

    var results = [],
        w, h, allocation;

    for (var i = 0; i < bins.length; i++) {
        w = bins[i].w || bins[i].width;
        h = bins[i].h || bins[i].height;
        if (w && h) {
            allocation = this.packOne(w, h);
            if (!allocation) {
                continue;
            }
            if (options.inPlace) {
                bins[i].x = allocation.x;
                bins[i].y = allocation.y;
            }
            results.push(allocation);
        }
    }

    return results;
};

/**
 * Pack a single bin into the sprite.
 *
 * @param   {number}  w   Width of the bin to allocate
 * @param   {number}  h   Height of the bin to allocate
 * @returns {Object}  Allocated bin object with `x`, `y`, `w`, `h` properties, or `null` if allocation failed
 * @example
 * var results = sprite.packOne(12, 16);
 */
ShelfPack.prototype.packOne = function(w, h) {
    var y = 0,
        best = { shelf: -1, waste: Infinity },
        shelf, waste;

    // find the best shelf
    for (var i = 0; i < this.shelves.length; i++) {
        shelf = this.shelves[i];
        y += shelf.h;

        // exactly the right height with width to spare, pack it..
        if (h === shelf.h && w <= shelf.free) {
            this.count(h);
            return shelf.alloc(w, h);
        }
        // not enough height or width, skip it..
        if (h > shelf.h || w > shelf.free) {
            continue;
        }
        // maybe enough height or width, minimize waste..
        if (h < shelf.h && w <= shelf.free) {
            waste = shelf.h - h;
            if (waste < best.waste) {
                best.waste = waste;
                best.shelf = i;
            }
        }
    }

    if (best.shelf !== -1) {
        shelf = this.shelves[best.shelf];
        this.count(h);
        return shelf.alloc(w, h);
    }

    // add shelf..
    if (h <= (this.h - y) && w <= this.w) {
        shelf = new Shelf(y, this.w, h);
        this.shelves.push(shelf);
        this.count(h);
        return shelf.alloc(w, h);
    }

    // no more space..
    // If `autoResize` option is set, grow the sprite as follows:
    //  * double whichever sprite dimension is smaller (`w1` or `h1`)
    //  * if sprite dimensions are equal, grow width before height
    //  * accomodate very large bin requests (big `w` or `h`)
    if (this.autoResize) {
        var h1, h2, w1, w2;

        h1 = h2 = this.h;
        w1 = w2 = this.w;

        if (w1 <= h1 || w > w1) {   // grow width..
            w2 = Math.max(w, w1) * 2;
        }
        if (h1 < w1 || h > h1) {    // grow height..
            h2 = Math.max(h, h1) * 2;
        }

        this.resize(w2, h2);
        return this.packOne(w, h);  // retry
    }

    return null;
};

/**
 * Clear the sprite.
 *
 * @example
 * sprite.clear();
 */
ShelfPack.prototype.clear = function() {
    this.shelves = [];
    this.stats = {};
};

/**
 * Resize the sprite.
 * The resize will fail if the requested dimensions are smaller than the current sprite dimensions.
 *
 * @param   {number}  w  Requested new sprite width
 * @param   {number}  h  Requested new sprite height
 * @returns {boolean} `true` if resize succeeded, `false` if failed
 * @example
 * sprite.resize(256, 256);
 */
ShelfPack.prototype.resize = function(w, h) {
    if (w < this.w || h < this.h) {
        return false;
    }

    this.w = w;
    this.h = h;
    for (var i = 0; i < this.shelves.length; i++) {
        this.shelves[i].resize(w);
    }
    return true;
};



/**
 * Create a new Shelf.
 *
 * @private
 * @class  Shelf
 * @param  {number}  y   Top coordinate of the new shelf
 * @param  {number}  w   Width of the new shelf
 * @param  {number}  h   Height of the new shelf
 * @example
 * var shelf = new Shelf(64, 512, 24);
 */
function Shelf(y, w, h) {
    this.x = 0;
    this.y = y;
    this.w = this.free = w;
    this.h = h;
}

/**
 * Allocate a single bin into the shelf.
 *
 * @private
 * @param   {number}  w   Width of the bin to allocate
 * @param   {number}  h   Height of the bin to allocate
 * @returns {Object}  Allocated bin object with `x`, `y`, `w`, `h` properties, or `null` if allocation failed
 * @example
 * shelf.alloc(12, 16);
 */
Shelf.prototype.alloc = function(w, h) {
    if (w > this.free || h > this.h) {
        return null;
    }
    var x = this.x;
    this.x += w;
    this.free -= w;
    return { x: x, y: this.y, w: w, h: h, width: w, height: h };
};

/**
 * Resize the shelf.
 * The resize will fail if the requested width is smaller than the current shelf width.
 *
 * @private
 * @param   {number}  w  Requested new width of the shelf
 * @returns {boolean} true if resize succeeded, false if failed
 * @example
 * shelf.resize(512);
 */
Shelf.prototype.resize = function(w) {
    if (w < this.w) {
        return false;
    }
    this.free += (w - this.w);
    this.w = w;
    return true;
};

},{}],175:[function(require,module,exports){
'use strict';

var kdbush = require('kdbush');

module.exports = supercluster;

function supercluster(options) {
    return new SuperCluster(options);
}

function SuperCluster(options) {
    this.options = extend(Object.create(this.options), options);
    this.trees = new Array(this.options.maxZoom + 1);
}

SuperCluster.prototype = {
    options: {
        minZoom: 0,   // min zoom to generate clusters on
        maxZoom: 16,  // max zoom level to cluster the points on
        radius: 40,   // cluster radius in pixels
        extent: 512,  // tile extent (radius is calculated relative to it)
        nodeSize: 64, // size of the KD-tree leaf node, affects performance
        log: false    // whether to log timing info
    },

    load: function (points) {
        var log = this.options.log;

        if (log) console.time('total time');

        var timerId = 'prepare ' + points.length + ' points';
        if (log) console.time(timerId);

        this.points = points;

        // generate a cluster object for each point
        var clusters = points.map(createPointCluster);
        if (log) console.timeEnd(timerId);

        // cluster points on max zoom, then cluster the results on previous zoom, etc.;
        // results in a cluster hierarchy across zoom levels
        for (var z = this.options.maxZoom; z >= this.options.minZoom; z--) {
            var now = +Date.now();

            // index input points into a KD-tree
            this.trees[z + 1] = kdbush(clusters, getX, getY, this.options.nodeSize, Float32Array);

            clusters = this._cluster(clusters, z); // create a new set of clusters for the zoom

            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);
        }

        // index top-level clusters
        this.trees[this.options.minZoom] = kdbush(clusters, getX, getY, this.options.nodeSize, Float32Array);

        if (log) console.timeEnd('total time');

        return this;
    },

    getClusters: function (bbox, zoom) {
        var tree = this.trees[this._limitZoom(zoom)];
        var ids = tree.range(lngX(bbox[0]), latY(bbox[3]), lngX(bbox[2]), latY(bbox[1]));
        var clusters = [];
        for (var i = 0; i < ids.length; i++) {
            var c = tree.points[ids[i]];
            clusters.push(c.id !== -1 ? this.points[c.id] : getClusterJSON(c));
        }
        return clusters;
    },

    getTile: function (z, x, y) {
        var z2 = Math.pow(2, z);
        var extent = this.options.extent;
        var p = this.options.radius / extent;
        var tree = this.trees[this._limitZoom(z)];
        var ids = tree.range(
            (x - p) / z2,
            (y - p) / z2,
            (x + 1 + p) / z2,
            (y + 1 + p) / z2);

        if (!ids.length) return null;

        var tile = {
            features: []
        };
        for (var i = 0; i < ids.length; i++) {
            var c = tree.points[ids[i]];
            var feature = {
                type: 1,
                geometry: [[
                    Math.round(extent * (c.x * z2 - x)),
                    Math.round(extent * (c.y * z2 - y))
                ]],
                tags: c.id !== -1 ? this.points[c.id].properties : getClusterProperties(c)
            };
            tile.features.push(feature);
        }
        return tile;
    },

    _limitZoom: function (z) {
        return Math.max(this.options.minZoom, Math.min(z, this.options.maxZoom + 1));
    },

    _cluster: function (points, zoom) {
        var clusters = [];
        var r = this.options.radius / (this.options.extent * Math.pow(2, zoom));

        // loop through each point
        for (var i = 0; i < points.length; i++) {
            var p = points[i];
            // if we've already visited the point at this zoom level, skip it
            if (p.zoom <= zoom) continue;
            p.zoom = zoom;

            // find all nearby points
            var tree = this.trees[zoom + 1];
            var neighborIds = tree.within(p.x, p.y, r);

            var foundNeighbors = false;
            var numPoints = p.numPoints;
            var wx = p.x * numPoints;
            var wy = p.y * numPoints;

            for (var j = 0; j < neighborIds.length; j++) {
                var b = tree.points[neighborIds[j]];
                // filter out neighbors that are too far or already processed
                if (zoom < b.zoom) {
                    foundNeighbors = true;
                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)
                    wx += b.x * b.numPoints; // accumulate coordinates for calculating weighted center
                    wy += b.y * b.numPoints;
                    numPoints += b.numPoints;
                }
            }

            clusters.push(foundNeighbors ? createCluster(wx / numPoints, wy / numPoints, numPoints, -1) : p);
        }

        return clusters;
    }
};

function createCluster(x, y, numPoints, id) {
    return {
        x: x, // weighted cluster center
        y: y,
        zoom: Infinity, // the last zoom the cluster was processed at
        id: id, // index of the source feature in the original input array
        numPoints: numPoints
    };
}

function createPointCluster(p, i) {
    var coords = p.geometry.coordinates;
    return createCluster(lngX(coords[0]), latY(coords[1]), 1, i);
}

function getClusterJSON(cluster) {
    return {
        type: 'Feature',
        properties: getClusterProperties(cluster),
        geometry: {
            type: 'Point',
            coordinates: [xLng(cluster.x), yLat(cluster.y)]
        }
    };
}

function getClusterProperties(cluster) {
    var count = cluster.numPoints;
    var abbrev = count >= 10000 ? Math.round(count / 1000) + 'k' :
                 count >= 1000 ? (Math.round(count / 100) / 10) + 'k' : count;
    return {
        cluster: true,
        point_count: count,
        point_count_abbreviated: abbrev
    };
}

// longitude/latitude to spherical mercator in [0..1] range
function lngX(lng) {
    return lng / 360 + 0.5;
}
function latY(lat) {
    var sin = Math.sin(lat * Math.PI / 180),
        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);
    return y < 0 ? 0 :
           y > 1 ? 1 : y;
}

// spherical mercator to longitude/latitude
function xLng(x) {
    return (x - 0.5) * 360;
}
function yLat(y) {
    var y2 = (180 - y * 360) * Math.PI / 180;
    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;
}

function extend(dest, src) {
    for (var id in src) dest[id] = src[id];
    return dest;
}

function getX(p) {
    return p.x;
}
function getY(p) {
    return p.y;
}

},{"kdbush":176}],176:[function(require,module,exports){
'use strict';

var sort = require('./sort');
var range = require('./range');
var within = require('./within');

module.exports = kdbush;

function kdbush(points, getX, getY, nodeSize, ArrayType) {
    return new KDBush(points, getX, getY, nodeSize, ArrayType);
}

function KDBush(points, getX, getY, nodeSize, ArrayType) {
    getX = getX || defaultGetX;
    getY = getY || defaultGetY;
    ArrayType = ArrayType || Array;

    this.nodeSize = nodeSize || 64;
    this.points = points;

    this.ids = new ArrayType(points.length);
    this.coords = new ArrayType(points.length * 2);

    for (var i = 0; i < points.length; i++) {
        this.ids[i] = i;
        this.coords[2 * i] = getX(points[i]);
        this.coords[2 * i + 1] = getY(points[i]);
    }

    sort(this.ids, this.coords, this.nodeSize, 0, this.ids.length - 1, 0);
}

KDBush.prototype = {
    range: function (minX, minY, maxX, maxY) {
        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);
    },

    within: function (x, y, r) {
        return within(this.ids, this.coords, x, y, r, this.nodeSize);
    }
};

function defaultGetX(p) { return p[0]; }
function defaultGetY(p) { return p[1]; }

},{"./range":177,"./sort":178,"./within":179}],177:[function(require,module,exports){
'use strict';

module.exports = range;

function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {
    var stack = [0, ids.length - 1, 0];
    var result = [];
    var x, y;

    while (stack.length) {
        var axis = stack.pop();
        var right = stack.pop();
        var left = stack.pop();

        if (right - left <= nodeSize) {
            for (var i = left; i <= right; i++) {
                x = coords[2 * i];
                y = coords[2 * i + 1];
                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);
            }
            continue;
        }

        var m = Math.floor((left + right) / 2);

        x = coords[2 * m];
        y = coords[2 * m + 1];

        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);

        var nextAxis = (axis + 1) % 2;

        if (axis === 0 ? minX <= x : minY <= y) {
            stack.push(left);
            stack.push(m - 1);
            stack.push(nextAxis);
        }
        if (axis === 0 ? maxX >= x : maxY >= y) {
            stack.push(m + 1);
            stack.push(right);
            stack.push(nextAxis);
        }
    }

    return result;
}

},{}],178:[function(require,module,exports){
'use strict';

module.exports = sortKD;

function sortKD(ids, coords, nodeSize, left, right, depth) {
    if (right - left <= nodeSize) return;

    var m = Math.floor((left + right) / 2);

    select(ids, coords, m, left, right, depth % 2);

    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);
    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);
}

function select(ids, coords, k, left, right, inc) {

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            select(ids, coords, k, newLeft, newRight, inc);
        }

        var t = coords[2 * k + inc];
        var i = left;
        var j = right;

        swapItem(ids, coords, left, k);
        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);

        while (i < j) {
            swapItem(ids, coords, i, j);
            i++;
            j--;
            while (coords[2 * i + inc] < t) i++;
            while (coords[2 * j + inc] > t) j--;
        }

        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);
        else {
            j++;
            swapItem(ids, coords, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swapItem(ids, coords, i, j) {
    swap(ids, i, j);
    swap(coords, 2 * i, 2 * j);
    swap(coords, 2 * i + 1, 2 * j + 1);
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

},{}],179:[function(require,module,exports){
'use strict';

module.exports = within;

function within(ids, coords, qx, qy, r, nodeSize) {
    var stack = [0, ids.length - 1, 0];
    var result = [];
    var r2 = r * r;

    while (stack.length) {
        var axis = stack.pop();
        var right = stack.pop();
        var left = stack.pop();

        if (right - left <= nodeSize) {
            for (var i = left; i <= right; i++) {
                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);
            }
            continue;
        }

        var m = Math.floor((left + right) / 2);

        var x = coords[2 * m];
        var y = coords[2 * m + 1];

        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);

        var nextAxis = (axis + 1) % 2;

        if (axis === 0 ? qx - r <= x : qy - r <= y) {
            stack.push(left);
            stack.push(m - 1);
            stack.push(nextAxis);
        }
        if (axis === 0 ? qx + r >= x : qy + r >= y) {
            stack.push(m + 1);
            stack.push(right);
            stack.push(nextAxis);
        }
    }

    return result;
}

function sqDist(ax, ay, bx, by) {
    var dx = ax - bx;
    var dy = ay - by;
    return dx * dx + dy * dy;
}

},{}],180:[function(require,module,exports){
/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Ported from Webkit
 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
 */

module.exports = UnitBezier;

function UnitBezier(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    this.cx = 3.0 * p1x;
    this.bx = 3.0 * (p2x - p1x) - this.cx;
    this.ax = 1.0 - this.cx - this.bx;

    this.cy = 3.0 * p1y;
    this.by = 3.0 * (p2y - p1y) - this.cy;
    this.ay = 1.0 - this.cy - this.by;

    this.p1x = p1x;
    this.p1y = p2y;
    this.p2x = p2x;
    this.p2y = p2y;
}

UnitBezier.prototype.sampleCurveX = function(t) {
    // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
    return ((this.ax * t + this.bx) * t + this.cx) * t;
};

UnitBezier.prototype.sampleCurveY = function(t) {
    return ((this.ay * t + this.by) * t + this.cy) * t;
};

UnitBezier.prototype.sampleCurveDerivativeX = function(t) {
    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
};

UnitBezier.prototype.solveCurveX = function(x, epsilon) {
    if (typeof epsilon === 'undefined') epsilon = 1e-6;

    var t0, t1, t2, x2, i;

    // First try a few iterations of Newton's method -- normally very fast.
    for (t2 = x, i = 0; i < 8; i++) {

        x2 = this.sampleCurveX(t2) - x;
        if (Math.abs(x2) < epsilon) return t2;

        var d2 = this.sampleCurveDerivativeX(t2);
        if (Math.abs(d2) < 1e-6) break;

        t2 = t2 - x2 / d2;
    }

    // Fall back to the bisection method for reliability.
    t0 = 0.0;
    t1 = 1.0;
    t2 = x;

    if (t2 < t0) return t0;
    if (t2 > t1) return t1;

    while (t0 < t1) {

        x2 = this.sampleCurveX(t2);
        if (Math.abs(x2 - x) < epsilon) return t2;

        if (x > x2) {
            t0 = t2;
        } else {
            t1 = t2;
        }

        t2 = (t1 - t0) * 0.5 + t0;
    }

    // Failure.
    return t2;
};

UnitBezier.prototype.solve = function(x, epsilon) {
    return this.sampleCurveY(this.solveCurveX(x, epsilon));
};

},{}],181:[function(require,module,exports){
module.exports.VectorTile = require('./lib/vectortile.js');
module.exports.VectorTileFeature = require('./lib/vectortilefeature.js');
module.exports.VectorTileLayer = require('./lib/vectortilelayer.js');

},{"./lib/vectortile.js":182,"./lib/vectortilefeature.js":183,"./lib/vectortilelayer.js":184}],182:[function(require,module,exports){
'use strict';

var VectorTileLayer = require('./vectortilelayer');

module.exports = VectorTile;

function VectorTile(pbf, end) {
    this.layers = pbf.readFields(readTile, {}, end);
}

function readTile(tag, layers, pbf) {
    if (tag === 3) {
        var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length) layers[layer.name] = layer;
    }
}


},{"./vectortilelayer":184}],183:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = VectorTileFeature;

function VectorTileFeature(pbf, end, extent, keys, values) {
    // Public
    this.properties = {};
    this.extent = extent;
    this.type = 0;

    // Private
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;

    pbf.readFields(readFeature, this, end);
}

function readFeature(tag, feature, pbf) {
    if (tag == 1) feature._id = pbf.readVarint();
    else if (tag == 2) readTag(pbf, feature);
    else if (tag == 3) feature.type = pbf.readVarint();
    else if (tag == 4) feature._geometry = pbf.pos;
}

function readTag(pbf, feature) {
    var end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var key = feature._keys[pbf.readVarint()],
            value = feature._values[pbf.readVarint()];
        feature.properties[key] = value;
    }
}

VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature.prototype.loadGeometry = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        lines = [],
        line;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();

            if (cmd === 1) { // moveTo
                if (line) lines.push(line);
                line = [];
            }

            line.push(new Point(x, y));

        } else if (cmd === 7) {

            // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90
            if (line) {
                line.push(line[0].clone()); // closePolygon
            }

        } else {
            throw new Error('unknown command ' + cmd);
        }
    }

    if (line) lines.push(line);

    return lines;
};

VectorTileFeature.prototype.bbox = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();
            if (x < x1) x1 = x;
            if (x > x2) x2 = x;
            if (y < y1) y1 = y;
            if (y > y2) y2 = y;

        } else if (cmd !== 7) {
            throw new Error('unknown command ' + cmd);
        }
    }

    return [x1, y1, x2, y2];
};

VectorTileFeature.prototype.toGeoJSON = function(x, y, z) {
    var size = this.extent * Math.pow(2, z),
        x0 = this.extent * x,
        y0 = this.extent * y,
        coords = this.loadGeometry(),
        type = VectorTileFeature.types[this.type],
        i, j;

    function project(line) {
        for (var j = 0; j < line.length; j++) {
            var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;
            line[j] = [
                (p.x + x0) * 360 / size - 180,
                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
            ];
        }
    }

    switch (this.type) {
    case 1:
        var points = [];
        for (i = 0; i < coords.length; i++) {
            points[i] = coords[i][0];
        }
        coords = points;
        project(coords);
        break;

    case 2:
        for (i = 0; i < coords.length; i++) {
            project(coords[i]);
        }
        break;

    case 3:
        coords = classifyRings(coords);
        for (i = 0; i < coords.length; i++) {
            for (j = 0; j < coords[i].length; j++) {
                project(coords[i][j]);
            }
        }
        break;
    }

    if (coords.length === 1) {
        coords = coords[0];
    } else {
        type = 'Multi' + type;
    }

    var result = {
        type: "Feature",
        geometry: {
            type: type,
            coordinates: coords
        },
        properties: this.properties
    };

    if ('_id' in this) {
        result.id = this._id;
    }

    return result;
};

// classifies an array of rings into polygons with outer rings and holes

function classifyRings(rings) {
    var len = rings.length;

    if (len <= 1) return [rings];

    var polygons = [],
        polygon,
        ccw;

    for (var i = 0; i < len; i++) {
        var area = signedArea(rings[i]);
        if (area === 0) continue;

        if (ccw === undefined) ccw = area < 0;

        if (ccw === area < 0) {
            if (polygon) polygons.push(polygon);
            polygon = [rings[i]];

        } else {
            polygon.push(rings[i]);
        }
    }
    if (polygon) polygons.push(polygon);

    return polygons;
}

function signedArea(ring) {
    var sum = 0;
    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
        p1 = ring[i];
        p2 = ring[j];
        sum += (p2.x - p1.x) * (p1.y + p2.y);
    }
    return sum;
}

},{"point-geometry":172}],184:[function(require,module,exports){
'use strict';

var VectorTileFeature = require('./vectortilefeature.js');

module.exports = VectorTileLayer;

function VectorTileLayer(pbf, end) {
    // Public
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;

    // Private
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];

    pbf.readFields(readLayer, this, end);

    this.length = this._features.length;
}

function readLayer(tag, layer, pbf) {
    if (tag === 15) layer.version = pbf.readVarint();
    else if (tag === 1) layer.name = pbf.readString();
    else if (tag === 5) layer.extent = pbf.readVarint();
    else if (tag === 2) layer._features.push(pbf.pos);
    else if (tag === 3) layer._keys.push(pbf.readString());
    else if (tag === 4) layer._values.push(readValueMessage(pbf));
}

function readValueMessage(pbf) {
    var value = null,
        end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var tag = pbf.readVarint() >> 3;

        value = tag === 1 ? pbf.readString() :
            tag === 2 ? pbf.readFloat() :
            tag === 3 ? pbf.readDouble() :
            tag === 4 ? pbf.readVarint64() :
            tag === 5 ? pbf.readVarint() :
            tag === 6 ? pbf.readSVarint() :
            tag === 7 ? pbf.readBoolean() : null;
    }

    return value;
}

// return feature `i` from this layer as a `VectorTileFeature`
VectorTileLayer.prototype.feature = function(i) {
    if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');

    this._pbf.pos = this._features[i];

    var end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
};

},{"./vectortilefeature.js":183}],185:[function(require,module,exports){
var Pbf = require('pbf')
var vtpb = require('./vector-tile-pb')
var GeoJSONWrapper = require('./lib/geojson_wrapper')

module.exports = fromVectorTileJs
module.exports.fromVectorTileJs = fromVectorTileJs
module.exports.fromGeojsonVt = fromGeojsonVt
module.exports.GeoJSONWrapper = GeoJSONWrapper

/**
 * Serialize a vector-tile-js-created tile to pbf
 *
 * @param {Object} tile
 * @return {Buffer} uncompressed, pbf-serialized tile data
 */
function fromVectorTileJs (tile) {
  var layers = []
  for (var l in tile.layers) {
    layers.push(prepareLayer(tile.layers[l]))
  }

  var out = new Pbf()
  vtpb.tile.write({ layers: layers }, out)
  return out.finish()
}

/**
 * Serialized a geojson-vt-created tile to pbf.
 *
 * @param {Object} layers - An object mapping layer names to geojson-vt-created vector tile objects
 * @return {Buffer} uncompressed, pbf-serialized tile data
 */
function fromGeojsonVt (layers) {
  var l = {}
  for (var k in layers) {
    l[k] = new GeoJSONWrapper(layers[k].features)
    l[k].name = k
  }
  return fromVectorTileJs({layers: l})
}

/**
 * Prepare the given layer to be serialized by the auto-generated pbf
 * serializer by encoding the feature geometry and properties.
 */
function prepareLayer (layer) {
  var preparedLayer = {
    name: layer.name || '',
    version: layer.version || 1,
    extent: layer.extent || 4096,
    keys: [],
    values: [],
    features: []
  }

  var keycache = {}
  var valuecache = {}

  for (var i = 0; i < layer.length; i++) {
    var feature = layer.feature(i)
    feature.geometry = encodeGeometry(feature.loadGeometry())

    var tags = []
    for (var key in feature.properties) {
      var keyIndex = keycache[key]
      if (typeof keyIndex === 'undefined') {
        preparedLayer.keys.push(key)
        keyIndex = preparedLayer.keys.length - 1
        keycache[key] = keyIndex
      }
      var value = wrapValue(feature.properties[key])
      var valueIndex = valuecache[value.key]
      if (typeof valueIndex === 'undefined') {
        preparedLayer.values.push(value)
        valueIndex = preparedLayer.values.length - 1
        valuecache[value.key] = valueIndex
      }
      tags.push(keyIndex)
      tags.push(valueIndex)
    }

    feature.tags = tags
    preparedLayer.features.push(feature)
  }

  return preparedLayer
}

function command (cmd, length) {
  return (length << 3) + (cmd & 0x7)
}

function zigzag (num) {
  return (num << 1) ^ (num >> 31)
}

/**
 * Encode a polygon's geometry into an array ready to be serialized
 * to mapbox vector tile specified geometry data.
 *
 * @param {Array} Rings, each being an array of [x, y] tile-space coordinates
 * @return {Array} encoded geometry
 */
function encodeGeometry (geometry) {
  var encoded = []
  var x = 0
  var y = 0
  var rings = geometry.length
  for (var r = 0; r < rings; r++) {
    var ring = geometry[r]
    encoded.push(command(1, 1)) // moveto
    for (var i = 0; i < ring.length; i++) {
      if (i === 1) {
        encoded.push(command(2, ring.length - 1)) // lineto
      }
      var dx = ring[i].x - x
      var dy = ring[i].y - y
      encoded.push(zigzag(dx), zigzag(dy))
      x += dx
      y += dy
    }
  }

  return encoded
}

/**
 * Wrap a property value according to its type. The returned object
 * is of the form { xxxx_value: primitiveValue }, which is what the generated
 * protobuf serializer expects.
 */
function wrapValue (value) {
  var result
  var type = typeof value
  if (type === 'string') {
    result = { string_value: value }
  } else if (type === 'boolean') {
    result = { bool_value: value }
  } else if (type === 'number') {
    if (value !== (value | 0)) {
      result = { float_value: value }
    } else if (value < 0) {
      result = { sint_value: value }
    } else {
      result = { uint_value: value }
    }
  } else {
    result = { string_value: '' + value }
  }

  result.key = type + ':' + value
  return result
}

},{"./lib/geojson_wrapper":186,"./vector-tile-pb":187,"pbf":170}],186:[function(require,module,exports){
'use strict'

var Point = require('point-geometry')
var VectorTileFeature = require('vector-tile').VectorTileFeature

module.exports = GeoJSONWrapper

// conform to vectortile api
function GeoJSONWrapper (features) {
  this.features = features
  this.length = features.length
}

GeoJSONWrapper.prototype.feature = function (i) {
  return new FeatureWrapper(this.features[i])
}

function FeatureWrapper (feature) {
  this.type = feature.type
  this.rawGeometry = feature.type === 1 ? [feature.geometry] : feature.geometry
  this.properties = feature.tags
  this.extent = 4096
}

FeatureWrapper.prototype.loadGeometry = function () {
  var rings = this.rawGeometry
  this.geometry = []

  for (var i = 0; i < rings.length; i++) {
    var ring = rings[i]
    var newRing = []
    for (var j = 0; j < ring.length; j++) {
      newRing.push(new Point(ring[j][0], ring[j][1]))
    }
    this.geometry.push(newRing)
  }
  return this.geometry
}

FeatureWrapper.prototype.bbox = function () {
  if (!this.geometry) this.loadGeometry()

  var rings = this.geometry
  var x1 = Infinity
  var x2 = -Infinity
  var y1 = Infinity
  var y2 = -Infinity

  for (var i = 0; i < rings.length; i++) {
    var ring = rings[i]

    for (var j = 0; j < ring.length; j++) {
      var coord = ring[j]

      x1 = Math.min(x1, coord.x)
      x2 = Math.max(x2, coord.x)
      y1 = Math.min(y1, coord.y)
      y2 = Math.max(y2, coord.y)
    }
  }

  return [x1, y1, x2, y2]
}

FeatureWrapper.prototype.toGeoJSON = VectorTileFeature.prototype.toGeoJSON

},{"point-geometry":172,"vector-tile":181}],187:[function(require,module,exports){
'use strict';

// tile ========================================

var tile = exports.tile = {read: readTile, write: writeTile};

tile.GeomType = {
    "Unknown": 0,
    "Point": 1,
    "LineString": 2,
    "Polygon": 3
};

function readTile(pbf, end) {
    return pbf.readFields(readTileField, {"layers": []}, end);
}

function readTileField(tag, tile, pbf) {
    if (tag === 3) tile.layers.push(readLayer(pbf, pbf.readVarint() + pbf.pos));
}

function writeTile(tile, pbf) {
    var i;
    if (tile.layers !== undefined) for (i = 0; i < tile.layers.length; i++) pbf.writeMessage(3, writeLayer, tile.layers[i]);
}

// value ========================================

tile.value = {read: readValue, write: writeValue};

function readValue(pbf, end) {
    return pbf.readFields(readValueField, {}, end);
}

function readValueField(tag, value, pbf) {
    if (tag === 1) value.string_value = pbf.readString();
    else if (tag === 2) value.float_value = pbf.readFloat();
    else if (tag === 3) value.double_value = pbf.readDouble();
    else if (tag === 4) value.int_value = pbf.readVarint();
    else if (tag === 5) value.uint_value = pbf.readVarint();
    else if (tag === 6) value.sint_value = pbf.readSVarint();
    else if (tag === 7) value.bool_value = pbf.readBoolean();
}

function writeValue(value, pbf) {
    if (value.string_value !== undefined) pbf.writeStringField(1, value.string_value);
    if (value.float_value !== undefined) pbf.writeFloatField(2, value.float_value);
    if (value.double_value !== undefined) pbf.writeDoubleField(3, value.double_value);
    if (value.int_value !== undefined) pbf.writeVarintField(4, value.int_value);
    if (value.uint_value !== undefined) pbf.writeVarintField(5, value.uint_value);
    if (value.sint_value !== undefined) pbf.writeSVarintField(6, value.sint_value);
    if (value.bool_value !== undefined) pbf.writeBooleanField(7, value.bool_value);
}

// feature ========================================

tile.feature = {read: readFeature, write: writeFeature};

function readFeature(pbf, end) {
    var feature = pbf.readFields(readFeatureField, {}, end);
    if (feature.type === undefined) feature.type = "Unknown";
    return feature;
}

function readFeatureField(tag, feature, pbf) {
    if (tag === 1) feature.id = pbf.readVarint();
    else if (tag === 2) feature.tags = pbf.readPackedVarint();
    else if (tag === 3) feature.type = pbf.readVarint();
    else if (tag === 4) feature.geometry = pbf.readPackedVarint();
}

function writeFeature(feature, pbf) {
    if (feature.id !== undefined) pbf.writeVarintField(1, feature.id);
    if (feature.tags !== undefined) pbf.writePackedVarint(2, feature.tags);
    if (feature.type !== undefined) pbf.writeVarintField(3, feature.type);
    if (feature.geometry !== undefined) pbf.writePackedVarint(4, feature.geometry);
}

// layer ========================================

tile.layer = {read: readLayer, write: writeLayer};

function readLayer(pbf, end) {
    return pbf.readFields(readLayerField, {"features": [], "keys": [], "values": []}, end);
}

function readLayerField(tag, layer, pbf) {
    if (tag === 15) layer.version = pbf.readVarint();
    else if (tag === 1) layer.name = pbf.readString();
    else if (tag === 2) layer.features.push(readFeature(pbf, pbf.readVarint() + pbf.pos));
    else if (tag === 3) layer.keys.push(pbf.readString());
    else if (tag === 4) layer.values.push(readValue(pbf, pbf.readVarint() + pbf.pos));
    else if (tag === 5) layer.extent = pbf.readVarint();
}

function writeLayer(layer, pbf) {
    if (layer.version !== undefined) pbf.writeVarintField(15, layer.version);
    if (layer.name !== undefined) pbf.writeStringField(1, layer.name);
    var i;
    if (layer.features !== undefined) for (i = 0; i < layer.features.length; i++) pbf.writeMessage(2, writeFeature, layer.features[i]);
    if (layer.keys !== undefined) for (i = 0; i < layer.keys.length; i++) pbf.writeStringField(3, layer.keys[i]);
    if (layer.values !== undefined) for (i = 0; i < layer.values.length; i++) pbf.writeMessage(4, writeValue, layer.values[i]);
    if (layer.extent !== undefined) pbf.writeVarintField(5, layer.extent);
}

},{}],188:[function(require,module,exports){
var bundleFn = arguments[3];
var sources = arguments[4];
var cache = arguments[5];

var stringify = JSON.stringify;

module.exports = function (fn, options) {
    var wkey;
    var cacheKeys = Object.keys(cache);

    for (var i = 0, l = cacheKeys.length; i < l; i++) {
        var key = cacheKeys[i];
        var exp = cache[key].exports;
        // Using babel as a transpiler to use esmodule, the export will always
        // be an object with the default export as a property of it. To ensure
        // the existing api and babel esmodule exports are both supported we
        // check for both
        if (exp === fn || exp && exp.default === fn) {
            wkey = key;
            break;
        }
    }

    if (!wkey) {
        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var wcache = {};
        for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            wcache[key] = key;
        }
        sources[wkey] = [
            Function(['require','module','exports'], '(' + fn + ')(self)'),
            wcache
        ];
    }
    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);

    var scache = {}; scache[wkey] = wkey;
    sources[skey] = [
        Function(['require'], (
            // try to call default if defined to also support babel esmodule
            // exports
            'var f = require(' + stringify(wkey) + ');' +
            '(f.default ? f.default : f)(self);'
        )),
        scache
    ];

    var src = '(' + bundleFn + ')({'
        + Object.keys(sources).map(function (key) {
            return stringify(key) + ':['
                + sources[key][0]
                + ',' + stringify(sources[key][1]) + ']'
            ;
        }).join(',')
        + '},{},[' + stringify(skey) + '])'
    ;

    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    var blob = new Blob([src], { type: 'text/javascript' });
    if (options && options.bare) { return blob; }
    var workerUrl = URL.createObjectURL(blob);
    var worker = new Worker(workerUrl);
    if (typeof URL.revokeObjectURL == "function") {
      URL.revokeObjectURL(workerUrl);
    }
    return worker;
};

},{}],189:[function(require,module,exports){
//! moment.js
//! version : 2.13.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    function isUndefined(input) {
        return input === void 0;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (utils_hooks__hooks.deprecationHandler != null) {
                utils_hooks__hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (utils_hooks__hooks.deprecationHandler != null) {
            utils_hooks__hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;
    utils_hooks__hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function isObject(input) {
        return Object.prototype.toString.call(input) === '[object Object]';
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    // internal storage for locale config files
    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale');
                config = mergeConfigs(locales[name]._config, config);
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    config = mergeConfigs(locales[config.parentLocale]._config, config);
                } else {
                    // treat as if there is no base config
                    deprecateSimple('parentLocaleUndefined',
                            'specified parentLocale is not defined yet');
                }
            }
            locales[name] = new Locale(config);

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale;
            if (locales[name] != null) {
                config = mergeConfigs(locales[name]._config, config);
            }
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function locale_locales__listLocales() {
        return keys(locales);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function get_set__set (mom, unit, value) {
        if (mom.isValid()) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    // MOMENTS

    function getSet (units, value) {
        var unit;
        if (typeof units === 'object') {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        return isArray(this._months) ? this._months[m.month()] :
            this._months[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function units_month__handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = create_utc__createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return units_month__handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (typeof value !== 'number') {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        //the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(utils_hooks__hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (getParsingFlags(config).bigHour === true &&
                config._a[HOUR] <= 12 &&
                config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else if (isDate(input)) {
            config._d = input;
        } else {
            configFromInput(config);
        }

        if (!valid__isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date(utils_hooks__hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
         'moment().min is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
         function () {
             var other = local__createLocal.apply(null, arguments);
             if (this.isValid() && other.isValid()) {
                 return other < this ? this : other;
             } else {
                 return valid__createInvalid();
             }
         }
     );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = ((string || '').match(matcher) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
            } else if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(matchOffset, this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            diff = this.diff(sod, 'days', true),
            format = diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format]() : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input,units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input,units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            delta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if (isFunction(Date.prototype.toISOString)) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }

        // 'date' is an alias for 'day', so it should be considered as such.
        if (units === 'date') {
            units = 'day';
        }

        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return this._offset ? new Date(this.valueOf()) : this._d;
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        return isArray(this._weekdays) ? this._weekdays[m.day()] :
            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function day_of_week__handleStrictParse(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = create_utc__createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = create_utc__createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add               = add_subtract__add;
    momentPrototype__proto.calendar          = moment_calendar__calendar;
    momentPrototype__proto.clone             = clone;
    momentPrototype__proto.diff              = diff;
    momentPrototype__proto.endOf             = endOf;
    momentPrototype__proto.format            = format;
    momentPrototype__proto.from              = from;
    momentPrototype__proto.fromNow           = fromNow;
    momentPrototype__proto.to                = to;
    momentPrototype__proto.toNow             = toNow;
    momentPrototype__proto.get               = getSet;
    momentPrototype__proto.invalidAt         = invalidAt;
    momentPrototype__proto.isAfter           = isAfter;
    momentPrototype__proto.isBefore          = isBefore;
    momentPrototype__proto.isBetween         = isBetween;
    momentPrototype__proto.isSame            = isSame;
    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
    momentPrototype__proto.isValid           = moment_valid__isValid;
    momentPrototype__proto.lang              = lang;
    momentPrototype__proto.locale            = locale;
    momentPrototype__proto.localeData        = localeData;
    momentPrototype__proto.max               = prototypeMax;
    momentPrototype__proto.min               = prototypeMin;
    momentPrototype__proto.parsingFlags      = parsingFlags;
    momentPrototype__proto.set               = getSet;
    momentPrototype__proto.startOf           = startOf;
    momentPrototype__proto.subtract          = add_subtract__subtract;
    momentPrototype__proto.toArray           = toArray;
    momentPrototype__proto.toObject          = toObject;
    momentPrototype__proto.toDate            = toDate;
    momentPrototype__proto.toISOString       = moment_format__toISOString;
    momentPrototype__proto.toJSON            = toJSON;
    momentPrototype__proto.toString          = toString;
    momentPrototype__proto.unix              = unix;
    momentPrototype__proto.valueOf           = to_type__valueOf;
    momentPrototype__proto.creationData      = creationData;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    function preParsePostFormat (string) {
        return string;
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var prototype__proto = Locale.prototype;

    prototype__proto._calendar       = defaultCalendar;
    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto._invalidDate    = defaultInvalidDate;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto._ordinal        = defaultOrdinal;
    prototype__proto.ordinal         = ordinal;
    prototype__proto._ordinalParse   = defaultOrdinalParse;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto._relativeTime   = defaultRelativeTime;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months            =        localeMonths;
    prototype__proto._months           = defaultLocaleMonths;
    prototype__proto.monthsShort       =        localeMonthsShort;
    prototype__proto._monthsShort      = defaultLocaleMonthsShort;
    prototype__proto.monthsParse       =        localeMonthsParse;
    prototype__proto._monthsRegex      = defaultMonthsRegex;
    prototype__proto.monthsRegex       = monthsRegex;
    prototype__proto._monthsShortRegex = defaultMonthsShortRegex;
    prototype__proto.monthsShortRegex  = monthsShortRegex;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto._weekdays      = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    prototype__proto._weekdaysRegex      = defaultWeekdaysRegex;
    prototype__proto.weekdaysRegex       =        weekdaysRegex;
    prototype__proto._weekdaysShortRegex = defaultWeekdaysShortRegex;
    prototype__proto.weekdaysShortRegex  =        weekdaysShortRegex;
    prototype__proto._weekdaysMinRegex   = defaultWeekdaysMinRegex;
    prototype__proto.weekdaysMinRegex    =        weekdaysMinRegex;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = lists__get(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = locale_locales__getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return lists__get(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = lists__get(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function lists__listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function lists__listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function lists__listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function lists__listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes <= 1           && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   <= 1           && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    <= 1           && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  <= 1           && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   <= 1           && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.13.0';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.now                   = now;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.updateLocale          = updateLocale;
    utils_hooks__hooks.locales               = locale_locales__listLocales;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    utils_hooks__hooks.prototype             = momentPrototype;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
},{}],190:[function(require,module,exports){
"use strict";
var window = require("global/window")
var once = require("once")
var isFunction = require("is-function")
var parseHeaders = require("parse-headers")
var xtend = require("xtend")

module.exports = createXHR
createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest

forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback)
        options.method = method.toUpperCase()
        return _createXHR(options)
    }
})

function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
        iterator(array[i])
    }
}

function isEmpty(obj){
    for(var i in obj){
        if(obj.hasOwnProperty(i)) return false
    }
    return true
}

function initParams(uri, options, callback) {
    var params = uri

    if (isFunction(options)) {
        callback = options
        if (typeof uri === "string") {
            params = {uri:uri}
        }
    } else {
        params = xtend(options, {uri: uri})
    }

    params.callback = callback
    return params
}

function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback)
    return _createXHR(options)
}

function _createXHR(options) {
    var callback = options.callback
    if(typeof callback === "undefined"){
        throw new Error("callback argument missing")
    }
    callback = once(callback)

    function readystatechange() {
        if (xhr.readyState === 4) {
            loadFunc()
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else if (xhr.responseType === "text" || !xhr.responseType) {
            body = xhr.responseText || xhr.responseXML
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    var failureResponse = {
                body: undefined,
                headers: {},
                statusCode: 0,
                method: method,
                url: uri,
                rawRequest: xhr
            }

    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
        }
        evt.statusCode = 0
        callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        if (aborted) return
        var status
        clearTimeout(timeoutTimer)
        if(options.useXDR && xhr.status===undefined) {
            //IE8 CORS GET successful response doesn't have a status field, but body is fine
            status = 200
        } else {
            status = (xhr.status === 1223 ? 204 : xhr.status)
        }
        var response = failureResponse
        var err = null

        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        callback(err, response, response.body)

    }

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new createXHR.XDomainRequest()
        }else{
            xhr = new createXHR.XMLHttpRequest()
        }
    }

    var key
    var aborted
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data || null
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer

    if ("json" in options) {
        isJson = true
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
            body = JSON.stringify(options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync, options.username, options.password)
    //has to be after open
    if(!sync) {
        xhr.withCredentials = !!options.withCredentials
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            aborted=true//IE9 may still call readystatechange
            xhr.abort("timeout")
            var e = new Error("XMLHttpRequest timeout")
            e.code = "ETIMEDOUT"
            errorFunc(e)
        }, options.timeout )
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }

    if ("beforeSend" in options &&
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    xhr.send(body)

    return xhr


}

function noop() {}

},{"global/window":191,"is-function":192,"once":193,"parse-headers":196,"xtend":197}],191:[function(require,module,exports){
(function (global){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],192:[function(require,module,exports){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],193:[function(require,module,exports){
module.exports = once

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var called = false
  return function () {
    if (called) return
    called = true
    return fn.apply(this, arguments)
  }
}

},{}],194:[function(require,module,exports){
var isFunction = require('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

},{"is-function":192}],195:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],196:[function(require,module,exports){
var trim = require('trim')
  , forEach = require('for-each')
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}
},{"for-each":194,"trim":195}],197:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}]},{},[3])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9jb25maWcuanMiLCJqcy9nZW9qc29uQ2hhbmdlcy5qcyIsImpzL2luZGV4LmpzIiwianMvb3NtLmpzIiwianMvb3ZlcnBhc3MuanMiLCJqcy9vdmVycGFzc1RvR2VvSlNPTi5qcyIsImpzL3Byb3BzRGlmZi5qcyIsImpzL3JlbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9hc3NlcnQvYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvZGF0YS9idWNrZXQuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL2RhdGEvYnVja2V0L2NpcmNsZV9idWNrZXQuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL2RhdGEvYnVja2V0L2ZpbGxfYnVja2V0LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy9kYXRhL2J1Y2tldC9saW5lX2J1Y2tldC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvZGF0YS9idWNrZXQvc3ltYm9sX2J1Y2tldC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvZGF0YS9idWZmZXIuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL2RhdGEvZmVhdHVyZV9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvZGF0YS9sb2FkX2dlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy9nZW8vY29vcmRpbmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvZ2VvL2xuZ19sYXQuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL2dlby9sbmdfbGF0X2JvdW5kcy5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvZ2VvL3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvbGliL2RlYnVndGV4dC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvbWFwYm94LWdsLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy9yZW5kZXIvZHJhd19iYWNrZ3JvdW5kLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy9yZW5kZXIvZHJhd19jaXJjbGUuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3JlbmRlci9kcmF3X2NvbGxpc2lvbl9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvcmVuZGVyL2RyYXdfZGVidWcuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3JlbmRlci9kcmF3X2ZpbGwuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3JlbmRlci9kcmF3X2xpbmUuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3JlbmRlci9kcmF3X3Jhc3Rlci5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvcmVuZGVyL2RyYXdfc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy9yZW5kZXIvZnJhbWVfaGlzdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvcmVuZGVyL2xpbmVfYXRsYXMuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3JlbmRlci9wYWludGVyLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy9yZW5kZXIvcGFpbnRlci91c2VfcHJvZ3JhbS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvcmVuZGVyL3ZlcnRleF9hcnJheV9vYmplY3QuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3NvdXJjZS9nZW9qc29uX3NvdXJjZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvc291cmNlL2dlb2pzb25fd3JhcHBlci5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvc291cmNlL2ltYWdlX3NvdXJjZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvc291cmNlL3BpeGVsc190b190aWxlX3VuaXRzLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy9zb3VyY2UvcmFzdGVyX3RpbGVfc291cmNlLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy9zb3VyY2Uvc291cmNlLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy9zb3VyY2UvdGlsZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvc291cmNlL3RpbGVfY29vcmQuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3NvdXJjZS90aWxlX3B5cmFtaWQuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3NvdXJjZS92ZWN0b3JfdGlsZV9zb3VyY2UuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3NvdXJjZS92aWRlb19zb3VyY2UuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3NvdXJjZS93b3JrZXIuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3NvdXJjZS93b3JrZXJfdGlsZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvc3R5bGUvYW5pbWF0aW9uX2xvb3AuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3N0eWxlL2ltYWdlX3Nwcml0ZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvc3R5bGUvcGFyc2VfY29sb3IuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3N0eWxlL3N0eWxlLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy9zdHlsZS9zdHlsZV9kZWNsYXJhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvc3R5bGUvc3R5bGVfZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3N0eWxlL3N0eWxlX2xheWVyLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy9zdHlsZS9zdHlsZV9sYXllci9iYWNrZ3JvdW5kX3N0eWxlX2xheWVyLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy9zdHlsZS9zdHlsZV9sYXllci9jaXJjbGVfc3R5bGVfbGF5ZXIuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3N0eWxlL3N0eWxlX2xheWVyL2ZpbGxfc3R5bGVfbGF5ZXIuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3N0eWxlL3N0eWxlX2xheWVyL2xpbmVfc3R5bGVfbGF5ZXIuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3N0eWxlL3N0eWxlX2xheWVyL3Jhc3Rlcl9zdHlsZV9sYXllci5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvc3R5bGUvc3R5bGVfbGF5ZXIvc3ltYm9sX3N0eWxlX2xheWVyLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy9zdHlsZS9zdHlsZV9zcGVjLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy9zdHlsZS9zdHlsZV90cmFuc2l0aW9uLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy9zdHlsZS92YWxpZGF0ZV9zdHlsZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvc3ltYm9sL2FuY2hvci5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvc3ltYm9sL2NoZWNrX21heF9hbmdsZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvc3ltYm9sL2NsaXBfbGluZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvc3ltYm9sL2NvbGxpc2lvbl9ib3guanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3N5bWJvbC9jb2xsaXNpb25fZmVhdHVyZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvc3ltYm9sL2NvbGxpc2lvbl90aWxlLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy9zeW1ib2wvZ2V0X2FuY2hvcnMuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3N5bWJvbC9nbHlwaF9hdGxhcy5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvc3ltYm9sL2dseXBoX3NvdXJjZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvc3ltYm9sL21lcmdlbGluZXMuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3N5bWJvbC9xdWFkcy5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvc3ltYm9sL3Jlc29sdmVfdGV4dC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvc3ltYm9sL3NoYXBpbmcuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3N5bWJvbC9zcHJpdGVfYXRsYXMuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3VpL2NhbWVyYS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvdWkvY29udHJvbC9hdHRyaWJ1dGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvdWkvY29udHJvbC9jb250cm9sLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy91aS9jb250cm9sL2dlb2xvY2F0ZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvdWkvY29udHJvbC9uYXZpZ2F0aW9uLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy91aS9oYW5kbGVyL2JveF96b29tLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy91aS9oYW5kbGVyL2RibGNsaWNrX3pvb20uanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3VpL2hhbmRsZXIvZHJhZ19wYW4uanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3VpL2hhbmRsZXIvZHJhZ19yb3RhdGUuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3VpL2hhbmRsZXIva2V5Ym9hcmQuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3VpL2hhbmRsZXIvc2Nyb2xsX3pvb20uanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3VpL2hhbmRsZXIvdG91Y2hfem9vbV9yb3RhdGUuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3VpL2hhc2guanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3VpL2ludGVyYWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy91aS9tYXAuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3VpL3BvcHVwLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy91dGlsL2FjdG9yLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy91dGlsL2Jyb3dzZXIvYWpheC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvdXRpbC9icm93c2VyL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3V0aWwvYnJvd3Nlci9jYW52YXMuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3V0aWwvYnJvd3Nlci9kaXNwYXRjaGVyLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy91dGlsL2Jyb3dzZXIvZG9tLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy91dGlsL2NvbmZpZy5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvdXRpbC9kaWN0aW9uYXJ5X2NvZGVyLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy91dGlsL2V2ZW50ZWQuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3V0aWwvZ2x5cGhzLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy91dGlsL2ludGVycG9sYXRlLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy91dGlsL2ludGVyc2VjdGlvbl90ZXN0cy5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvdXRpbC9scnVfY2FjaGUuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL2pzL3V0aWwvbWFwYm94LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy91dGlsL3N0cnVjdF9hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvdXRpbC90b2tlbi5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvanMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9qcy91dGlsL3ZlY3RvcnRpbGVfdG9fZ2VvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvbm9kZV9tb2R1bGVzL2Nzc2NvbG9ycGFyc2VyL2Nzc2NvbG9ycGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9ub2RlX21vZHVsZXMvZmVhdHVyZS1maWx0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9nZW9qc29uLXJld2luZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvbm9kZV9tb2R1bGVzL2dlb2pzb24tcmV3aW5kL25vZGVfbW9kdWxlcy9nZW9qc29uLWFyZWEvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9nZW9qc29uLXJld2luZC9ub2RlX21vZHVsZXMvZ2VvanNvbi1hcmVhL25vZGVfbW9kdWxlcy93Z3M4NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvbm9kZV9tb2R1bGVzL2dlb2pzb24tdnQvc3JjL2NsaXAuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy9jb252ZXJ0LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9ub2RlX21vZHVsZXMvZ2VvanNvbi12dC9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy9zaW1wbGlmeS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvbm9kZV9tb2R1bGVzL2dlb2pzb24tdnQvc3JjL3RpbGUuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy93cmFwLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXguanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9jb21tb24uanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQyLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0MmQuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQzLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0NC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3F1YXQuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWMyLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvdmVjMy5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzQuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9ncmlkLWluZGV4L2dyaWQtaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wtZnVuY3Rpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wtanMtc3VwcG9ydGVkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9ub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL2Vycm9yL3ZhbGlkYXRpb25fZXJyb3IuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdXRpbC9leHRlbmQuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdXRpbC9nZXRfdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvbm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi91dGlsL3VuYnVuZGxlX2pzb25saW50LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9ub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL3ZhbGlkYXRlLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9ub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL3ZhbGlkYXRlX2FycmF5LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9ub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL3ZhbGlkYXRlX2Jvb2xlYW4uanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGUvdmFsaWRhdGVfY29sb3IuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGUvdmFsaWRhdGVfY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9ub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL3ZhbGlkYXRlX2VudW0uanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGUvdmFsaWRhdGVfZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9ub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL3ZhbGlkYXRlX2Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9ub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL3ZhbGlkYXRlX2dseXBoc191cmwuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGUvdmFsaWRhdGVfbGF5ZXIuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGUvdmFsaWRhdGVfbGF5b3V0X3Byb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9ub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL3ZhbGlkYXRlX251bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvbm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZS92YWxpZGF0ZV9vYmplY3QuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGUvdmFsaWRhdGVfcGFpbnRfcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGUvdmFsaWRhdGVfc291cmNlLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9ub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL3ZhbGlkYXRlX3N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvbm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZV9zdHlsZS5taW4uanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9yZWZlcmVuY2UvbGF0ZXN0LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9ub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvcmVmZXJlbmNlL2xhdGVzdC5taW4uanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9yZWZlcmVuY2UvdjguanNvbiIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvbm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL3JlZmVyZW5jZS92OC5taW4uanNvbiIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvbm9kZV9tb2R1bGVzL3BiZi9idWZmZXIuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9wYmYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9wYmYvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9wb2ludC1nZW9tZXRyeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvbm9kZV9tb2R1bGVzL3Jlc29sdmUtdXJsL3Jlc29sdmUtdXJsLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9ub2RlX21vZHVsZXMvc2hlbGYtcGFjay9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvbm9kZV9tb2R1bGVzL3N1cGVyY2x1c3Rlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvbm9kZV9tb2R1bGVzL3N1cGVyY2x1c3Rlci9ub2RlX21vZHVsZXMva2RidXNoL3NyYy9rZGJ1c2guanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9zdXBlcmNsdXN0ZXIvbm9kZV9tb2R1bGVzL2tkYnVzaC9zcmMvcmFuZ2UuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy9zdXBlcmNsdXN0ZXIvbm9kZV9tb2R1bGVzL2tkYnVzaC9zcmMvc29ydC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvbm9kZV9tb2R1bGVzL3N1cGVyY2x1c3Rlci9ub2RlX21vZHVsZXMva2RidXNoL3NyYy93aXRoaW4uanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy91bml0YmV6aWVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC9ub2RlX21vZHVsZXMvdmVjdG9yLXRpbGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9saWIvdmVjdG9ydGlsZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvbm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2xpYi92ZWN0b3J0aWxlZmVhdHVyZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvbm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2xpYi92ZWN0b3J0aWxlbGF5ZXIuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy92dC1wYmYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsL25vZGVfbW9kdWxlcy92dC1wYmYvbGliL2dlb2pzb25fd3JhcHBlci5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvbm9kZV9tb2R1bGVzL3Z0LXBiZi92ZWN0b3ItdGlsZS1wYi5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wvbm9kZV9tb2R1bGVzL3dlYndvcmtpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9tZW50L21vbWVudC5qcyIsIm5vZGVfbW9kdWxlcy94aHIvaW5kZXguanMiLCJub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9nbG9iYWwvd2luZG93LmpzIiwibm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvaXMtZnVuY3Rpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9vbmNlL29uY2UuanMiLCJub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL25vZGVfbW9kdWxlcy9mb3ItZWFjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvbm9kZV9tb2R1bGVzL3RyaW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL3BhcnNlLWhlYWRlcnMuanMiLCJub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4d0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGxFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4bEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMza0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3p3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDam1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyM0NBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Y4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb25maWcgPSB7XG4gICAgJ292ZXJwYXNzQmFzZSc6ICdodHRwczovL292ZXJwYXNzLWNmbi1zdGFnaW5nLnRpbGVzdHJlYW0ubmV0L2FwaS9pbnRlcnByZXRlcicsXG4gICAgLy8nb3ZlcnBhc3NCYXNlJzogJ2h0dHBzOi8vb3ZlcnBhc3MtYXBpLmRlL2FwaS9pbnRlcnByZXRlcicsXG4gICAgJ29zbUJhc2UnOiAnaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvYXBpLzAuNi8nLFxuICAgIC8vICdtYXBib3hBY2Nlc3NUb2tlbic6ICdway5leUoxSWpvaWMyRnVhbUY1WWlJc0ltRWlPaUkzTmpWdk1GWTBJbjAuYnluX2VDWkdBd1IxeWFQZUMtU1ZLdydcbiAgICAnbWFwYm94QWNjZXNzVG9rZW4nOiAncGsuZXlKMUlqb2ljR3hoYm1WdFlXUWlMQ0poSWpvaWVtZFlTVlZMUlNKOS5nM2xiZ19lTjBrenRtc2ZJUHhhOU1RJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb25maWc7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGdldENoYW5nZXMoZ2VvanNvbiwgY2hhbmdlc2V0KSB7XG4gICAgdmFyIGZlYXR1cmVzID0gZ2VvanNvbi5mZWF0dXJlcztcbiAgICB2YXIgZmVhdHVyZU1hcCA9IHt9O1xuICAgIHZhciBjaGFuZ2VHZW9KU09OID0ge1xuICAgICAgICAndHlwZSc6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgICdmZWF0dXJlcyc6IFtdXG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gZmVhdHVyZXNbaV0ucHJvcGVydGllcy5pZDtcbiAgICAgICAgZmVhdHVyZU1hcFtpZF0gPSBmZWF0dXJlTWFwW2lkXSB8fCBbXTtcbiAgICAgICAgZmVhdHVyZU1hcFtpZF0ucHVzaChmZWF0dXJlc1tpXSk7XG4gICAgfVxuICAgIGZvciAodmFyIG9zbUlEIGluIGZlYXR1cmVNYXApIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmZWF0dXJlTWFwW29zbUlEXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGYgPSBmZWF0dXJlTWFwW29zbUlEXVtqXTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZ2V0Q2hhbmdlVHlwZShmLCBmZWF0dXJlTWFwLCBjaGFuZ2VzZXQpO1xuICAgICAgICAgICAgZi5wcm9wZXJ0aWVzLmNoYW5nZVR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgY2hhbmdlR2VvSlNPTi5mZWF0dXJlcy5wdXNoKGYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgICdmZWF0dXJlTWFwJzogZmVhdHVyZU1hcCxcbiAgICAgICAgJ2dlb2pzb24nOiBjaGFuZ2VHZW9KU09OXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2hhbmdlVHlwZShmZWF0dXJlLCBmZWF0dXJlcywgY2hhbmdlc2V0KSB7XG4gICAgdmFyIHByb3BzID0gZmVhdHVyZS5wcm9wZXJ0aWVzO1xuICAgIHZhciB2ZXJzaW9uID0gcGFyc2VJbnQocHJvcHMudmVyc2lvbik7XG4gICAgdmFyIGhhc05leHQgPSBoYXNOZXh0VmVyc2lvbih2ZXJzaW9uLCBmZWF0dXJlLCBmZWF0dXJlcyk7XG4gICAgaWYgKGhhc05leHQpIHtcbiAgICAgICAgcmV0dXJuICdtb2RpZmllZE9sZCc7XG4gICAgfVxuICAgIHZhciBoYXNQcmV2ID0gaGFzUHJldmlvdXNWZXJzaW9uKHZlcnNpb24sIGZlYXR1cmUsIGZlYXR1cmVzKTtcbiAgICBpZiAoaGFzUHJldikge1xuICAgICAgICByZXR1cm4gJ21vZGlmaWVkTmV3JztcbiAgICB9XG4gICAgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgaWYgKHByb3BzLnVpZCA9PT0gcGFyc2VJbnQoY2hhbmdlc2V0LnVpZCkgJiYgcHJvcHMuY2hhbmdlc2V0ID09PSBwYXJzZUludChjaGFuZ2VzZXQuaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2FkZGVkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnZGVsZXRlZCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdkZWxldGVkJzsgLy90aGlzIGlzIHBvc3NpYmx5IHdyb25nLlxufVxuXG5mdW5jdGlvbiBoYXNOZXh0VmVyc2lvbih2ZXJzaW9uLCBmZWF0dXJlLCBmZWF0dXJlcykge1xuICAgIHZhciBpZCA9IGZlYXR1cmUucHJvcGVydGllcy5pZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVzW2lkXS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZiA9IGZlYXR1cmVzW2lkXVtpXTtcbiAgICAgICAgaWYgKGYucHJvcGVydGllcy52ZXJzaW9uID09PSAodmVyc2lvbiArIDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVzW2lkXS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZiA9IGZlYXR1cmVzW2lkXVtpXTtcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIGYucHJvcGVydGllcy5fbm9kZVZlcnNpb25zKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFZlcnNpb24gPSBmZWF0dXJlLnByb3BlcnRpZXMuX25vZGVWZXJzaW9uc1tub2RlSWRdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRWZXJzaW9uIDwgZi5wcm9wZXJ0aWVzLl9ub2RlVmVyc2lvbnNbbm9kZUlkXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaGFzUHJldmlvdXNWZXJzaW9uKHZlcnNpb24sIGZlYXR1cmUsIGZlYXR1cmVzKSB7XG4gICAgdmFyIGlkID0gZmVhdHVyZS5wcm9wZXJ0aWVzLmlkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZXNbaWRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmID0gZmVhdHVyZXNbaWRdW2ldO1xuICAgICAgICBpZiAoZi5wcm9wZXJ0aWVzLnZlcnNpb24gPT09ICh2ZXJzaW9uIC0gMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZXNbaWRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmID0gZmVhdHVyZXNbaWRdW2ldO1xuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gZi5wcm9wZXJ0aWVzLl9ub2RlVmVyc2lvbnMpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50VmVyc2lvbiA9IGZlYXR1cmUucHJvcGVydGllcy5fbm9kZVZlcnNpb25zW25vZGVJZF07XG4gICAgICAgICAgICBpZiAoY3VycmVudFZlcnNpb24gPiBmLnByb3BlcnRpZXMuX25vZGVWZXJzaW9uc1tub2RlSWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldENoYW5nZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZW5kZXIgPSByZXF1aXJlKCcuL3JlbmRlcicpO1xuXG5pZiAobG9jYXRpb24uaGFzaCAhPT0gJycpIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9ybUNvbnRhaW5lcicpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgcmVuZGVyKGxvY2F0aW9uLmhhc2gsIHt9KTtcbn1cblxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYW5nZXNldEZvcm0nKS5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9ybUNvbnRhaW5lcicpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdmFyIGNoYW5nZXNldElEID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYW5nZXNldElucHV0JykudmFsdWU7XG4gICAgbG9jYXRpb24uaGFzaCA9IGNoYW5nZXNldElEO1xuICAgIHJlbmRlcihsb2NhdGlvbi5oYXNoLCB7fSk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHhociA9IHJlcXVpcmUoJ3hocicpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbnZhciBxdWVyeSA9IGZ1bmN0aW9uIChjaGFuZ2VzZXRJRCwgY2FsbGJhY2spIHtcbiAgICB2YXIgdXJsID0gY29uZmlnLm9zbUJhc2UgKyAnY2hhbmdlc2V0LycgKyBjaGFuZ2VzZXRJRDtcbiAgICB2YXIgeGhyT3B0aW9ucyA9IHtcbiAgICAgICAgJ3Jlc3BvbnNlVHlwZSc6ICdkb2N1bWVudCdcbiAgICB9O1xuICAgIHhoci5nZXQodXJsLCB4aHJPcHRpb25zLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeG1sID0gcmVzcG9uc2UuYm9keTtcbiAgICAgICAgdmFyIGNzRmVhdHVyZSA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2hhbmdlc2V0JylbMF07XG4gICAgICAgIHZhciBjcyA9IGNzRmVhdHVyZS5hdHRyaWJ1dGVzO1xuICAgICAgICB2YXIgdWlkID0gY3MudWlkLnRleHRDb250ZW50O1xuICAgICAgICB2YXIgdXNlciA9IGNzLnVzZXIudGV4dENvbnRlbnQ7XG4gICAgICAgIHZhciBmcm9tID0gbW9tZW50KGNzLmNyZWF0ZWRfYXQudGV4dENvbnRlbnQsICdZWVlZLU1NLUREVEhIOm1tOnNzXFxcXFonKS5zdWJ0cmFjdCgnc2Vjb25kcycsIDEpLmZvcm1hdCgnWVlZWS1NTS1ERFRISDptbTpzc1xcXFxaJyk7XG4gICAgICAgIHZhciB0byA9IGNzLmNsb3NlZF9hdCA/IGNzLmNsb3NlZF9hdC50ZXh0Q29udGVudCA6IG51bGw7XG4gICAgICAgIHZhciBsZWZ0ID0gY3MubWluX2xvbi50ZXh0Q29udGVudDtcbiAgICAgICAgdmFyIGJvdHRvbSA9IGNzLm1pbl9sYXQudGV4dENvbnRlbnQ7XG4gICAgICAgIHZhciByaWdodCA9IGNzLm1heF9sb24udGV4dENvbnRlbnQ7XG4gICAgICAgIHZhciB0b3AgPSBjcy5tYXhfbGF0LnRleHRDb250ZW50O1xuICAgICAgICB2YXIgY2hhbmdlc2V0ID0ge1xuICAgICAgICAgICAgJ2lkJzogY2hhbmdlc2V0SUQsXG4gICAgICAgICAgICAndWlkJzogdWlkLFxuICAgICAgICAgICAgJ3VzZXInOiB1c2VyLFxuICAgICAgICAgICAgJ2Zyb20nOiBmcm9tLFxuICAgICAgICAgICAgJ3RvJzogdG8sXG4gICAgICAgICAgICAnYmJveCc6IHtcbiAgICAgICAgICAgICAgICAnbGVmdCc6IGxlZnQsXG4gICAgICAgICAgICAgICAgJ2JvdHRvbSc6IGJvdHRvbSxcbiAgICAgICAgICAgICAgICAncmlnaHQnOiByaWdodCxcbiAgICAgICAgICAgICAgICAndG9wJzogdG9wXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBjaGFuZ2VzZXQpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ3F1ZXJ5JzogcXVlcnlcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB4aHIgPSByZXF1aXJlKCd4aHInKTtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xudmFyIG9zbSA9IHJlcXVpcmUoJy4vb3NtJyk7XG52YXIgb3ZlcnBhc3NUb0dlb0pTT04gPSByZXF1aXJlKCcuL292ZXJwYXNzVG9HZW9KU09OJyk7XG52YXIgZ2VvanNvbkNoYW5nZXMgPSByZXF1aXJlKCcuL2dlb2pzb25DaGFuZ2VzJyk7XG5cbnZhciBxdWVyeSA9IGZ1bmN0aW9uIChjaGFuZ2VzZXRJRCwgY2FsbGJhY2spIHtcbiAgICBvc20ucXVlcnkoY2hhbmdlc2V0SUQsIGZ1bmN0aW9uIChlcnIsIGNoYW5nZXNldCkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgJ21zZyc6ICdPU00gUXVlcnkgZmFpbGVkLiBBcmUgeW91IHN1cmUgeW91IGVudGVyZWQgYSB2YWxpZCBjaGFuZ2VzZXQgaWQ/JyxcbiAgICAgICAgICAgICAgICAnZXJyb3InOiBlcnJcbiAgICAgICAgICAgIH0sIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhID0gZ2V0RGF0YVBhcmFtKGNoYW5nZXNldCk7XG4gICAgICAgIHZhciBiYm94ID0gZ2V0QmJveFBhcmFtKGNoYW5nZXNldC5iYm94KTtcbiAgICAgICAgdmFyIHVybCA9IGNvbmZpZy5vdmVycGFzc0Jhc2UgKyAnP2RhdGE9JyArIGRhdGEgKyAnJmJib3g9JyArIGJib3g7XG4gICAgICAgIHZhciB4aHJPcHRpb25zID0ge1xuICAgICAgICAgICAgJ3Jlc3BvbnNlVHlwZSc6ICdqc29uJ1xuICAgICAgICB9O1xuICAgICAgICB4aHIuZ2V0KHVybCwgeGhyT3B0aW9ucywgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICAnbXNnJzogJ092ZXJwYXNzIHF1ZXJ5IGZhaWxlZC4nLFxuICAgICAgICAgICAgICAgICAgICAnZXJyb3InOiBlcnJcbiAgICAgICAgICAgICAgICB9LCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHJlc3BvbnNlLmJvZHkuZWxlbWVudHM7XG4gICAgICAgICAgICB2YXIgZ2VvanNvbiA9IG92ZXJwYXNzVG9HZW9KU09OKGVsZW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VzID0gZ2VvanNvbkNoYW5nZXMoZ2VvanNvbiwgY2hhbmdlc2V0KTtcblxuICAgICAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICAgICAgICAnZ2VvanNvbic6IGNoYW5nZXMuZ2VvanNvbixcbiAgICAgICAgICAgICAgICAnZmVhdHVyZU1hcCc6IGNoYW5nZXMuZmVhdHVyZU1hcCxcbiAgICAgICAgICAgICAgICAnY2hhbmdlc2V0JzogY2hhbmdlc2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJldCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gZ2V0RGF0YVBhcmFtKGMpIHtcbiAgICByZXR1cm4gJ1tvdXQ6anNvbl1bYWRpZmY6JTIyJyArIGMuZnJvbS50b1N0cmluZygpICArICcsJTIyLCUyMicgKyBjLnRvLnRvU3RyaW5nKCkgKyAnJTIyXTsobm9kZShiYm94KShjaGFuZ2VkKTt3YXkoYmJveCkoY2hhbmdlZCk7KTtvdXQlMjBtZXRhJTIwZ2VvbShiYm94KTsnO1xufVxuXG5mdW5jdGlvbiBnZXRCYm94UGFyYW0oYmJveCkge1xuICAgIHJldHVybiBbYmJveC5sZWZ0LCBiYm94LmJvdHRvbSwgYmJveC5yaWdodCwgYmJveC50b3BdLmpvaW4oJywnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ3F1ZXJ5JzogcXVlcnlcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG92ZXJwYXNzVG9HZW9KU09OKG92ZXJwYXNzRWxlbWVudHMpIHtcbiAgICB2YXIgTk9ERVMgPSBnZXROb2Rlc0J5SWQob3ZlcnBhc3NFbGVtZW50cyk7XG5cbiAgICB2YXIgZmVhdHVyZXMgPSBbXTtcbiAgICBvdmVycGFzc0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciBnZW9qc29uO1xuICAgICAgICBpZiAoZWwudHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgICAgICAgICBnZW9qc29uID0gZ2V0Tm9kZUdlb0pTT04oZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2VvanNvbiA9IGdldFdheUdlb0pTT04oZWwsIE5PREVTKTtcbiAgICAgICAgfVxuICAgICAgICBmZWF0dXJlcy5wdXNoKGdlb2pzb24pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgICd0eXBlJzogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgICAgJ2ZlYXR1cmVzJzogZmVhdHVyZXNcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXROb2Rlc0J5SWQob3ZlcnBhc3NFbGVtZW50cykge1xuICAgIHJldHVybiBvdmVycGFzc0VsZW1lbnRzXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uIChlbHQpIHsgcmV0dXJuIGVsdC50eXBlID09PSAnbm9kZSc7IH0pXG4gICAgICAucmVkdWNlKGZ1bmN0aW9uIChub2Rlcywgbm9kZSkge1xuICAgICAgICAgIG5vZGVzW25vZGUuaWRdID0gbm9kZXNbbm9kZS5pZF0gfHwgW107XG4gICAgICAgICAgbm9kZXNbbm9kZS5pZF0ucHVzaCh7XG4gICAgICAgICAgICAgIGxhdDogbm9kZS5sYXQsXG4gICAgICAgICAgICAgIGxvbjogbm9kZS5sb24sXG4gICAgICAgICAgICAgIHZlcnNpb246IG5vZGUudmVyc2lvblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcHMob2JqKSB7XG4gICAgdmFyIHByb3BzID0gb2JqLnRhZ3MgfHwge307XG4gICAgcHJvcHMuY2hhbmdlc2V0ID0gb2JqLmNoYW5nZXNldDtcbiAgICBwcm9wcy50aW1lc3RhbXAgPSBvYmoudGltZXN0YW1wO1xuICAgIHByb3BzLnZlcnNpb24gPSBvYmoudmVyc2lvbjtcbiAgICBwcm9wcy51aWQgPSBvYmoudWlkO1xuICAgIHByb3BzLnVzZXIgPSBvYmoudXNlcjtcbiAgICBwcm9wcy5pZCA9IG9iai5pZDtcbiAgICBwcm9wcy50eXBlID0gb2JqLnR5cGU7XG4gICAgcmV0dXJuIHByb3BzO1xufVxuXG4vLyBnZXQgZ2VvanNvbiBmb3IgYSBwb2ludCB0eXBlXG5mdW5jdGlvbiBnZXROb2RlR2VvSlNPTihub2RlKSB7XG4gICAgdmFyIHByb3BzID0gZ2V0UHJvcHMobm9kZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgJ3R5cGUnOiAnRmVhdHVyZScsXG4gICAgICAgICdwcm9wZXJ0aWVzJzogcHJvcHMsXG4gICAgICAgICdnZW9tZXRyeSc6IHtcbiAgICAgICAgICAgICd0eXBlJzogJ1BvaW50JyxcbiAgICAgICAgICAgICdjb29yZGluYXRlcyc6IFtub2RlLmxvbiwgbm9kZS5sYXRdXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb29yZHMoZ2VvbSkge1xuICAgIHJldHVybiBnZW9tLm1hcChmdW5jdGlvbiAocHQpIHtcbiAgICAgICAgaWYgKHB0ICYmIHB0LmxvbiAmJiBwdC5sYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBbcHQubG9uLCBwdC5sYXRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHB0KSB7XG4gICAgICAgIHJldHVybiAhIXB0O1xuICAgIH0pO1xufVxuXG4vLyBnZXQgZ2VvanNvbiBmb3IgYSBcIndheVwiIC0gZWl0aGVyIGxpbmUgb3IgcG9seWdvblxuZnVuY3Rpb24gZ2V0V2F5R2VvSlNPTih3YXksIE5PREVTKSB7XG4gICAgdmFyIHByb3BzID0gZ2V0UHJvcHMod2F5KTtcblxuICAgIC8vIGZvciBzb21lIHJlYXNvbiwgT3ZlcnBhc3Mgc29tZXRpbWUgcmV0dXJucyBub2RlcyBpbiBhIGdlb21ldHJ5IGFzIG51bGxcbiAgICAvLyBzaW5jZSBJIGRvbid0IGtub3cgd2hhdCBlbHNlIHRvIGRvIHdpdGggdGhlbSwgbGV0J3MganVzdCBmaWx0ZXIgdGhlbSBvdXRcbiAgICAvLyBhbG9uZyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmcgbm9kZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdheS5nZW9tZXRyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAod2F5Lmdlb21ldHJ5W2ldID09PSBudWxsKSB7XG4gICAgICAgICAgICB3YXkuZ2VvbWV0cnkuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgd2F5Lm5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBub2RlVmVyc2lvbnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdheS5ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSB3YXkubm9kZXNbaV07XG4gICAgICAgIHZhciBnZW9tZXRyeSA9IHdheS5nZW9tZXRyeVtpXTtcbiAgICAgICAgaWYgKE5PREVTW2lkXSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBOT0RFU1tpZF0uZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUubGF0ID09PSBnZW9tZXRyeS5sYXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5sb24gPT09IGdlb21ldHJ5LmxvbjtcbiAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgICAgbm9kZVZlcnNpb25zW2lkXSA9IG5vZGUudmVyc2lvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgYXMgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSwgc28gdGhhdCBpdCBkb2Vzbid0XG4gICAgLy8gZ2V0IHBpY2tlZCB1cCB3aGVuIGdlbmVyYXRpbmcgdGhlIHByb3BzIHRhYmxlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAnX25vZGVWZXJzaW9ucycsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBub2RlVmVyc2lvbnNcbiAgICB9KTtcblxuICAgIHZhciBmaXJzdE5vZGUgPSB3YXkuZ2VvbWV0cnlbMF07XG4gICAgdmFyIGxhc3ROb2RlID0gd2F5Lmdlb21ldHJ5W3dheS5nZW9tZXRyeS5sZW5ndGggLSAxXTtcbiAgICB2YXIgZ2VvbVR5cGU7XG4gICAgaWYgKGZpcnN0Tm9kZS5sYXQgPT09IGxhc3ROb2RlLmxhdCAmJiBmaXJzdE5vZGUubG9uID09PSBsYXN0Tm9kZS5sb24pIHtcbiAgICAgICAgZ2VvbVR5cGUgPSAnUG9seWdvbic7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2VvbVR5cGUgPSAnTGluZVN0cmluZyc7XG4gICAgfVxuICAgIHZhciBjb29yZHMgPSBnZXRDb29yZHMod2F5Lmdlb21ldHJ5KTtcbiAgICBpZiAoZ2VvbVR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICBjb29yZHMgPSBbY29vcmRzXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgJ3R5cGUnOiAnRmVhdHVyZScsXG4gICAgICAgICdwcm9wZXJ0aWVzJzogcHJvcHMsXG4gICAgICAgICdnZW9tZXRyeSc6IHtcbiAgICAgICAgICAgICd0eXBlJzogZ2VvbVR5cGUsXG4gICAgICAgICAgICAnY29vcmRpbmF0ZXMnOiBjb29yZHNcbiAgICAgICAgfVxuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlcnBhc3NUb0dlb0pTT047XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHByb3BzRGlmZihwcm9wc0FycmF5KSB7XG4gICAgaWYgKHByb3BzQXJyYXkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBjaGFuZ2VUeXBlID0gcHJvcHNBcnJheVswXS5jaGFuZ2VUeXBlO1xuICAgICAgICBpZiAoY2hhbmdlVHlwZSA9PT0gJ2FkZGVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFkZGVkKHByb3BzQXJyYXlbMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5nZVR5cGUgPT09ICdkZWxldGVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGdldERlbGV0ZWQocHJvcHNBcnJheVswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkgMSBlbGVtZW50IGJ1dCBuZWl0aGVyIGFkZGVkIG5vciBkZWxldGVkJyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbW9kaWZpZWRPbGQgPSBnZXRPbGQocHJvcHNBcnJheSk7XG4gICAgICAgIHZhciBtb2RpZmllZE5ldyA9IGdldE5ldyhwcm9wc0FycmF5KTtcbiAgICAgICAgcmV0dXJuIGdldERpZmYobW9kaWZpZWRPbGQsIG1vZGlmaWVkTmV3KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldERpZmYob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIGZvciAodmFyIHByb3AgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgcmV0W3Byb3BdID0ge307XG4gICAgICAgIGlmICghb2xkUHJvcHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIHJldFtwcm9wXVsnYWRkZWQnXSA9IG5ld1Byb3BzW3Byb3BdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gb2xkUHJvcHNbcHJvcF07XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBuZXdQcm9wc1twcm9wXTtcbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSA9PT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXRbcHJvcF1bJ3VuY2hhbmdlZCddID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldFtwcm9wXVsnbW9kaWZpZWRPbGQnXSA9IG9sZFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldFtwcm9wXVsnbW9kaWZpZWROZXcnXSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIG9sZFByb3AgaW4gb2xkUHJvcHMpIHtcbiAgICAgICAgaWYgKCFyZXQuaGFzT3duUHJvcGVydHkob2xkUHJvcCkpIHtcbiAgICAgICAgICAgIHJldFtvbGRQcm9wXSA9IHtcbiAgICAgICAgICAgICAgICAnZGVsZXRlZCc6IG9sZFByb3BzW29sZFByb3BdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGdldEFkZGVkKHByb3BzKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIGZvciAodmFyIHByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgcmV0W3Byb3BdID0ge1xuICAgICAgICAgICAgJ2FkZGVkJzogcHJvcHNbcHJvcF1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZ2V0RGVsZXRlZChwcm9wcykge1xuICAgIHZhciByZXQgPSB7fTtcbiAgICBmb3IgKHZhciBwcm9wIGluIHByb3BzKSB7XG4gICAgICAgIHJldFtwcm9wXSA9IHtcbiAgICAgICAgICAgICdkZWxldGVkJzogcHJvcHNbcHJvcF1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZ2V0T2xkKHByb3BzQXJyYXkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHByb3BzQXJyYXlbaV0uY2hhbmdlVHlwZSA9PT0gJ21vZGlmaWVkT2xkJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzQXJyYXlbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldE5ldyhwcm9wc0FycmF5KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wc0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwcm9wc0FycmF5W2ldLmNoYW5nZVR5cGUgPT09ICdtb2RpZmllZE5ldycpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wc0FycmF5W2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3BzRGlmZjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1hcGJveGdsID0gcmVxdWlyZSgnbWFwYm94LWdsJyk7XG52YXIgb3ZlcnBhc3MgPSByZXF1aXJlKCcuL292ZXJwYXNzJyk7XG52YXIgcHJvcHNEaWZmID0gcmVxdWlyZSgnLi9wcm9wc0RpZmYnKTtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuXG5mdW5jdGlvbiByZW5kZXIoaGFzaCwgb3B0aW9ucykge1xuICAgIHZhciBjaGFuZ2VzZXRJZCA9IGhhc2guc3BsaXQoJy8nKVswXS5yZXBsYWNlKCcjJywgJycpO1xuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvYWRpbmcnKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXIgfHwgJ21hcCc7XG4gICAgbWFwYm94Z2wuYWNjZXNzVG9rZW4gPSBjb25maWcubWFwYm94QWNjZXNzVG9rZW47XG5cbiAgICB2YXIgbWFwID0gbmV3IG1hcGJveGdsLk1hcCh7XG4gICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICBzdHlsZTogJ21hcGJveDovL3N0eWxlcy9wbGFuZW1hZC9jaWpjZWZwM3EwMGVsYnNrcTRjZ3ZjaXZmJyxcbiAgICAgICAgY2VudGVyOiBbMCwgMF0sXG4gICAgICAgIHpvb206IDNcbiAgICB9KTtcblxuICAgIG92ZXJwYXNzLnF1ZXJ5KGNoYW5nZXNldElkLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgaWYgKGVyci5tc2cpIHtcbiAgICAgICAgICAgICAgICBhbGVydChlcnIubXNnKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIuZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbGVydCgnQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cmVkJyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9hZGluZycpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsYXllclNlbGVjdG9yJykuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaGFuZ2VzZXQnKS50ZXh0ID0gY2hhbmdlc2V0SWQ7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd1c2VyJykudGV4dCA9IHJlc3VsdC5jaGFuZ2VzZXQudXNlcjtcbiAgICAgICAgdmFyIHRpbWUgPSByZXN1bHQuY2hhbmdlc2V0LnRvID8gcmVzdWx0LmNoYW5nZXNldC50byA6IHJlc3VsdC5jaGFuZ2VzZXQuZnJvbTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RpbWUnKS50ZXh0Q29udGVudCA9IG1vbWVudCh0aW1lKS5mb3JtYXQoJ01NTU0gRG8gWVlZWSwgaDptbSBhJyk7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd1c2VyJykuaHJlZiA9ICdodHRwczovL29wZW5zdHJlZXRtYXAub3JnL3VzZXIvJyArIHJlc3VsdC5jaGFuZ2VzZXQudXNlcjtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYW5nZXNldCcpLmhyZWYgPSAnaHR0cHM6Ly9vcGVuc3RyZWV0bWFwLm9yZy9jaGFuZ2VzZXQvJyArIGNoYW5nZXNldElkO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2lkZWJhcicpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB2YXIgYmJveCA9IHJlc3VsdC5jaGFuZ2VzZXQuYmJveDtcbiAgICAgICAgdmFyIGZlYXR1cmVNYXAgPSByZXN1bHQuZmVhdHVyZU1hcDtcbiAgICAgICAgbWFwLmFkZFNvdXJjZSgnY2hhbmdlc2V0Jywge1xuICAgICAgICAgICAgJ3R5cGUnOiAnZ2VvanNvbicsXG4gICAgICAgICAgICAnZGF0YSc6IHJlc3VsdC5nZW9qc29uXG4gICAgICAgIH0pO1xuICAgICAgICBtYXAuYWRkTGF5ZXIoe1xuICAgICAgICAgICAgJ2lkJzogJ2NoYW5nZXNldC1saW5lJyxcbiAgICAgICAgICAgICdzb3VyY2UnOiAnY2hhbmdlc2V0JyxcbiAgICAgICAgICAgICd0eXBlJzogJ2xpbmUnLFxuICAgICAgICAgICAgJ2xheW91dCc6IHtcbiAgICAgICAgICAgICAgICAnbGluZS1qb2luJzogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICAnbGluZS1jYXAnOiAncm91bmQnLFxuICAgICAgICAgICAgICAgICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3BhaW50Jzoge1xuICAgICAgICAgICAgICAgICdsaW5lLWNvbG9yJzogJyNmZmYnLFxuICAgICAgICAgICAgICAgICdsaW5lLXdpZHRoJzogM1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmaWx0ZXInOiBbXG4gICAgICAgICAgICAgICAgJz09JywgJ2lkJywgJydcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIG1hcC5hZGRMYXllcih7XG4gICAgICAgICAgICAnaWQnOiAnY2hhbmdlc2V0LXBvaW50JyxcbiAgICAgICAgICAgICdzb3VyY2UnOiAnY2hhbmdlc2V0JyxcbiAgICAgICAgICAgICd0eXBlJzogJ2NpcmNsZScsXG4gICAgICAgICAgICAnbGF5b3V0Jzoge1xuICAgICAgICAgICAgICAgICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3BhaW50Jzoge1xuICAgICAgICAgICAgICAgICdjaXJjbGUtcmFkaXVzJzogNCxcbiAgICAgICAgICAgICAgICAnY2lyY2xlLWNvbG9yJzogJyNmZmYnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZpbHRlcic6IFtcbiAgICAgICAgICAgICAgICAnPT0nLCAnaWQnLCAnJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgICAgbWFwLmFkZExheWVyKHtcbiAgICAgICAgICAgICdpZCc6ICdhZGRlZC1saW5lJyxcbiAgICAgICAgICAgICdzb3VyY2UnOiAnY2hhbmdlc2V0JyxcbiAgICAgICAgICAgICd0eXBlJzogJ2xpbmUnLFxuICAgICAgICAgICAgJ2ludGVyYWN0aXZlJzogdHJ1ZSxcbiAgICAgICAgICAgICdsYXlvdXQnOiB7XG4gICAgICAgICAgICAgICAgJ3Zpc2liaWxpdHknOiAndmlzaWJsZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncGFpbnQnOiB7XG4gICAgICAgICAgICAgICAgJ2xpbmUtY29sb3InOiAnIzg1OTkwMCcsXG4gICAgICAgICAgICAgICAgJ2xpbmUtd2lkdGgnOiAyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZpbHRlcic6IFtcbiAgICAgICAgICAgICAgICAnPT0nLCAnY2hhbmdlVHlwZScsICdhZGRlZCdcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIG1hcC5hZGRMYXllcih7XG4gICAgICAgICAgICAnaWQnOiAnYWRkZWQtcG9pbnQnLFxuICAgICAgICAgICAgJ3NvdXJjZSc6ICdjaGFuZ2VzZXQnLFxuICAgICAgICAgICAgJ3R5cGUnOiAnY2lyY2xlJyxcbiAgICAgICAgICAgICdpbnRlcmFjdGl2ZSc6IHRydWUsXG4gICAgICAgICAgICAnbGF5b3V0Jzoge1xuICAgICAgICAgICAgICAgICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3BhaW50Jzoge1xuICAgICAgICAgICAgICAgICdjaXJjbGUtY29sb3InOiAnIzg1OTkwMCcsXG4gICAgICAgICAgICAgICAgJ2NpcmNsZS1yYWRpdXMnOiAzLFxuICAgICAgICAgICAgICAgICdjaXJjbGUtYmx1cic6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmlsdGVyJzogW1xuICAgICAgICAgICAgICAgICc9PScsICdjaGFuZ2VUeXBlJywgJ2FkZGVkJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgICAgbWFwLmFkZExheWVyKHtcbiAgICAgICAgICAgICdpZCc6ICdtb2RpZmllZC1vbGQtbGluZScsXG4gICAgICAgICAgICAnc291cmNlJzogJ2NoYW5nZXNldCcsXG4gICAgICAgICAgICAndHlwZSc6ICdsaW5lJyxcbiAgICAgICAgICAgICdpbnRlcmFjdGl2ZSc6IHRydWUsXG4gICAgICAgICAgICAnbGF5b3V0Jzoge1xuICAgICAgICAgICAgICAgICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3BhaW50Jzoge1xuICAgICAgICAgICAgICAgICdsaW5lLWNvbG9yJzogJyNmZGY2ZTMnLFxuICAgICAgICAgICAgICAgICdsaW5lLXdpZHRoJzogMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmaWx0ZXInOiBbXG4gICAgICAgICAgICAgICAgJz09JywgJ2NoYW5nZVR5cGUnLCAnbW9kaWZpZWRPbGQnXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgICBtYXAuYWRkTGF5ZXIoe1xuICAgICAgICAgICAgJ2lkJzogJ21vZGlmaWVkLW9sZC1wb2ludCcsXG4gICAgICAgICAgICAnc291cmNlJzogJ2NoYW5nZXNldCcsXG4gICAgICAgICAgICAndHlwZSc6ICdjaXJjbGUnLFxuICAgICAgICAgICAgJ2ludGVyYWN0aXZlJzogdHJ1ZSxcbiAgICAgICAgICAgICdsYXlvdXQnOiB7XG4gICAgICAgICAgICAgICAgJ3Zpc2liaWxpdHknOiAndmlzaWJsZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncGFpbnQnOiB7XG4gICAgICAgICAgICAgICAgJ2NpcmNsZS1jb2xvcic6ICcjZmRmNmUzJyxcbiAgICAgICAgICAgICAgICAnY2lyY2xlLXJhZGl1cyc6IDMsXG4gICAgICAgICAgICAgICAgJ2NpcmNsZS1ibHVyJzogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmaWx0ZXInOiBbXG4gICAgICAgICAgICAgICAgJz09JywgJ2NoYW5nZVR5cGUnLCAnbW9kaWZpZWRPbGQnXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgICBtYXAuYWRkTGF5ZXIoe1xuICAgICAgICAgICAgJ2lkJzogJ21vZGlmaWVkLW5ldy1saW5lJyxcbiAgICAgICAgICAgICdzb3VyY2UnOiAnY2hhbmdlc2V0JyxcbiAgICAgICAgICAgICd0eXBlJzogJ2xpbmUnLFxuICAgICAgICAgICAgJ2ludGVyYWN0aXZlJzogdHJ1ZSxcbiAgICAgICAgICAgICdsYXlvdXQnOiB7XG4gICAgICAgICAgICAgICAgJ3Zpc2liaWxpdHknOiAndmlzaWJsZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncGFpbnQnOiB7XG4gICAgICAgICAgICAgICAgJ2xpbmUtY29sb3InOiAnI2I1ODkwMCcsXG4gICAgICAgICAgICAgICAgJ2xpbmUtd2lkdGgnOiAyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZpbHRlcic6IFtcbiAgICAgICAgICAgICAgICAnPT0nLCAnY2hhbmdlVHlwZScsICdtb2RpZmllZE5ldydcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIG1hcC5hZGRMYXllcih7XG4gICAgICAgICAgICAnaWQnOiAnbW9kaWZpZWQtbmV3LXBvaW50JyxcbiAgICAgICAgICAgICdzb3VyY2UnOiAnY2hhbmdlc2V0JyxcbiAgICAgICAgICAgICd0eXBlJzogJ2NpcmNsZScsXG4gICAgICAgICAgICAnaW50ZXJhY3RpdmUnOiB0cnVlLFxuICAgICAgICAgICAgJ2xheW91dCc6IHtcbiAgICAgICAgICAgICAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdwYWludCc6IHtcbiAgICAgICAgICAgICAgICAnY2lyY2xlLWNvbG9yJzogJyNiNTg5MDAnLFxuICAgICAgICAgICAgICAgICdjaXJjbGUtcmFkaXVzJzogMyxcbiAgICAgICAgICAgICAgICAnY2lyY2xlLWJsdXInOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZpbHRlcic6IFtcbiAgICAgICAgICAgICAgICAnPT0nLCAnY2hhbmdlVHlwZScsICdtb2RpZmllZE5ldydcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIG1hcC5hZGRMYXllcih7XG4gICAgICAgICAgICAnaWQnOiAnZGVsZXRlZC1saW5lJyxcbiAgICAgICAgICAgICdzb3VyY2UnOiAnY2hhbmdlc2V0JyxcbiAgICAgICAgICAgICd0eXBlJzogJ2xpbmUnLFxuICAgICAgICAgICAgJ2ludGVyYWN0aXZlJzogdHJ1ZSxcbiAgICAgICAgICAgICdsYXlvdXQnOiB7XG4gICAgICAgICAgICAgICAgJ3Zpc2liaWxpdHknOiAndmlzaWJsZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncGFpbnQnOiB7XG4gICAgICAgICAgICAgICAgJ2xpbmUtY29sb3InOiAnI2RjMzIyZicsXG4gICAgICAgICAgICAgICAgJ2xpbmUtd2lkdGgnOiAyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZpbHRlcic6IFtcbiAgICAgICAgICAgICAgICAnPT0nLCAnY2hhbmdlVHlwZScsICdkZWxldGVkJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgICAgbWFwLmFkZExheWVyKHtcbiAgICAgICAgICAgICdpZCc6ICdkZWxldGVkLXBvaW50JyxcbiAgICAgICAgICAgICdzb3VyY2UnOiAnY2hhbmdlc2V0JyxcbiAgICAgICAgICAgICd0eXBlJzogJ2NpcmNsZScsXG4gICAgICAgICAgICAnaW50ZXJhY3RpdmUnOiB0cnVlLFxuICAgICAgICAgICAgJ2xheW91dCc6IHtcbiAgICAgICAgICAgICAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdwYWludCc6IHtcbiAgICAgICAgICAgICAgICAnY2lyY2xlLWNvbG9yJzogJyNkYzMyMmYnLFxuICAgICAgICAgICAgICAgICdjaXJjbGUtcmFkaXVzJzogMyxcbiAgICAgICAgICAgICAgICAnY2lyY2xlLWJsdXInOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZpbHRlcic6IFtcbiAgICAgICAgICAgICAgICAnPT0nLCAnY2hhbmdlVHlwZScsICdkZWxldGVkJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcblxuICAgICAgICBtYXAub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB4MXkxID0gW2UucG9pbnQueCAtIDUsIGUucG9pbnQueSAtIDVdO1xuICAgICAgICAgICAgdmFyIHgyeTIgPSBbZS5wb2ludC54ICsgNSwgZS5wb2ludC55ICsgNV07XG4gICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBtYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKFt4MXkxLCB4MnkyXSwge1xuICAgICAgICAgICAgICAgICdsYXllcnMnOiBbXG4gICAgICAgICAgICAgICAgICAgICdhZGRlZC1saW5lJyxcbiAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLXBvaW50JyxcbiAgICAgICAgICAgICAgICAgICAgJ21vZGlmaWVkLW9sZC1saW5lJyxcbiAgICAgICAgICAgICAgICAgICAgJ21vZGlmaWVkLW9sZC1wb2ludCcsXG4gICAgICAgICAgICAgICAgICAgICdtb2RpZmllZC1uZXctbGluZScsXG4gICAgICAgICAgICAgICAgICAgICdtb2RpZmllZC1uZXctcG9pbnQnLFxuICAgICAgICAgICAgICAgICAgICAnZGVsZXRlZC1saW5lJyxcbiAgICAgICAgICAgICAgICAgICAgJ2RlbGV0ZWQtcG9pbnQnXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChmZWF0dXJlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RGZWF0dXJlKGZlYXR1cmVzWzBdLCBmZWF0dXJlTWFwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYXJGZWF0dXJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBib3VuZHMgPSBbXG4gICAgICAgICAgICBbYmJveC5sZWZ0LCBiYm94LnRvcF0sXG4gICAgICAgICAgICBbYmJveC5yaWdodCwgYmJveC5ib3R0b21dXG4gICAgICAgIF07XG4gICAgICAgIG1hcC5maXRCb3VuZHMoYm91bmRzKTtcblxuICAgICAgICB2YXIgbGF5ZXJzS2V5ID0ge1xuICAgICAgICAgICAgJ2FkZGVkJzogW1xuICAgICAgICAgICAgICAgICdhZGRlZC1saW5lJyxcbiAgICAgICAgICAgICAgICAnYWRkZWQtcG9pbnQnXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ21vZGlmaWVkJzogW1xuICAgICAgICAgICAgICAgICdtb2RpZmllZC1vbGQtbGluZScsXG4gICAgICAgICAgICAgICAgJ21vZGlmaWVkLW9sZC1wb2ludCcsXG4gICAgICAgICAgICAgICAgJ21vZGlmaWVkLW5ldy1saW5lJyxcbiAgICAgICAgICAgICAgICAnbW9kaWZpZWQtbmV3LXBvaW50J1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdkZWxldGVkJzogW1xuICAgICAgICAgICAgICAgICdkZWxldGVkLWxpbmUnLFxuICAgICAgICAgICAgICAgICdkZWxldGVkLXBvaW50J1xuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgICB2YXIgc2VsZWN0ZWRMYXllcnMgPSBbXG4gICAgICAgICAgICAnYWRkZWQtbGluZScsXG4gICAgICAgICAgICAnYWRkZWQtcG9pbnQnLFxuICAgICAgICAgICAgJ21vZGlmaWVkLW9sZC1saW5lJyxcbiAgICAgICAgICAgICdtb2RpZmllZC1vbGQtcG9pbnQnLFxuICAgICAgICAgICAgJ21vZGlmaWVkLW5ldy1saW5lJyxcbiAgICAgICAgICAgICdtb2RpZmllZC1uZXctcG9pbnQnLFxuICAgICAgICAgICAgJ2RlbGV0ZWQtbGluZScsXG4gICAgICAgICAgICAnZGVsZXRlZC1wb2ludCdcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIGxheWVyU2VsZWN0b3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGF5ZXJTZWxlY3RvcicpO1xuICAgICAgICBsYXllclNlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkTGF5ZXJzID0gc2VsZWN0ZWRMYXllcnMuY29uY2F0KGxheWVyc0tleVtrZXldKTtcbiAgICAgICAgICAgICAgICBsYXllcnNLZXlba2V5XS5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkobGF5ZXIsICd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRMYXllcnMgPSBzZWxlY3RlZExheWVycy5maWx0ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhKGxheWVyIGluIGxheWVyc0tleVtrZXldKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsYXllcnNLZXlba2V5XS5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkobGF5ZXIsICd2aXNpYmlsaXR5JywgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIFssIGdlb21ldHJ5VHlwZSwgZmVhdHVyZUlkXSA9IGhhc2guc3BsaXQoJy8nKTtcblxuICAgICAgICBpZiAoZ2VvbWV0cnlUeXBlICYmIGZlYXR1cmVJZCkge1xuICAgICAgICAgICAgc2VsZWN0RmVhdHVyZShmZWF0dXJlTWFwW2ZlYXR1cmVJZF1bMF0sIGZlYXR1cmVNYXApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBkaXNwbGF5RGlmZihpZCwgZmVhdHVyZU1hcCkge1xuICAgICAgICB2YXIgZmVhdHVyZXNXaXRoSWQgPSBmZWF0dXJlTWFwW2lkXTtcbiAgICAgICAgdmFyIHByb3BzQXJyYXkgPSBmZWF0dXJlc1dpdGhJZC5tYXAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIHJldHVybiBmLnByb3BlcnRpZXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBkaWZmID0gcHJvcHNEaWZmKHByb3BzQXJyYXkpO1xuICAgICAgICB2YXIgZGlmZkhUTUwgPSBnZXREaWZmSFRNTChkaWZmKTtcblxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlmZicpLmlubmVySFRNTCA9ICcnO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlmZicpLmFwcGVuZENoaWxkKGRpZmZIVE1MKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RpZmYnKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckRpZmYoKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaWZmJykuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaWZmJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREaWZmSFRNTChkaWZmKSB7XG4gICAgICAgIHZhciByb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFibGUnKTtcbiAgICAgICAgcm9vdC5jbGFzc0xpc3QuYWRkKCdkaWZmLXRhYmxlJyk7XG5cbiAgICAgICAgdmFyIHR5cGVzID0gWydhZGRlZCcsICd1bmNoYW5nZWQnLCAnZGVsZXRlZCcsICdtb2RpZmllZE9sZCcsICdtb2RpZmllZE5ldyddO1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGRpZmYpIHtcbiAgICAgICAgICAgIHZhciB0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG5cbiAgICAgICAgICAgIHZhciB0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJyk7XG4gICAgICAgICAgICB0aC50ZXh0Q29udGVudCA9IHByb3A7XG4gICAgICAgICAgICB0ci5hcHBlbmRDaGlsZCh0aCk7XG5cbiAgICAgICAgICAgIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlmZltwcm9wXS5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2FkZGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVtcHR5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcHR5LmNsYXNzTGlzdC5hZGQoJ2RpZmYtcHJvcGVydHknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcHR5LmNsYXNzTGlzdC5hZGQodHlwZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFwcGVuZENoaWxkKGVtcHR5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgICAgICAgICAgICAgIHRkLmNsYXNzTGlzdC5hZGQoJ2RpZmYtcHJvcGVydHknKTtcbiAgICAgICAgICAgICAgICAgICAgdGQuY2xhc3NMaXN0LmFkZCh0eXBlKTtcblxuICAgICAgICAgICAgICAgICAgICB0ZC50ZXh0Q29udGVudCA9IGRpZmZbcHJvcF1bdHlwZV07XG4gICAgICAgICAgICAgICAgICAgIHRyLmFwcGVuZENoaWxkKHRkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2RlbGV0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW1wdHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1wdHkuY2xhc3NMaXN0LmFkZCgnZGlmZi1wcm9wZXJ0eScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1wdHkuY2xhc3NMaXN0LmFkZCh0eXBlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuYXBwZW5kQ2hpbGQoZW1wdHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICd1bmNoYW5nZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQodHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb290O1xuICAgIH1cblxuICAgIC8vIGZ1bmN0aW9uIGFkZExheWVyIChuYW1lLCBpZCkge1xuICAgIC8vICAgICB2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAvLyAgICAgbGluay5ocmVmID0gJyMnO1xuICAgIC8vICAgICBsaW5rLmNsYXNzTmFtZSA9ICdhY3RpdmUnO1xuICAgIC8vICAgICBsaW5rLnRleHRDb250ZW50ID0gbmFtZTtcbiAgICAvL1xuICAgIC8vICAgICBsaW5rLm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgIC8vICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAvL1xuICAgIC8vICAgICAgICAgdmFyIHZpc2liaWxpdHkgPSBtYXAuZ2V0TGF5b3V0UHJvcGVydHkoaWQsICd2aXNpYmlsaXR5Jyk7XG4gICAgLy9cbiAgICAvLyAgICAgICAgIGlmICh2aXNpYmlsaXR5ID09PSAndmlzaWJsZScpIHtcbiAgICAvLyAgICAgICAgICAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkoaWQsICd2aXNpYmlsaXR5JywgJ25vbmUnKTtcbiAgICAvLyAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICcnO1xuICAgIC8vICAgICAgICAgfSBlbHNlIHtcbiAgICAvLyAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICdhY3RpdmUnO1xuICAgIC8vICAgICAgICAgICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShpZCwgJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICB9O1xuICAgIC8vXG4gICAgLy8gICAgIHZhciBsYXllcnMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWVudScpO1xuICAgIC8vICAgICBsYXllcnMuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgLy8gfVxuXG4gICAgZnVuY3Rpb24gaGlnaGxpZ2h0RmVhdHVyZShmZWF0dXJlSWQpIHtcbiAgICAgICAgbWFwLnNldEZpbHRlcignY2hhbmdlc2V0LWxpbmUnLCBbXG4gICAgICAgICAgICAnPT0nLCAnaWQnLCBmZWF0dXJlSWRcbiAgICAgICAgXSk7XG4gICAgICAgIG1hcC5zZXRGaWx0ZXIoJ2NoYW5nZXNldC1wb2ludCcsIFtcbiAgICAgICAgICAgICc9PScsICdpZCcsIGZlYXR1cmVJZFxuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckhpZ2hsaWdodCgpIHtcbiAgICAgICAgbWFwLnNldEZpbHRlcignY2hhbmdlc2V0LWxpbmUnLCBbXG4gICAgICAgICAgICAnPT0nLCAnaWQnLCAnJ1xuICAgICAgICBdKTtcbiAgICAgICAgbWFwLnNldEZpbHRlcignY2hhbmdlc2V0LXBvaW50JywgW1xuICAgICAgICAgICAgJz09JywgJ2lkJywgJydcbiAgICAgICAgXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlSGFzaChvc21UeXBlLCBmZWF0dXJlSWQpIHtcbiAgICAgICAgY2xlYXJIYXNoKCk7XG5cbiAgICAgICAgbG9jYXRpb24uaGFzaCArPSAnLycgKyBvc21UeXBlO1xuICAgICAgICBsb2NhdGlvbi5oYXNoICs9ICcvJyArIGZlYXR1cmVJZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckhhc2goKSB7XG4gICAgICAgIHZhciBjaGFuZ2VzZXRJZCA9IGxvY2F0aW9uLmhhc2hcbiAgICAgICAgICAuc3BsaXQoJy8nKVswXVxuICAgICAgICAgIC5yZXBsYWNlKCcjJywgJycpO1xuXG4gICAgICAgIGxvY2F0aW9uLmhhc2ggPSBjaGFuZ2VzZXRJZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZWxlY3RGZWF0dXJlKGZlYXR1cmUsIGZlYXR1cmVNYXApIHtcbiAgICAgICAgdmFyIGZlYXR1cmVJZCA9IGZlYXR1cmUucHJvcGVydGllcy5pZDtcbiAgICAgICAgdmFyIG9zbVR5cGUgPSBmZWF0dXJlLnByb3BlcnRpZXMudHlwZTtcblxuICAgICAgICBoaWdobGlnaHRGZWF0dXJlKGZlYXR1cmVJZCk7XG4gICAgICAgIGRpc3BsYXlEaWZmKGZlYXR1cmVJZCwgZmVhdHVyZU1hcCk7XG4gICAgICAgIHVwZGF0ZUhhc2gob3NtVHlwZSwgZmVhdHVyZUlkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckZlYXR1cmUoKSB7XG4gICAgICAgIGNsZWFySGlnaGxpZ2h0KCk7XG4gICAgICAgIGNsZWFyRGlmZigpO1xuICAgICAgICBjbGVhckhhc2goKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVuZGVyO1xuIiwiLy8gaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvVW5pdF9UZXN0aW5nLzEuMFxuLy9cbi8vIFRISVMgSVMgTk9UIFRFU1RFRCBOT1IgTElLRUxZIFRPIFdPUksgT1VUU0lERSBWOCFcbi8vXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHdoZW4gdXNlZCBpbiBub2RlLCB0aGlzIHdpbGwgYWN0dWFsbHkgbG9hZCB0aGUgdXRpbCBtb2R1bGUgd2UgZGVwZW5kIG9uXG4vLyB2ZXJzdXMgbG9hZGluZyB0aGUgYnVpbHRpbiB1dGlsIG1vZHVsZSBhcyBoYXBwZW5zIG90aGVyd2lzZVxuLy8gdGhpcyBpcyBhIGJ1ZyBpbiBub2RlIG1vZHVsZSBsb2FkaW5nIGFzIGZhciBhcyBJIGFtIGNvbmNlcm5lZFxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xuXG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8vIDEuIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcblxuLy8gMi4gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gYXNzZXJ0LlxuLy8gbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7IG1lc3NhZ2U6IG1lc3NhZ2UsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkIH0pXG5cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE1lc3NhZ2UodGhpcyk7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuICB2YXIgc3RhY2tTdGFydEZ1bmN0aW9uID0gb3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb24gfHwgZmFpbDtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIG5vbiB2OCBicm93c2VycyBzbyB3ZSBjYW4gaGF2ZSBhIHN0YWNrdHJhY2VcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgdmFyIG91dCA9IGVyci5zdGFjaztcblxuICAgICAgLy8gdHJ5IHRvIHN0cmlwIHVzZWxlc3MgZnJhbWVzXG4gICAgICB2YXIgZm5fbmFtZSA9IHN0YWNrU3RhcnRGdW5jdGlvbi5uYW1lO1xuICAgICAgdmFyIGlkeCA9IG91dC5pbmRleE9mKCdcXG4nICsgZm5fbmFtZSk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgLy8gb25jZSB3ZSBoYXZlIGxvY2F0ZWQgdGhlIGZ1bmN0aW9uIGZyYW1lXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc3RyaXAgb3V0IGV2ZXJ5dGhpbmcgYmVmb3JlIGl0IChhbmQgaXRzIGxpbmUpXG4gICAgICAgIHZhciBuZXh0X2xpbmUgPSBvdXQuaW5kZXhPZignXFxuJywgaWR4ICsgMSk7XG4gICAgICAgIG91dCA9IG91dC5zdWJzdHJpbmcobmV4dF9saW5lICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhY2sgPSBvdXQ7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxudXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICBpZiAodXRpbC5pc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgfVxuICBpZiAodXRpbC5pc051bWJlcih2YWx1ZSkgJiYgIWlzRmluaXRlKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIGlmICh1dGlsLmlzRnVuY3Rpb24odmFsdWUpIHx8IHV0aWwuaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHMpKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoIDwgbiA/IHMgOiBzLnNsaWNlKDAsIG4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2VsZikge1xuICByZXR1cm4gdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoc2VsZi5hY3R1YWwsIHJlcGxhY2VyKSwgMTI4KSArICcgJyArXG4gICAgICAgICBzZWxmLm9wZXJhdG9yICsgJyAnICtcbiAgICAgICAgIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHNlbGYuZXhwZWN0ZWQsIHJlcGxhY2VyKSwgMTI4KTtcbn1cblxuLy8gQXQgcHJlc2VudCBvbmx5IHRoZSB0aHJlZSBrZXlzIG1lbnRpb25lZCBhYm92ZSBhcmUgdXNlZCBhbmRcbi8vIHVuZGVyc3Rvb2QgYnkgdGhlIHNwZWMuIEltcGxlbWVudGF0aW9ucyBvciBzdWIgbW9kdWxlcyBjYW4gcGFzc1xuLy8gb3RoZXIga2V5cyB0byB0aGUgQXNzZXJ0aW9uRXJyb3IncyBjb25zdHJ1Y3RvciAtIHRoZXkgd2lsbCBiZVxuLy8gaWdub3JlZC5cblxuLy8gMy4gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZ1bmN0aW9uKSB7XG4gIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHN0YWNrU3RhcnRGdW5jdGlvblxuICB9KTtcbn1cblxuLy8gRVhURU5TSU9OISBhbGxvd3MgZm9yIHdlbGwgYmVoYXZlZCBlcnJvcnMgZGVmaW5lZCBlbHNld2hlcmUuXG5hc3NlcnQuZmFpbCA9IGZhaWw7XG5cbi8vIDQuIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhZ3VhcmQuXG4vLyBhc3NlcnQub2soZ3VhcmQsIG1lc3NhZ2Vfb3B0KTtcbi8vIFRoaXMgc3RhdGVtZW50IGlzIGVxdWl2YWxlbnQgdG8gYXNzZXJ0LmVxdWFsKHRydWUsICEhZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5vayk7XG59XG5hc3NlcnQub2sgPSBvaztcblxuLy8gNS4gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoXG4vLyA9PS5cbi8vIGFzc2VydC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQuZXF1YWwpO1xufTtcblxuLy8gNi4gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdCBlcXVhbFxuLy8gd2l0aCAhPSBhc3NlcnQubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPScsIGFzc2VydC5ub3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDcuIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuLy8gYXNzZXJ0LmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwRXF1YWwnLCBhc3NlcnQuZGVlcEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0J1ZmZlcihhY3R1YWwpICYmIHV0aWwuaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgaWYgKGFjdHVhbC5sZW5ndGggIT0gZXhwZWN0ZWQubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdHVhbC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFjdHVhbFtpXSAhPT0gZXhwZWN0ZWRbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0RhdGUoYWN0dWFsKSAmJiB1dGlsLmlzRGF0ZShleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMyBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIFJlZ0V4cCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzb3VyY2UgYW5kXG4gIC8vIHByb3BlcnRpZXMgKGBnbG9iYWxgLCBgbXVsdGlsaW5lYCwgYGxhc3RJbmRleGAsIGBpZ25vcmVDYXNlYCkuXG4gIH0gZWxzZSBpZiAodXRpbC5pc1JlZ0V4cChhY3R1YWwpICYmIHV0aWwuaXNSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5zb3VyY2UgPT09IGV4cGVjdGVkLnNvdXJjZSAmJlxuICAgICAgICAgICBhY3R1YWwuZ2xvYmFsID09PSBleHBlY3RlZC5nbG9iYWwgJiZcbiAgICAgICAgICAgYWN0dWFsLm11bHRpbGluZSA9PT0gZXhwZWN0ZWQubXVsdGlsaW5lICYmXG4gICAgICAgICAgIGFjdHVhbC5sYXN0SW5kZXggPT09IGV4cGVjdGVkLmxhc3RJbmRleCAmJlxuICAgICAgICAgICBhY3R1YWwuaWdub3JlQ2FzZSA9PT0gZXhwZWN0ZWQuaWdub3JlQ2FzZTtcblxuICAvLyA3LjQuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNPYmplY3QoYWN0dWFsKSAmJiAhdXRpbC5pc09iamVjdChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNSBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIpIHtcbiAgaWYgKHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoYSkgfHwgdXRpbC5pc051bGxPclVuZGVmaW5lZChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvLyBpZiBvbmUgaXMgYSBwcmltaXRpdmUsIHRoZSBvdGhlciBtdXN0IGJlIHNhbWVcbiAgaWYgKHV0aWwuaXNQcmltaXRpdmUoYSkgfHwgdXRpbC5pc1ByaW1pdGl2ZShiKSkge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9XG4gIHZhciBhSXNBcmdzID0gaXNBcmd1bWVudHMoYSksXG4gICAgICBiSXNBcmdzID0gaXNBcmd1bWVudHMoYik7XG4gIGlmICgoYUlzQXJncyAmJiAhYklzQXJncykgfHwgKCFhSXNBcmdzICYmIGJJc0FyZ3MpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGFJc0FyZ3MpIHtcbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIpO1xuICB9XG4gIHZhciBrYSA9IG9iamVjdEtleXMoYSksXG4gICAgICBrYiA9IG9iamVjdEtleXMoYiksXG4gICAgICBrZXksIGk7XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV4cGVjdGVkKSA9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csIGJsb2NrLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsO1xuXG4gIGlmICh1dGlsLmlzU3RyaW5nKGV4cGVjdGVkKSkge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBhY3R1YWwgPSBlO1xuICB9XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoIXNob3VsZFRocm93ICYmIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFt0cnVlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cy5hcHBseSh0aGlzLCBbZmFsc2VdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB7dGhyb3cgZXJyO319O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPVxuICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xudmFyIHNwbGl0UGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbn07XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGgocGF0aClbM107XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmZWF0dXJlRmlsdGVyID0gcmVxdWlyZSgnZmVhdHVyZS1maWx0ZXInKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlcicpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBTdHJ1Y3RBcnJheVR5cGUgPSByZXF1aXJlKCcuLi91dGlsL3N0cnVjdF9hcnJheScpO1xudmFyIFZlcnRleEFycmF5T2JqZWN0ID0gcmVxdWlyZSgnLi4vcmVuZGVyL3ZlcnRleF9hcnJheV9vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWNrZXQ7XG5cbi8qKlxuICogSW5zdGFudGlhdGUgdGhlIGFwcHJvcHJpYXRlIHN1YmNsYXNzIG9mIGBCdWNrZXRgIGZvciBgb3B0aW9uc2AuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIG9wdGlvbnMgU2VlIGBCdWNrZXRgIGNvbnN0cnVjdG9yIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtCdWNrZXR9XG4gKi9cbkJ1Y2tldC5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIENsYXNzZXMgPSB7XG4gICAgICAgIGZpbGw6IHJlcXVpcmUoJy4vYnVja2V0L2ZpbGxfYnVja2V0JyksXG4gICAgICAgIGxpbmU6IHJlcXVpcmUoJy4vYnVja2V0L2xpbmVfYnVja2V0JyksXG4gICAgICAgIGNpcmNsZTogcmVxdWlyZSgnLi9idWNrZXQvY2lyY2xlX2J1Y2tldCcpLFxuICAgICAgICBzeW1ib2w6IHJlcXVpcmUoJy4vYnVja2V0L3N5bWJvbF9idWNrZXQnKVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBDbGFzc2VzW29wdGlvbnMubGF5ZXIudHlwZV0ob3B0aW9ucyk7XG59O1xuXG5cbi8qKlxuICogVGhlIG1heGltdW0gZXh0ZW50IG9mIGEgZmVhdHVyZSB0aGF0IGNhbiBiZSBzYWZlbHkgc3RvcmVkIGluIHRoZSBidWZmZXIuXG4gKiBJbiBwcmFjdGljZSwgYWxsIGZlYXR1cmVzIGFyZSBjb252ZXJ0ZWQgdG8gdGhpcyBleHRlbnQgYmVmb3JlIGJlaW5nIGFkZGVkLlxuICpcbiAqIFBvc2l0aW9ucyBhcmUgc3RvcmVkIGFzIHNpZ25lZCAxNmJpdCBpbnRlZ2Vycy5cbiAqIE9uZSBiaXQgaXMgbG9zdCBmb3Igc2lnbmVkbmVzcyB0byBzdXBwb3J0IGZlYXR1ZXJzIGV4dGVuZGluZyBwYXN0IHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHRpbGUuXG4gKiBPbmUgYml0IGlzIGxvc3QgYmVjYXVzZSB0aGUgbGluZSB2ZXJ0ZXggYnVmZmVyIHBhY2tzIDEgYml0IG9mIG90aGVyIGRhdGEgaW50byB0aGUgaW50LlxuICogT25lIGJpdCBpcyBsb3N0IHRvIHN1cHBvcnQgZmVhdHVyZXMgZXh0ZW5kaW5nIHBhc3QgdGhlIGV4dGVudCBvbiB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgdGlsZS5cbiAqIFRoaXMgbGVhdmVzIHVzIHdpdGggMl4xMyA9IDgxOTJcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJlYWRvbmx5XG4gKi9cbkJ1Y2tldC5FWFRFTlQgPSA4MTkyO1xuXG4vKipcbiAqIFRoZSBgQnVja2V0YCBjbGFzcyBpcyB0aGUgc2luZ2xlIHBvaW50IG9mIGtub3dsZWRnZSBhYm91dCB0dXJuaW5nIHZlY3RvclxuICogdGlsZXMgaW50byBXZWJHTCBidWZmZXJzLlxuICpcbiAqIGBCdWNrZXRgIGlzIGFuIGFic3RyYWN0IGNsYXNzLiBBIHN1YmNsYXNzIGV4aXN0cyBmb3IgZWFjaCBNYXBib3ggR0xcbiAqIHN0eWxlIHNwZWMgbGF5ZXIgdHlwZS4gQmVjYXVzZSBgQnVja2V0YCBpcyBhbiBhYnN0cmFjdCBjbGFzcyxcbiAqIGluc3RhbmNlcyBzaG91bGQgYmUgY3JlYXRlZCB2aWEgdGhlIGBCdWNrZXQuY3JlYXRlYCBtZXRob2QuXG4gKlxuICogQGNsYXNzIEJ1Y2tldFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy56b29tIFpvb20gbGV2ZWwgb2YgdGhlIGJ1ZmZlcnMgYmVpbmcgYnVpbHQuIE1heSBiZVxuICogICAgIGEgZnJhY3Rpb25hbCB6b29tIGxldmVsLlxuICogQHBhcmFtIG9wdGlvbnMubGF5ZXIgQSBNYXBib3ggR0wgc3R5bGUgbGF5ZXIgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBCdWZmZXI+fSBvcHRpb25zLmJ1ZmZlcnMgVGhlIHNldCBvZiBgQnVmZmVyYHMgYmVpbmdcbiAqICAgICBidWlsdCBmb3IgdGhpcyB0aWxlLiBUaGlzIG9iamVjdCBmYWNpbGl0YXRlcyBzaGFyaW5nIG9mIGBCdWZmZXJgcyBiZVxuICAgICAgIGJldHdlZW4gYEJ1Y2tldGBzLlxuICovXG5mdW5jdGlvbiBCdWNrZXQob3B0aW9ucykge1xuICAgIHRoaXMuem9vbSA9IG9wdGlvbnMuem9vbTtcbiAgICB0aGlzLm92ZXJzY2FsaW5nID0gb3B0aW9ucy5vdmVyc2NhbGluZztcbiAgICB0aGlzLmxheWVyID0gb3B0aW9ucy5sYXllcjtcbiAgICB0aGlzLmNoaWxkTGF5ZXJzID0gb3B0aW9ucy5jaGlsZExheWVycztcblxuICAgIHRoaXMudHlwZSA9IHRoaXMubGF5ZXIudHlwZTtcbiAgICB0aGlzLmZlYXR1cmVzID0gW107XG4gICAgdGhpcy5pZCA9IHRoaXMubGF5ZXIuaWQ7XG4gICAgdGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG4gICAgdGhpcy5zb3VyY2VMYXllciA9IHRoaXMubGF5ZXIuc291cmNlTGF5ZXI7XG4gICAgdGhpcy5zb3VyY2VMYXllckluZGV4ID0gb3B0aW9ucy5zb3VyY2VMYXllckluZGV4O1xuICAgIHRoaXMubWluWm9vbSA9IHRoaXMubGF5ZXIubWluem9vbTtcbiAgICB0aGlzLm1heFpvb20gPSB0aGlzLmxheWVyLm1heHpvb207XG5cbiAgICB0aGlzLnBhaW50QXR0cmlidXRlcyA9IGNyZWF0ZVBhaW50QXR0cmlidXRlcyh0aGlzKTtcblxuICAgIGlmIChvcHRpb25zLmFycmF5cykge1xuICAgICAgICB2YXIgY2hpbGRMYXllcnMgPSB0aGlzLmNoaWxkTGF5ZXJzO1xuICAgICAgICB0aGlzLmJ1ZmZlckdyb3VwcyA9IHV0aWwubWFwT2JqZWN0KG9wdGlvbnMuYXJyYXlzLCBmdW5jdGlvbihwcm9ncmFtQXJyYXlHcm91cHMsIHByb2dyYW1OYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvZ3JhbUFycmF5R3JvdXBzLm1hcChmdW5jdGlvbihwcm9ncmFtQXJyYXlHcm91cCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gdXRpbC5tYXBPYmplY3QocHJvZ3JhbUFycmF5R3JvdXAsIGZ1bmN0aW9uKGFycmF5cywgbGF5b3V0T3JQYWludCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5tYXBPYmplY3QoYXJyYXlzLCBmdW5jdGlvbihhcnJheSwgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5VHlwZSA9IG9wdGlvbnMuYXJyYXlUeXBlc1twcm9ncmFtTmFtZV1bbGF5b3V0T3JQYWludF1bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IChhcnJheVR5cGUubWVtYmVycy5sZW5ndGggJiYgYXJyYXlUeXBlLm1lbWJlcnNbMF0ubmFtZSA9PT0gJ3ZlcnRpY2VzJyA/IEJ1ZmZlci5CdWZmZXJUeXBlLkVMRU1FTlQgOiBCdWZmZXIuQnVmZmVyVHlwZS5WRVJURVgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJyYXksIGFycmF5VHlwZSwgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZ3JvdXAudmFvcyA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChncm91cC5sYXlvdXQuZWxlbWVudDIpIGdyb3VwLnNlY29uZFZhb3MgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGNoaWxkTGF5ZXJzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXllck5hbWUgPSBjaGlsZExheWVyc1tsXS5pZDtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAudmFvc1tsYXllck5hbWVdID0gbmV3IFZlcnRleEFycmF5T2JqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91cC5sYXlvdXQuZWxlbWVudDIpIGdyb3VwLnNlY29uZFZhb3NbbGF5ZXJOYW1lXSA9IG5ldyBWZXJ0ZXhBcnJheU9iamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBncm91cDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQnVpbGQgdGhlIGJ1ZmZlcnMhIEZlYXR1cmVzIGFyZSBzZXQgZGlyZWN0bHkgdG8gdGhlIGBmZWF0dXJlc2AgcHJvcGVydHkuXG4gKiBAcHJpdmF0ZVxuICovXG5CdWNrZXQucHJvdG90eXBlLnBvcHVsYXRlQnVmZmVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY3JlYXRlQXJyYXlzKCk7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZVN0eWxlTGF5ZXJzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGRGZWF0dXJlKHRoaXMuZmVhdHVyZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMudHJpbUFycmF5cygpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGVyZSBpcyBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGVsZW1lbnQgZ3JvdXAgZm9yXG4gKiBgdmVydGV4TGVuZ3RoYCB2ZXJ0aWNlcy4gSWYgbm90LCBhcHBlbmQgYSBuZXcgZWxlbWVudEdyb3VwLiBTaG91bGQgYmUgY2FsbGVkXG4gKiBieSBgcG9wdWxhdGVCdWZmZXJzYCBhbmQgaXRzIGNhbGxlZXMuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb2dyYW1OYW1lIHRoZSBuYW1lIG9mIHRoZSBwcm9ncmFtIGFzc29jaWF0ZWQgd2l0aCB0aGUgYnVmZmVyIHRoYXQgd2lsbCByZWNlaXZlIHRoZSB2ZXJ0aWNlc1xuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRleExlbmd0aCBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIHRoYXQgd2lsbCBiZSBpbnNlcnRlZCB0byB0aGUgYnVmZmVyLlxuICovXG5CdWNrZXQucHJvdG90eXBlLm1ha2VSb29tRm9yID0gZnVuY3Rpb24ocHJvZ3JhbU5hbWUsIG51bVZlcnRpY2VzKSB7XG4gICAgdmFyIGdyb3VwcyA9IHRoaXMuYXJyYXlHcm91cHNbcHJvZ3JhbU5hbWVdO1xuICAgIHZhciBjdXJyZW50R3JvdXAgPSBncm91cHMubGVuZ3RoICYmIGdyb3Vwc1tncm91cHMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoIWN1cnJlbnRHcm91cCB8fCBjdXJyZW50R3JvdXAubGF5b3V0LnZlcnRleC5sZW5ndGggKyBudW1WZXJ0aWNlcyA+IDY1NTM1KSB7XG5cbiAgICAgICAgdmFyIGFycmF5VHlwZXMgPSB0aGlzLmFycmF5VHlwZXNbcHJvZ3JhbU5hbWVdO1xuICAgICAgICB2YXIgVmVydGV4QXJyYXlUeXBlID0gYXJyYXlUeXBlcy5sYXlvdXQudmVydGV4O1xuICAgICAgICB2YXIgRWxlbWVudEFycmF5VHlwZSA9IGFycmF5VHlwZXMubGF5b3V0LmVsZW1lbnQ7XG4gICAgICAgIHZhciBFbGVtZW50QXJyYXlUeXBlMiA9IGFycmF5VHlwZXMubGF5b3V0LmVsZW1lbnQyO1xuXG4gICAgICAgIGN1cnJlbnRHcm91cCA9IHtcbiAgICAgICAgICAgIGluZGV4OiBncm91cHMubGVuZ3RoLFxuICAgICAgICAgICAgbGF5b3V0OiB7fSxcbiAgICAgICAgICAgIHBhaW50OiB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIGN1cnJlbnRHcm91cC5sYXlvdXQudmVydGV4ID0gbmV3IFZlcnRleEFycmF5VHlwZSgpO1xuICAgICAgICBpZiAoRWxlbWVudEFycmF5VHlwZSkgY3VycmVudEdyb3VwLmxheW91dC5lbGVtZW50ID0gbmV3IEVsZW1lbnRBcnJheVR5cGUoKTtcbiAgICAgICAgaWYgKEVsZW1lbnRBcnJheVR5cGUyKSBjdXJyZW50R3JvdXAubGF5b3V0LmVsZW1lbnQyID0gbmV3IEVsZW1lbnRBcnJheVR5cGUyKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXJOYW1lID0gdGhpcy5jaGlsZExheWVyc1tpXS5pZDtcbiAgICAgICAgICAgIHZhciBQYWludFZlcnRleEFycmF5VHlwZSA9IGFycmF5VHlwZXMucGFpbnRbbGF5ZXJOYW1lXTtcbiAgICAgICAgICAgIGN1cnJlbnRHcm91cC5wYWludFtsYXllck5hbWVdID0gbmV3IFBhaW50VmVydGV4QXJyYXlUeXBlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBncm91cHMucHVzaChjdXJyZW50R3JvdXApO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50R3JvdXA7XG59O1xuXG4vKipcbiAqIFN0YXJ0IHVzaW5nIGEgbmV3IHNoYXJlZCBgYnVmZmVyc2Agb2JqZWN0IGFuZCByZWNyZWF0ZSBpbnN0YW5jZXMgb2YgYEJ1ZmZlcmBcbiAqIGFzIG5lY2Vzc2FyeS5cbiAqIEBwcml2YXRlXG4gKi9cbkJ1Y2tldC5wcm90b3R5cGUuY3JlYXRlQXJyYXlzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hcnJheUdyb3VwcyA9IHt9O1xuICAgIHRoaXMuYXJyYXlUeXBlcyA9IHt9O1xuXG4gICAgZm9yICh2YXIgcHJvZ3JhbU5hbWUgaW4gdGhpcy5wcm9ncmFtSW50ZXJmYWNlcykge1xuICAgICAgICB2YXIgcHJvZ3JhbUludGVyZmFjZSA9IHRoaXMucHJvZ3JhbUludGVyZmFjZXNbcHJvZ3JhbU5hbWVdO1xuICAgICAgICB2YXIgcHJvZ3JhbUFycmF5VHlwZXMgPSB0aGlzLmFycmF5VHlwZXNbcHJvZ3JhbU5hbWVdID0geyBsYXlvdXQ6IHt9LCBwYWludDoge30gfTtcbiAgICAgICAgdGhpcy5hcnJheUdyb3Vwc1twcm9ncmFtTmFtZV0gPSBbXTtcblxuICAgICAgICBpZiAocHJvZ3JhbUludGVyZmFjZS52ZXJ0ZXhCdWZmZXIpIHtcbiAgICAgICAgICAgIHZhciBWZXJ0ZXhBcnJheVR5cGUgPSBuZXcgU3RydWN0QXJyYXlUeXBlKHtcbiAgICAgICAgICAgICAgICBtZW1iZXJzOiB0aGlzLnByb2dyYW1JbnRlcmZhY2VzW3Byb2dyYW1OYW1lXS5sYXlvdXRBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIGFsaWdubWVudDogQnVmZmVyLlZFUlRFWF9BVFRSSUJVVEVfQUxJR05NRU5UXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHJvZ3JhbUFycmF5VHlwZXMubGF5b3V0LnZlcnRleCA9IFZlcnRleEFycmF5VHlwZTtcblxuICAgICAgICAgICAgdmFyIGxheWVyUGFpbnRBdHRyaWJ1dGVzID0gdGhpcy5wYWludEF0dHJpYnV0ZXNbcHJvZ3JhbU5hbWVdO1xuICAgICAgICAgICAgZm9yICh2YXIgbGF5ZXJOYW1lIGluIGxheWVyUGFpbnRBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIFBhaW50VmVydGV4QXJyYXlUeXBlID0gbmV3IFN0cnVjdEFycmF5VHlwZSh7XG4gICAgICAgICAgICAgICAgICAgIG1lbWJlcnM6IGxheWVyUGFpbnRBdHRyaWJ1dGVzW2xheWVyTmFtZV0uYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50OiBCdWZmZXIuVkVSVEVYX0FUVFJJQlVURV9BTElHTk1FTlRcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHByb2dyYW1BcnJheVR5cGVzLnBhaW50W2xheWVyTmFtZV0gPSBQYWludFZlcnRleEFycmF5VHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9ncmFtSW50ZXJmYWNlLmVsZW1lbnRCdWZmZXIpIHtcbiAgICAgICAgICAgIHZhciBFbGVtZW50QXJyYXlUeXBlID0gY3JlYXRlRWxlbWVudEJ1ZmZlclR5cGUocHJvZ3JhbUludGVyZmFjZS5lbGVtZW50QnVmZmVyQ29tcG9uZW50cyk7XG4gICAgICAgICAgICBwcm9ncmFtQXJyYXlUeXBlcy5sYXlvdXQuZWxlbWVudCA9IEVsZW1lbnRBcnJheVR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvZ3JhbUludGVyZmFjZS5lbGVtZW50QnVmZmVyMikge1xuICAgICAgICAgICAgdmFyIEVsZW1lbnRBcnJheVR5cGUyID0gY3JlYXRlRWxlbWVudEJ1ZmZlclR5cGUocHJvZ3JhbUludGVyZmFjZS5lbGVtZW50QnVmZmVyMkNvbXBvbmVudHMpO1xuICAgICAgICAgICAgcHJvZ3JhbUFycmF5VHlwZXMubGF5b3V0LmVsZW1lbnQyID0gRWxlbWVudEFycmF5VHlwZTI7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5CdWNrZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihnbCkge1xuICAgIGZvciAodmFyIHByb2dyYW1OYW1lIGluIHRoaXMuYnVmZmVyR3JvdXBzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtQnVmZmVyR3JvdXBzID0gdGhpcy5idWZmZXJHcm91cHNbcHJvZ3JhbU5hbWVdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb2dyYW1CdWZmZXJHcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcm9ncmFtQnVmZmVycyA9IHByb2dyYW1CdWZmZXJHcm91cHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwYWludEJ1ZmZlciBpbiBwcm9ncmFtQnVmZmVycy5wYWludCkge1xuICAgICAgICAgICAgICAgIHByb2dyYW1CdWZmZXJzLnBhaW50W3BhaW50QnVmZmVyXS5kZXN0cm95KGdsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGxheW91dEJ1ZmZlciBpbiBwcm9ncmFtQnVmZmVycy5sYXlvdXQpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmFtQnVmZmVycy5sYXlvdXRbbGF5b3V0QnVmZmVyXS5kZXN0cm95KGdsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogaW4gcHJvZ3JhbUJ1ZmZlcnMudmFvcykge1xuICAgICAgICAgICAgICAgIHByb2dyYW1CdWZmZXJzLnZhb3Nbal0uZGVzdHJveShnbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIHByb2dyYW1CdWZmZXJzLnNlY29uZFZhb3MpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmFtQnVmZmVycy5zZWNvbmRWYW9zW2tdLmRlc3Ryb3koZ2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG5CdWNrZXQucHJvdG90eXBlLnRyaW1BcnJheXMgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBwcm9ncmFtTmFtZSBpbiB0aGlzLmFycmF5R3JvdXBzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtQXJyYXlzID0gdGhpcy5hcnJheUdyb3Vwc1twcm9ncmFtTmFtZV07XG4gICAgICAgIGZvciAodmFyIHBhaW50QXJyYXkgaW4gcHJvZ3JhbUFycmF5cy5wYWludCkge1xuICAgICAgICAgICAgcHJvZ3JhbUFycmF5cy5wYWludFtwYWludEFycmF5XS50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgbGF5b3V0QXJyYXkgaW4gcHJvZ3JhbUFycmF5cy5sYXlvdXQpIHtcbiAgICAgICAgICAgIHByb2dyYW1BcnJheXMubGF5b3V0W2xheW91dEFycmF5XS50cmltKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5CdWNrZXQucHJvdG90eXBlLnNldFVuaWZvcm1zID0gZnVuY3Rpb24oZ2wsIHByb2dyYW1OYW1lLCBwcm9ncmFtLCBsYXllciwgZ2xvYmFsUHJvcGVydGllcykge1xuICAgIHZhciB1bmlmb3JtcyA9IHRoaXMucGFpbnRBdHRyaWJ1dGVzW3Byb2dyYW1OYW1lXVtsYXllci5pZF0udW5pZm9ybXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmlmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdW5pZm9ybSA9IHVuaWZvcm1zW2ldO1xuICAgICAgICB2YXIgdW5pZm9ybUxvY2F0aW9uID0gcHJvZ3JhbVt1bmlmb3JtLm5hbWVdO1xuICAgICAgICBnbFsndW5pZm9ybScgKyB1bmlmb3JtLmNvbXBvbmVudHMgKyAnZnYnXSh1bmlmb3JtTG9jYXRpb24sIHVuaWZvcm0uZ2V0VmFsdWUobGF5ZXIsIGdsb2JhbFByb3BlcnRpZXMpKTtcbiAgICB9XG59O1xuXG5CdWNrZXQucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxheWVySWQ6IHRoaXMubGF5ZXIuaWQsXG4gICAgICAgIHpvb206IHRoaXMuem9vbSxcbiAgICAgICAgYXJyYXlzOiB1dGlsLm1hcE9iamVjdCh0aGlzLmFycmF5R3JvdXBzLCBmdW5jdGlvbihwcm9ncmFtQXJyYXlHcm91cHMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9ncmFtQXJyYXlHcm91cHMubWFwKGZ1bmN0aW9uKGFycmF5R3JvdXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5tYXBPYmplY3QoYXJyYXlHcm91cCwgZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLm1hcE9iamVjdChhcnJheXMsIGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXkuc2VyaWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLFxuICAgICAgICBhcnJheVR5cGVzOiB1dGlsLm1hcE9iamVjdCh0aGlzLmFycmF5VHlwZXMsIGZ1bmN0aW9uKHByb2dyYW1BcnJheVR5cGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbC5tYXBPYmplY3QocHJvZ3JhbUFycmF5VHlwZXMsIGZ1bmN0aW9uKGFycmF5VHlwZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5tYXBPYmplY3QoYXJyYXlUeXBlcywgZnVuY3Rpb24oYXJyYXlUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVR5cGUuc2VyaWFsaXplKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSksXG5cbiAgICAgICAgY2hpbGRMYXllcklkczogdGhpcy5jaGlsZExheWVycy5tYXAoZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXllci5pZDtcbiAgICAgICAgfSlcbiAgICB9O1xufTtcblxuQnVja2V0LnByb3RvdHlwZS5jcmVhdGVGaWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gZmVhdHVyZUZpbHRlcih0aGlzLmxheWVyLmZpbHRlcik7XG4gICAgfVxufTtcblxudmFyIEZBS0VfWk9PTV9ISVNUT1JZID0geyBsYXN0SW50ZWdlclpvb206IEluZmluaXR5LCBsYXN0SW50ZWdlclpvb21UaW1lOiAwLCBsYXN0Wm9vbTogMCB9O1xuQnVja2V0LnByb3RvdHlwZS5yZWNhbGN1bGF0ZVN0eWxlTGF5ZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuY2hpbGRMYXllcnNbaV0ucmVjYWxjdWxhdGUodGhpcy56b29tLCBGQUtFX1pPT01fSElTVE9SWSk7XG4gICAgfVxufTtcblxuQnVja2V0LnByb3RvdHlwZS5nZXRQcm9ncmFtTWFjcm9zID0gZnVuY3Rpb24ocHJvZ3JhbUludGVyZmFjZSwgbGF5ZXIpIHtcbiAgICB2YXIgbWFjcm9zID0gW107XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLnBhaW50QXR0cmlidXRlc1twcm9ncmFtSW50ZXJmYWNlXVtsYXllci5pZF0uYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaV07XG4gICAgICAgIG1hY3Jvcy5wdXNoKCdBVFRSSUJVVEVfJyArIChhdHRyaWJ1dGUuaXNGdW5jdGlvbiA/ICdaT09NX0ZVTkNUSU9OXycgOiAnJykgKyBhdHRyaWJ1dGUubmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hY3Jvcztcbn07XG5cbkJ1Y2tldC5wcm90b3R5cGUuYWRkUGFpbnRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oaW50ZXJmYWNlTmFtZSwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMsIHN0YXJ0R3JvdXAsIHN0YXJ0SW5kZXgpIHtcbiAgICBmb3IgKHZhciBsID0gMDsgbCA8IHRoaXMuY2hpbGRMYXllcnMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5jaGlsZExheWVyc1tsXTtcbiAgICAgICAgdmFyIGdyb3VwcyA9IHRoaXMuYXJyYXlHcm91cHNbaW50ZXJmYWNlTmFtZV07XG4gICAgICAgIGZvciAodmFyIGcgPSBzdGFydEdyb3VwLmluZGV4OyBnIDwgZ3JvdXBzLmxlbmd0aDsgZysrKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbZ107XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gZ3JvdXAubGF5b3V0LnZlcnRleC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgdmVydGV4QXJyYXkgPSBncm91cC5wYWludFtsYXllci5pZF07XG4gICAgICAgICAgICB2ZXJ0ZXhBcnJheS5yZXNpemUobGVuZ3RoKTtcblxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLnBhaW50QXR0cmlidXRlc1tpbnRlcmZhY2VOYW1lXVtsYXllci5pZF0uYXR0cmlidXRlcztcbiAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgYXR0cmlidXRlcy5sZW5ndGg7IG0rKykge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW21dO1xuXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlLmdldFZhbHVlKGxheWVyLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgdmFyIG11bHRpcGxpZXIgPSBhdHRyaWJ1dGUubXVsdGlwbGllciB8fCAxO1xuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRzID0gYXR0cmlidXRlLmNvbXBvbmVudHMgfHwgMTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRleEFycmF5LmdldChpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjb21wb25lbnRzOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZW1iZXJOYW1lID0gY29tcG9uZW50cyA+IDEgPyAoYXR0cmlidXRlLm5hbWUgKyBjKSA6IGF0dHJpYnV0ZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4W21lbWJlck5hbWVdID0gdmFsdWVbY10gKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudEJ1ZmZlclR5cGUoY29tcG9uZW50cykge1xuICAgIHJldHVybiBuZXcgU3RydWN0QXJyYXlUeXBlKHtcbiAgICAgICAgbWVtYmVyczogW3tcbiAgICAgICAgICAgIHR5cGU6IEJ1ZmZlci5FTEVNRU5UX0FUVFJJQlVURV9UWVBFLFxuICAgICAgICAgICAgbmFtZTogJ3ZlcnRpY2VzJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHMgfHwgM1xuICAgICAgICB9XVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQYWludEF0dHJpYnV0ZXMoYnVja2V0KSB7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBmb3IgKHZhciBpbnRlcmZhY2VOYW1lIGluIGJ1Y2tldC5wcm9ncmFtSW50ZXJmYWNlcykge1xuICAgICAgICB2YXIgbGF5ZXJQYWludEF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzW2ludGVyZmFjZU5hbWVdID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBidWNrZXQuY2hpbGRMYXllcnMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZExheWVyID0gYnVja2V0LmNoaWxkTGF5ZXJzW2NdO1xuICAgICAgICAgICAgbGF5ZXJQYWludEF0dHJpYnV0ZXNbY2hpbGRMYXllci5pZF0gPSB7IGF0dHJpYnV0ZXM6IFtdLCB1bmlmb3JtczogW10gfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbnRlcmZhY2VfID0gYnVja2V0LnByb2dyYW1JbnRlcmZhY2VzW2ludGVyZmFjZU5hbWVdO1xuICAgICAgICBpZiAoIWludGVyZmFjZV8ucGFpbnRBdHRyaWJ1dGVzKSBjb250aW51ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnRlcmZhY2VfLnBhaW50QXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGludGVyZmFjZV8ucGFpbnRBdHRyaWJ1dGVzW2ldO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJ1Y2tldC5jaGlsZExheWVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IGJ1Y2tldC5jaGlsZExheWVyc1tqXTtcbiAgICAgICAgICAgICAgICB2YXIgcGFpbnRBdHRyaWJ1dGVzID0gbGF5ZXJQYWludEF0dHJpYnV0ZXNbbGF5ZXIuaWRdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLmlzUGFpbnRWYWx1ZUZlYXR1cmVDb25zdGFudChhdHRyaWJ1dGUucGFpbnRQcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLnVuaWZvcm1zLnB1c2goYXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxheWVyLmlzUGFpbnRWYWx1ZVpvb21Db25zdGFudChhdHRyaWJ1dGUucGFpbnRQcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLmF0dHJpYnV0ZXMucHVzaChhdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHpvb21MZXZlbHMgPSBsYXllci5nZXRQYWludFZhbHVlU3RvcFpvb21MZXZlbHMoYXR0cmlidXRlLnBhaW50UHJvcGVydHkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFBpY2sgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBvZmZzZXQgdG8gYWRkIHRvIHRoZSBidWZmZXJzLlxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBmb3VyIGNsb3Nlc3Qgc3RvcHMsIGlkZWFsbHkgd2l0aCB0d28gb24gZWFjaCBzaWRlIG9mIHRoZSB6b29tIGxldmVsLlxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtU3RvcHMgPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobnVtU3RvcHMgPCB6b29tTGV2ZWxzLmxlbmd0aCAmJiB6b29tTGV2ZWxzW251bVN0b3BzXSA8IGJ1Y2tldC56b29tKSBudW1TdG9wcysrO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcE9mZnNldCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHpvb21MZXZlbHMubGVuZ3RoIC0gNCwgbnVtU3RvcHMgLSAyKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvdXJab29tTGV2ZWxzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgNDsgcysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VyWm9vbUxldmVscy5wdXNoKHpvb21MZXZlbHNbTWF0aC5taW4oc3RvcE9mZnNldCArIHMsIHpvb21MZXZlbHMubGVuZ3RoIC0gMSldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRzID0gYXR0cmlidXRlLmNvbXBvbmVudHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWludEF0dHJpYnV0ZXMuYXR0cmlidXRlcy5wdXNoKHV0aWwuZXh0ZW5kKHt9LCBhdHRyaWJ1dGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZTogY3JlYXRlRnVuY3Rpb25HZXRWYWx1ZShhdHRyaWJ1dGUsIGZvdXJab29tTGV2ZWxzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHMgKiA0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IDQ7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhaW50QXR0cmlidXRlcy5hdHRyaWJ1dGVzLnB1c2godXRpbC5leHRlbmQoe30sIGF0dHJpYnV0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZTogY3JlYXRlRnVuY3Rpb25HZXRWYWx1ZShhdHRyaWJ1dGUsIFtmb3VyWm9vbUxldmVsc1trXV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBhdHRyaWJ1dGUubmFtZSArIGtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwYWludEF0dHJpYnV0ZXMudW5pZm9ybXMucHVzaCh1dGlsLmV4dGVuZCh7fSwgYXR0cmlidXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndV8nICsgYXR0cmlidXRlLm5hbWUuc2xpY2UoMikgKyAnX3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWU6IGNyZWF0ZUdldFVuaWZvcm0oYXR0cmlidXRlLCBzdG9wT2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IDFcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25HZXRWYWx1ZShhdHRyaWJ1dGUsIHN0b3Bab29tTGV2ZWxzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGxheWVyLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcykge1xuICAgICAgICBpZiAoc3RvcFpvb21MZXZlbHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gb25lIG11bHRpLWNvbXBvbmVudCB2YWx1ZSBsaWtlIGNvbG9yMFxuICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZS5nZXRWYWx1ZShsYXllciwgdXRpbC5leHRlbmQoe30sIGdsb2JhbFByb3BlcnRpZXMsIHsgem9vbTogc3RvcFpvb21MZXZlbHNbMF0gfSksIGZlYXR1cmVQcm9wZXJ0aWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhY2sgbXVsdGlwbGUgc2luZ2xlLWNvbXBvbmVudCB2YWx1ZXMgaW50byBhIGZvdXIgY29tcG9uZW50IGF0dHJpYnV0ZVxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgeiA9IDA7IHogPCBzdG9wWm9vbUxldmVscy5sZW5ndGg7IHorKykge1xuICAgICAgICAgICAgICAgIHZhciBzdG9wWm9vbUxldmVsID0gc3RvcFpvb21MZXZlbHNbel07XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goYXR0cmlidXRlLmdldFZhbHVlKGxheWVyLCB1dGlsLmV4dGVuZCh7fSwgZ2xvYmFsUHJvcGVydGllcywgeyB6b29tOiBzdG9wWm9vbUxldmVsIH0pLCBmZWF0dXJlUHJvcGVydGllcylbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdldFVuaWZvcm0oYXR0cmlidXRlLCBzdG9wT2Zmc2V0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGxheWVyLCBnbG9iYWxQcm9wZXJ0aWVzKSB7XG4gICAgICAgIC8vIHN0b3BJbnRlcnAgaW5kaWNhdGVzIHdoaWNoIHN0b3BzIG5lZWQgdG8gYmUgaW50ZXJwb2xhdGVkLlxuICAgICAgICAvLyBJZiBzdG9wSW50ZXJwIGlzIDMuNSB0aGVuIGludGVycG9sYXRlIGhhbGYgd2F5IGJldHdlZW4gc3RvcHMgMyBhbmQgNC5cbiAgICAgICAgdmFyIHN0b3BJbnRlcnAgPSBsYXllci5nZXRQYWludEludGVycG9sYXRpb25UKGF0dHJpYnV0ZS5wYWludFByb3BlcnR5LCBnbG9iYWxQcm9wZXJ0aWVzLnpvb20pO1xuICAgICAgICAvLyBXZSBjYW4gb25seSBzdG9yZSBmb3VyIHN0b3AgdmFsdWVzIGluIHRoZSBidWZmZXJzLiBzdG9wT2Zmc2V0IGlzIHRoZSBudW1iZXIgb2Ygc3RvcHMgdGhhdCBjb21lXG4gICAgICAgIC8vIGJlZm9yZSB0aGUgc3RvcHMgdGhhdCB3ZXJlIGFkZGVkIHRvIHRoZSBidWZmZXJzLlxuICAgICAgICByZXR1cm4gW01hdGgubWF4KDAsIE1hdGgubWluKDQsIHN0b3BJbnRlcnAgLSBzdG9wT2Zmc2V0KSldO1xuICAgIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCdWNrZXQgPSByZXF1aXJlKCcuLi9idWNrZXQnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgbG9hZEdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vbG9hZF9nZW9tZXRyeScpO1xudmFyIEVYVEVOVCA9IEJ1Y2tldC5FWFRFTlQ7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlQnVja2V0O1xuXG4vKipcbiAqIENpcmNsZXMgYXJlIHJlcHJlc2VudGVkIGJ5IHR3byB0cmlhbmdsZXMuXG4gKlxuICogRWFjaCBjb3JuZXIgaGFzIGEgcG9zIHRoYXQgaXMgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIGFuZCBhbiBleHRydXNpb25cbiAqIHZlY3RvciB0aGF0IGlzIHdoZXJlIGl0IHBvaW50cy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIENpcmNsZUJ1Y2tldCgpIHtcbiAgICBCdWNrZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuQ2lyY2xlQnVja2V0LnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChCdWNrZXQsIHt9KTtcblxuQ2lyY2xlQnVja2V0LnByb3RvdHlwZS5hZGRDaXJjbGVWZXJ0ZXggPSBmdW5jdGlvbih2ZXJ0ZXhBcnJheSwgeCwgeSwgZXh0cnVkZVgsIGV4dHJ1ZGVZKSB7XG4gICAgcmV0dXJuIHZlcnRleEFycmF5LmVtcGxhY2VCYWNrKFxuICAgICAgICAgICAgKHggKiAyKSArICgoZXh0cnVkZVggKyAxKSAvIDIpLFxuICAgICAgICAgICAgKHkgKiAyKSArICgoZXh0cnVkZVkgKyAxKSAvIDIpKTtcbn07XG5cbkNpcmNsZUJ1Y2tldC5wcm90b3R5cGUucHJvZ3JhbUludGVyZmFjZXMgPSB7XG4gICAgY2lyY2xlOiB7XG4gICAgICAgIHZlcnRleEJ1ZmZlcjogdHJ1ZSxcbiAgICAgICAgZWxlbWVudEJ1ZmZlcjogdHJ1ZSxcblxuICAgICAgICBsYXlvdXRBdHRyaWJ1dGVzOiBbe1xuICAgICAgICAgICAgbmFtZTogJ2FfcG9zJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICAgICAgICB0eXBlOiAnSW50MTYnXG4gICAgICAgIH1dLFxuICAgICAgICBwYWludEF0dHJpYnV0ZXM6IFt7XG4gICAgICAgICAgICBuYW1lOiAnYV9jb2xvcicsXG4gICAgICAgICAgICBjb21wb25lbnRzOiA0LFxuICAgICAgICAgICAgdHlwZTogJ1VpbnQ4JyxcbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbihsYXllciwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5wcmVtdWx0aXBseShsYXllci5nZXRQYWludFZhbHVlKFwiY2lyY2xlLWNvbG9yXCIsIGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXVsdGlwbGllcjogMjU1LFxuICAgICAgICAgICAgcGFpbnRQcm9wZXJ0eTogJ2NpcmNsZS1jb2xvcidcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2FfcmFkaXVzJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IDEsXG4gICAgICAgICAgICB0eXBlOiAnVWludDE2JyxcbiAgICAgICAgICAgIGlzTGF5ZXJDb25zdGFudDogZmFsc2UsXG4gICAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24obGF5ZXIsIGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsYXllci5nZXRQYWludFZhbHVlKFwiY2lyY2xlLXJhZGl1c1wiLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcyldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11bHRpcGxpZXI6IDEwLFxuICAgICAgICAgICAgcGFpbnRQcm9wZXJ0eTogJ2NpcmNsZS1yYWRpdXMnXG4gICAgICAgIH1dXG4gICAgfVxufTtcblxuQ2lyY2xlQnVja2V0LnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgIHZhciBnbG9iYWxQcm9wZXJ0aWVzID0ge3pvb206IHRoaXMuem9vbX07XG4gICAgdmFyIGdlb21ldHJpZXMgPSBsb2FkR2VvbWV0cnkoZmVhdHVyZSk7XG5cbiAgICB2YXIgc3RhcnRHcm91cCA9IHRoaXMubWFrZVJvb21Gb3IoJ2NpcmNsZScsIDApO1xuICAgIHZhciBzdGFydEluZGV4ID0gc3RhcnRHcm91cC5sYXlvdXQudmVydGV4Lmxlbmd0aDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2VvbWV0cmllcy5sZW5ndGg7IGorKykge1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGdlb21ldHJpZXNbal0ubGVuZ3RoOyBrKyspIHtcblxuICAgICAgICAgICAgdmFyIHggPSBnZW9tZXRyaWVzW2pdW2tdLng7XG4gICAgICAgICAgICB2YXIgeSA9IGdlb21ldHJpZXNbal1ba10ueTtcblxuICAgICAgICAgICAgLy8gRG8gbm90IGluY2x1ZGUgcG9pbnRzIHRoYXQgYXJlIG91dHNpZGUgdGhlIHRpbGUgYm91bmRhcmllcy5cbiAgICAgICAgICAgIGlmICh4IDwgMCB8fCB4ID49IEVYVEVOVCB8fCB5IDwgMCB8fCB5ID49IEVYVEVOVCkgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIHRoaXMgZ2VvbWV0cnkgd2lsbCBiZSBvZiB0aGUgUG9pbnQgdHlwZSwgYW5kIHdlJ2xsIGRlcml2ZVxuICAgICAgICAgICAgLy8gdHdvIHRyaWFuZ2xlcyBmcm9tIGl0LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgICAgICAgICAgLy8g4pSCIDMgICAgIDIg4pSCXG4gICAgICAgICAgICAvLyDilIIgICAgICAgICDilIJcbiAgICAgICAgICAgIC8vIOKUgiAwICAgICAxIOKUglxuICAgICAgICAgICAgLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG5cbiAgICAgICAgICAgIHZhciBncm91cCA9IHRoaXMubWFrZVJvb21Gb3IoJ2NpcmNsZScsIDQpO1xuICAgICAgICAgICAgdmFyIHZlcnRleEFycmF5ID0gZ3JvdXAubGF5b3V0LnZlcnRleDtcblxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5hZGRDaXJjbGVWZXJ0ZXgodmVydGV4QXJyYXksIHgsIHksIC0xLCAtMSk7XG4gICAgICAgICAgICB0aGlzLmFkZENpcmNsZVZlcnRleCh2ZXJ0ZXhBcnJheSwgeCwgeSwgMSwgLTEpO1xuICAgICAgICAgICAgdGhpcy5hZGRDaXJjbGVWZXJ0ZXgodmVydGV4QXJyYXksIHgsIHksIDEsIDEpO1xuICAgICAgICAgICAgdGhpcy5hZGRDaXJjbGVWZXJ0ZXgodmVydGV4QXJyYXksIHgsIHksIC0xLCAxKTtcblxuICAgICAgICAgICAgZ3JvdXAubGF5b3V0LmVsZW1lbnQuZW1wbGFjZUJhY2soaW5kZXgsIGluZGV4ICsgMSwgaW5kZXggKyAyKTtcbiAgICAgICAgICAgIGdyb3VwLmxheW91dC5lbGVtZW50LmVtcGxhY2VCYWNrKGluZGV4LCBpbmRleCArIDMsIGluZGV4ICsgMik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFkZFBhaW50QXR0cmlidXRlcygnY2lyY2xlJywgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZS5wcm9wZXJ0aWVzLCBzdGFydEdyb3VwLCBzdGFydEluZGV4KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCdWNrZXQgPSByZXF1aXJlKCcuLi9idWNrZXQnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgbG9hZEdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vbG9hZF9nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbGxCdWNrZXQ7XG5cbmZ1bmN0aW9uIEZpbGxCdWNrZXQoKSB7XG4gICAgQnVja2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbkZpbGxCdWNrZXQucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEJ1Y2tldCwge30pO1xuXG5GaWxsQnVja2V0LnByb3RvdHlwZS5wcm9ncmFtSW50ZXJmYWNlcyA9IHtcbiAgICBmaWxsOiB7XG4gICAgICAgIHZlcnRleEJ1ZmZlcjogdHJ1ZSxcbiAgICAgICAgZWxlbWVudEJ1ZmZlcjogdHJ1ZSxcbiAgICAgICAgZWxlbWVudEJ1ZmZlcjI6IHRydWUsXG4gICAgICAgIGVsZW1lbnRCdWZmZXIyQ29tcG9uZW50czogMixcblxuICAgICAgICBsYXlvdXRBdHRyaWJ1dGVzOiBbe1xuICAgICAgICAgICAgbmFtZTogJ2FfcG9zJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICAgICAgICB0eXBlOiAnSW50MTYnXG4gICAgICAgIH1dXG4gICAgfVxufTtcblxuRmlsbEJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICB2YXIgbGluZXMgPSBsb2FkR2VvbWV0cnkoZmVhdHVyZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZEZpbGwobGluZXNbaV0pO1xuICAgIH1cbn07XG5cbkZpbGxCdWNrZXQucHJvdG90eXBlLmFkZEZpbGwgPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPCAzKSB7XG4gICAgICAgIC8vY29uc29sZS53YXJuKCdhIGZpbGwgbXVzdCBoYXZlIGF0IGxlYXN0IHRocmVlIHZlcnRpY2VzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHRvdGFsIG51bWJlciBvZiB2ZXJ0aWNlcyB3ZSdyZSBnb2luZyB0byBwcm9kdWNlIHNvIHRoYXQgd2VcbiAgICAvLyBjYW4gcmVzaXplIHRoZSBidWZmZXIgYmVmb3JlaGFuZCwgb3IgZGV0ZWN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgbGluZVxuICAgIC8vIHdvbid0IGZpdCBpbnRvIHRoZSBidWZmZXIgYW55bW9yZS5cbiAgICAvLyBJbiBvcmRlciB0byBiZSBhYmxlIHRvIHVzZSB0aGUgdmVydGV4IGJ1ZmZlciBmb3IgZHJhd2luZyB0aGUgYW50aWFsaWFzZWRcbiAgICAvLyBvdXRsaW5lcywgd2Ugc2VwYXJhdGUgYWxsIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGRlZ2VuZXJhdGUgKG91dC1vZi1cbiAgICAvLyB2aWV3cGxhbmUpIHZlcnRleC5cblxuICAgIHZhciBsZW4gPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICAvLyBFeHBhbmQgdGhpcyBnZW9tZXRyeSBidWZmZXIgdG8gaG9sZCBhbGwgdGhlIHJlcXVpcmVkIHZlcnRpY2VzLlxuICAgIHZhciBncm91cCA9IHRoaXMubWFrZVJvb21Gb3IoJ2ZpbGwnLCBsZW4gKyAxKTtcblxuICAgIC8vIFdlJ3JlIGdlbmVyYXRpbmcgdHJpYW5nbGUgZmFucywgc28gd2UgYWx3YXlzIHN0YXJ0IHdpdGggdGhlIGZpcnN0IGNvb3JkaW5hdGUgaW4gdGhpcyBwb2x5Z29uLlxuICAgIHZhciBmaXJzdEluZGV4LCBwcmV2SW5kZXg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3VycmVudFZlcnRleCA9IHZlcnRpY2VzW2ldO1xuXG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBncm91cC5sYXlvdXQudmVydGV4LmVtcGxhY2VCYWNrKGN1cnJlbnRWZXJ0ZXgueCwgY3VycmVudFZlcnRleC55KTtcbiAgICAgICAgaWYgKGkgPT09IDApIGZpcnN0SW5kZXggPSBjdXJyZW50SW5kZXg7XG5cbiAgICAgICAgLy8gT25seSBhZGQgdHJpYW5nbGVzIHRoYXQgaGF2ZSBkaXN0aW5jdCB2ZXJ0aWNlcy5cbiAgICAgICAgaWYgKGkgPj0gMiAmJiAoY3VycmVudFZlcnRleC54ICE9PSB2ZXJ0aWNlc1swXS54IHx8IGN1cnJlbnRWZXJ0ZXgueSAhPT0gdmVydGljZXNbMF0ueSkpIHtcbiAgICAgICAgICAgIGdyb3VwLmxheW91dC5lbGVtZW50LmVtcGxhY2VCYWNrKGZpcnN0SW5kZXgsIHByZXZJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID49IDEpIHtcbiAgICAgICAgICAgIGdyb3VwLmxheW91dC5lbGVtZW50Mi5lbXBsYWNlQmFjayhwcmV2SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2SW5kZXggPSBjdXJyZW50SW5kZXg7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1Y2tldCA9IHJlcXVpcmUoJy4uL2J1Y2tldCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcbnZhciBsb2FkR2VvbWV0cnkgPSByZXF1aXJlKCcuLi9sb2FkX2dlb21ldHJ5Jyk7XG52YXIgRVhURU5UID0gQnVja2V0LkVYVEVOVDtcblxuLy8gTk9URSBPTiBFWFRSVURFIFNDQUxFOlxuLy8gc2NhbGUgdGhlIGV4dHJ1c2lvbiB2ZWN0b3Igc28gdGhhdCB0aGUgbm9ybWFsIGxlbmd0aCBpcyB0aGlzIHZhbHVlLlxuLy8gY29udGFpbnMgdGhlIFwidGV4dHVyZVwiIG5vcm1hbHMgKC0xLi4xKS4gdGhpcyBpcyBkaXN0aW5jdCBmcm9tIHRoZSBleHRydWRlXG4vLyBub3JtYWxzIGZvciBsaW5lIGpvaW5zLCBiZWNhdXNlIHRoZSB4LXZhbHVlIHJlbWFpbnMgMCBmb3IgdGhlIHRleHR1cmVcbi8vIG5vcm1hbCBhcnJheSwgd2hpbGUgdGhlIGV4dHJ1ZGUgbm9ybWFsIGFjdHVhbGx5IG1vdmVzIHRoZSB2ZXJ0ZXggdG8gY3JlYXRlXG4vLyB0aGUgYWN1dGUvYmV2ZWxsZWQgbGluZSBqb2luLlxudmFyIEVYVFJVREVfU0NBTEUgPSA2MztcblxuLypcbiAqIFNoYXJwIGNvcm5lcnMgY2F1c2UgZGFzaGVkIGxpbmVzIHRvIHRpbHQgYmVjYXVzZSB0aGUgZGlzdGFuY2UgYWxvbmcgdGhlIGxpbmVcbiAqIGlzIHRoZSBzYW1lIGF0IGJvdGggdGhlIGlubmVyIGFuZCBvdXRlciBjb3JuZXJzLiBUbyBpbXByb3ZlIHRoZSBhcHBlYXJhbmNlIG9mXG4gKiBkYXNoZWQgbGluZXMgd2UgYWRkIGV4dHJhIHBvaW50cyBuZWFyIHNoYXJwIGNvcm5lcnMgc28gdGhhdCBhIHNtYWxsZXIgcGFydFxuICogb2YgdGhlIGxpbmUgaXMgdGlsdGVkLlxuICpcbiAqIENPU19IQUxGX1NIQVJQX0NPUk5FUiBjb250cm9scyBob3cgc2hhcnAgYSBjb3JuZXIgaGFzIHRvIGJlIGZvciB1cyB0byBhZGQgYW5cbiAqIGV4dHJhIHZlcnRleC4gVGhlIGRlZmF1bHQgaXMgNzUgZGVncmVlcy5cbiAqXG4gKiBUaGUgbmV3bHkgY3JlYXRlZCB2ZXJ0aWNlcyBhcmUgcGxhY2VkIFNIQVJQX0NPUk5FUl9PRkZTRVQgcGl4ZWxzIGZyb20gdGhlIGNvcm5lci5cbiAqL1xudmFyIENPU19IQUxGX1NIQVJQX0NPUk5FUiA9IE1hdGguY29zKDc1IC8gMiAqIChNYXRoLlBJIC8gMTgwKSk7XG52YXIgU0hBUlBfQ09STkVSX09GRlNFVCA9IDE1O1xuXG4vLyBUaGUgbnVtYmVyIG9mIGJpdHMgdGhhdCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBsaW5lIGRpc3RhbmNlIGluIHRoZSBidWZmZXIuXG52YXIgTElORV9ESVNUQU5DRV9CVUZGRVJfQklUUyA9IDE0O1xuXG4vLyBXZSBkb24ndCBoYXZlIGVub3VnaCBiaXRzIGZvciB0aGUgbGluZSBkaXN0YW5jZSBhcyB3ZSdkIGxpa2UgdG8gaGF2ZSwgc29cbi8vIHVzZSB0aGlzIHZhbHVlIHRvIHNjYWxlIHRoZSBsaW5lIGRpc3RhbmNlIChpbiB0aWxlIHVuaXRzKSBkb3duIHRvIGEgc21hbGxlclxuLy8gdmFsdWUuIFRoaXMgbGV0cyB1cyBzdG9yZSBsb25nZXIgZGlzdGFuY2VzIHdoaWxlIHNhY3JpZmljaW5nIHByZWNpc2lvbi5cbnZhciBMSU5FX0RJU1RBTkNFX1NDQUxFID0gMSAvIDI7XG5cbi8vIFRoZSBtYXhpbXVtIGxpbmUgZGlzdGFuY2UsIGluIHRpbGUgdW5pdHMsIHRoYXQgZml0cyBpbiB0aGUgYnVmZmVyLlxudmFyIE1BWF9MSU5FX0RJU1RBTkNFID0gTWF0aC5wb3coMiwgTElORV9ESVNUQU5DRV9CVUZGRVJfQklUUykgLyBMSU5FX0RJU1RBTkNFX1NDQUxFO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTGluZUJ1Y2tldDtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBMaW5lQnVja2V0KCkge1xuICAgIEJ1Y2tldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5MaW5lQnVja2V0LnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChCdWNrZXQsIHt9KTtcblxuTGluZUJ1Y2tldC5wcm90b3R5cGUuYWRkTGluZVZlcnRleCA9IGZ1bmN0aW9uKHZlcnRleEJ1ZmZlciwgcG9pbnQsIGV4dHJ1ZGUsIHR4LCB0eSwgZGlyLCBsaW5lc29mYXIpIHtcbiAgICByZXR1cm4gdmVydGV4QnVmZmVyLmVtcGxhY2VCYWNrKFxuICAgICAgICAgICAgLy8gYV9wb3NcbiAgICAgICAgICAgIChwb2ludC54IDw8IDEpIHwgdHgsXG4gICAgICAgICAgICAocG9pbnQueSA8PCAxKSB8IHR5LFxuICAgICAgICAgICAgLy8gYV9kYXRhXG4gICAgICAgICAgICAvLyBhZGQgMTI4IHRvIHN0b3JlIGFuIGJ5dGUgaW4gYW4gdW5zaWduZWQgYnl0ZVxuICAgICAgICAgICAgTWF0aC5yb3VuZChFWFRSVURFX1NDQUxFICogZXh0cnVkZS54KSArIDEyOCxcbiAgICAgICAgICAgIE1hdGgucm91bmQoRVhUUlVERV9TQ0FMRSAqIGV4dHJ1ZGUueSkgKyAxMjgsXG4gICAgICAgICAgICAvLyBFbmNvZGUgdGhlIC0xLzAvMSBkaXJlY3Rpb24gdmFsdWUgaW50byB0aGUgZmlyc3QgdHdvIGJpdHMgb2YgLnogb2YgYV9kYXRhLlxuICAgICAgICAgICAgLy8gQ29tYmluZSBpdCB3aXRoIHRoZSBsb3dlciA2IGJpdHMgb2YgYGxpbmVzb2ZhcmAgKHNoaWZ0ZWQgYnkgMiBiaXRlcyB0byBtYWtlXG4gICAgICAgICAgICAvLyByb29tIGZvciB0aGUgZGlyZWN0aW9uIHZhbHVlKS4gVGhlIHVwcGVyIDggYml0cyBvZiBgbGluZXNvZmFyYCBhcmUgcGxhY2VkIGluXG4gICAgICAgICAgICAvLyB0aGUgYHdgIGNvbXBvbmVudC4gYGxpbmVzb2ZhcmAgaXMgc2NhbGVkIGRvd24gYnkgYExJTkVfRElTVEFOQ0VfU0NBTEVgIHNvIHRoYXRcbiAgICAgICAgICAgIC8vIHdlIGNhbiBzdG9yZSBsb25nZXIgZGlzdGFuY2VzIHdoaWxlIHNhY3JpZmljaW5nIHByZWNpc2lvbi5cbiAgICAgICAgICAgICgoZGlyID09PSAwID8gMCA6IChkaXIgPCAwID8gLTEgOiAxKSkgKyAxKSB8ICgoKGxpbmVzb2ZhciAqIExJTkVfRElTVEFOQ0VfU0NBTEUpICYgMHgzRikgPDwgMiksXG4gICAgICAgICAgICAobGluZXNvZmFyICogTElORV9ESVNUQU5DRV9TQ0FMRSkgPj4gNik7XG59O1xuXG5MaW5lQnVja2V0LnByb3RvdHlwZS5wcm9ncmFtSW50ZXJmYWNlcyA9IHtcbiAgICBsaW5lOiB7XG4gICAgICAgIHZlcnRleEJ1ZmZlcjogdHJ1ZSxcbiAgICAgICAgZWxlbWVudEJ1ZmZlcjogdHJ1ZSxcblxuICAgICAgICBsYXlvdXRBdHRyaWJ1dGVzOiBbe1xuICAgICAgICAgICAgbmFtZTogJ2FfcG9zJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICAgICAgICB0eXBlOiAnSW50MTYnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdhX2RhdGEnLFxuICAgICAgICAgICAgY29tcG9uZW50czogNCxcbiAgICAgICAgICAgIHR5cGU6ICdVaW50OCdcbiAgICAgICAgfV1cbiAgICB9XG59O1xuXG5MaW5lQnVja2V0LnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgIHZhciBsaW5lcyA9IGxvYWRHZW9tZXRyeShmZWF0dXJlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRkTGluZShcbiAgICAgICAgICAgIGxpbmVzW2ldLFxuICAgICAgICAgICAgdGhpcy5sYXllci5sYXlvdXRbJ2xpbmUtam9pbiddLFxuICAgICAgICAgICAgdGhpcy5sYXllci5sYXlvdXRbJ2xpbmUtY2FwJ10sXG4gICAgICAgICAgICB0aGlzLmxheWVyLmxheW91dFsnbGluZS1taXRlci1saW1pdCddLFxuICAgICAgICAgICAgdGhpcy5sYXllci5sYXlvdXRbJ2xpbmUtcm91bmQtbGltaXQnXVxuICAgICAgICApO1xuICAgIH1cbn07XG5cbkxpbmVCdWNrZXQucHJvdG90eXBlLmFkZExpbmUgPSBmdW5jdGlvbih2ZXJ0aWNlcywgam9pbiwgY2FwLCBtaXRlckxpbWl0LCByb3VuZExpbWl0KSB7XG5cbiAgICB2YXIgbGVuID0gdmVydGljZXMubGVuZ3RoO1xuICAgIC8vIElmIHRoZSBsaW5lIGhhcyBkdXBsaWNhdGUgdmVydGljZXMgYXQgdGhlIGVuZCwgYWRqdXN0IGxlbmd0aCB0byByZW1vdmUgdGhlbS5cbiAgICB3aGlsZSAobGVuID4gMiAmJiB2ZXJ0aWNlc1tsZW4gLSAxXS5lcXVhbHModmVydGljZXNbbGVuIC0gMl0pKSB7XG4gICAgICAgIGxlbi0tO1xuICAgIH1cblxuICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIC8vY29uc29sZS53YXJuKCdhIGxpbmUgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byB2ZXJ0aWNlcycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGpvaW4gPT09ICdiZXZlbCcpIG1pdGVyTGltaXQgPSAxLjA1O1xuXG4gICAgdmFyIHNoYXJwQ29ybmVyT2Zmc2V0ID0gU0hBUlBfQ09STkVSX09GRlNFVCAqIChFWFRFTlQgLyAoNTEyICogdGhpcy5vdmVyc2NhbGluZykpO1xuXG4gICAgdmFyIGZpcnN0VmVydGV4ID0gdmVydGljZXNbMF0sXG4gICAgICAgIGxhc3RWZXJ0ZXggPSB2ZXJ0aWNlc1tsZW4gLSAxXSxcbiAgICAgICAgY2xvc2VkID0gZmlyc3RWZXJ0ZXguZXF1YWxzKGxhc3RWZXJ0ZXgpO1xuXG4gICAgLy8gd2UgY291bGQgYmUgbW9yZSBwcmVjaXNlLCBidXQgaXQgd291bGQgb25seSBzYXZlIGEgbmVnbGlnaWJsZSBhbW91bnQgb2Ygc3BhY2VcbiAgICB0aGlzLm1ha2VSb29tRm9yKCdsaW5lJywgbGVuICogMTApO1xuXG4gICAgaWYgKGxlbiA9PT0gMiAmJiBjbG9zZWQpIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCdhIGxpbmUgbWF5IG5vdCBoYXZlIGNvaW5jaWRlbnQgcG9pbnRzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3RhbmNlID0gMDtcblxuICAgIHZhciBiZWdpbkNhcCA9IGNhcCxcbiAgICAgICAgZW5kQ2FwID0gY2xvc2VkID8gJ2J1dHQnIDogY2FwLFxuICAgICAgICBzdGFydE9mTGluZSA9IHRydWUsXG4gICAgICAgIGN1cnJlbnRWZXJ0ZXgsIHByZXZWZXJ0ZXgsIG5leHRWZXJ0ZXgsIHByZXZOb3JtYWwsIG5leHROb3JtYWwsIG9mZnNldEEsIG9mZnNldEI7XG5cbiAgICAvLyB0aGUgbGFzdCB0aHJlZSB2ZXJ0aWNlcyBhZGRlZFxuICAgIHRoaXMuZTEgPSB0aGlzLmUyID0gdGhpcy5lMyA9IC0xO1xuXG4gICAgaWYgKGNsb3NlZCkge1xuICAgICAgICBjdXJyZW50VmVydGV4ID0gdmVydGljZXNbbGVuIC0gMl07XG4gICAgICAgIG5leHROb3JtYWwgPSBmaXJzdFZlcnRleC5zdWIoY3VycmVudFZlcnRleCkuX3VuaXQoKS5fcGVycCgpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICBuZXh0VmVydGV4ID0gY2xvc2VkICYmIGkgPT09IGxlbiAtIDEgP1xuICAgICAgICAgICAgdmVydGljZXNbMV0gOiAvLyBpZiB0aGUgbGluZSBpcyBjbG9zZWQsIHdlIHRyZWF0IHRoZSBsYXN0IHZlcnRleCBsaWtlIHRoZSBmaXJzdFxuICAgICAgICAgICAgdmVydGljZXNbaSArIDFdOyAvLyBqdXN0IHRoZSBuZXh0IHZlcnRleFxuXG4gICAgICAgIC8vIGlmIHR3byBjb25zZWN1dGl2ZSB2ZXJ0aWNlcyBleGlzdCwgc2tpcCB0aGUgY3VycmVudCBvbmVcbiAgICAgICAgaWYgKG5leHRWZXJ0ZXggJiYgdmVydGljZXNbaV0uZXF1YWxzKG5leHRWZXJ0ZXgpKSBjb250aW51ZTtcblxuICAgICAgICBpZiAobmV4dE5vcm1hbCkgcHJldk5vcm1hbCA9IG5leHROb3JtYWw7XG4gICAgICAgIGlmIChjdXJyZW50VmVydGV4KSBwcmV2VmVydGV4ID0gY3VycmVudFZlcnRleDtcblxuICAgICAgICBjdXJyZW50VmVydGV4ID0gdmVydGljZXNbaV07XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBub3JtYWwgdG93YXJkcyB0aGUgbmV4dCB2ZXJ0ZXggaW4gdGhpcyBsaW5lLiBJbiBjYXNlXG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIG5leHQgdmVydGV4LCBwcmV0ZW5kIHRoYXQgdGhlIGxpbmUgaXMgY29udGludWluZyBzdHJhaWdodCxcbiAgICAgICAgLy8gbWVhbmluZyB0aGF0IHdlIGFyZSBqdXN0IHVzaW5nIHRoZSBwcmV2aW91cyBub3JtYWwuXG4gICAgICAgIG5leHROb3JtYWwgPSBuZXh0VmVydGV4ID8gbmV4dFZlcnRleC5zdWIoY3VycmVudFZlcnRleCkuX3VuaXQoKS5fcGVycCgpIDogcHJldk5vcm1hbDtcblxuICAgICAgICAvLyBJZiB3ZSBzdGlsbCBkb24ndCBoYXZlIGEgcHJldmlvdXMgbm9ybWFsLCB0aGlzIGlzIHRoZSBiZWdpbm5pbmcgb2YgYVxuICAgICAgICAvLyBub24tY2xvc2VkIGxpbmUsIHNvIHdlJ3JlIGRvaW5nIGEgc3RyYWlnaHQgXCJqb2luXCIuXG4gICAgICAgIHByZXZOb3JtYWwgPSBwcmV2Tm9ybWFsIHx8IG5leHROb3JtYWw7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBub3JtYWwgb2YgdGhlIGpvaW4gZXh0cnVzaW9uLiBJdCBpcyB0aGUgYW5nbGUgYmlzZWN0b3JcbiAgICAgICAgLy8gb2YgdGhlIHNlZ21lbnRzIGJldHdlZW4gdGhlIHByZXZpb3VzIGxpbmUgYW5kIHRoZSBuZXh0IGxpbmUuXG4gICAgICAgIHZhciBqb2luTm9ybWFsID0gcHJldk5vcm1hbC5hZGQobmV4dE5vcm1hbCkuX3VuaXQoKTtcblxuICAgICAgICAvKiAgam9pbk5vcm1hbCAgICAgcHJldk5vcm1hbFxuICAgICAgICAgKiAgICAgICAgICAgICDihpYgICAgICDihpFcbiAgICAgICAgICogICAgICAgICAgICAgICAgLl9fX19fX19fLiBwcmV2VmVydGV4XG4gICAgICAgICAqICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogbmV4dE5vcm1hbCAg4oaQICB8ICBjdXJyZW50VmVydGV4XG4gICAgICAgICAqICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIG5leHRWZXJ0ZXggIVxuICAgICAgICAgKlxuICAgICAgICAgKi9cblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiB0aGUgbWl0ZXIgKHRoZSByYXRpbyBvZiB0aGUgbWl0ZXIgdG8gdGhlIHdpZHRoKS5cbiAgICAgICAgLy8gRmluZCB0aGUgY29zaW5lIG9mIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSBuZXh0IGFuZCBqb2luIG5vcm1hbHNcbiAgICAgICAgLy8gdXNpbmcgZG90IHByb2R1Y3QuIFRoZSBpbnZlcnNlIG9mIHRoYXQgaXMgdGhlIG1pdGVyIGxlbmd0aC5cbiAgICAgICAgdmFyIGNvc0hhbGZBbmdsZSA9IGpvaW5Ob3JtYWwueCAqIG5leHROb3JtYWwueCArIGpvaW5Ob3JtYWwueSAqIG5leHROb3JtYWwueTtcbiAgICAgICAgdmFyIG1pdGVyTGVuZ3RoID0gMSAvIGNvc0hhbGZBbmdsZTtcblxuICAgICAgICB2YXIgaXNTaGFycENvcm5lciA9IGNvc0hhbGZBbmdsZSA8IENPU19IQUxGX1NIQVJQX0NPUk5FUiAmJiBwcmV2VmVydGV4ICYmIG5leHRWZXJ0ZXg7XG5cbiAgICAgICAgaWYgKGlzU2hhcnBDb3JuZXIgJiYgaSA+IDApIHtcbiAgICAgICAgICAgIHZhciBwcmV2U2VnbWVudExlbmd0aCA9IGN1cnJlbnRWZXJ0ZXguZGlzdChwcmV2VmVydGV4KTtcbiAgICAgICAgICAgIGlmIChwcmV2U2VnbWVudExlbmd0aCA+IDIgKiBzaGFycENvcm5lck9mZnNldCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdQcmV2VmVydGV4ID0gY3VycmVudFZlcnRleC5zdWIoY3VycmVudFZlcnRleC5zdWIocHJldlZlcnRleCkuX211bHQoc2hhcnBDb3JuZXJPZmZzZXQgLyBwcmV2U2VnbWVudExlbmd0aCkuX3JvdW5kKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgKz0gbmV3UHJldlZlcnRleC5kaXN0KHByZXZWZXJ0ZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChuZXdQcmV2VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBwcmV2Tm9ybWFsLm11bHQoMSksIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBwcmV2VmVydGV4ID0gbmV3UHJldlZlcnRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBqb2luIGlmIGEgbWlkZGxlIHZlcnRleCwgb3RoZXJ3aXNlIHRoZSBjYXAuXG4gICAgICAgIHZhciBtaWRkbGVWZXJ0ZXggPSBwcmV2VmVydGV4ICYmIG5leHRWZXJ0ZXg7XG4gICAgICAgIHZhciBjdXJyZW50Sm9pbiA9IG1pZGRsZVZlcnRleCA/IGpvaW4gOiBuZXh0VmVydGV4ID8gYmVnaW5DYXAgOiBlbmRDYXA7XG5cbiAgICAgICAgaWYgKG1pZGRsZVZlcnRleCAmJiBjdXJyZW50Sm9pbiA9PT0gJ3JvdW5kJykge1xuICAgICAgICAgICAgaWYgKG1pdGVyTGVuZ3RoIDwgcm91bmRMaW1pdCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRKb2luID0gJ21pdGVyJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWl0ZXJMZW5ndGggPD0gMikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRKb2luID0gJ2Zha2Vyb3VuZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudEpvaW4gPT09ICdtaXRlcicgJiYgbWl0ZXJMZW5ndGggPiBtaXRlckxpbWl0KSB7XG4gICAgICAgICAgICBjdXJyZW50Sm9pbiA9ICdiZXZlbCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudEpvaW4gPT09ICdiZXZlbCcpIHtcbiAgICAgICAgICAgIC8vIFRoZSBtYXhpbXVtIGV4dHJ1ZGUgbGVuZ3RoIGlzIDEyOCAvIDYzID0gMiB0aW1lcyB0aGUgd2lkdGggb2YgdGhlIGxpbmVcbiAgICAgICAgICAgIC8vIHNvIGlmIG1pdGVyTGVuZ3RoID49IDIgd2UgbmVlZCB0byBkcmF3IGEgZGlmZmVyZW50IHR5cGUgb2YgYmV2ZWwgd2hlcmUuXG4gICAgICAgICAgICBpZiAobWl0ZXJMZW5ndGggPiAyKSBjdXJyZW50Sm9pbiA9ICdmbGlwYmV2ZWwnO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgbWl0ZXJMZW5ndGggaXMgcmVhbGx5IHNtYWxsIGFuZCB0aGUgbGluZSBiZXZlbCB3b3VsZG4ndCBiZSB2aXNpYmxlLFxuICAgICAgICAgICAgLy8ganVzdCBkcmF3IGEgbWl0ZXIgam9pbiB0byBzYXZlIGEgdHJpYW5nbGUuXG4gICAgICAgICAgICBpZiAobWl0ZXJMZW5ndGggPCBtaXRlckxpbWl0KSBjdXJyZW50Sm9pbiA9ICdtaXRlcic7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgaG93IGZhciBhbG9uZyB0aGUgbGluZSB0aGUgY3VycmVudFZlcnRleCBpc1xuICAgICAgICBpZiAocHJldlZlcnRleCkgdGhpcy5kaXN0YW5jZSArPSBjdXJyZW50VmVydGV4LmRpc3QocHJldlZlcnRleCk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRKb2luID09PSAnbWl0ZXInKSB7XG5cbiAgICAgICAgICAgIGpvaW5Ob3JtYWwuX211bHQobWl0ZXJMZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIGpvaW5Ob3JtYWwsIDAsIDAsIGZhbHNlKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRKb2luID09PSAnZmxpcGJldmVsJykge1xuICAgICAgICAgICAgLy8gbWl0ZXIgaXMgdG9vIGJpZywgZmxpcCB0aGUgZGlyZWN0aW9uIHRvIG1ha2UgYSBiZXZlbGVkIGpvaW5cblxuICAgICAgICAgICAgaWYgKG1pdGVyTGVuZ3RoID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxtb3N0IHBhcmFsbGVsIGxpbmVzXG4gICAgICAgICAgICAgICAgam9pbk5vcm1hbCA9IG5leHROb3JtYWwuY2xvbmUoKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gcHJldk5vcm1hbC54ICogbmV4dE5vcm1hbC55IC0gcHJldk5vcm1hbC55ICogbmV4dE5vcm1hbC54ID4gMCA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICB2YXIgYmV2ZWxMZW5ndGggPSBtaXRlckxlbmd0aCAqIHByZXZOb3JtYWwuYWRkKG5leHROb3JtYWwpLm1hZygpIC8gcHJldk5vcm1hbC5zdWIobmV4dE5vcm1hbCkubWFnKCk7XG4gICAgICAgICAgICAgICAgam9pbk5vcm1hbC5fcGVycCgpLl9tdWx0KGJldmVsTGVuZ3RoICogZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBqb2luTm9ybWFsLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgam9pbk5vcm1hbC5tdWx0KC0xKSwgMCwgMCwgZmFsc2UpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEpvaW4gPT09ICdiZXZlbCcgfHwgY3VycmVudEpvaW4gPT09ICdmYWtlcm91bmQnKSB7XG4gICAgICAgICAgICB2YXIgbGluZVR1cm5zTGVmdCA9IChwcmV2Tm9ybWFsLnggKiBuZXh0Tm9ybWFsLnkgLSBwcmV2Tm9ybWFsLnkgKiBuZXh0Tm9ybWFsLngpID4gMDtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAtTWF0aC5zcXJ0KG1pdGVyTGVuZ3RoICogbWl0ZXJMZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGlmIChsaW5lVHVybnNMZWZ0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0QiA9IDA7XG4gICAgICAgICAgICAgICAgb2Zmc2V0QSA9IG9mZnNldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0QSA9IDA7XG4gICAgICAgICAgICAgICAgb2Zmc2V0QiA9IG9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2xvc2UgcHJldmlvdXMgc2VnbWVudCB3aXRoIGEgYmV2ZWxcbiAgICAgICAgICAgIGlmICghc3RhcnRPZkxpbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgcHJldk5vcm1hbCwgb2Zmc2V0QSwgb2Zmc2V0QiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudEpvaW4gPT09ICdmYWtlcm91bmQnKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGpvaW4gYW5nbGUgaXMgc2hhcnAgZW5vdWdoIHRoYXQgYSByb3VuZCBqb2luIHdvdWxkIGJlIHZpc2libGUuXG4gICAgICAgICAgICAgICAgLy8gQmV2ZWwgam9pbnMgZmlsbCB0aGUgZ2FwIGJldHdlZW4gc2VnbWVudHMgd2l0aCBhIHNpbmdsZSBwaWUgc2xpY2UgdHJpYW5nbGUuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcm91bmQgam9pbiBieSBhZGRpbmcgbXVsdGlwbGUgcGllIHNsaWNlcy4gVGhlIGpvaW4gaXNuJ3QgYWN0dWFsbHkgcm91bmQsIGJ1dFxuICAgICAgICAgICAgICAgIC8vIGl0IGxvb2tzIGxpa2UgaXQgaXMgYXQgdGhlIHNpemVzIHdlIHJlbmRlciBsaW5lcyBhdC5cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBtb3JlIHRyaWFuZ2xlcyBmb3Igc2hhcnBlciBhbmdsZXMuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBtYXRoIGlzIGp1c3QgYSBnb29kIGVub3VnaCBhcHByb3hpbWF0aW9uLiBJdCBpc24ndCBcImNvcnJlY3RcIi5cbiAgICAgICAgICAgICAgICB2YXIgbiA9IE1hdGguZmxvb3IoKDAuNSAtIChjb3NIYWxmQW5nbGUgLSAwLjUpKSAqIDgpO1xuICAgICAgICAgICAgICAgIHZhciBhcHByb3hGcmFjdGlvbmFsSm9pbk5vcm1hbDtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgbjsgbSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcHJveEZyYWN0aW9uYWxKb2luTm9ybWFsID0gbmV4dE5vcm1hbC5tdWx0KChtICsgMSkgLyAobiArIDEpKS5fYWRkKHByZXZOb3JtYWwpLl91bml0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUGllU2xpY2VWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgYXBwcm94RnJhY3Rpb25hbEpvaW5Ob3JtYWwsIGxpbmVUdXJuc0xlZnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuYWRkUGllU2xpY2VWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgam9pbk5vcm1hbCwgbGluZVR1cm5zTGVmdCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gbiAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcHJveEZyYWN0aW9uYWxKb2luTm9ybWFsID0gcHJldk5vcm1hbC5tdWx0KChrICsgMSkgLyAobiArIDEpKS5fYWRkKG5leHROb3JtYWwpLl91bml0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUGllU2xpY2VWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgYXBwcm94RnJhY3Rpb25hbEpvaW5Ob3JtYWwsIGxpbmVUdXJuc0xlZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RhcnQgbmV4dCBzZWdtZW50XG4gICAgICAgICAgICBpZiAobmV4dFZlcnRleCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBuZXh0Tm9ybWFsLCAtb2Zmc2V0QSwgLW9mZnNldEIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRKb2luID09PSAnYnV0dCcpIHtcbiAgICAgICAgICAgIGlmICghc3RhcnRPZkxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9zZSBwcmV2aW91cyBzZWdtZW50IHdpdGggYSBidXR0XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIHByZXZOb3JtYWwsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RhcnQgbmV4dCBzZWdtZW50IHdpdGggYSBidXR0XG4gICAgICAgICAgICBpZiAobmV4dFZlcnRleCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBuZXh0Tm9ybWFsLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Sm9pbiA9PT0gJ3NxdWFyZScpIHtcblxuICAgICAgICAgICAgaWYgKCFzdGFydE9mTGluZSkge1xuICAgICAgICAgICAgICAgIC8vIENsb3NlIHByZXZpb3VzIHNlZ21lbnQgd2l0aCBhIHNxdWFyZSBjYXBcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgcHJldk5vcm1hbCwgMSwgMSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHNlZ21lbnQgaXMgZG9uZS4gVW5zZXQgdmVydGljZXMgdG8gZGlzY29ubmVjdCBzZWdtZW50cy5cbiAgICAgICAgICAgICAgICB0aGlzLmUxID0gdGhpcy5lMiA9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdGFydCBuZXh0IHNlZ21lbnRcbiAgICAgICAgICAgIGlmIChuZXh0VmVydGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIG5leHROb3JtYWwsIC0xLCAtMSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEpvaW4gPT09ICdyb3VuZCcpIHtcblxuICAgICAgICAgICAgaWYgKCFzdGFydE9mTGluZSkge1xuICAgICAgICAgICAgICAgIC8vIENsb3NlIHByZXZpb3VzIHNlZ21lbnQgd2l0aCBidXR0XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIHByZXZOb3JtYWwsIDAsIDAsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCByb3VuZCBjYXAgb3IgbGluZWpvaW4gYXQgZW5kIG9mIHNlZ21lbnRcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgcHJldk5vcm1hbCwgMSwgMSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgc2VnbWVudCBpcyBkb25lLiBVbnNldCB2ZXJ0aWNlcyB0byBkaXNjb25uZWN0IHNlZ21lbnRzLlxuICAgICAgICAgICAgICAgIHRoaXMuZTEgPSB0aGlzLmUyID0gLTE7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy8gU3RhcnQgbmV4dCBzZWdtZW50IHdpdGggYSBidXR0XG4gICAgICAgICAgICBpZiAobmV4dFZlcnRleCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCByb3VuZCBjYXAgYmVmb3JlIGZpcnN0IHNlZ21lbnRcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgbmV4dE5vcm1hbCwgLTEsIC0xLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBuZXh0Tm9ybWFsLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNTaGFycENvcm5lciAmJiBpIDwgbGVuIC0gMSkge1xuICAgICAgICAgICAgdmFyIG5leHRTZWdtZW50TGVuZ3RoID0gY3VycmVudFZlcnRleC5kaXN0KG5leHRWZXJ0ZXgpO1xuICAgICAgICAgICAgaWYgKG5leHRTZWdtZW50TGVuZ3RoID4gMiAqIHNoYXJwQ29ybmVyT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0N1cnJlbnRWZXJ0ZXggPSBjdXJyZW50VmVydGV4LmFkZChuZXh0VmVydGV4LnN1YihjdXJyZW50VmVydGV4KS5fbXVsdChzaGFycENvcm5lck9mZnNldCAvIG5leHRTZWdtZW50TGVuZ3RoKS5fcm91bmQoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSArPSBuZXdDdXJyZW50VmVydGV4LmRpc3QoY3VycmVudFZlcnRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KG5ld0N1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIG5leHROb3JtYWwubXVsdCgxKSwgMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRWZXJ0ZXggPSBuZXdDdXJyZW50VmVydGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRPZkxpbmUgPSBmYWxzZTtcbiAgICB9XG5cbn07XG5cbi8qKlxuICogQWRkIHR3byB2ZXJ0aWNlcyB0byB0aGUgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3VycmVudFZlcnRleCB0aGUgbGluZSB2ZXJ0ZXggdG8gYWRkIGJ1ZmZlciB2ZXJ0aWNlcyBmb3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lIHRvIHRoZSB2ZXJ0ZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRMZWZ0IGV4dHJ1ZGUgdG8gc2hpZnQgdGhlIGxlZnQgdmVydGV4IGFsb25nIHRoZSBsaW5lXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kUmlnaHQgZXh0cnVkZSB0byBzaGlmdCB0aGUgbGVmdCB2ZXJ0ZXggYWxvbmcgdGhlIGxpbmVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcm91bmQgd2hldGhlciB0aGlzIGlzIGEgcm91bmQgY2FwXG4gKiBAcHJpdmF0ZVxuICovXG5MaW5lQnVja2V0LnByb3RvdHlwZS5hZGRDdXJyZW50VmVydGV4ID0gZnVuY3Rpb24oY3VycmVudFZlcnRleCwgZGlzdGFuY2UsIG5vcm1hbCwgZW5kTGVmdCwgZW5kUmlnaHQsIHJvdW5kKSB7XG4gICAgdmFyIHR4ID0gcm91bmQgPyAxIDogMDtcbiAgICB2YXIgZXh0cnVkZTtcbiAgICB2YXIgbGF5b3V0QXJyYXlzID0gdGhpcy5hcnJheUdyb3Vwcy5saW5lW3RoaXMuYXJyYXlHcm91cHMubGluZS5sZW5ndGggLSAxXS5sYXlvdXQ7XG4gICAgdmFyIHZlcnRleEFycmF5ID0gbGF5b3V0QXJyYXlzLnZlcnRleDtcbiAgICB2YXIgZWxlbWVudEFycmF5ID0gbGF5b3V0QXJyYXlzLmVsZW1lbnQ7XG5cbiAgICBleHRydWRlID0gbm9ybWFsLmNsb25lKCk7XG4gICAgaWYgKGVuZExlZnQpIGV4dHJ1ZGUuX3N1Yihub3JtYWwucGVycCgpLl9tdWx0KGVuZExlZnQpKTtcbiAgICB0aGlzLmUzID0gdGhpcy5hZGRMaW5lVmVydGV4KHZlcnRleEFycmF5LCBjdXJyZW50VmVydGV4LCBleHRydWRlLCB0eCwgMCwgZW5kTGVmdCwgZGlzdGFuY2UpO1xuICAgIGlmICh0aGlzLmUxID49IDAgJiYgdGhpcy5lMiA+PSAwKSB7XG4gICAgICAgIGVsZW1lbnRBcnJheS5lbXBsYWNlQmFjayh0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzKTtcbiAgICB9XG4gICAgdGhpcy5lMSA9IHRoaXMuZTI7XG4gICAgdGhpcy5lMiA9IHRoaXMuZTM7XG5cbiAgICBleHRydWRlID0gbm9ybWFsLm11bHQoLTEpO1xuICAgIGlmIChlbmRSaWdodCkgZXh0cnVkZS5fc3ViKG5vcm1hbC5wZXJwKCkuX211bHQoZW5kUmlnaHQpKTtcbiAgICB0aGlzLmUzID0gdGhpcy5hZGRMaW5lVmVydGV4KHZlcnRleEFycmF5LCBjdXJyZW50VmVydGV4LCBleHRydWRlLCB0eCwgMSwgLWVuZFJpZ2h0LCBkaXN0YW5jZSk7XG4gICAgaWYgKHRoaXMuZTEgPj0gMCAmJiB0aGlzLmUyID49IDApIHtcbiAgICAgICAgZWxlbWVudEFycmF5LmVtcGxhY2VCYWNrKHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMpO1xuICAgIH1cbiAgICB0aGlzLmUxID0gdGhpcy5lMjtcbiAgICB0aGlzLmUyID0gdGhpcy5lMztcblxuICAgIC8vIFRoZXJlIGlzIGEgbWF4aW11bSBcImRpc3RhbmNlIGFsb25nIHRoZSBsaW5lXCIgdGhhdCB3ZSBjYW4gc3RvcmUgaW4gdGhlIGJ1ZmZlcnMuXG4gICAgLy8gV2hlbiB3ZSBnZXQgY2xvc2UgdG8gdGhlIGRpc3RhbmNlLCByZXNldCBpdCB0byB6ZXJvIGFuZCBhZGQgdGhlIHZlcnRleCBhZ2FpbiB3aXRoXG4gICAgLy8gYSBkaXN0YW5jZSBvZiB6ZXJvLiBUaGUgbWF4IGRpc3RhbmNlIGlzIGRldGVybWluZWQgYnkgdGhlIG51bWJlciBvZiBiaXRzIHdlIGFsbG9jYXRlXG4gICAgLy8gdG8gYGxpbmVzb2ZhcmAuXG4gICAgaWYgKGRpc3RhbmNlID4gTUFYX0xJTkVfRElTVEFOQ0UgLyAyKSB7XG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgbm9ybWFsLCBlbmRMZWZ0LCBlbmRSaWdodCwgcm91bmQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQWRkIGEgc2luZ2xlIG5ldyB2ZXJ0ZXggYW5kIGEgdHJpYW5nbGUgdXNpbmcgdHdvIHByZXZpb3VzIHZlcnRpY2VzLlxuICogVGhpcyBhZGRzIGEgcGllIHNsaWNlIHRyaWFuZ2xlIG5lYXIgYSBqb2luIHRvIHNpbXVsYXRlIHJvdW5kIGpvaW5zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN1cnJlbnRWZXJ0ZXggdGhlIGxpbmUgdmVydGV4IHRvIGFkZCBidWZmZXIgdmVydGljZXMgZm9yXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGJlZ2dpbmluZyBvZiB0aGUgbGluZSB0byB0aGUgdmVydGV4XG4gKiBAcGFyYW0ge09iamVjdH0gZXh0cnVkZSB0aGUgb2Zmc2V0IG9mIHRoZSBuZXcgdmVydGV4IGZyb20gdGhlIGN1cnJlbnRWZXJ0ZXhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gd2hldGhlciB0aGUgbGluZSBpcyB0dXJuaW5nIGxlZnQgb3IgcmlnaHQgYXQgdGhpcyBhbmdsZVxuICogQHByaXZhdGVcbiAqL1xuTGluZUJ1Y2tldC5wcm90b3R5cGUuYWRkUGllU2xpY2VWZXJ0ZXggPSBmdW5jdGlvbihjdXJyZW50VmVydGV4LCBkaXN0YW5jZSwgZXh0cnVkZSwgbGluZVR1cm5zTGVmdCkge1xuICAgIHZhciB0eSA9IGxpbmVUdXJuc0xlZnQgPyAxIDogMDtcbiAgICBleHRydWRlID0gZXh0cnVkZS5tdWx0KGxpbmVUdXJuc0xlZnQgPyAtMSA6IDEpO1xuICAgIHZhciBsYXlvdXRBcnJheXMgPSB0aGlzLmFycmF5R3JvdXBzLmxpbmVbdGhpcy5hcnJheUdyb3Vwcy5saW5lLmxlbmd0aCAtIDFdLmxheW91dDtcbiAgICB2YXIgdmVydGV4QXJyYXkgPSBsYXlvdXRBcnJheXMudmVydGV4O1xuICAgIHZhciBlbGVtZW50QXJyYXkgPSBsYXlvdXRBcnJheXMuZWxlbWVudDtcblxuICAgIHRoaXMuZTMgPSB0aGlzLmFkZExpbmVWZXJ0ZXgodmVydGV4QXJyYXksIGN1cnJlbnRWZXJ0ZXgsIGV4dHJ1ZGUsIDAsIHR5LCAwLCBkaXN0YW5jZSk7XG5cbiAgICBpZiAodGhpcy5lMSA+PSAwICYmIHRoaXMuZTIgPj0gMCkge1xuICAgICAgICBlbGVtZW50QXJyYXkuZW1wbGFjZUJhY2sodGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMyk7XG4gICAgfVxuXG4gICAgaWYgKGxpbmVUdXJuc0xlZnQpIHtcbiAgICAgICAgdGhpcy5lMiA9IHRoaXMuZTM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lMSA9IHRoaXMuZTM7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxudmFyIEJ1Y2tldCA9IHJlcXVpcmUoJy4uL2J1Y2tldCcpO1xudmFyIEFuY2hvciA9IHJlcXVpcmUoJy4uLy4uL3N5bWJvbC9hbmNob3InKTtcbnZhciBnZXRBbmNob3JzID0gcmVxdWlyZSgnLi4vLi4vc3ltYm9sL2dldF9hbmNob3JzJyk7XG52YXIgcmVzb2x2ZVRva2VucyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdG9rZW4nKTtcbnZhciBRdWFkcyA9IHJlcXVpcmUoJy4uLy4uL3N5bWJvbC9xdWFkcycpO1xudmFyIFNoYXBpbmcgPSByZXF1aXJlKCcuLi8uLi9zeW1ib2wvc2hhcGluZycpO1xudmFyIHJlc29sdmVUZXh0ID0gcmVxdWlyZSgnLi4vLi4vc3ltYm9sL3Jlc29sdmVfdGV4dCcpO1xudmFyIG1lcmdlTGluZXMgPSByZXF1aXJlKCcuLi8uLi9zeW1ib2wvbWVyZ2VsaW5lcycpO1xudmFyIGNsaXBMaW5lID0gcmVxdWlyZSgnLi4vLi4vc3ltYm9sL2NsaXBfbGluZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcbnZhciBsb2FkR2VvbWV0cnkgPSByZXF1aXJlKCcuLi9sb2FkX2dlb21ldHJ5Jyk7XG52YXIgQ29sbGlzaW9uRmVhdHVyZSA9IHJlcXVpcmUoJy4uLy4uL3N5bWJvbC9jb2xsaXNpb25fZmVhdHVyZScpO1xuXG52YXIgc2hhcGVUZXh0ID0gU2hhcGluZy5zaGFwZVRleHQ7XG52YXIgc2hhcGVJY29uID0gU2hhcGluZy5zaGFwZUljb247XG52YXIgZ2V0R2x5cGhRdWFkcyA9IFF1YWRzLmdldEdseXBoUXVhZHM7XG52YXIgZ2V0SWNvblF1YWRzID0gUXVhZHMuZ2V0SWNvblF1YWRzO1xuXG52YXIgRVhURU5UID0gQnVja2V0LkVYVEVOVDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2xCdWNrZXQ7XG5cbmZ1bmN0aW9uIFN5bWJvbEJ1Y2tldChvcHRpb25zKSB7XG4gICAgQnVja2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5zaG93Q29sbGlzaW9uQm94ZXMgPSBvcHRpb25zLnNob3dDb2xsaXNpb25Cb3hlcztcbiAgICB0aGlzLm92ZXJzY2FsaW5nID0gb3B0aW9ucy5vdmVyc2NhbGluZztcbiAgICB0aGlzLmNvbGxpc2lvbkJveEFycmF5ID0gb3B0aW9ucy5jb2xsaXNpb25Cb3hBcnJheTtcblxuICAgIHRoaXMuc2RmSWNvbnMgPSBvcHRpb25zLnNkZkljb25zO1xuICAgIHRoaXMuaWNvbnNOZWVkTGluZWFyID0gb3B0aW9ucy5pY29uc05lZWRMaW5lYXI7XG4gICAgdGhpcy5hZGp1c3RlZFRleHRTaXplID0gb3B0aW9ucy5hZGp1c3RlZFRleHRTaXplO1xuICAgIHRoaXMuYWRqdXN0ZWRJY29uU2l6ZSA9IG9wdGlvbnMuYWRqdXN0ZWRJY29uU2l6ZTtcbiAgICB0aGlzLmZvbnRzdGFjayA9IG9wdGlvbnMuZm9udHN0YWNrO1xufVxuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEJ1Y2tldCwge30pO1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZXJpYWxpemVkID0gQnVja2V0LnByb3RvdHlwZS5zZXJpYWxpemUuYXBwbHkodGhpcyk7XG4gICAgc2VyaWFsaXplZC5zZGZJY29ucyA9IHRoaXMuc2RmSWNvbnM7XG4gICAgc2VyaWFsaXplZC5pY29uc05lZWRMaW5lYXIgPSB0aGlzLmljb25zTmVlZExpbmVhcjtcbiAgICBzZXJpYWxpemVkLmFkanVzdGVkVGV4dFNpemUgPSB0aGlzLmFkanVzdGVkVGV4dFNpemU7XG4gICAgc2VyaWFsaXplZC5hZGp1c3RlZEljb25TaXplID0gdGhpcy5hZGp1c3RlZEljb25TaXplO1xuICAgIHNlcmlhbGl6ZWQuZm9udHN0YWNrID0gdGhpcy5mb250c3RhY2s7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59O1xuXG52YXIgcHJvZ3JhbUF0dHJpYnV0ZXMgPSBbe1xuICAgIG5hbWU6ICdhX3BvcycsXG4gICAgY29tcG9uZW50czogMixcbiAgICB0eXBlOiAnSW50MTYnXG59LCB7XG4gICAgbmFtZTogJ2Ffb2Zmc2V0JyxcbiAgICBjb21wb25lbnRzOiAyLFxuICAgIHR5cGU6ICdJbnQxNidcbn0sIHtcbiAgICBuYW1lOiAnYV9kYXRhMScsXG4gICAgY29tcG9uZW50czogNCxcbiAgICB0eXBlOiAnVWludDgnXG59LCB7XG4gICAgbmFtZTogJ2FfZGF0YTInLFxuICAgIGNvbXBvbmVudHM6IDIsXG4gICAgdHlwZTogJ1VpbnQ4J1xufV07XG5cbmZ1bmN0aW9uIGFkZFZlcnRleChhcnJheSwgeCwgeSwgb3gsIG95LCB0eCwgdHksIG1pbnpvb20sIG1heHpvb20sIGxhYmVsbWluem9vbSkge1xuICAgIHJldHVybiBhcnJheS5lbXBsYWNlQmFjayhcbiAgICAgICAgICAgIC8vIHBvc1xuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICAvLyBvZmZzZXRcbiAgICAgICAgICAgIE1hdGgucm91bmQob3ggKiA2NCksIC8vIHVzZSAxLzY0IHBpeGVscyBmb3IgcGxhY2VtZW50XG4gICAgICAgICAgICBNYXRoLnJvdW5kKG95ICogNjQpLFxuICAgICAgICAgICAgLy8gZGF0YTFcbiAgICAgICAgICAgIHR4IC8gNCwgICAgICAgICAgICAgICAgICAgLy8gdGV4XG4gICAgICAgICAgICB0eSAvIDQsICAgICAgICAgICAgICAgICAgIC8vIHRleFxuICAgICAgICAgICAgKGxhYmVsbWluem9vbSB8fCAwKSAqIDEwLCAvLyBsYWJlbG1pbnpvb21cbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAvLyBkYXRhMlxuICAgICAgICAgICAgKG1pbnpvb20gfHwgMCkgKiAxMCwgICAgICAgICAgICAgICAvLyBtaW56b29tXG4gICAgICAgICAgICBNYXRoLm1pbihtYXh6b29tIHx8IDI1LCAyNSkgKiAxMCk7IC8vIG1pbnpvb21cbn1cblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5hZGRDb2xsaXNpb25Cb3hWZXJ0ZXggPSBmdW5jdGlvbih2ZXJ0ZXhBcnJheSwgcG9pbnQsIGV4dHJ1ZGUsIG1heFpvb20sIHBsYWNlbWVudFpvb20pIHtcbiAgICByZXR1cm4gdmVydGV4QXJyYXkuZW1wbGFjZUJhY2soXG4gICAgICAgICAgICAvLyBwb3NcbiAgICAgICAgICAgIHBvaW50LngsXG4gICAgICAgICAgICBwb2ludC55LFxuICAgICAgICAgICAgLy8gZXh0cnVkZVxuICAgICAgICAgICAgTWF0aC5yb3VuZChleHRydWRlLngpLFxuICAgICAgICAgICAgTWF0aC5yb3VuZChleHRydWRlLnkpLFxuICAgICAgICAgICAgLy8gZGF0YVxuICAgICAgICAgICAgbWF4Wm9vbSAqIDEwLFxuICAgICAgICAgICAgcGxhY2VtZW50Wm9vbSAqIDEwKTtcbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUucHJvZ3JhbUludGVyZmFjZXMgPSB7XG5cbiAgICBnbHlwaDoge1xuICAgICAgICB2ZXJ0ZXhCdWZmZXI6IHRydWUsXG4gICAgICAgIGVsZW1lbnRCdWZmZXI6IHRydWUsXG4gICAgICAgIGxheW91dEF0dHJpYnV0ZXM6IHByb2dyYW1BdHRyaWJ1dGVzXG4gICAgfSxcblxuICAgIGljb246IHtcbiAgICAgICAgdmVydGV4QnVmZmVyOiB0cnVlLFxuICAgICAgICBlbGVtZW50QnVmZmVyOiB0cnVlLFxuICAgICAgICBsYXlvdXRBdHRyaWJ1dGVzOiBwcm9ncmFtQXR0cmlidXRlc1xuICAgIH0sXG5cbiAgICBjb2xsaXNpb25Cb3g6IHtcbiAgICAgICAgdmVydGV4QnVmZmVyOiB0cnVlLFxuXG4gICAgICAgIGxheW91dEF0dHJpYnV0ZXM6IFt7XG4gICAgICAgICAgICBuYW1lOiAnYV9wb3MnLFxuICAgICAgICAgICAgY29tcG9uZW50czogMixcbiAgICAgICAgICAgIHR5cGU6ICdJbnQxNidcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2FfZXh0cnVkZScsXG4gICAgICAgICAgICBjb21wb25lbnRzOiAyLFxuICAgICAgICAgICAgdHlwZTogJ0ludDE2J1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnYV9kYXRhJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICAgICAgICB0eXBlOiAnVWludDgnXG4gICAgICAgIH1dXG4gICAgfVxufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5wb3B1bGF0ZUJ1ZmZlcnMgPSBmdW5jdGlvbihjb2xsaXNpb25UaWxlLCBzdGFja3MsIGljb25zKSB7XG5cbiAgICAvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBsYWJlbHMgdGhhdCBqdW1wIGFyb3VuZCB3aGVuIHpvb21pbmcgd2UgbmVlZFxuICAgIC8vIHRvIHVzZSBhIHRleHQtc2l6ZSB2YWx1ZSB0aGF0IGlzIHRoZSBzYW1lIGZvciBhbGwgem9vbSBsZXZlbHMuXG4gICAgLy8gVGhpcyBjYWxjdWxhdGVzIHRleHQtc2l6ZSBhdCBhIGhpZ2ggem9vbSBsZXZlbCBzbyB0aGF0IGFsbCB0aWxlcyBjYW5cbiAgICAvLyB1c2UgdGhlIHNhbWUgdmFsdWUgd2hlbiBjYWxjdWxhdGluZyBhbmNob3IgcG9zaXRpb25zLlxuICAgIHZhciB6b29tSGlzdG9yeSA9IHsgbGFzdEludGVnZXJab29tOiBJbmZpbml0eSwgbGFzdEludGVnZXJab29tVGltZTogMCwgbGFzdFpvb206IDAgfTtcbiAgICB0aGlzLmFkanVzdGVkVGV4dE1heFNpemUgPSB0aGlzLmxheWVyLmdldExheW91dFZhbHVlKCd0ZXh0LXNpemUnLCB7em9vbTogMTgsIHpvb21IaXN0b3J5OiB6b29tSGlzdG9yeX0pO1xuICAgIHRoaXMuYWRqdXN0ZWRUZXh0U2l6ZSA9IHRoaXMubGF5ZXIuZ2V0TGF5b3V0VmFsdWUoJ3RleHQtc2l6ZScsIHt6b29tOiB0aGlzLnpvb20gKyAxLCB6b29tSGlzdG9yeTogem9vbUhpc3Rvcnl9KTtcbiAgICB0aGlzLmFkanVzdGVkSWNvbk1heFNpemUgPSB0aGlzLmxheWVyLmdldExheW91dFZhbHVlKCdpY29uLXNpemUnLCB7em9vbTogMTgsIHpvb21IaXN0b3J5OiB6b29tSGlzdG9yeX0pO1xuICAgIHRoaXMuYWRqdXN0ZWRJY29uU2l6ZSA9IHRoaXMubGF5ZXIuZ2V0TGF5b3V0VmFsdWUoJ2ljb24tc2l6ZScsIHt6b29tOiB0aGlzLnpvb20gKyAxLCB6b29tSGlzdG9yeTogem9vbUhpc3Rvcnl9KTtcblxuICAgIHZhciB0aWxlU2l6ZSA9IDUxMiAqIHRoaXMub3ZlcnNjYWxpbmc7XG4gICAgdGhpcy50aWxlUGl4ZWxSYXRpbyA9IEVYVEVOVCAvIHRpbGVTaXplO1xuICAgIHRoaXMuY29tcGFyZVRleHQgPSB7fTtcbiAgICB0aGlzLnN5bWJvbEluc3RhbmNlcyA9IFtdO1xuICAgIHRoaXMuaWNvbnNOZWVkTGluZWFyID0gZmFsc2U7XG5cbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5sYXllci5sYXlvdXQ7XG4gICAgdmFyIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlcztcbiAgICB2YXIgdGV4dEZlYXR1cmVzID0gdGhpcy50ZXh0RmVhdHVyZXM7XG5cbiAgICB2YXIgaG9yaXpvbnRhbEFsaWduID0gMC41LFxuICAgICAgICB2ZXJ0aWNhbEFsaWduID0gMC41O1xuXG4gICAgc3dpdGNoIChsYXlvdXRbJ3RleHQtYW5jaG9yJ10pIHtcbiAgICBjYXNlICdyaWdodCc6XG4gICAgY2FzZSAndG9wLXJpZ2h0JzpcbiAgICBjYXNlICdib3R0b20tcmlnaHQnOlxuICAgICAgICBob3Jpem9udGFsQWxpZ24gPSAxO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdsZWZ0JzpcbiAgICBjYXNlICd0b3AtbGVmdCc6XG4gICAgY2FzZSAnYm90dG9tLWxlZnQnOlxuICAgICAgICBob3Jpem9udGFsQWxpZ24gPSAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGxheW91dFsndGV4dC1hbmNob3InXSkge1xuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgY2FzZSAnYm90dG9tLXJpZ2h0JzpcbiAgICBjYXNlICdib3R0b20tbGVmdCc6XG4gICAgICAgIHZlcnRpY2FsQWxpZ24gPSAxO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICd0b3AnOlxuICAgIGNhc2UgJ3RvcC1yaWdodCc6XG4gICAgY2FzZSAndG9wLWxlZnQnOlxuICAgICAgICB2ZXJ0aWNhbEFsaWduID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGp1c3RpZnkgPSBsYXlvdXRbJ3RleHQtanVzdGlmeSddID09PSAncmlnaHQnID8gMSA6XG4gICAgICAgIGxheW91dFsndGV4dC1qdXN0aWZ5J10gPT09ICdsZWZ0JyA/IDAgOlxuICAgICAgICAwLjU7XG5cbiAgICB2YXIgb25lRW0gPSAyNDtcbiAgICB2YXIgbGluZUhlaWdodCA9IGxheW91dFsndGV4dC1saW5lLWhlaWdodCddICogb25lRW07XG4gICAgdmFyIG1heFdpZHRoID0gbGF5b3V0WydzeW1ib2wtcGxhY2VtZW50J10gIT09ICdsaW5lJyA/IGxheW91dFsndGV4dC1tYXgtd2lkdGgnXSAqIG9uZUVtIDogMDtcbiAgICB2YXIgc3BhY2luZyA9IGxheW91dFsndGV4dC1sZXR0ZXItc3BhY2luZyddICogb25lRW07XG4gICAgdmFyIHRleHRPZmZzZXQgPSBbbGF5b3V0Wyd0ZXh0LW9mZnNldCddWzBdICogb25lRW0sIGxheW91dFsndGV4dC1vZmZzZXQnXVsxXSAqIG9uZUVtXTtcbiAgICB2YXIgZm9udHN0YWNrID0gdGhpcy5mb250c3RhY2sgPSBsYXlvdXRbJ3RleHQtZm9udCddLmpvaW4oJywnKTtcblxuICAgIHZhciBnZW9tZXRyaWVzID0gW107XG4gICAgZm9yICh2YXIgZyA9IDA7IGcgPCBmZWF0dXJlcy5sZW5ndGg7IGcrKykge1xuICAgICAgICBnZW9tZXRyaWVzLnB1c2gobG9hZEdlb21ldHJ5KGZlYXR1cmVzW2ddKSk7XG4gICAgfVxuXG4gICAgaWYgKGxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZScpIHtcbiAgICAgICAgLy8gTWVyZ2UgYWRqYWNlbnQgbGluZXMgd2l0aCB0aGUgc2FtZSB0ZXh0IHRvIGltcHJvdmUgbGFiZWxsaW5nLlxuICAgICAgICAvLyBJdCdzIGJldHRlciB0byBwbGFjZSBsYWJlbHMgb24gb25lIGxvbmcgbGluZSB0aGFuIG9uIG1hbnkgc2hvcnQgc2VnbWVudHMuXG4gICAgICAgIHZhciBtZXJnZWQgPSBtZXJnZUxpbmVzKGZlYXR1cmVzLCB0ZXh0RmVhdHVyZXMsIGdlb21ldHJpZXMpO1xuXG4gICAgICAgIGdlb21ldHJpZXMgPSBtZXJnZWQuZ2VvbWV0cmllcztcbiAgICAgICAgZmVhdHVyZXMgPSBtZXJnZWQuZmVhdHVyZXM7XG4gICAgICAgIHRleHRGZWF0dXJlcyA9IG1lcmdlZC50ZXh0RmVhdHVyZXM7XG4gICAgfVxuXG4gICAgdmFyIHNoYXBlZFRleHQsIHNoYXBlZEljb247XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGZlYXR1cmVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGlmICghZ2VvbWV0cmllc1trXSkgY29udGludWU7XG5cbiAgICAgICAgaWYgKHRleHRGZWF0dXJlc1trXSkge1xuICAgICAgICAgICAgc2hhcGVkVGV4dCA9IHNoYXBlVGV4dCh0ZXh0RmVhdHVyZXNba10sIHN0YWNrc1tmb250c3RhY2tdLCBtYXhXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodCwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBqdXN0aWZ5LCBzcGFjaW5nLCB0ZXh0T2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNoYXBlZFRleHQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxheW91dFsnaWNvbi1pbWFnZSddKSB7XG4gICAgICAgICAgICB2YXIgaWNvbk5hbWUgPSByZXNvbHZlVG9rZW5zKGZlYXR1cmVzW2tdLnByb3BlcnRpZXMsIGxheW91dFsnaWNvbi1pbWFnZSddKTtcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IGljb25zW2ljb25OYW1lXTtcbiAgICAgICAgICAgIHNoYXBlZEljb24gPSBzaGFwZUljb24oaW1hZ2UsIGxheW91dCk7XG5cbiAgICAgICAgICAgIGlmIChpbWFnZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNkZkljb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZGZJY29ucyA9IGltYWdlLnNkZjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2RmSWNvbnMgIT09IGltYWdlLnNkZikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1N0eWxlIHNoZWV0IHdhcm5pbmc6IENhbm5vdCBtaXggU0RGIGFuZCBub24tU0RGIGljb25zIGluIG9uZSBidWZmZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlLnBpeGVsUmF0aW8gIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pY29uc05lZWRMaW5lYXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNoYXBlZEljb24gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlZFRleHQgfHwgc2hhcGVkSWNvbikge1xuICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlKGdlb21ldHJpZXNba10sIHNoYXBlZFRleHQsIHNoYXBlZEljb24sIGZlYXR1cmVzW2tdLmluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucGxhY2VGZWF0dXJlcyhjb2xsaXNpb25UaWxlLCB0aGlzLnNob3dDb2xsaXNpb25Cb3hlcyk7XG5cbiAgICB0aGlzLnRyaW1BcnJheXMoKTtcbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uKGxpbmVzLCBzaGFwZWRUZXh0LCBzaGFwZWRJY29uLCBmZWF0dXJlSW5kZXgpIHtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5sYXllci5sYXlvdXQ7XG5cbiAgICB2YXIgZ2x5cGhTaXplID0gMjQ7XG5cbiAgICB2YXIgZm9udFNjYWxlID0gdGhpcy5hZGp1c3RlZFRleHRTaXplIC8gZ2x5cGhTaXplLFxuICAgICAgICB0ZXh0TWF4U2l6ZSA9IHRoaXMuYWRqdXN0ZWRUZXh0TWF4U2l6ZSAhPT0gdW5kZWZpbmVkID8gdGhpcy5hZGp1c3RlZFRleHRNYXhTaXplIDogdGhpcy5hZGp1c3RlZFRleHRTaXplLFxuICAgICAgICB0ZXh0Qm94U2NhbGUgPSB0aGlzLnRpbGVQaXhlbFJhdGlvICogZm9udFNjYWxlLFxuICAgICAgICB0ZXh0TWF4Qm94U2NhbGUgPSB0aGlzLnRpbGVQaXhlbFJhdGlvICogdGV4dE1heFNpemUgLyBnbHlwaFNpemUsXG4gICAgICAgIGljb25Cb3hTY2FsZSA9IHRoaXMudGlsZVBpeGVsUmF0aW8gKiB0aGlzLmFkanVzdGVkSWNvblNpemUsXG4gICAgICAgIHN5bWJvbE1pbkRpc3RhbmNlID0gdGhpcy50aWxlUGl4ZWxSYXRpbyAqIGxheW91dFsnc3ltYm9sLXNwYWNpbmcnXSxcbiAgICAgICAgYXZvaWRFZGdlcyA9IGxheW91dFsnc3ltYm9sLWF2b2lkLWVkZ2VzJ10sXG4gICAgICAgIHRleHRQYWRkaW5nID0gbGF5b3V0Wyd0ZXh0LXBhZGRpbmcnXSAqIHRoaXMudGlsZVBpeGVsUmF0aW8sXG4gICAgICAgIGljb25QYWRkaW5nID0gbGF5b3V0WydpY29uLXBhZGRpbmcnXSAqIHRoaXMudGlsZVBpeGVsUmF0aW8sXG4gICAgICAgIHRleHRNYXhBbmdsZSA9IGxheW91dFsndGV4dC1tYXgtYW5nbGUnXSAvIDE4MCAqIE1hdGguUEksXG4gICAgICAgIHRleHRBbG9uZ0xpbmUgPSBsYXlvdXRbJ3RleHQtcm90YXRpb24tYWxpZ25tZW50J10gPT09ICdtYXAnICYmIGxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZScsXG4gICAgICAgIGljb25BbG9uZ0xpbmUgPSBsYXlvdXRbJ2ljb24tcm90YXRpb24tYWxpZ25tZW50J10gPT09ICdtYXAnICYmIGxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZScsXG4gICAgICAgIG1heU92ZXJsYXAgPSBsYXlvdXRbJ3RleHQtYWxsb3ctb3ZlcmxhcCddIHx8IGxheW91dFsnaWNvbi1hbGxvdy1vdmVybGFwJ10gfHxcbiAgICAgICAgICAgIGxheW91dFsndGV4dC1pZ25vcmUtcGxhY2VtZW50J10gfHwgbGF5b3V0WydpY29uLWlnbm9yZS1wbGFjZW1lbnQnXSxcbiAgICAgICAgaXNMaW5lID0gbGF5b3V0WydzeW1ib2wtcGxhY2VtZW50J10gPT09ICdsaW5lJyxcbiAgICAgICAgdGV4dFJlcGVhdERpc3RhbmNlID0gc3ltYm9sTWluRGlzdGFuY2UgLyAyO1xuXG4gICAgaWYgKGlzTGluZSkge1xuICAgICAgICBsaW5lcyA9IGNsaXBMaW5lKGxpbmVzLCAwLCAwLCBFWFRFTlQsIEVYVEVOVCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYW5jaG9yIHBvaW50cyBhcm91bmQgd2hpY2ggeW91IHdhbnQgdG8gcGxhY2UgbGFiZWxzXG4gICAgICAgIHZhciBhbmNob3JzO1xuICAgICAgICBpZiAoaXNMaW5lKSB7XG4gICAgICAgICAgICBhbmNob3JzID0gZ2V0QW5jaG9ycyhcbiAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgIHN5bWJvbE1pbkRpc3RhbmNlLFxuICAgICAgICAgICAgICAgIHRleHRNYXhBbmdsZSxcbiAgICAgICAgICAgICAgICBzaGFwZWRUZXh0LFxuICAgICAgICAgICAgICAgIHNoYXBlZEljb24sXG4gICAgICAgICAgICAgICAgZ2x5cGhTaXplLFxuICAgICAgICAgICAgICAgIHRleHRNYXhCb3hTY2FsZSxcbiAgICAgICAgICAgICAgICB0aGlzLm92ZXJzY2FsaW5nLFxuICAgICAgICAgICAgICAgIEVYVEVOVFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcnMgPSBbIG5ldyBBbmNob3IobGluZVswXS54LCBsaW5lWzBdLnksIDApIF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3IgZWFjaCBwb3RlbnRpYWwgbGFiZWwsIGNyZWF0ZSB0aGUgcGxhY2VtZW50IGZlYXR1cmVzIHVzZWQgdG8gY2hlY2sgZm9yIGNvbGxpc2lvbnMsIGFuZCB0aGUgcXVhZHMgdXNlIGZvciByZW5kZXJpbmcuXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBhbmNob3JzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gYW5jaG9yc1tqXTtcblxuICAgICAgICAgICAgaWYgKHNoYXBlZFRleHQgJiYgaXNMaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5jaG9ySXNUb29DbG9zZShzaGFwZWRUZXh0LnRleHQsIHRleHRSZXBlYXREaXN0YW5jZSwgYW5jaG9yKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbnNpZGUgPSAhKGFuY2hvci54IDwgMCB8fCBhbmNob3IueCA+IEVYVEVOVCB8fCBhbmNob3IueSA8IDAgfHwgYW5jaG9yLnkgPiBFWFRFTlQpO1xuXG4gICAgICAgICAgICBpZiAoYXZvaWRFZGdlcyAmJiAhaW5zaWRlKSBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gTm9ybWFsbHkgc3ltYm9sIGxheWVycyBhcmUgZHJhd24gYWNyb3NzIHRpbGUgYm91bmRhcmllcy4gT25seSBzeW1ib2xzXG4gICAgICAgICAgICAvLyB3aXRoIHRoZWlyIGFuY2hvcnMgd2l0aGluIHRoZSB0aWxlIGJvdW5kYXJpZXMgYXJlIGFkZGVkIHRvIHRoZSBidWZmZXJzXG4gICAgICAgICAgICAvLyB0byBwcmV2ZW50IHN5bWJvbHMgZnJvbSBiZWluZyBkcmF3biB0d2ljZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBTeW1ib2xzIGluIGxheWVycyB3aXRoIG92ZXJsYXAgYXJlIHNvcnRlZCBpbiB0aGUgeSBkaXJlY3Rpb24gc28gdGhhdFxuICAgICAgICAgICAgLy8gc3ltYm9scyBsb3dlciBvbiB0aGUgY2FudmFzIGFyZSBkcmF3biBvbiB0b3Agb2Ygc3ltYm9scyBuZWFyIHRoZSB0b3AuXG4gICAgICAgICAgICAvLyBUbyBwcmVzZXJ2ZSB0aGlzIG9yZGVyIGFjcm9zcyB0aWxlIGJvdW5kYXJpZXMgdGhlc2Ugc3ltYm9scyBjYW4ndFxuICAgICAgICAgICAgLy8gYmUgZHJhd24gYWNyb3NzIHRpbGUgYm91bmRhcmllcy4gSW5zdGVhZCB0aGV5IG5lZWQgdG8gYmUgaW5jbHVkZWQgaW5cbiAgICAgICAgICAgIC8vIHRoZSBidWZmZXJzIGZvciBib3RoIHRpbGVzIGFuZCBjbGlwcGVkIHRvIHRpbGUgYm91bmRhcmllcyBhdCBkcmF3IHRpbWUuXG4gICAgICAgICAgICB2YXIgYWRkVG9CdWZmZXJzID0gaW5zaWRlIHx8IG1heU92ZXJsYXA7XG5cbiAgICAgICAgICAgIHRoaXMuc3ltYm9sSW5zdGFuY2VzLnB1c2gobmV3IFN5bWJvbEluc3RhbmNlKGFuY2hvciwgbGluZSwgc2hhcGVkVGV4dCwgc2hhcGVkSWNvbiwgbGF5b3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkVG9CdWZmZXJzLCB0aGlzLnN5bWJvbEluc3RhbmNlcy5sZW5ndGgsIHRoaXMuY29sbGlzaW9uQm94QXJyYXksIGZlYXR1cmVJbmRleCwgdGhpcy5zb3VyY2VMYXllckluZGV4LCB0aGlzLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEJveFNjYWxlLCB0ZXh0UGFkZGluZywgdGV4dEFsb25nTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25Cb3hTY2FsZSwgaWNvblBhZGRpbmcsIGljb25BbG9uZ0xpbmUpKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuYW5jaG9ySXNUb29DbG9zZSA9IGZ1bmN0aW9uKHRleHQsIHJlcGVhdERpc3RhbmNlLCBhbmNob3IpIHtcbiAgICB2YXIgY29tcGFyZVRleHQgPSB0aGlzLmNvbXBhcmVUZXh0O1xuICAgIGlmICghKHRleHQgaW4gY29tcGFyZVRleHQpKSB7XG4gICAgICAgIGNvbXBhcmVUZXh0W3RleHRdID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG90aGVyQW5jaG9ycyA9IGNvbXBhcmVUZXh0W3RleHRdO1xuICAgICAgICBmb3IgKHZhciBrID0gb3RoZXJBbmNob3JzLmxlbmd0aCAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgICAgICBpZiAoYW5jaG9yLmRpc3Qob3RoZXJBbmNob3JzW2tdKSA8IHJlcGVhdERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyB3aXRoaW4gcmVwZWF0RGlzdGFuY2Ugb2Ygb25lIGFuY2hvciwgc3RvcCBsb29raW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgYW5jaG9yIGlzIG5vdCB3aXRoaW4gcmVwZWF0RGlzdGFuY2Ugb2YgYW55IG90aGVyIGFuY2hvciwgYWRkIHRvIGFycmF5XG4gICAgY29tcGFyZVRleHRbdGV4dF0ucHVzaChhbmNob3IpO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUucGxhY2VGZWF0dXJlcyA9IGZ1bmN0aW9uKGNvbGxpc2lvblRpbGUsIHNob3dDb2xsaXNpb25Cb3hlcykge1xuICAgIHRoaXMucmVjYWxjdWxhdGVTdHlsZUxheWVycygpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHdoaWNoIGxhYmVscyBjYW4gYmUgc2hvd24gYW5kIHdoZW4gdGhleSBjYW4gYmUgc2hvd24gYW5kXG4gICAgLy8gY3JlYXRlIHRoZSBidWZlcnMgdXNlZCBmb3IgcmVuZGVyaW5nLlxuXG4gICAgdGhpcy5jcmVhdGVBcnJheXMoKTtcblxuICAgIHZhciBsYXlvdXQgPSB0aGlzLmxheWVyLmxheW91dDtcblxuICAgIHZhciBtYXhTY2FsZSA9IGNvbGxpc2lvblRpbGUubWF4U2NhbGU7XG5cbiAgICB2YXIgdGV4dEFsb25nTGluZSA9IGxheW91dFsndGV4dC1yb3RhdGlvbi1hbGlnbm1lbnQnXSA9PT0gJ21hcCcgJiYgbGF5b3V0WydzeW1ib2wtcGxhY2VtZW50J10gPT09ICdsaW5lJztcbiAgICB2YXIgaWNvbkFsb25nTGluZSA9IGxheW91dFsnaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnQnXSA9PT0gJ21hcCcgJiYgbGF5b3V0WydzeW1ib2wtcGxhY2VtZW50J10gPT09ICdsaW5lJztcblxuICAgIHZhciBtYXlPdmVybGFwID0gbGF5b3V0Wyd0ZXh0LWFsbG93LW92ZXJsYXAnXSB8fCBsYXlvdXRbJ2ljb24tYWxsb3ctb3ZlcmxhcCddIHx8XG4gICAgICAgIGxheW91dFsndGV4dC1pZ25vcmUtcGxhY2VtZW50J10gfHwgbGF5b3V0WydpY29uLWlnbm9yZS1wbGFjZW1lbnQnXTtcblxuICAgIC8vIFNvcnQgc3ltYm9scyBieSB0aGVpciB5IHBvc2l0aW9uIG9uIHRoZSBjYW52YXMgc28gdGhhdCB0aGV5IGxvd2VyIHN5bWJvbHNcbiAgICAvLyBhcmUgZHJhd24gb24gdG9wIG9mIGhpZ2hlciBzeW1ib2xzLlxuICAgIC8vIERvbid0IHNvcnQgc3ltYm9scyB0aGF0IHdvbid0IG92ZXJsYXAgYmVjYXVzZSBpdCBpc24ndCBuZWNlc3NhcnkgYW5kXG4gICAgLy8gYmVjYXVzZSBpdCBjYXVzZXMgbW9yZSBsYWJlbHMgdG8gcG9wIGluIGFuZCBvdXQgd2hlbiByb3RhdGluZy5cbiAgICBpZiAobWF5T3ZlcmxhcCkge1xuICAgICAgICB2YXIgYW5nbGUgPSBjb2xsaXNpb25UaWxlLmFuZ2xlO1xuICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuXG4gICAgICAgIHRoaXMuc3ltYm9sSW5zdGFuY2VzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgdmFyIGFSb3RhdGVkID0gKHNpbiAqIGEueCArIGNvcyAqIGEueSkgfCAwO1xuICAgICAgICAgICAgdmFyIGJSb3RhdGVkID0gKHNpbiAqIGIueCArIGNvcyAqIGIueSkgfCAwO1xuICAgICAgICAgICAgcmV0dXJuIChhUm90YXRlZCAtIGJSb3RhdGVkKSB8fCAoYi5pbmRleCAtIGEuaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwID0gMDsgcCA8IHRoaXMuc3ltYm9sSW5zdGFuY2VzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgIHZhciBzeW1ib2xJbnN0YW5jZSA9IHRoaXMuc3ltYm9sSW5zdGFuY2VzW3BdO1xuICAgICAgICB2YXIgaGFzVGV4dCA9IHN5bWJvbEluc3RhbmNlLmhhc1RleHQ7XG4gICAgICAgIHZhciBoYXNJY29uID0gc3ltYm9sSW5zdGFuY2UuaGFzSWNvbjtcblxuICAgICAgICB2YXIgaWNvbldpdGhvdXRUZXh0ID0gbGF5b3V0Wyd0ZXh0LW9wdGlvbmFsJ10gfHwgIWhhc1RleHQsXG4gICAgICAgICAgICB0ZXh0V2l0aG91dEljb24gPSBsYXlvdXRbJ2ljb24tb3B0aW9uYWwnXSB8fCAhaGFzSWNvbjtcblxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgc2NhbGVzIGF0IHdoaWNoIHRoZSB0ZXh0IGFuZCBpY29uIGNhbiBiZSBwbGFjZWQgd2l0aG91dCBjb2xsaXNpb24uXG5cbiAgICAgICAgdmFyIGdseXBoU2NhbGUgPSBoYXNUZXh0ID9cbiAgICAgICAgICAgIGNvbGxpc2lvblRpbGUucGxhY2VDb2xsaXNpb25GZWF0dXJlKHN5bWJvbEluc3RhbmNlLnRleHRDb2xsaXNpb25GZWF0dXJlLFxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRbJ3RleHQtYWxsb3ctb3ZlcmxhcCddLCBsYXlvdXRbJ3N5bWJvbC1hdm9pZC1lZGdlcyddKSA6XG4gICAgICAgICAgICBjb2xsaXNpb25UaWxlLm1pblNjYWxlO1xuXG4gICAgICAgIHZhciBpY29uU2NhbGUgPSBoYXNJY29uID9cbiAgICAgICAgICAgIGNvbGxpc2lvblRpbGUucGxhY2VDb2xsaXNpb25GZWF0dXJlKHN5bWJvbEluc3RhbmNlLmljb25Db2xsaXNpb25GZWF0dXJlLFxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRbJ2ljb24tYWxsb3ctb3ZlcmxhcCddLCBsYXlvdXRbJ3N5bWJvbC1hdm9pZC1lZGdlcyddKSA6XG4gICAgICAgICAgICBjb2xsaXNpb25UaWxlLm1pblNjYWxlO1xuXG5cbiAgICAgICAgLy8gQ29tYmluZSB0aGUgc2NhbGVzIGZvciBpY29ucyBhbmQgdGV4dC5cblxuICAgICAgICBpZiAoIWljb25XaXRob3V0VGV4dCAmJiAhdGV4dFdpdGhvdXRJY29uKSB7XG4gICAgICAgICAgICBpY29uU2NhbGUgPSBnbHlwaFNjYWxlID0gTWF0aC5tYXgoaWNvblNjYWxlLCBnbHlwaFNjYWxlKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGV4dFdpdGhvdXRJY29uICYmIGdseXBoU2NhbGUpIHtcbiAgICAgICAgICAgIGdseXBoU2NhbGUgPSBNYXRoLm1heChpY29uU2NhbGUsIGdseXBoU2NhbGUpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpY29uV2l0aG91dFRleHQgJiYgaWNvblNjYWxlKSB7XG4gICAgICAgICAgICBpY29uU2NhbGUgPSBNYXRoLm1heChpY29uU2NhbGUsIGdseXBoU2NhbGUpO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBJbnNlcnQgZmluYWwgcGxhY2VtZW50IGludG8gY29sbGlzaW9uIHRyZWUgYW5kIGFkZCBnbHlwaHMvaWNvbnMgdG8gYnVmZmVyc1xuXG4gICAgICAgIGlmIChoYXNUZXh0KSB7XG4gICAgICAgICAgICBjb2xsaXNpb25UaWxlLmluc2VydENvbGxpc2lvbkZlYXR1cmUoc3ltYm9sSW5zdGFuY2UudGV4dENvbGxpc2lvbkZlYXR1cmUsIGdseXBoU2NhbGUsIGxheW91dFsndGV4dC1pZ25vcmUtcGxhY2VtZW50J10pO1xuICAgICAgICAgICAgaWYgKGdseXBoU2NhbGUgPD0gbWF4U2NhbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFN5bWJvbHMoJ2dseXBoJywgc3ltYm9sSW5zdGFuY2UuZ2x5cGhRdWFkcywgZ2x5cGhTY2FsZSwgbGF5b3V0Wyd0ZXh0LWtlZXAtdXByaWdodCddLCB0ZXh0QWxvbmdMaW5lLCBjb2xsaXNpb25UaWxlLmFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNJY29uKSB7XG4gICAgICAgICAgICBjb2xsaXNpb25UaWxlLmluc2VydENvbGxpc2lvbkZlYXR1cmUoc3ltYm9sSW5zdGFuY2UuaWNvbkNvbGxpc2lvbkZlYXR1cmUsIGljb25TY2FsZSwgbGF5b3V0WydpY29uLWlnbm9yZS1wbGFjZW1lbnQnXSk7XG4gICAgICAgICAgICBpZiAoaWNvblNjYWxlIDw9IG1heFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTeW1ib2xzKCdpY29uJywgc3ltYm9sSW5zdGFuY2UuaWNvblF1YWRzLCBpY29uU2NhbGUsIGxheW91dFsnaWNvbi1rZWVwLXVwcmlnaHQnXSwgaWNvbkFsb25nTGluZSwgY29sbGlzaW9uVGlsZS5hbmdsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGlmIChzaG93Q29sbGlzaW9uQm94ZXMpIHRoaXMuYWRkVG9EZWJ1Z0J1ZmZlcnMoY29sbGlzaW9uVGlsZSk7XG59O1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLmFkZFN5bWJvbHMgPSBmdW5jdGlvbihwcm9ncmFtTmFtZSwgcXVhZHMsIHNjYWxlLCBrZWVwVXByaWdodCwgYWxvbmdMaW5lLCBwbGFjZW1lbnRBbmdsZSkge1xuXG4gICAgdmFyIGdyb3VwID0gdGhpcy5tYWtlUm9vbUZvcihwcm9ncmFtTmFtZSwgNCAqIHF1YWRzLmxlbmd0aCk7XG5cbiAgICB2YXIgZWxlbWVudEFycmF5ID0gZ3JvdXAubGF5b3V0LmVsZW1lbnQ7XG4gICAgdmFyIHZlcnRleEFycmF5ID0gZ3JvdXAubGF5b3V0LnZlcnRleDtcblxuICAgIHZhciB6b29tID0gdGhpcy56b29tO1xuICAgIHZhciBwbGFjZW1lbnRab29tID0gTWF0aC5tYXgoTWF0aC5sb2coc2NhbGUpIC8gTWF0aC5MTjIgKyB6b29tLCAwKTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcXVhZHMubGVuZ3RoOyBrKyspIHtcblxuICAgICAgICB2YXIgc3ltYm9sID0gcXVhZHNba10sXG4gICAgICAgICAgICBhbmdsZSA9IHN5bWJvbC5hbmdsZTtcblxuICAgICAgICAvLyBkcm9wIHVwc2lkZSBkb3duIHZlcnNpb25zIG9mIGdseXBoc1xuICAgICAgICB2YXIgYSA9IChhbmdsZSArIHBsYWNlbWVudEFuZ2xlICsgTWF0aC5QSSkgJSAoTWF0aC5QSSAqIDIpO1xuICAgICAgICBpZiAoa2VlcFVwcmlnaHQgJiYgYWxvbmdMaW5lICYmIChhIDw9IE1hdGguUEkgLyAyIHx8IGEgPiBNYXRoLlBJICogMyAvIDIpKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgdGwgPSBzeW1ib2wudGwsXG4gICAgICAgICAgICB0ciA9IHN5bWJvbC50cixcbiAgICAgICAgICAgIGJsID0gc3ltYm9sLmJsLFxuICAgICAgICAgICAgYnIgPSBzeW1ib2wuYnIsXG4gICAgICAgICAgICB0ZXggPSBzeW1ib2wudGV4LFxuICAgICAgICAgICAgYW5jaG9yUG9pbnQgPSBzeW1ib2wuYW5jaG9yUG9pbnQsXG5cbiAgICAgICAgICAgIG1pblpvb20gPSBNYXRoLm1heCh6b29tICsgTWF0aC5sb2coc3ltYm9sLm1pblNjYWxlKSAvIE1hdGguTE4yLCBwbGFjZW1lbnRab29tKSxcbiAgICAgICAgICAgIG1heFpvb20gPSBNYXRoLm1pbih6b29tICsgTWF0aC5sb2coc3ltYm9sLm1heFNjYWxlKSAvIE1hdGguTE4yLCAyNSk7XG5cbiAgICAgICAgaWYgKG1heFpvb20gPD0gbWluWm9vbSkgY29udGludWU7XG5cbiAgICAgICAgLy8gTG93ZXIgbWluIHpvb20gc28gdGhhdCB3aGlsZSBmYWRpbmcgb3V0IHRoZSBsYWJlbCBpdCBjYW4gYmUgc2hvd24gb3V0c2lkZSBvZiBjb2xsaXNpb24tZnJlZSB6b29tIGxldmVsc1xuICAgICAgICBpZiAobWluWm9vbSA9PT0gcGxhY2VtZW50Wm9vbSkgbWluWm9vbSA9IDA7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gYWRkVmVydGV4KHZlcnRleEFycmF5LCBhbmNob3JQb2ludC54LCBhbmNob3JQb2ludC55LCB0bC54LCB0bC55LCB0ZXgueCwgdGV4LnksIG1pblpvb20sIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICBhZGRWZXJ0ZXgodmVydGV4QXJyYXksIGFuY2hvclBvaW50LngsIGFuY2hvclBvaW50LnksIHRyLngsIHRyLnksIHRleC54ICsgdGV4LncsIHRleC55LCBtaW5ab29tLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgYWRkVmVydGV4KHZlcnRleEFycmF5LCBhbmNob3JQb2ludC54LCBhbmNob3JQb2ludC55LCBibC54LCBibC55LCB0ZXgueCwgdGV4LnkgKyB0ZXguaCwgbWluWm9vbSwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgIGFkZFZlcnRleCh2ZXJ0ZXhBcnJheSwgYW5jaG9yUG9pbnQueCwgYW5jaG9yUG9pbnQueSwgYnIueCwgYnIueSwgdGV4LnggKyB0ZXgudywgdGV4LnkgKyB0ZXguaCwgbWluWm9vbSwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG5cbiAgICAgICAgZWxlbWVudEFycmF5LmVtcGxhY2VCYWNrKGluZGV4LCBpbmRleCArIDEsIGluZGV4ICsgMik7XG4gICAgICAgIGVsZW1lbnRBcnJheS5lbXBsYWNlQmFjayhpbmRleCArIDEsIGluZGV4ICsgMiwgaW5kZXggKyAzKTtcbiAgICB9XG5cbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUudXBkYXRlSWNvbnMgPSBmdW5jdGlvbihpY29ucykge1xuICAgIHRoaXMucmVjYWxjdWxhdGVTdHlsZUxheWVycygpO1xuICAgIHZhciBpY29uVmFsdWUgPSB0aGlzLmxheWVyLmxheW91dFsnaWNvbi1pbWFnZSddO1xuICAgIGlmICghaWNvblZhbHVlKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGljb25OYW1lID0gcmVzb2x2ZVRva2Vucyh0aGlzLmZlYXR1cmVzW2ldLnByb3BlcnRpZXMsIGljb25WYWx1ZSk7XG4gICAgICAgIGlmIChpY29uTmFtZSlcbiAgICAgICAgICAgIGljb25zW2ljb25OYW1lXSA9IHRydWU7XG4gICAgfVxufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS51cGRhdGVGb250ID0gZnVuY3Rpb24oc3RhY2tzKSB7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZVN0eWxlTGF5ZXJzKCk7XG4gICAgdmFyIGZvbnROYW1lID0gdGhpcy5sYXllci5sYXlvdXRbJ3RleHQtZm9udCddLFxuICAgICAgICBzdGFjayA9IHN0YWNrc1tmb250TmFtZV0gPSBzdGFja3NbZm9udE5hbWVdIHx8IHt9O1xuXG4gICAgdGhpcy50ZXh0RmVhdHVyZXMgPSByZXNvbHZlVGV4dCh0aGlzLmZlYXR1cmVzLCB0aGlzLmxheWVyLmxheW91dCwgc3RhY2spO1xufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5hZGRUb0RlYnVnQnVmZmVycyA9IGZ1bmN0aW9uKGNvbGxpc2lvblRpbGUpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLm1ha2VSb29tRm9yKCdjb2xsaXNpb25Cb3gnLCAwKTtcbiAgICB2YXIgdmVydGV4QXJyYXkgPSBncm91cC5sYXlvdXQudmVydGV4O1xuICAgIHZhciBhbmdsZSA9IC1jb2xsaXNpb25UaWxlLmFuZ2xlO1xuICAgIHZhciB5U3RyZXRjaCA9IGNvbGxpc2lvblRpbGUueVN0cmV0Y2g7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuc3ltYm9sSW5zdGFuY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZSA9IHRoaXMuc3ltYm9sSW5zdGFuY2VzW2pdW2kgPT09IDAgPyAndGV4dENvbGxpc2lvbkZlYXR1cmUnIDogJ2ljb25Db2xsaXNpb25GZWF0dXJlJ107XG4gICAgICAgICAgICBpZiAoIWZlYXR1cmUpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gZmVhdHVyZS5ib3hTdGFydEluZGV4OyBiIDwgZmVhdHVyZS5ib3hFbmRJbmRleDsgYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJveCA9IHRoaXMuY29sbGlzaW9uQm94QXJyYXkuZ2V0KGIpO1xuICAgICAgICAgICAgICAgIHZhciBhbmNob3JQb2ludCA9IGJveC5hbmNob3JQb2ludDtcblxuICAgICAgICAgICAgICAgIHZhciB0bCA9IG5ldyBQb2ludChib3gueDEsIGJveC55MSAqIHlTdHJldGNoKS5fcm90YXRlKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICB2YXIgdHIgPSBuZXcgUG9pbnQoYm94LngyLCBib3gueTEgKiB5U3RyZXRjaCkuX3JvdGF0ZShhbmdsZSk7XG4gICAgICAgICAgICAgICAgdmFyIGJsID0gbmV3IFBvaW50KGJveC54MSwgYm94LnkyICogeVN0cmV0Y2gpLl9yb3RhdGUoYW5nbGUpO1xuICAgICAgICAgICAgICAgIHZhciBiciA9IG5ldyBQb2ludChib3gueDIsIGJveC55MiAqIHlTdHJldGNoKS5fcm90YXRlKGFuZ2xlKTtcblxuICAgICAgICAgICAgICAgIHZhciBtYXhab29tID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjUsIHRoaXMuem9vbSArIE1hdGgubG9nKGJveC5tYXhTY2FsZSkgLyBNYXRoLkxOMikpO1xuICAgICAgICAgICAgICAgIHZhciBwbGFjZW1lbnRab29tID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjUsIHRoaXMuem9vbSArIE1hdGgubG9nKGJveC5wbGFjZW1lbnRTY2FsZSkgLyBNYXRoLkxOMikpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDb2xsaXNpb25Cb3hWZXJ0ZXgodmVydGV4QXJyYXksIGFuY2hvclBvaW50LCB0bCwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDb2xsaXNpb25Cb3hWZXJ0ZXgodmVydGV4QXJyYXksIGFuY2hvclBvaW50LCB0ciwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDb2xsaXNpb25Cb3hWZXJ0ZXgodmVydGV4QXJyYXksIGFuY2hvclBvaW50LCB0ciwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDb2xsaXNpb25Cb3hWZXJ0ZXgodmVydGV4QXJyYXksIGFuY2hvclBvaW50LCBiciwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDb2xsaXNpb25Cb3hWZXJ0ZXgodmVydGV4QXJyYXksIGFuY2hvclBvaW50LCBiciwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDb2xsaXNpb25Cb3hWZXJ0ZXgodmVydGV4QXJyYXksIGFuY2hvclBvaW50LCBibCwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDb2xsaXNpb25Cb3hWZXJ0ZXgodmVydGV4QXJyYXksIGFuY2hvclBvaW50LCBibCwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDb2xsaXNpb25Cb3hWZXJ0ZXgodmVydGV4QXJyYXksIGFuY2hvclBvaW50LCB0bCwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5mdW5jdGlvbiBTeW1ib2xJbnN0YW5jZShhbmNob3IsIGxpbmUsIHNoYXBlZFRleHQsIHNoYXBlZEljb24sIGxheW91dCwgYWRkVG9CdWZmZXJzLCBpbmRleCwgY29sbGlzaW9uQm94QXJyYXksIGZlYXR1cmVJbmRleCwgc291cmNlTGF5ZXJJbmRleCwgYnVja2V0SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Qm94U2NhbGUsIHRleHRQYWRkaW5nLCB0ZXh0QWxvbmdMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbkJveFNjYWxlLCBpY29uUGFkZGluZywgaWNvbkFsb25nTGluZSkge1xuXG4gICAgdGhpcy54ID0gYW5jaG9yLng7XG4gICAgdGhpcy55ID0gYW5jaG9yLnk7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuaGFzVGV4dCA9ICEhc2hhcGVkVGV4dDtcbiAgICB0aGlzLmhhc0ljb24gPSAhIXNoYXBlZEljb247XG5cbiAgICBpZiAodGhpcy5oYXNUZXh0KSB7XG4gICAgICAgIHRoaXMuZ2x5cGhRdWFkcyA9IGFkZFRvQnVmZmVycyA/IGdldEdseXBoUXVhZHMoYW5jaG9yLCBzaGFwZWRUZXh0LCB0ZXh0Qm94U2NhbGUsIGxpbmUsIGxheW91dCwgdGV4dEFsb25nTGluZSkgOiBbXTtcbiAgICAgICAgdGhpcy50ZXh0Q29sbGlzaW9uRmVhdHVyZSA9IG5ldyBDb2xsaXNpb25GZWF0dXJlKGNvbGxpc2lvbkJveEFycmF5LCBsaW5lLCBhbmNob3IsIGZlYXR1cmVJbmRleCwgc291cmNlTGF5ZXJJbmRleCwgYnVja2V0SW5kZXgsXG4gICAgICAgICAgICAgICAgc2hhcGVkVGV4dCwgdGV4dEJveFNjYWxlLCB0ZXh0UGFkZGluZywgdGV4dEFsb25nTGluZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc0ljb24pIHtcbiAgICAgICAgdGhpcy5pY29uUXVhZHMgPSBhZGRUb0J1ZmZlcnMgPyBnZXRJY29uUXVhZHMoYW5jaG9yLCBzaGFwZWRJY29uLCBpY29uQm94U2NhbGUsIGxpbmUsIGxheW91dCwgaWNvbkFsb25nTGluZSkgOiBbXTtcbiAgICAgICAgdGhpcy5pY29uQ29sbGlzaW9uRmVhdHVyZSA9IG5ldyBDb2xsaXNpb25GZWF0dXJlKGNvbGxpc2lvbkJveEFycmF5LCBsaW5lLCBhbmNob3IsIGZlYXR1cmVJbmRleCwgc291cmNlTGF5ZXJJbmRleCwgYnVja2V0SW5kZXgsXG4gICAgICAgICAgICAgICAgc2hhcGVkSWNvbiwgaWNvbkJveFNjYWxlLCBpY29uUGFkZGluZywgaWNvbkFsb25nTGluZSwgdHJ1ZSk7XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyO1xuXG4vKipcbiAqIFRoZSBgQnVmZmVyYCBjbGFzcyB0dXJucyBhIGBTdHJ1Y3RBcnJheWAgaW50byBhIFdlYkdMIGJ1ZmZlci4gRWFjaCBtZW1iZXIgb2YgdGhlIFN0cnVjdEFycmF5J3NcbiAqIFN0cnVjdCB0eXBlIGlzIGNvbnZlcnRlZCB0byBhIFdlYkdMIGF0cmlidXRlLlxuICpcbiAqIEBjbGFzcyBCdWZmZXJcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gYXJyYXkgQSBzZXJpYWxpemVkIFN0cnVjdEFycmF5LlxuICogQHBhcmFtIHtvYmplY3R9IGFycmF5VHlwZSBBIHNlcmlhbGl6ZWQgU3RydWN0QXJyYXlUeXBlLlxuICogQHBhcmFtIHtCdWZmZXJUeXBlfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlcihhcnJheSwgYXJyYXlUeXBlLCB0eXBlKSB7XG4gICAgdGhpcy5hcnJheUJ1ZmZlciA9IGFycmF5LmFycmF5QnVmZmVyO1xuICAgIHRoaXMubGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IGFycmF5VHlwZS5tZW1iZXJzO1xuICAgIHRoaXMuaXRlbVNpemUgPSBhcnJheVR5cGUuYnl0ZXNQZXJFbGVtZW50O1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hcnJheVR5cGUgPSBhcnJheVR5cGU7XG59XG5cbi8qKlxuICogQmluZCB0aGlzIGJ1ZmZlciB0byBhIFdlYkdMIGNvbnRleHQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGdsIFRoZSBXZWJHTCBjb250ZXh0XG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGdsKSB7XG4gICAgdmFyIHR5cGUgPSBnbFt0aGlzLnR5cGVdO1xuXG4gICAgaWYgKCF0aGlzLmJ1ZmZlcikge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKHR5cGUsIHRoaXMuYnVmZmVyKTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YSh0eXBlLCB0aGlzLmFycmF5QnVmZmVyLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAgICAgLy8gZHVtcCBhcnJheSBidWZmZXIgb25jZSBpdCdzIGJvdW5kIHRvIGdsXG4gICAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIodHlwZSwgdGhpcy5idWZmZXIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQGVudW0ge3N0cmluZ30gQXR0cmlidXRlVHlwZVxuICogQHByaXZhdGVcbiAqIEByZWFkb25seVxuICovXG52YXIgQXR0cmlidXRlVHlwZSA9IHtcbiAgICBJbnQ4OiAgICdCWVRFJyxcbiAgICBVaW50ODogICdVTlNJR05FRF9CWVRFJyxcbiAgICBJbnQxNjogICdTSE9SVCcsXG4gICAgVWludDE2OiAnVU5TSUdORURfU0hPUlQnXG59O1xuXG4vKipcbiAqIFNldCB0aGUgYXR0cmlidXRlIHBvaW50ZXJzIGluIGEgV2ViR0wgY29udGV4dFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBnbCBUaGUgV2ViR0wgY29udGV4dFxuICogQHBhcmFtIHByb2dyYW0gVGhlIGFjdGl2ZSBXZWJHTCBwcm9ncmFtXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUuc2V0VmVydGV4QXR0cmliUG9pbnRlcnMgPSBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5hdHRyaWJ1dGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBtZW1iZXIgPSB0aGlzLmF0dHJpYnV0ZXNbal07XG4gICAgICAgIHZhciBhdHRyaWJJbmRleCA9IHByb2dyYW1bbWVtYmVyLm5hbWVdO1xuICAgICAgICBhc3NlcnQoYXR0cmliSW5kZXggIT09IHVuZGVmaW5lZCwgJ2FycmF5IG1lbWJlciBcIicgKyBtZW1iZXIubmFtZSArICdcIiBuYW1lIGRvZXMgbm90IG1hdGNoIHNoYWRlciBhdHRyaWJ1dGUgbmFtZScpO1xuXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgICAgICBhdHRyaWJJbmRleCxcbiAgICAgICAgICAgIG1lbWJlci5jb21wb25lbnRzLFxuICAgICAgICAgICAgZ2xbQXR0cmlidXRlVHlwZVttZW1iZXIudHlwZV1dLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICB0aGlzLmFycmF5VHlwZS5ieXRlc1BlckVsZW1lbnQsXG4gICAgICAgICAgICBtZW1iZXIub2Zmc2V0XG4gICAgICAgICk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBHTCBidWZmZXIgYm91bmQgdG8gdGhlIGdpdmVuIFdlYkdMIGNvbnRleHRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ2wgVGhlIFdlYkdMIGNvbnRleHRcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oZ2wpIHtcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMuYnVmZmVyKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9IEJ1ZmZlclR5cGVcbiAqIEBwcml2YXRlXG4gKiBAcmVhZG9ubHlcbiAqL1xuQnVmZmVyLkJ1ZmZlclR5cGUgPSB7XG4gICAgVkVSVEVYOiAnQVJSQVlfQlVGRkVSJyxcbiAgICBFTEVNRU5UOiAnRUxFTUVOVF9BUlJBWV9CVUZGRVInXG59O1xuXG4vKipcbiAqIEFuIGBCdWZmZXJUeXBlLkVMRU1FTlRgIGJ1ZmZlciBob2xkcyBpbmRpY2llcyBvZiBhIGNvcnJlc3BvbmRpbmcgYEJ1ZmZlclR5cGUuVkVSVEVYYCBidWZmZXIuXG4gKiBUaGVzZSBpbmRpY2llcyBhcmUgc3RvcmVkIGluIHRoZSBgQnVmZmVyVHlwZS5FTEVNRU5UYCBidWZmZXIgYXMgYFVOU0lHTkVEX1NIT1JUYHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEByZWFkb25seVxuICovXG5CdWZmZXIuRUxFTUVOVF9BVFRSSUJVVEVfVFlQRSA9ICdVaW50MTYnO1xuXG4vKipcbiAqIFdlYkdMIHBlcmZvcm1zIGJlc3QgaWYgdmVydGV4IGF0dHJpYnV0ZSBvZmZzZXRzIGFyZSBhbGlnbmVkIHRvIDQgYnl0ZSBib3VuZGFyaWVzLlxuICogQHByaXZhdGVcbiAqIEByZWFkb25seVxuICovXG5CdWZmZXIuVkVSVEVYX0FUVFJJQlVURV9BTElHTk1FTlQgPSA0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xudmFyIGxvYWRHZW9tZXRyeSA9IHJlcXVpcmUoJy4vbG9hZF9nZW9tZXRyeScpO1xudmFyIEVYVEVOVCA9IHJlcXVpcmUoJy4vYnVja2V0JykuRVhURU5UO1xudmFyIGZlYXR1cmVGaWx0ZXIgPSByZXF1aXJlKCdmZWF0dXJlLWZpbHRlcicpO1xudmFyIFN0cnVjdEFycmF5VHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvc3RydWN0X2FycmF5Jyk7XG52YXIgR3JpZCA9IHJlcXVpcmUoJ2dyaWQtaW5kZXgnKTtcbnZhciBEaWN0aW9uYXJ5Q29kZXIgPSByZXF1aXJlKCcuLi91dGlsL2RpY3Rpb25hcnlfY29kZXInKTtcbnZhciB2dCA9IHJlcXVpcmUoJ3ZlY3Rvci10aWxlJyk7XG52YXIgUHJvdG9idWYgPSByZXF1aXJlKCdwYmYnKTtcbnZhciBHZW9KU09ORmVhdHVyZSA9IHJlcXVpcmUoJy4uL3V0aWwvdmVjdG9ydGlsZV90b19nZW9qc29uJyk7XG52YXIgYXJyYXlzSW50ZXJzZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJykuYXJyYXlzSW50ZXJzZWN0O1xuXG52YXIgaW50ZXJzZWN0aW9uID0gcmVxdWlyZSgnLi4vdXRpbC9pbnRlcnNlY3Rpb25fdGVzdHMnKTtcbnZhciBtdWx0aVBvbHlnb25JbnRlcnNlY3RzQnVmZmVyZWRNdWx0aVBvaW50ID0gaW50ZXJzZWN0aW9uLm11bHRpUG9seWdvbkludGVyc2VjdHNCdWZmZXJlZE11bHRpUG9pbnQ7XG52YXIgbXVsdGlQb2x5Z29uSW50ZXJzZWN0c011bHRpUG9seWdvbiA9IGludGVyc2VjdGlvbi5tdWx0aVBvbHlnb25JbnRlcnNlY3RzTXVsdGlQb2x5Z29uO1xudmFyIG11bHRpUG9seWdvbkludGVyc2VjdHNCdWZmZXJlZE11bHRpTGluZSA9IGludGVyc2VjdGlvbi5tdWx0aVBvbHlnb25JbnRlcnNlY3RzQnVmZmVyZWRNdWx0aUxpbmU7XG5cblxudmFyIEZlYXR1cmVJbmRleEFycmF5ID0gbmV3IFN0cnVjdEFycmF5VHlwZSh7XG4gICAgbWVtYmVyczogW1xuICAgICAgICAvLyB0aGUgaW5kZXggb2YgdGhlIGZlYXR1cmUgaW4gdGhlIG9yaWdpbmFsIHZlY3RvcnRpbGVcbiAgICAgICAgeyB0eXBlOiAnVWludDMyJywgbmFtZTogJ2ZlYXR1cmVJbmRleCcgfSxcbiAgICAgICAgLy8gdGhlIHNvdXJjZSBsYXllciB0aGUgZmVhdHVyZSBhcHBlYXJzIGluXG4gICAgICAgIHsgdHlwZTogJ1VpbnQxNicsIG5hbWU6ICdzb3VyY2VMYXllckluZGV4JyB9LFxuICAgICAgICAvLyB0aGUgYnVja2V0IHRoZSBmZWF0dXJlIGFwcGVhcnMgaW5cbiAgICAgICAgeyB0eXBlOiAnVWludDE2JywgbmFtZTogJ2J1Y2tldEluZGV4JyB9XG4gICAgXX0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZlYXR1cmVJbmRleDtcblxuZnVuY3Rpb24gRmVhdHVyZUluZGV4KGNvb3JkLCBvdmVyc2NhbGluZywgY29sbGlzaW9uVGlsZSkge1xuICAgIGlmIChjb29yZC5ncmlkKSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVkID0gY29vcmQ7XG4gICAgICAgIHZhciByYXdUaWxlRGF0YSA9IG92ZXJzY2FsaW5nO1xuICAgICAgICBjb29yZCA9IHNlcmlhbGl6ZWQuY29vcmQ7XG4gICAgICAgIG92ZXJzY2FsaW5nID0gc2VyaWFsaXplZC5vdmVyc2NhbGluZztcbiAgICAgICAgdGhpcy5ncmlkID0gbmV3IEdyaWQoc2VyaWFsaXplZC5ncmlkKTtcbiAgICAgICAgdGhpcy5mZWF0dXJlSW5kZXhBcnJheSA9IG5ldyBGZWF0dXJlSW5kZXhBcnJheShzZXJpYWxpemVkLmZlYXR1cmVJbmRleEFycmF5KTtcbiAgICAgICAgdGhpcy5yYXdUaWxlRGF0YSA9IHJhd1RpbGVEYXRhO1xuICAgICAgICB0aGlzLmJ1Y2tldExheWVySURzID0gc2VyaWFsaXplZC5idWNrZXRMYXllcklEcztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmdyaWQgPSBuZXcgR3JpZChFWFRFTlQsIDE2LCAwKTtcbiAgICAgICAgdGhpcy5mZWF0dXJlSW5kZXhBcnJheSA9IG5ldyBGZWF0dXJlSW5kZXhBcnJheSgpO1xuICAgIH1cbiAgICB0aGlzLmNvb3JkID0gY29vcmQ7XG4gICAgdGhpcy5vdmVyc2NhbGluZyA9IG92ZXJzY2FsaW5nO1xuICAgIHRoaXMueCA9IGNvb3JkLng7XG4gICAgdGhpcy55ID0gY29vcmQueTtcbiAgICB0aGlzLnogPSBjb29yZC56IC0gTWF0aC5sb2cob3ZlcnNjYWxpbmcpIC8gTWF0aC5MTjI7XG4gICAgdGhpcy5zZXRDb2xsaXNpb25UaWxlKGNvbGxpc2lvblRpbGUpO1xufVxuXG5GZWF0dXJlSW5kZXgucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKGZlYXR1cmUsIGZlYXR1cmVJbmRleCwgc291cmNlTGF5ZXJJbmRleCwgYnVja2V0SW5kZXgpIHtcbiAgICB2YXIga2V5ID0gdGhpcy5mZWF0dXJlSW5kZXhBcnJheS5sZW5ndGg7XG4gICAgdGhpcy5mZWF0dXJlSW5kZXhBcnJheS5lbXBsYWNlQmFjayhmZWF0dXJlSW5kZXgsIHNvdXJjZUxheWVySW5kZXgsIGJ1Y2tldEluZGV4KTtcbiAgICB2YXIgZ2VvbWV0cnkgPSBsb2FkR2VvbWV0cnkoZmVhdHVyZSk7XG5cbiAgICBmb3IgKHZhciByID0gMDsgciA8IGdlb21ldHJ5Lmxlbmd0aDsgcisrKSB7XG4gICAgICAgIHZhciByaW5nID0gZ2VvbWV0cnlbcl07XG5cbiAgICAgICAgLy8gVE9ETzogc2tpcCBob2xlcyB3aGVuIHdlIHN0YXJ0IHVzaW5nIHZlY3RvciB0aWxlIHNwZWMgMi4wXG5cbiAgICAgICAgdmFyIGJib3ggPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHAgPSByaW5nW2ldO1xuICAgICAgICAgICAgYmJveFswXSA9IE1hdGgubWluKGJib3hbMF0sIHAueCk7XG4gICAgICAgICAgICBiYm94WzFdID0gTWF0aC5taW4oYmJveFsxXSwgcC55KTtcbiAgICAgICAgICAgIGJib3hbMl0gPSBNYXRoLm1heChiYm94WzJdLCBwLngpO1xuICAgICAgICAgICAgYmJveFszXSA9IE1hdGgubWF4KGJib3hbM10sIHAueSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdyaWQuaW5zZXJ0KGtleSwgYmJveFswXSwgYmJveFsxXSwgYmJveFsyXSwgYmJveFszXSk7XG4gICAgfVxufTtcblxuRmVhdHVyZUluZGV4LnByb3RvdHlwZS5zZXRDb2xsaXNpb25UaWxlID0gZnVuY3Rpb24oY29sbGlzaW9uVGlsZSkge1xuICAgIHRoaXMuY29sbGlzaW9uVGlsZSA9IGNvbGxpc2lvblRpbGU7XG59O1xuXG5GZWF0dXJlSW5kZXgucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgICBjb29yZDogdGhpcy5jb29yZCxcbiAgICAgICAgb3ZlcnNjYWxpbmc6IHRoaXMub3ZlcnNjYWxpbmcsXG4gICAgICAgIGdyaWQ6IHRoaXMuZ3JpZC50b0FycmF5QnVmZmVyKCksXG4gICAgICAgIGZlYXR1cmVJbmRleEFycmF5OiB0aGlzLmZlYXR1cmVJbmRleEFycmF5LnNlcmlhbGl6ZSgpLFxuICAgICAgICBidWNrZXRMYXllcklEczogdGhpcy5idWNrZXRMYXllcklEc1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgdHJhbnNmZXJhYmxlczogW2RhdGEuZ3JpZCwgZGF0YS5mZWF0dXJlSW5kZXhBcnJheS5hcnJheUJ1ZmZlcl1cbiAgICB9O1xufTtcblxuZnVuY3Rpb24gdHJhbnNsYXRlRGlzdGFuY2UodHJhbnNsYXRlKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0cmFuc2xhdGVbMF0gKiB0cmFuc2xhdGVbMF0gKyB0cmFuc2xhdGVbMV0gKiB0cmFuc2xhdGVbMV0pO1xufVxuXG4vLyBGaW5kcyBmZWF0dXJlcyBpbiB0aGlzIHRpbGUgYXQgYSBwYXJ0aWN1bGFyIHBvc2l0aW9uLlxuRmVhdHVyZUluZGV4LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKGFyZ3MsIHN0eWxlTGF5ZXJzKSB7XG4gICAgaWYgKCF0aGlzLnZ0TGF5ZXJzKSB7XG4gICAgICAgIHRoaXMudnRMYXllcnMgPSBuZXcgdnQuVmVjdG9yVGlsZShuZXcgUHJvdG9idWYobmV3IFVpbnQ4QXJyYXkodGhpcy5yYXdUaWxlRGF0YSkpKS5sYXllcnM7XG4gICAgICAgIHRoaXMuc291cmNlTGF5ZXJDb2RlciA9IG5ldyBEaWN0aW9uYXJ5Q29kZXIodGhpcy52dExheWVycyA/IE9iamVjdC5rZXlzKHRoaXMudnRMYXllcnMpLnNvcnQoKSA6IFsnX2dlb2pzb25UaWxlTGF5ZXInXSk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgdmFyIHBhcmFtcyA9IGFyZ3MucGFyYW1zIHx8IHt9LFxuICAgICAgICBwaXhlbHNUb1RpbGVVbml0cyA9IEVYVEVOVCAvIGFyZ3MudGlsZVNpemUgLyBhcmdzLnNjYWxlLFxuICAgICAgICBmaWx0ZXIgPSBmZWF0dXJlRmlsdGVyKHBhcmFtcy5maWx0ZXIpO1xuXG4gICAgLy8gRmVhdHVyZXMgYXJlIGluZGV4ZWQgdGhlaXIgb3JpZ2luYWwgZ2VvbWV0cmllcy4gVGhlIHJlbmRlcmVkIGdlb21ldHJpZXMgbWF5XG4gICAgLy8gYmUgYnVmZmVyZWQsIHRyYW5zbGF0ZWQgb3Igb2Zmc2V0LiBGaWd1cmUgb3V0IGhvdyBtdWNoIHRoZSBzZWFyY2ggcmFkaXVzIG5lZWRzIHRvIGJlXG4gICAgLy8gZXhwYW5kZWQgYnkgdG8gaW5jbHVkZSB0aGVzZSBmZWF0dXJlcy5cbiAgICB2YXIgYWRkaXRpb25hbFJhZGl1cyA9IDA7XG4gICAgZm9yICh2YXIgaWQgaW4gc3R5bGVMYXllcnMpIHtcbiAgICAgICAgdmFyIHN0eWxlTGF5ZXIgPSBzdHlsZUxheWVyc1tpZF07XG4gICAgICAgIHZhciBwYWludCA9IHN0eWxlTGF5ZXIucGFpbnQ7XG5cbiAgICAgICAgdmFyIHN0eWxlTGF5ZXJEaXN0YW5jZSA9IDA7XG4gICAgICAgIGlmIChzdHlsZUxheWVyLnR5cGUgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgc3R5bGVMYXllckRpc3RhbmNlID0gZ2V0TGluZVdpZHRoKHBhaW50KSAvIDIgKyBNYXRoLmFicyhwYWludFsnbGluZS1vZmZzZXQnXSkgKyB0cmFuc2xhdGVEaXN0YW5jZShwYWludFsnbGluZS10cmFuc2xhdGUnXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3R5bGVMYXllci50eXBlID09PSAnZmlsbCcpIHtcbiAgICAgICAgICAgIHN0eWxlTGF5ZXJEaXN0YW5jZSA9IHRyYW5zbGF0ZURpc3RhbmNlKHBhaW50WydmaWxsLXRyYW5zbGF0ZSddKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZUxheWVyLnR5cGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICAgICAgICBzdHlsZUxheWVyRGlzdGFuY2UgPSBwYWludFsnY2lyY2xlLXJhZGl1cyddICsgdHJhbnNsYXRlRGlzdGFuY2UocGFpbnRbJ2NpcmNsZS10cmFuc2xhdGUnXSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkaXRpb25hbFJhZGl1cyA9IE1hdGgubWF4KGFkZGl0aW9uYWxSYWRpdXMsIHN0eWxlTGF5ZXJEaXN0YW5jZSAqIHBpeGVsc1RvVGlsZVVuaXRzKTtcbiAgICB9XG5cbiAgICB2YXIgcXVlcnlHZW9tZXRyeSA9IGFyZ3MucXVlcnlHZW9tZXRyeS5tYXAoZnVuY3Rpb24ocSkge1xuICAgICAgICByZXR1cm4gcS5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwLngsIHAueSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVlcnlHZW9tZXRyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmluZyA9IHF1ZXJ5R2VvbWV0cnlbaV07XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcmluZy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdmFyIHAgPSByaW5nW2tdO1xuICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHAueCk7XG4gICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgcC55KTtcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBwLngpO1xuICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHAueSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hpbmcgPSB0aGlzLmdyaWQucXVlcnkobWluWCAtIGFkZGl0aW9uYWxSYWRpdXMsIG1pblkgLSBhZGRpdGlvbmFsUmFkaXVzLCBtYXhYICsgYWRkaXRpb25hbFJhZGl1cywgbWF4WSArIGFkZGl0aW9uYWxSYWRpdXMpO1xuICAgIG1hdGNoaW5nLnNvcnQodG9wRG93bkZlYXR1cmVDb21wYXJhdG9yKTtcbiAgICB0aGlzLmZpbHRlck1hdGNoaW5nKHJlc3VsdCwgbWF0Y2hpbmcsIHRoaXMuZmVhdHVyZUluZGV4QXJyYXksIHF1ZXJ5R2VvbWV0cnksIGZpbHRlciwgcGFyYW1zLmxheWVycywgc3R5bGVMYXllcnMsIGFyZ3MuYmVhcmluZywgcGl4ZWxzVG9UaWxlVW5pdHMpO1xuXG4gICAgdmFyIG1hdGNoaW5nU3ltYm9scyA9IHRoaXMuY29sbGlzaW9uVGlsZS5xdWVyeVJlbmRlcmVkU3ltYm9scyhtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCBhcmdzLnNjYWxlKTtcbiAgICBtYXRjaGluZ1N5bWJvbHMuc29ydCgpO1xuICAgIHRoaXMuZmlsdGVyTWF0Y2hpbmcocmVzdWx0LCBtYXRjaGluZ1N5bWJvbHMsIHRoaXMuY29sbGlzaW9uVGlsZS5jb2xsaXNpb25Cb3hBcnJheSwgcXVlcnlHZW9tZXRyeSwgZmlsdGVyLCBwYXJhbXMubGF5ZXJzLCBzdHlsZUxheWVycywgYXJncy5iZWFyaW5nLCBwaXhlbHNUb1RpbGVVbml0cyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gdG9wRG93bkZlYXR1cmVDb21wYXJhdG9yKGEsIGIpIHtcbiAgICByZXR1cm4gYiAtIGE7XG59XG5cbmZ1bmN0aW9uIGdldExpbmVXaWR0aChwYWludCkge1xuICAgIGlmIChwYWludFsnbGluZS1nYXAtd2lkdGgnXSA+IDApIHtcbiAgICAgICAgcmV0dXJuIHBhaW50WydsaW5lLWdhcC13aWR0aCddICsgMiAqIHBhaW50WydsaW5lLXdpZHRoJ107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhaW50WydsaW5lLXdpZHRoJ107XG4gICAgfVxufVxuXG5GZWF0dXJlSW5kZXgucHJvdG90eXBlLmZpbHRlck1hdGNoaW5nID0gZnVuY3Rpb24ocmVzdWx0LCBtYXRjaGluZywgYXJyYXksIHF1ZXJ5R2VvbWV0cnksIGZpbHRlciwgZmlsdGVyTGF5ZXJJRHMsIHN0eWxlTGF5ZXJzLCBiZWFyaW5nLCBwaXhlbHNUb1RpbGVVbml0cykge1xuICAgIHZhciBwcmV2aW91c0luZGV4O1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbWF0Y2hpbmcubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbWF0Y2hpbmdba107XG5cbiAgICAgICAgLy8gZG9uJ3QgY2hlY2sgdGhlIHNhbWUgZmVhdHVyZSBtb3JlIHRoYW4gb25jZVxuICAgICAgICBpZiAoaW5kZXggPT09IHByZXZpb3VzSW5kZXgpIGNvbnRpbnVlO1xuICAgICAgICBwcmV2aW91c0luZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgdmFyIG1hdGNoID0gYXJyYXkuZ2V0KGluZGV4KTtcblxuICAgICAgICB2YXIgbGF5ZXJJRHMgPSB0aGlzLmJ1Y2tldExheWVySURzW21hdGNoLmJ1Y2tldEluZGV4XTtcbiAgICAgICAgaWYgKGZpbHRlckxheWVySURzICYmICFhcnJheXNJbnRlcnNlY3QoZmlsdGVyTGF5ZXJJRHMsIGxheWVySURzKSkgY29udGludWU7XG5cbiAgICAgICAgdmFyIHNvdXJjZUxheWVyTmFtZSA9IHRoaXMuc291cmNlTGF5ZXJDb2Rlci5kZWNvZGUobWF0Y2guc291cmNlTGF5ZXJJbmRleCk7XG4gICAgICAgIHZhciBzb3VyY2VMYXllciA9IHRoaXMudnRMYXllcnNbc291cmNlTGF5ZXJOYW1lXTtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBzb3VyY2VMYXllci5mZWF0dXJlKG1hdGNoLmZlYXR1cmVJbmRleCk7XG5cbiAgICAgICAgaWYgKCFmaWx0ZXIoZmVhdHVyZSkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG51bGw7XG5cbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsYXllcklEcy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgdmFyIGxheWVySUQgPSBsYXllcklEc1tsXTtcblxuICAgICAgICAgICAgaWYgKGZpbHRlckxheWVySURzICYmIGZpbHRlckxheWVySURzLmluZGV4T2YobGF5ZXJJRCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdHlsZUxheWVyID0gc3R5bGVMYXllcnNbbGF5ZXJJRF07XG4gICAgICAgICAgICBpZiAoIXN0eWxlTGF5ZXIpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB2YXIgdHJhbnNsYXRlZFBvbHlnb247XG4gICAgICAgICAgICBpZiAoc3R5bGVMYXllci50eXBlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIC8vIGFsbCBzeW1ib2xzIGFscmVhZHkgbWF0Y2ggdGhlIHN0eWxlXG5cbiAgICAgICAgICAgICAgICBpZiAoIWdlb21ldHJ5KSBnZW9tZXRyeSA9IGxvYWRHZW9tZXRyeShmZWF0dXJlKTtcblxuICAgICAgICAgICAgICAgIHZhciBwYWludCA9IHN0eWxlTGF5ZXIucGFpbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVMYXllci50eXBlID09PSAnbGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlZFBvbHlnb24gPSB0cmFuc2xhdGUocXVlcnlHZW9tZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWludFsnbGluZS10cmFuc2xhdGUnXSwgcGFpbnRbJ2xpbmUtdHJhbnNsYXRlLWFuY2hvciddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlYXJpbmcsIHBpeGVsc1RvVGlsZVVuaXRzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbGZXaWR0aCA9IGdldExpbmVXaWR0aChwYWludCkgLyAyICogcGl4ZWxzVG9UaWxlVW5pdHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWludFsnbGluZS1vZmZzZXQnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBvZmZzZXRMaW5lKGdlb21ldHJ5LCBwYWludFsnbGluZS1vZmZzZXQnXSAqIHBpeGVsc1RvVGlsZVVuaXRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW11bHRpUG9seWdvbkludGVyc2VjdHNCdWZmZXJlZE11bHRpTGluZSh0cmFuc2xhdGVkUG9seWdvbiwgZ2VvbWV0cnksIGhhbGZXaWR0aCkpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZUxheWVyLnR5cGUgPT09ICdmaWxsJykge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVkUG9seWdvbiA9IHRyYW5zbGF0ZShxdWVyeUdlb21ldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhaW50WydmaWxsLXRyYW5zbGF0ZSddLCBwYWludFsnZmlsbC10cmFuc2xhdGUtYW5jaG9yJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVhcmluZywgcGl4ZWxzVG9UaWxlVW5pdHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW11bHRpUG9seWdvbkludGVyc2VjdHNNdWx0aVBvbHlnb24odHJhbnNsYXRlZFBvbHlnb24sIGdlb21ldHJ5KSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlTGF5ZXIudHlwZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlZFBvbHlnb24gPSB0cmFuc2xhdGUocXVlcnlHZW9tZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWludFsnY2lyY2xlLXRyYW5zbGF0ZSddLCBwYWludFsnY2lyY2xlLXRyYW5zbGF0ZS1hbmNob3InXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWFyaW5nLCBwaXhlbHNUb1RpbGVVbml0cyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaXJjbGVSYWRpdXMgPSBwYWludFsnY2lyY2xlLXJhZGl1cyddICogcGl4ZWxzVG9UaWxlVW5pdHM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbXVsdGlQb2x5Z29uSW50ZXJzZWN0c0J1ZmZlcmVkTXVsdGlQb2ludCh0cmFuc2xhdGVkUG9seWdvbiwgZ2VvbWV0cnksIGNpcmNsZVJhZGl1cykpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGdlb2pzb25GZWF0dXJlID0gbmV3IEdlb0pTT05GZWF0dXJlKGZlYXR1cmUsIHRoaXMueiwgdGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgZ2VvanNvbkZlYXR1cmUubGF5ZXIgPSBzdHlsZUxheWVyLnNlcmlhbGl6ZSh7XG4gICAgICAgICAgICAgICAgaW5jbHVkZVJlZlByb3BlcnRpZXM6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGxheWVyUmVzdWx0ID0gcmVzdWx0W2xheWVySURdO1xuICAgICAgICAgICAgaWYgKGxheWVyUmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsYXllclJlc3VsdCA9IHJlc3VsdFtsYXllcklEXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGF5ZXJSZXN1bHQucHVzaChnZW9qc29uRmVhdHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5mdW5jdGlvbiB0cmFuc2xhdGUocXVlcnlHZW9tZXRyeSwgdHJhbnNsYXRlLCB0cmFuc2xhdGVBbmNob3IsIGJlYXJpbmcsIHBpeGVsc1RvVGlsZVVuaXRzKSB7XG4gICAgaWYgKCF0cmFuc2xhdGVbMF0gJiYgIXRyYW5zbGF0ZVsxXSkge1xuICAgICAgICByZXR1cm4gcXVlcnlHZW9tZXRyeTtcbiAgICB9XG5cbiAgICB0cmFuc2xhdGUgPSBQb2ludC5jb252ZXJ0KHRyYW5zbGF0ZSk7XG5cbiAgICBpZiAodHJhbnNsYXRlQW5jaG9yID09PSBcInZpZXdwb3J0XCIpIHtcbiAgICAgICAgdHJhbnNsYXRlLl9yb3RhdGUoLWJlYXJpbmcpO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2xhdGVkID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWVyeUdlb21ldHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByaW5nID0gcXVlcnlHZW9tZXRyeVtpXTtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZWRSaW5nID0gW107XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcmluZy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdHJhbnNsYXRlZFJpbmcucHVzaChyaW5nW2tdLnN1Yih0cmFuc2xhdGUuX211bHQocGl4ZWxzVG9UaWxlVW5pdHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNsYXRlZC5wdXNoKHRyYW5zbGF0ZWRSaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zbGF0ZWQ7XG59XG5cbmZ1bmN0aW9uIG9mZnNldExpbmUocmluZ3MsIG9mZnNldCkge1xuICAgIHZhciBuZXdSaW5ncyA9IFtdO1xuICAgIHZhciB6ZXJvID0gbmV3IFBvaW50KDAsIDApO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcmluZ3MubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSByaW5nc1trXTtcbiAgICAgICAgdmFyIG5ld1JpbmcgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHJpbmdbaSAtIDFdO1xuICAgICAgICAgICAgdmFyIGIgPSByaW5nW2ldO1xuICAgICAgICAgICAgdmFyIGMgPSByaW5nW2kgKyAxXTtcbiAgICAgICAgICAgIHZhciBhVG9CID0gaSA9PT0gMCA/IHplcm8gOiBiLnN1YihhKS5fdW5pdCgpLl9wZXJwKCk7XG4gICAgICAgICAgICB2YXIgYlRvQyA9IGkgPT09IHJpbmcubGVuZ3RoIC0gMSA/IHplcm8gOiBjLnN1YihiKS5fdW5pdCgpLl9wZXJwKCk7XG4gICAgICAgICAgICB2YXIgZXh0cnVkZSA9IGFUb0IuX2FkZChiVG9DKS5fdW5pdCgpO1xuXG4gICAgICAgICAgICB2YXIgY29zSGFsZkFuZ2xlID0gZXh0cnVkZS54ICogYlRvQy54ICsgZXh0cnVkZS55ICogYlRvQy55O1xuICAgICAgICAgICAgZXh0cnVkZS5fbXVsdCgxIC8gY29zSGFsZkFuZ2xlKTtcblxuICAgICAgICAgICAgbmV3UmluZy5wdXNoKGV4dHJ1ZGUuX211bHQob2Zmc2V0KS5fYWRkKGIpKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdSaW5ncy5wdXNoKG5ld1JpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3UmluZ3M7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFWFRFTlQgPSByZXF1aXJlKCcuL2J1Y2tldCcpLkVYVEVOVDtcbnZhciBFWFRFTlRfTUlOID0gRVhURU5UICogLTI7XG52YXIgRVhURU5UX01BWCA9IChFWFRFTlQgKiAyKSAtIDE7XG5cbi8vIG9ubHkgbG9nIGEgZ2VvbWV0cnkgd2FybmluZyBvbmNlIHBlciBjb250ZXh0XG52YXIgd2FybmVkID0gZmFsc2U7XG5cbi8qKlxuICogTG9hZHMgYSBnZW9tZXRyeSBmcm9tIGEgVmVjdG9yVGlsZUZlYXR1cmUgYW5kIHNjYWxlcyBpdCB0byB0aGUgY29tbW9uIGV4dGVudFxuICogdXNlZCBpbnRlcm5hbGx5LlxuICogQHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsb2FkR2VvbWV0cnkoZmVhdHVyZSkge1xuICAgIHZhciBzY2FsZSA9IEVYVEVOVCAvIGZlYXR1cmUuZXh0ZW50O1xuICAgIHZhciBnZW9tZXRyeSA9IGZlYXR1cmUubG9hZEdlb21ldHJ5KCk7XG4gICAgZm9yICh2YXIgciA9IDA7IHIgPCBnZW9tZXRyeS5sZW5ndGg7IHIrKykge1xuICAgICAgICB2YXIgcmluZyA9IGdlb21ldHJ5W3JdO1xuICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHJpbmcubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IHJpbmdbcF07XG4gICAgICAgICAgICAvLyByb3VuZCBoZXJlIGJlY2F1c2UgbWFwYm94LWdsLW5hdGl2ZSB1c2VzIGludGVnZXJzIHRvIHJlcHJlc2VudFxuICAgICAgICAgICAgLy8gcG9pbnRzIGFuZCB3ZSBuZWVkIHRvIGRvIHRoZSBzYW1lIHRvIGF2b2lkIHJlbmVyaW5nIGRpZmZlcmVuY2VzLlxuICAgICAgICAgICAgcG9pbnQueCA9IE1hdGgucm91bmQocG9pbnQueCAqIHNjYWxlKTtcbiAgICAgICAgICAgIHBvaW50LnkgPSBNYXRoLnJvdW5kKHBvaW50LnkgKiBzY2FsZSk7XG4gICAgICAgICAgICBpZiAod2FybmVkID09PSBmYWxzZSAmJiAoXG4gICAgICAgICAgICAgICAgcG9pbnQueCA8IEVYVEVOVF9NSU4gfHxcbiAgICAgICAgICAgICAgICBwb2ludC54ID4gRVhURU5UX01BWCB8fFxuICAgICAgICAgICAgICAgIHBvaW50LnkgPCBFWFRFTlRfTUlOIHx8XG4gICAgICAgICAgICAgICAgcG9pbnQueSA+IEVYVEVOVF9NQVgpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdHZW9tZXRyeSBleGNlZWRzIGFsbG93ZWQgZXh0ZW50LCByZWR1Y2UgeW91ciB2ZWN0b3IgdGlsZSBidWZmZXIgc2l6ZScpO1xuICAgICAgICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBDb29yZGluYXRlO1xuXG4vKipcbiAqIEEgY29vcmRpbmF0ZSBpcyBhIGNvbHVtbiwgcm93LCB6b29tIGNvbWJpbmF0aW9uLCBvZnRlbiB1c2VkXG4gKiBhcyB0aGUgZGF0YSBjb21wb25lbnQgb2YgYSB0aWxlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSB6b29tXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBDb29yZGluYXRlKGNvbHVtbiwgcm93LCB6b29tKSB7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgdGhpcy5yb3cgPSByb3c7XG4gICAgdGhpcy56b29tID0gem9vbTtcbn1cblxuQ29vcmRpbmF0ZS5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGlzIGNvb3JkaW5hdGUgdGhhdCBjYW4gYmUgbXV0YXRlZCB3aXRob3V0XG4gICAgICogY2hhbmdpbmcgdGhlIG9yaWdpbmFsIGNvb3JkaW5hdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb29yZGluYXRlfSBjbG9uZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogdmFyIGNvb3JkID0gbmV3IENvb3JkaW5hdGUoMCwgMCwgMCk7XG4gICAgICogdmFyIGMyID0gY29vcmQuY2xvbmUoKTtcbiAgICAgKiAvLyBzaW5jZSBjb29yZCBpcyBjbG9uZWQsIG1vZGlmeWluZyBhIHByb3BlcnR5IG9mIGMyIGRvZXNcbiAgICAgKiAvLyBub3QgbW9kaWZ5IGl0LlxuICAgICAqIGMyLnpvb20gPSAyO1xuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb29yZGluYXRlKHRoaXMuY29sdW1uLCB0aGlzLnJvdywgdGhpcy56b29tKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWm9vbSB0aGlzIGNvb3JkaW5hdGUgdG8gYSBnaXZlbiB6b29tIGxldmVsLiBUaGlzIHJldHVybnMgYSBuZXdcbiAgICAgKiBjb29yZGluYXRlIG9iamVjdCwgbm90IG11dGF0aW5nIHRoZSBvbGQgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpvb21cbiAgICAgKiBAcmV0dXJucyB7Q29vcmRpbmF0ZX0gem9vbWVkIGNvb3JkaW5hdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGNvb3JkID0gbmV3IENvb3JkaW5hdGUoMCwgMCwgMCk7XG4gICAgICogdmFyIGMyID0gY29vcmQuem9vbVRvKDEpO1xuICAgICAqIGMyIC8vIGVxdWFscyBuZXcgQ29vcmRpbmF0ZSgwLCAwLCAxKTtcbiAgICAgKi9cbiAgICB6b29tVG86IGZ1bmN0aW9uKHpvb20pIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fem9vbVRvKHpvb20pOyB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdGhlIGNvbHVtbiBhbmQgcm93IHZhbHVlcyBvZiB0aGlzIGNvb3JkaW5hdGUgZnJvbSB0aG9zZVxuICAgICAqIG9mIGFub3RoZXIgY29vcmRpbmF0ZS4gVGhlIG90aGVyIGNvb3JkaW5hdCB3aWxsIGJlIHpvb21lZCB0byB0aGVcbiAgICAgKiBzYW1lIGxldmVsIGFzIGB0aGlzYCBiZWZvcmUgdGhlIHN1YnRyYWN0aW9uIG9jY3Vyc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjIG90aGVyIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7Q29vcmRpbmF0ZX0gcmVzdWx0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdWI6IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fc3ViKGMpOyB9LFxuXG4gICAgX3pvb21UbzogZnVuY3Rpb24oem9vbSkge1xuICAgICAgICB2YXIgc2NhbGUgPSBNYXRoLnBvdygyLCB6b29tIC0gdGhpcy56b29tKTtcbiAgICAgICAgdGhpcy5jb2x1bW4gKj0gc2NhbGU7XG4gICAgICAgIHRoaXMucm93ICo9IHNjYWxlO1xuICAgICAgICB0aGlzLnpvb20gPSB6b29tO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3N1YjogZnVuY3Rpb24oYykge1xuICAgICAgICBjID0gYy56b29tVG8odGhpcy56b29tKTtcbiAgICAgICAgdGhpcy5jb2x1bW4gLT0gYy5jb2x1bW47XG4gICAgICAgIHRoaXMucm93IC09IGMucm93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExuZ0xhdDtcblxudmFyIHdyYXAgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKS53cmFwO1xuXG4vKipcbiAqIENyZWF0ZSBhIGxvbmdpdHVkZSwgbGF0aXR1ZGUgb2JqZWN0IGZyb20gYSBnaXZlbiBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIHBhaXIgaW4gZGVncmVlcy5cbiAqIE1hcGJveCBHTCB1c2VzIExvbmdpdHVkZSwgTGF0aXR1ZGUgY29vcmRpbmF0ZSBvcmRlciB0byBtYXRjaCBHZW9KU09OLlxuICpcbiAqIE5vdGUgdGhhdCBhbnkgTWFwYm94IEdMIG1ldGhvZCB0aGF0IGFjY2VwdHMgYSBgTG5nTGF0YCBvYmplY3QgY2FuIGFsc28gYWNjZXB0IGFuXG4gKiBgQXJyYXlgIGFuZCB3aWxsIHBlcmZvcm0gYW4gaW1wbGljaXQgY29udmVyc2lvbi4gIFRoZSBmb2xsb3dpbmcgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XG4gYGBgXG4gbWFwLnNldENlbnRlcihbLTczLjk3NDksIDQwLjc3MzZdKTtcbiBtYXAuc2V0Q2VudGVyKCBuZXcgbWFwYm94Z2wuTG5nTGF0KC03My45NzQ5LCA0MC43NzM2KSApO1xuIGBgYFxuICpcbiAqIEBjbGFzcyBMbmdMYXRcbiAqIEBjbGFzc2Rlc2MgQSByZXByZXNlbnRhdGlvbiBvZiBhIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcG9pbnQsIGluIGRlZ3JlZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gbG5nIGxvbmdpdHVkZVxuICogQHBhcmFtIHtudW1iZXJ9IGxhdCBsYXRpdHVkZVxuICogQGV4YW1wbGVcbiAqIHZhciBsbCA9IG5ldyBtYXBib3hnbC5MbmdMYXQoLTczLjk3NDksIDQwLjc3MzYpO1xuICovXG5mdW5jdGlvbiBMbmdMYXQobG5nLCBsYXQpIHtcbiAgICBpZiAoaXNOYU4obG5nKSB8fCBpc05hTihsYXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMbmdMYXQgb2JqZWN0OiAoJyArIGxuZyArICcsICcgKyBsYXQgKyAnKScpO1xuICAgIH1cbiAgICB0aGlzLmxuZyA9ICtsbmc7XG4gICAgdGhpcy5sYXQgPSArbGF0O1xuICAgIGlmICh0aGlzLmxhdCA+IDkwIHx8IHRoaXMubGF0IDwgLTkwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMbmdMYXQgbGF0aXR1ZGUgdmFsdWU6IG11c3QgYmUgYmV0d2VlbiAtOTAgYW5kIDkwJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIFJldHVybiBhIG5ldyBgTG5nTGF0YCBvYmplY3Qgd2hvc2UgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgdG8gdGhlIHJhbmdlICgtMTgwLCAxODApLlxuICpcbiAqIEByZXR1cm5zIHtMbmdMYXR9IHdyYXBwZWQgTG5nTGF0IG9iamVjdFxuICogQGV4YW1wbGVcbiAqIHZhciBsbCA9IG5ldyBtYXBib3hnbC5MbmdMYXQoMjg2LjAyNTEsIDQwLjc3MzYpO1xuICogdmFyIHdyYXBwZWQgPSBsbC53cmFwKCk7XG4gKiB3cmFwcGVkLmxuZzsgLy8gPSAtNzMuOTc0OVxuICovXG5MbmdMYXQucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBMbmdMYXQod3JhcCh0aGlzLmxuZywgLTE4MCwgMTgwKSwgdGhpcy5sYXQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBgTG5nTGF0YCBhcyBhbiBhcnJheVxuICpcbiAqIEByZXR1cm5zIHthcnJheX0gW2xuZywgbGF0XVxuICogQGV4YW1wbGVcbiAqIHZhciBsbCA9IG5ldyBtYXBib3hnbC5MbmdMYXQoLTczLjk3NDksIDQwLjc3MzYpO1xuICogbGwudG9BcnJheSgpOyAvLyA9IFstNzMuOTc0OSwgNDAuNzczNl1cbiAqL1xuTG5nTGF0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbdGhpcy5sbmcsIHRoaXMubGF0XTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGEgYExuZ0xhdGAgYXMgYSBzdHJpbmdcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBcIkxuZ0xhdChsbmcsIGxhdClcIlxuICogQGV4YW1wbGVcbiAqIHZhciBsbCA9IG5ldyBtYXBib3hnbC5MbmdMYXQoLTczLjk3NDksIDQwLjc3MzYpO1xuICogbGwudG9TdHJpbmcoKTsgLy8gPSBcIkxuZ0xhdCgtNzMuOTc0OSwgNDAuNzczNilcIlxuICovXG5MbmdMYXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnTG5nTGF0KCcgKyB0aGlzLmxuZyArICcsICcgKyB0aGlzLmxhdCArICcpJztcbn07XG5cbi8qKlxuICogQ29udmVydCBhbiBhcnJheSB0byBhIGBMbmdMYXRgIG9iamVjdCwgb3IgcmV0dXJuIGFuIGV4aXN0aW5nIGBMbmdMYXRgIG9iamVjdFxuICogdW5jaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPnxMbmdMYXR9IGlucHV0IGBpbnB1dGAgdG8gY29udmVydFxuICogQHJldHVybnMge0xuZ0xhdH0gTG5nTGF0IG9iamVjdCBvciBvcmlnaW5hbCBpbnB1dFxuICogQGV4YW1wbGVcbiAqIHZhciBhcnIgPSBbLTczLjk3NDksIDQwLjc3MzZdO1xuICogdmFyIGxsID0gbWFwYm94Z2wuTG5nTGF0LmNvbnZlcnQoYXJyKTtcbiAqIGxsOyAgIC8vID0gTG5nTGF0IHtsbmc6IC03My45NzQ5LCBsYXQ6IDQwLjc3MzZ9XG4gKi9cbkxuZ0xhdC5jb252ZXJ0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgTG5nTGF0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG5nTGF0KGlucHV0WzBdLCBpbnB1dFsxXSk7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gTG5nTGF0Qm91bmRzO1xuXG52YXIgTG5nTGF0ID0gcmVxdWlyZSgnLi9sbmdfbGF0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJvdW5kaW5nIGJveCBmcm9tIHRoZSBnaXZlbiBwYWlyIG9mIHBvaW50cy4gSWYgcGFyYW1ldGVyZXMgYXJlIG9taXR0ZWQsIGEgYG51bGxgIGJvdW5kaW5nIGJveCBpcyBjcmVhdGVkLlxuICpcbiAqIEBjbGFzcyBMbmdMYXRCb3VuZHNcbiAqIEBjbGFzc2Rlc2MgQSByZXByZXNlbnRhdGlvbiBvZiByZWN0YW5ndWxhciBib3ggb24gdGhlIGVhcnRoLCBkZWZpbmVkIGJ5IGl0cyBzb3V0aHdlc3QgYW5kIG5vcnRoZWFzdCBwb2ludHMgaW4gbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZS5cbiAqIEBwYXJhbSB7TG5nTGF0fSBzdyBzb3V0aHdlc3RcbiAqIEBwYXJhbSB7TG5nTGF0fSBuZSBub3J0aGVhc3RcbiAqIEBleGFtcGxlXG4gKiB2YXIgc3cgPSBuZXcgbWFwYm94Z2wuTG5nTGF0KC03My45ODc2LCA0MC43NjYxKTtcbiAqIHZhciBuZSA9IG5ldyBtYXBib3hnbC5MbmdMYXQoLTczLjkzOTcsIDQwLjgwMDIpO1xuICogdmFyIGxsYiA9IG5ldyBtYXBib3hnbC5MbmdMYXRCb3VuZHMoc3csIG5lKTtcbiAqL1xuZnVuY3Rpb24gTG5nTGF0Qm91bmRzKHN3LCBuZSkge1xuICAgIGlmICghc3cpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAobmUpIHtcbiAgICAgICAgdGhpcy5leHRlbmQoc3cpLmV4dGVuZChuZSk7XG4gICAgfSBlbHNlIGlmIChzdy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgdGhpcy5leHRlbmQoW3N3WzBdLCBzd1sxXV0pLmV4dGVuZChbc3dbMl0sIHN3WzNdXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHRlbmQoc3dbMF0pLmV4dGVuZChzd1sxXSk7XG4gICAgfVxufVxuXG5MbmdMYXRCb3VuZHMucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIHRoZSBib3VuZHMgdG8gaW5jbHVkZSBhIGdpdmVuIExuZ0xhdCBvciBMbmdMYXRCb3VuZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xuZ0xhdHxMbmdMYXRCb3VuZHN9IG9iaiBvYmplY3QgdG8gZXh0ZW5kIHRvXG4gICAgICogQHJldHVybnMge0xuZ0xhdEJvdW5kc30gYHRoaXNgXG4gICAgICovXG4gICAgZXh0ZW5kOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgdmFyIHN3ID0gdGhpcy5fc3csXG4gICAgICAgICAgICBuZSA9IHRoaXMuX25lLFxuICAgICAgICAgICAgc3cyLCBuZTI7XG5cbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIExuZ0xhdCkge1xuICAgICAgICAgICAgc3cyID0gb2JqO1xuICAgICAgICAgICAgbmUyID0gb2JqO1xuXG4gICAgICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTG5nTGF0Qm91bmRzKSB7XG4gICAgICAgICAgICBzdzIgPSBvYmouX3N3O1xuICAgICAgICAgICAgbmUyID0gb2JqLl9uZTtcblxuICAgICAgICAgICAgaWYgKCFzdzIgfHwgIW5lMikgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogPyB0aGlzLmV4dGVuZChMbmdMYXQuY29udmVydChvYmopIHx8IExuZ0xhdEJvdW5kcy5jb252ZXJ0KG9iaikpIDogdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3cgJiYgIW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9zdyA9IG5ldyBMbmdMYXQoc3cyLmxuZywgc3cyLmxhdCk7XG4gICAgICAgICAgICB0aGlzLl9uZSA9IG5ldyBMbmdMYXQobmUyLmxuZywgbmUyLmxhdCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3LmxuZyA9IE1hdGgubWluKHN3Mi5sbmcsIHN3LmxuZyk7XG4gICAgICAgICAgICBzdy5sYXQgPSBNYXRoLm1pbihzdzIubGF0LCBzdy5sYXQpO1xuICAgICAgICAgICAgbmUubG5nID0gTWF0aC5tYXgobmUyLmxuZywgbmUubG5nKTtcbiAgICAgICAgICAgIG5lLmxhdCA9IE1hdGgubWF4KG5lMi5sYXQsIG5lLmxhdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwb2ludCBlcXVpZGlzdGFudCBmcm9tIHRoaXMgYm94J3MgY29ybmVyc1xuICAgICAqIEByZXR1cm5zIHtMbmdMYXR9IGNlbnRlcnBvaW50XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgbGxiID0gbmV3IG1hcGJveGdsLkxuZ0xhdEJvdW5kcyhbLTczLjk4NzYsIDQwLjc2NjFdLCBbLTczLjkzOTcsIDQwLjgwMDJdKTtcbiAgICAgKiBsbGIuZ2V0Q2VudGVyKCk7IC8vID0gTG5nTGF0IHtsbmc6IC03My45NjM2NSwgbGF0OiA0MC43ODMxNX1cbiAgICAgKi9cbiAgICBnZXRDZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IExuZ0xhdCgodGhpcy5fc3cubG5nICsgdGhpcy5fbmUubG5nKSAvIDIsICh0aGlzLl9zdy5sYXQgKyB0aGlzLl9uZS5sYXQpIC8gMik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzb3V0aHdlc3QgY29ybmVyXG4gICAgICogQHJldHVybnMge0xuZ0xhdH0gc291dGh3ZXN0XG4gICAgICovXG4gICAgZ2V0U291dGhXZXN0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3N3OyB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IG5vcnRoZWFzdCBjb3JuZXJcbiAgICAgKiBAcmV0dXJucyB7TG5nTGF0fSBub3J0aGVhc3RcbiAgICAgKi9cbiAgICBnZXROb3J0aEVhc3Q6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fbmU7IH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbm9ydGh3ZXN0IGNvcm5lclxuICAgICAqIEByZXR1cm5zIHtMbmdMYXR9IG5vcnRod2VzdFxuICAgICAqL1xuICAgIGdldE5vcnRoV2VzdDogZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgTG5nTGF0KHRoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldE5vcnRoKCkpOyB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNvdXRoZWFzdCBjb3JuZXJcbiAgICAgKiBAcmV0dXJucyB7TG5nTGF0fSBzb3V0aGVhc3RcbiAgICAgKi9cbiAgICBnZXRTb3V0aEVhc3Q6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IExuZ0xhdCh0aGlzLmdldEVhc3QoKSwgdGhpcy5nZXRTb3V0aCgpKTsgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB3ZXN0IGVkZ2UgbG9uZ2l0dWRlXG4gICAgICogQHJldHVybnMge251bWJlcn0gd2VzdFxuICAgICAqL1xuICAgIGdldFdlc3Q6ICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3N3LmxuZzsgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzb3V0aCBlZGdlIGxhdGl0dWRlXG4gICAgICogQHJldHVybnMge251bWJlcn0gc291dGhcbiAgICAgKi9cbiAgICBnZXRTb3V0aDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9zdy5sYXQ7IH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgZWFzdCBlZGdlIGxvbmdpdHVkZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGVhc3RcbiAgICAgKi9cbiAgICBnZXRFYXN0OiAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9uZS5sbmc7IH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbm9ydGggZWRnZSBsYXRpdHVkZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG5vcnRoXG4gICAgICovXG4gICAgZ2V0Tm9ydGg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fbmUubGF0OyB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgYExuZ0xhdEJvdW5kc2AgYXMgYW4gYXJyYXlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHthcnJheX0gW2xuZywgbGF0XVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGxsYiA9IG5ldyBtYXBib3hnbC5MbmdMYXRCb3VuZHMoWy03My45ODc2LCA0MC43NjYxXSwgWy03My45Mzk3LCA0MC44MDAyXSk7XG4gICAgICogbGxiLnRvQXJyYXkoKTsgLy8gPSBbWy03My45ODc2LCA0MC43NjYxXSwgWy03My45Mzk3LCA0MC44MDAyXV1cbiAgICAgKi9cbiAgICB0b0FycmF5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5fc3cudG9BcnJheSgpLCB0aGlzLl9uZS50b0FycmF5KCldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBgTG5nTGF0Qm91bmRzYCBhcyBhIHN0cmluZ1xuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gXCJMbmdMYXRCb3VuZHMoTG5nTGF0KGxuZywgbGF0KSwgTG5nTGF0KGxuZywgbGF0KSlcIlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGxsYiA9IG5ldyBtYXBib3hnbC5MbmdMYXRCb3VuZHMoWy03My45ODc2LCA0MC43NjYxXSwgWy03My45Mzk3LCA0MC44MDAyXSk7XG4gICAgICogbGxiLnRvU3RyaW5nKCk7IC8vID0gXCJMbmdMYXRCb3VuZHMoTG5nTGF0KC03My45ODc2LCA0MC43NjYxKSwgTG5nTGF0KC03My45Mzk3LCA0MC44MDAyKSlcIlxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTG5nTGF0Qm91bmRzKCcgKyB0aGlzLl9zdy50b1N0cmluZygpICsgJywgJyArIHRoaXMuX25lLnRvU3RyaW5nKCkgKyAnKSc7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIGFycmF5IHRvIGEgYExuZ0xhdEJvdW5kc2Agb2JqZWN0LCBvciByZXR1cm4gYW4gZXhpc3RpbmdcbiAqIGBMbmdMYXRCb3VuZHNgIG9iamVjdCB1bmNoYW5nZWQuXG4gKlxuICogQ2FsbHMgYExuZ0xhdCNjb252ZXJ0YCBpbnRlcm5hbGx5IHRvIGNvbnZlcnQgYXJyYXlzIGFzIGBMbmdMYXRgIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge0xuZ0xhdEJvdW5kc3xBcnJheTxudW1iZXI+fEFycmF5PEFycmF5PG51bWJlcj4+fSBpbnB1dCBpbnB1dCB0byBjb252ZXJ0IHRvIGEgTG5nTGF0Qm91bmRzXG4gKiBAcmV0dXJucyB7TG5nTGF0Qm91bmRzfSBMbmdMYXRCb3VuZHMgb2JqZWN0IG9yIG9yaWdpbmFsIGlucHV0XG4gKiBAZXhhbXBsZVxuICogdmFyIGFyciA9IFtbLTczLjk4NzYsIDQwLjc2NjFdLCBbLTczLjkzOTcsIDQwLjgwMDJdXTtcbiAqIHZhciBsbGIgPSBtYXBib3hnbC5MbmdMYXRCb3VuZHMuY29udmVydChhcnIpO1xuICogbGxiOyAgIC8vID0gTG5nTGF0Qm91bmRzIHtfc3c6IExuZ0xhdCB7bG5nOiAtNzMuOTg3NiwgbGF0OiA0MC43NjYxfSwgX25lOiBMbmdMYXQge2xuZzogLTczLjkzOTcsIGxhdDogNDAuODAwMn19XG4gKi9cbkxuZ0xhdEJvdW5kcy5jb252ZXJ0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCB8fCBpbnB1dCBpbnN0YW5jZW9mIExuZ0xhdEJvdW5kcykgcmV0dXJuIGlucHV0O1xuICAgIHJldHVybiBuZXcgTG5nTGF0Qm91bmRzKGlucHV0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBMbmdMYXQgPSByZXF1aXJlKCcuL2xuZ19sYXQnKSxcbiAgICBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5JyksXG4gICAgQ29vcmRpbmF0ZSA9IHJlcXVpcmUoJy4vY29vcmRpbmF0ZScpLFxuICAgIHdyYXAgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKS53cmFwLFxuICAgIGludGVycCA9IHJlcXVpcmUoJy4uL3V0aWwvaW50ZXJwb2xhdGUnKSxcbiAgICBUaWxlQ29vcmQgPSByZXF1aXJlKCcuLi9zb3VyY2UvdGlsZV9jb29yZCcpLFxuICAgIEVYVEVOVCA9IHJlcXVpcmUoJy4uL2RhdGEvYnVja2V0JykuRVhURU5ULFxuICAgIGdsbWF0cml4ID0gcmVxdWlyZSgnZ2wtbWF0cml4Jyk7XG5cbnZhciB2ZWM0ID0gZ2xtYXRyaXgudmVjNCxcbiAgICBtYXQ0ID0gZ2xtYXRyaXgubWF0NCxcbiAgICBtYXQyID0gZ2xtYXRyaXgubWF0MjtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbi8qKlxuICogQSBzaW5nbGUgdHJhbnNmb3JtLCBnZW5lcmFsbHkgdXNlZCBmb3IgYSBzaW5nbGUgdGlsZSB0byBiZVxuICogc2NhbGVkLCByb3RhdGVkLCBhbmQgem9vbWVkLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5ab29tXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4Wm9vbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVHJhbnNmb3JtKG1pblpvb20sIG1heFpvb20pIHtcbiAgICB0aGlzLnRpbGVTaXplID0gNTEyOyAvLyBjb25zdGFudFxuXG4gICAgdGhpcy5fbWluWm9vbSA9IG1pblpvb20gfHwgMDtcbiAgICB0aGlzLl9tYXhab29tID0gbWF4Wm9vbSB8fCAyMjtcblxuICAgIHRoaXMubGF0UmFuZ2UgPSBbLTg1LjA1MTEzLCA4NS4wNTExM107XG5cbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5fY2VudGVyID0gbmV3IExuZ0xhdCgwLCAwKTtcbiAgICB0aGlzLnpvb20gPSAwO1xuICAgIHRoaXMuYW5nbGUgPSAwO1xuICAgIHRoaXMuX2FsdGl0dWRlID0gMS41O1xuICAgIHRoaXMuX3BpdGNoID0gMDtcbiAgICB0aGlzLl91bm1vZGlmaWVkID0gdHJ1ZTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZSA9IHtcbiAgICBnZXQgbWluWm9vbSgpIHsgcmV0dXJuIHRoaXMuX21pblpvb207IH0sXG4gICAgc2V0IG1pblpvb20oem9vbSkge1xuICAgICAgICBpZiAodGhpcy5fbWluWm9vbSA9PT0gem9vbSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9taW5ab29tID0gem9vbTtcbiAgICAgICAgdGhpcy56b29tID0gTWF0aC5tYXgodGhpcy56b29tLCB6b29tKTtcbiAgICB9LFxuXG4gICAgZ2V0IG1heFpvb20oKSB7IHJldHVybiB0aGlzLl9tYXhab29tOyB9LFxuICAgIHNldCBtYXhab29tKHpvb20pIHtcbiAgICAgICAgaWYgKHRoaXMuX21heFpvb20gPT09IHpvb20pIHJldHVybjtcbiAgICAgICAgdGhpcy5fbWF4Wm9vbSA9IHpvb207XG4gICAgICAgIHRoaXMuem9vbSA9IE1hdGgubWluKHRoaXMuem9vbSwgem9vbSk7XG4gICAgfSxcblxuICAgIGdldCB3b3JsZFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVTaXplICogdGhpcy5zY2FsZTtcbiAgICB9LFxuXG4gICAgZ2V0IGNlbnRlclBvaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplLl9kaXYoMik7XG4gICAgfSxcblxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgZ2V0IGJlYXJpbmcoKSB7XG4gICAgICAgIHJldHVybiAtdGhpcy5hbmdsZSAvIE1hdGguUEkgKiAxODA7XG4gICAgfSxcbiAgICBzZXQgYmVhcmluZyhiZWFyaW5nKSB7XG4gICAgICAgIHZhciBiID0gLXdyYXAoYmVhcmluZywgLTE4MCwgMTgwKSAqIE1hdGguUEkgLyAxODA7XG4gICAgICAgIGlmICh0aGlzLmFuZ2xlID09PSBiKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3VubW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmdsZSA9IGI7XG4gICAgICAgIHRoaXMuX2NhbGNQcm9qTWF0cml4KCk7XG5cbiAgICAgICAgLy8gMngyIG1hdHJpeCBmb3Igcm90YXRpbmcgcG9pbnRzXG4gICAgICAgIHRoaXMucm90YXRpb25NYXRyaXggPSBtYXQyLmNyZWF0ZSgpO1xuICAgICAgICBtYXQyLnJvdGF0ZSh0aGlzLnJvdGF0aW9uTWF0cml4LCB0aGlzLnJvdGF0aW9uTWF0cml4LCB0aGlzLmFuZ2xlKTtcbiAgICB9LFxuXG4gICAgZ2V0IHBpdGNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGl0Y2ggLyBNYXRoLlBJICogMTgwO1xuICAgIH0sXG4gICAgc2V0IHBpdGNoKHBpdGNoKSB7XG4gICAgICAgIHZhciBwID0gTWF0aC5taW4oNjAsIHBpdGNoKSAvIDE4MCAqIE1hdGguUEk7XG4gICAgICAgIGlmICh0aGlzLl9waXRjaCA9PT0gcCkgcmV0dXJuO1xuICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BpdGNoID0gcDtcbiAgICAgICAgdGhpcy5fY2FsY1Byb2pNYXRyaXgoKTtcbiAgICB9LFxuXG4gICAgZ2V0IGFsdGl0dWRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWx0aXR1ZGU7XG4gICAgfSxcbiAgICBzZXQgYWx0aXR1ZGUoYWx0aXR1ZGUpIHtcbiAgICAgICAgdmFyIGEgPSBNYXRoLm1heCgwLjc1LCBhbHRpdHVkZSk7XG4gICAgICAgIGlmICh0aGlzLl9hbHRpdHVkZSA9PT0gYSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2FsdGl0dWRlID0gYTtcbiAgICAgICAgdGhpcy5fY2FsY1Byb2pNYXRyaXgoKTtcbiAgICB9LFxuXG4gICAgZ2V0IHpvb20oKSB7IHJldHVybiB0aGlzLl96b29tOyB9LFxuICAgIHNldCB6b29tKHpvb20pIHtcbiAgICAgICAgdmFyIHogPSBNYXRoLm1pbihNYXRoLm1heCh6b29tLCB0aGlzLm1pblpvb20pLCB0aGlzLm1heFpvb20pO1xuICAgICAgICBpZiAodGhpcy5fem9vbSA9PT0geikgcmV0dXJuO1xuICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3pvb20gPSB6O1xuICAgICAgICB0aGlzLnNjYWxlID0gdGhpcy56b29tU2NhbGUoeik7XG4gICAgICAgIHRoaXMudGlsZVpvb20gPSBNYXRoLmZsb29yKHopO1xuICAgICAgICB0aGlzLnpvb21GcmFjdGlvbiA9IHogLSB0aGlzLnRpbGVab29tO1xuICAgICAgICB0aGlzLl9jYWxjUHJvak1hdHJpeCgpO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW4oKTtcbiAgICB9LFxuXG4gICAgZ2V0IGNlbnRlcigpIHsgcmV0dXJuIHRoaXMuX2NlbnRlcjsgfSxcbiAgICBzZXQgY2VudGVyKGNlbnRlcikge1xuICAgICAgICBpZiAoY2VudGVyLmxhdCA9PT0gdGhpcy5fY2VudGVyLmxhdCAmJiBjZW50ZXIubG5nID09PSB0aGlzLl9jZW50ZXIubG5nKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3VubW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2VudGVyID0gY2VudGVyO1xuICAgICAgICB0aGlzLl9jYWxjUHJvak1hdHJpeCgpO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW4oKTtcbiAgICB9LFxuXG4gICAgcmVzaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgdGhpcy5waXhlbHNUb0dMVW5pdHMgPSBbMiAvIHdpZHRoLCAtMiAvIGhlaWdodF07XG4gICAgICAgIHRoaXMuX2NhbGNQcm9qTWF0cml4KCk7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbigpO1xuICAgIH0sXG5cbiAgICBnZXQgdW5tb2RpZmllZCgpIHsgcmV0dXJuIHRoaXMuX3VubW9kaWZpZWQ7IH0sXG5cbiAgICB6b29tU2NhbGU6IGZ1bmN0aW9uKHpvb20pIHsgcmV0dXJuIE1hdGgucG93KDIsIHpvb20pOyB9LFxuICAgIHNjYWxlWm9vbTogZnVuY3Rpb24oc2NhbGUpIHsgcmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yOyB9LFxuXG4gICAgcHJvamVjdDogZnVuY3Rpb24obG5nbGF0LCB3b3JsZFNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgIHRoaXMubG5nWChsbmdsYXQubG5nLCB3b3JsZFNpemUpLFxuICAgICAgICAgICAgdGhpcy5sYXRZKGxuZ2xhdC5sYXQsIHdvcmxkU2l6ZSkpO1xuICAgIH0sXG5cbiAgICB1bnByb2plY3Q6IGZ1bmN0aW9uKHBvaW50LCB3b3JsZFNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMbmdMYXQoXG4gICAgICAgICAgICB0aGlzLnhMbmcocG9pbnQueCwgd29ybGRTaXplKSxcbiAgICAgICAgICAgIHRoaXMueUxhdChwb2ludC55LCB3b3JsZFNpemUpKTtcbiAgICB9LFxuXG4gICAgZ2V0IHgoKSB7IHJldHVybiB0aGlzLmxuZ1godGhpcy5jZW50ZXIubG5nKTsgfSxcbiAgICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMubGF0WSh0aGlzLmNlbnRlci5sYXQpOyB9LFxuXG4gICAgZ2V0IHBvaW50KCkgeyByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTsgfSxcblxuICAgIC8qKlxuICAgICAqIGxhdGl0dWRlIHRvIGFic29sdXRlIHggY29vcmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3b3JsZFNpemU9dGhpcy53b3JsZFNpemVdXG4gICAgICogQHJldHVybnMge251bWJlcn0gcGl4ZWwgY29vcmRpbmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbG5nWDogZnVuY3Rpb24obG5nLCB3b3JsZFNpemUpIHtcbiAgICAgICAgcmV0dXJuICgxODAgKyBsbmcpICogKHdvcmxkU2l6ZSB8fCB0aGlzLndvcmxkU2l6ZSkgLyAzNjA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBsYXRpdHVkZSB0byBhYnNvbHV0ZSB5IGNvb3JkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd29ybGRTaXplPXRoaXMud29ybGRTaXplXVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBpeGVsIGNvb3JkaW5hdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGxhdFk6IGZ1bmN0aW9uKGxhdCwgd29ybGRTaXplKSB7XG4gICAgICAgIHZhciB5ID0gMTgwIC8gTWF0aC5QSSAqIE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgbGF0ICogTWF0aC5QSSAvIDM2MCkpO1xuICAgICAgICByZXR1cm4gKDE4MCAtIHkpICogKHdvcmxkU2l6ZSB8fCB0aGlzLndvcmxkU2l6ZSkgLyAzNjA7XG4gICAgfSxcblxuICAgIHhMbmc6IGZ1bmN0aW9uKHgsIHdvcmxkU2l6ZSkge1xuICAgICAgICByZXR1cm4geCAqIDM2MCAvICh3b3JsZFNpemUgfHwgdGhpcy53b3JsZFNpemUpIC0gMTgwO1xuICAgIH0sXG4gICAgeUxhdDogZnVuY3Rpb24oeSwgd29ybGRTaXplKSB7XG4gICAgICAgIHZhciB5MiA9IDE4MCAtIHkgKiAzNjAgLyAod29ybGRTaXplIHx8IHRoaXMud29ybGRTaXplKTtcbiAgICAgICAgcmV0dXJuIDM2MCAvIE1hdGguUEkgKiBNYXRoLmF0YW4oTWF0aC5leHAoeTIgKiBNYXRoLlBJIC8gMTgwKSkgLSA5MDtcbiAgICB9LFxuXG4gICAgcGFuQnk6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLmNlbnRlclBvaW50Ll9hZGQob2Zmc2V0KTtcbiAgICAgICAgdGhpcy5jZW50ZXIgPSB0aGlzLnBvaW50TG9jYXRpb24ocG9pbnQpO1xuICAgIH0sXG5cbiAgICBzZXRMb2NhdGlvbkF0UG9pbnQ6IGZ1bmN0aW9uKGxuZ2xhdCwgcG9pbnQpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmxvY2F0aW9uQ29vcmRpbmF0ZShsbmdsYXQpO1xuICAgICAgICB2YXIgY29vcmRBdFBvaW50ID0gdGhpcy5wb2ludENvb3JkaW5hdGUocG9pbnQpO1xuICAgICAgICB2YXIgY29vcmRDZW50ZXIgPSB0aGlzLnBvaW50Q29vcmRpbmF0ZSh0aGlzLmNlbnRlclBvaW50KTtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZSA9IGNvb3JkQXRQb2ludC5fc3ViKGMpO1xuICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2VudGVyID0gdGhpcy5jb29yZGluYXRlTG9jYXRpb24oY29vcmRDZW50ZXIuX3N1Yih0cmFuc2xhdGUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBsb2NhdGlvbiwgcmV0dXJuIHRoZSBzY3JlZW4gcG9pbnQgdGhhdCBjb3JyZXNwb25kcyB0byBpdFxuICAgICAqIEBwYXJhbSB7TG5nTGF0fSBsbmdsYXQgbG9jYXRpb25cbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IHNjcmVlbiBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbG9jYXRpb25Qb2ludDogZnVuY3Rpb24obG5nbGF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvb3JkaW5hdGVQb2ludCh0aGlzLmxvY2F0aW9uQ29vcmRpbmF0ZShsbmdsYXQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBwb2ludCBvbiBzY3JlZW4sIHJldHVybiBpdHMgbG5nbGF0XG4gICAgICogQHBhcmFtIHtQb2ludH0gcCBzY3JlZW4gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7TG5nTGF0fSBsbmdsYXQgbG9jYXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBvaW50TG9jYXRpb246IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZUxvY2F0aW9uKHRoaXMucG9pbnRDb29yZGluYXRlKHApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBnZW9ncmFwaGljYWwgbG5nbGF0LCByZXR1cm4gYW4gdW5yb3VuZGVkXG4gICAgICogY29vcmRpbmF0ZSB0aGF0IHJlcHJlc2VudHMgaXQgYXQgdGhpcyB0cmFuc2Zvcm0ncyB6b29tIGxldmVsIGFuZFxuICAgICAqIHdvcmxkc2l6ZS5cbiAgICAgKiBAcGFyYW0ge0xuZ0xhdH0gbG5nbGF0XG4gICAgICogQHJldHVybnMge0Nvb3JkaW5hdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBsb2NhdGlvbkNvb3JkaW5hdGU6IGZ1bmN0aW9uKGxuZ2xhdCkge1xuICAgICAgICB2YXIgayA9IHRoaXMuem9vbVNjYWxlKHRoaXMudGlsZVpvb20pIC8gdGhpcy53b3JsZFNpemUsXG4gICAgICAgICAgICBsbCA9IExuZ0xhdC5jb252ZXJ0KGxuZ2xhdCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb29yZGluYXRlKFxuICAgICAgICAgICAgdGhpcy5sbmdYKGxsLmxuZykgKiBrLFxuICAgICAgICAgICAgdGhpcy5sYXRZKGxsLmxhdCkgKiBrLFxuICAgICAgICAgICAgdGhpcy50aWxlWm9vbSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgQ29vcmRpbmF0ZSwgcmV0dXJuIGl0cyBnZW9ncmFwaGljYWwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZFxuICAgICAqIEByZXR1cm5zIHtMbmdMYXR9IGxuZ2xhdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29vcmRpbmF0ZUxvY2F0aW9uOiBmdW5jdGlvbihjb29yZCkge1xuICAgICAgICB2YXIgd29ybGRTaXplID0gdGhpcy56b29tU2NhbGUoY29vcmQuem9vbSk7XG4gICAgICAgIHJldHVybiBuZXcgTG5nTGF0KFxuICAgICAgICAgICAgdGhpcy54TG5nKGNvb3JkLmNvbHVtbiwgd29ybGRTaXplKSxcbiAgICAgICAgICAgIHRoaXMueUxhdChjb29yZC5yb3csIHdvcmxkU2l6ZSkpO1xuICAgIH0sXG5cbiAgICBwb2ludENvb3JkaW5hdGU6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICB2YXIgdGFyZ2V0WiA9IDA7XG5cbiAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuY29vcmRpbmF0ZVBvaW50TWF0cml4KHRoaXMudGlsZVpvb20pO1xuICAgICAgICBtYXQ0LmludmVydChtYXRyaXgsIG1hdHJpeCk7XG5cbiAgICAgICAgaWYgKCFtYXRyaXgpIHRocm93IG5ldyBFcnJvcihcImZhaWxlZCB0byBpbnZlcnQgbWF0cml4XCIpO1xuXG4gICAgICAgIC8vIHNpbmNlIHdlIGRvbid0IGtub3cgdGhlIGNvcnJlY3QgcHJvamVjdGVkIHogdmFsdWUgZm9yIHRoZSBwb2ludCxcbiAgICAgICAgLy8gdW5wcm9qZWN0IHR3byBwb2ludHMgdG8gZ2V0IGEgbGluZSBhbmQgdGhlbiBmaW5kIHRoZSBwb2ludCBvbiB0aGF0XG4gICAgICAgIC8vIGxpbmUgd2l0aCB6PTBcblxuICAgICAgICB2YXIgY29vcmQwID0gW3AueCwgcC55LCAwLCAxXTtcbiAgICAgICAgdmFyIGNvb3JkMSA9IFtwLngsIHAueSwgMSwgMV07XG5cbiAgICAgICAgdmVjNC50cmFuc2Zvcm1NYXQ0KGNvb3JkMCwgY29vcmQwLCBtYXRyaXgpO1xuICAgICAgICB2ZWM0LnRyYW5zZm9ybU1hdDQoY29vcmQxLCBjb29yZDEsIG1hdHJpeCk7XG5cbiAgICAgICAgdmFyIHcwID0gY29vcmQwWzNdO1xuICAgICAgICB2YXIgdzEgPSBjb29yZDFbM107XG4gICAgICAgIHZhciB4MCA9IGNvb3JkMFswXSAvIHcwO1xuICAgICAgICB2YXIgeDEgPSBjb29yZDFbMF0gLyB3MTtcbiAgICAgICAgdmFyIHkwID0gY29vcmQwWzFdIC8gdzA7XG4gICAgICAgIHZhciB5MSA9IGNvb3JkMVsxXSAvIHcxO1xuICAgICAgICB2YXIgejAgPSBjb29yZDBbMl0gLyB3MDtcbiAgICAgICAgdmFyIHoxID0gY29vcmQxWzJdIC8gdzE7XG5cblxuICAgICAgICB2YXIgdCA9IHowID09PSB6MSA/IDAgOiAodGFyZ2V0WiAtIHowKSAvICh6MSAtIHowKTtcblxuICAgICAgICByZXR1cm4gbmV3IENvb3JkaW5hdGUoXG4gICAgICAgICAgICBpbnRlcnAoeDAsIHgxLCB0KSxcbiAgICAgICAgICAgIGludGVycCh5MCwgeTEsIHQpLFxuICAgICAgICAgICAgdGhpcy50aWxlWm9vbSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgY29vcmRpbmF0ZSwgcmV0dXJuIHRoZSBzY3JlZW4gcG9pbnQgdGhhdCBjb3JyZXNwb25kcyB0byBpdFxuICAgICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IHNjcmVlbiBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29vcmRpbmF0ZVBvaW50OiBmdW5jdGlvbihjb29yZCkge1xuICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5jb29yZGluYXRlUG9pbnRNYXRyaXgoY29vcmQuem9vbSk7XG4gICAgICAgIHZhciBwID0gW2Nvb3JkLmNvbHVtbiwgY29vcmQucm93LCAwLCAxXTtcbiAgICAgICAgdmVjNC50cmFuc2Zvcm1NYXQ0KHAsIHAsIG1hdHJpeCk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQocFswXSAvIHBbM10sIHBbMV0gLyBwWzNdKTtcbiAgICB9LFxuXG4gICAgY29vcmRpbmF0ZVBvaW50TWF0cml4OiBmdW5jdGlvbih6KSB7XG4gICAgICAgIHZhciBwcm9qID0gbWF0NC5jb3B5KG5ldyBGbG9hdDY0QXJyYXkoMTYpLCB0aGlzLnByb2pNYXRyaXgpO1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLndvcmxkU2l6ZSAvIHRoaXMuem9vbVNjYWxlKHopO1xuICAgICAgICBtYXQ0LnNjYWxlKHByb2osIHByb2osIFtzY2FsZSwgc2NhbGUsIDFdKTtcbiAgICAgICAgbWF0NC5tdWx0aXBseShwcm9qLCB0aGlzLmdldFBpeGVsTWF0cml4KCksIHByb2opO1xuICAgICAgICByZXR1cm4gcHJvajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29udmVydHMgZ2wgY29vcmRpbmF0ZXMgLTEuLjEgdG8gcGl4ZWxzIDAuLndpZHRoXG4gICAgICogQHJldHVybnMge09iamVjdH0gbWF0cml4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRQaXhlbE1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtID0gbWF0NC5jcmVhdGUoKTtcbiAgICAgICAgbWF0NC5zY2FsZShtLCBtLCBbdGhpcy53aWR0aCAvIDIsIC10aGlzLmhlaWdodCAvIDIsIDFdKTtcbiAgICAgICAgbWF0NC50cmFuc2xhdGUobSwgbSwgWzEsIC0xLCAwXSk7XG4gICAgICAgIHJldHVybiBtO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvc01hdHJpeCB0aGF0LCBnaXZlbiBhIHRpbGUgY29vcmRpbmF0ZSwgd291bGQgYmUgdXNlZCB0byBkaXNwbGF5IHRoZSB0aWxlIG9uIGEgbWFwLlxuICAgICAqIEBwYXJhbSB7VGlsZUNvb3JkfENvb3JkaW5hdGV9IGNvb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFpvb20gbWF4aW11bSBzb3VyY2Ugem9vbSB0byBhY2NvdW50IGZvciBvdmVyc2NhbGluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2FsY3VsYXRlUG9zTWF0cml4OiBmdW5jdGlvbihjb29yZCwgbWF4Wm9vbSkge1xuICAgICAgICBpZiAobWF4Wm9vbSA9PT0gdW5kZWZpbmVkKSBtYXhab29tID0gSW5maW5pdHk7XG4gICAgICAgIGlmIChjb29yZCBpbnN0YW5jZW9mIFRpbGVDb29yZCkgY29vcmQgPSBjb29yZC50b0Nvb3JkaW5hdGUobWF4Wm9vbSk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBtb2RlbC12aWV3IG1hdHJpeCB0aGF0IGNvbnZlcnRzIGZyb20gdGhlIHRpbGUgY29vcmRpbmF0ZXMgdG8gc2NyZWVuIGNvb3JkaW5hdGVzLlxuXG4gICAgICAgIC8vIGlmIHogPiBtYXh6b29tIHRoZW4gdGhlIHRpbGUgaXMgYWN0dWFsbHkgYSBvdmVyc2NhbGVkIG1heHpvb20gdGlsZSxcbiAgICAgICAgLy8gc28gY2FsY3VsYXRlIHRoZSBtYXRyaXggdGhlIG1heHpvb20gdGlsZSB3b3VsZCB1c2UuXG4gICAgICAgIHZhciB6ID0gTWF0aC5taW4oY29vcmQuem9vbSwgbWF4Wm9vbSk7XG5cbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy53b3JsZFNpemUgLyBNYXRoLnBvdygyLCB6KTtcbiAgICAgICAgdmFyIHBvc01hdHJpeCA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuXG4gICAgICAgIG1hdDQuaWRlbnRpdHkocG9zTWF0cml4KTtcbiAgICAgICAgbWF0NC50cmFuc2xhdGUocG9zTWF0cml4LCBwb3NNYXRyaXgsIFtjb29yZC5jb2x1bW4gKiBzY2FsZSwgY29vcmQucm93ICogc2NhbGUsIDBdKTtcbiAgICAgICAgbWF0NC5zY2FsZShwb3NNYXRyaXgsIHBvc01hdHJpeCwgWyBzY2FsZSAvIEVYVEVOVCwgc2NhbGUgLyBFWFRFTlQsIDEgXSk7XG4gICAgICAgIG1hdDQubXVsdGlwbHkocG9zTWF0cml4LCB0aGlzLnByb2pNYXRyaXgsIHBvc01hdHJpeCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkocG9zTWF0cml4KTtcbiAgICB9LFxuXG4gICAgX2NvbnN0cmFpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5jZW50ZXIgfHwgIXRoaXMud2lkdGggfHwgIXRoaXMuaGVpZ2h0IHx8IHRoaXMuX2NvbnN0cmFpbmluZykgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbmluZyA9IHRydWU7XG5cbiAgICAgICAgdmFyIG1pblksIG1heFksIG1pblgsIG1heFgsIHN5LCBzeCwgeDIsIHkyLFxuICAgICAgICAgICAgc2l6ZSA9IHRoaXMuc2l6ZSxcbiAgICAgICAgICAgIHVubW9kaWZpZWQgPSB0aGlzLl91bm1vZGlmaWVkO1xuXG4gICAgICAgIGlmICh0aGlzLmxhdFJhbmdlKSB7XG4gICAgICAgICAgICBtaW5ZID0gdGhpcy5sYXRZKHRoaXMubGF0UmFuZ2VbMV0pO1xuICAgICAgICAgICAgbWF4WSA9IHRoaXMubGF0WSh0aGlzLmxhdFJhbmdlWzBdKTtcbiAgICAgICAgICAgIHN5ID0gbWF4WSAtIG1pblkgPCBzaXplLnkgPyBzaXplLnkgLyAobWF4WSAtIG1pblkpIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmxuZ1JhbmdlKSB7XG4gICAgICAgICAgICBtaW5YID0gdGhpcy5sbmdYKHRoaXMubG5nUmFuZ2VbMF0pO1xuICAgICAgICAgICAgbWF4WCA9IHRoaXMubG5nWCh0aGlzLmxuZ1JhbmdlWzFdKTtcbiAgICAgICAgICAgIHN4ID0gbWF4WCAtIG1pblggPCBzaXplLnggPyBzaXplLnggLyAobWF4WCAtIG1pblgpIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhvdyBtdWNoIHRoZSBtYXAgc2hvdWxkIHNjYWxlIHRvIGZpdCB0aGUgc2NyZWVuIGludG8gZ2l2ZW4gbGF0aXR1ZGUvbG9uZ2l0dWRlIHJhbmdlc1xuICAgICAgICB2YXIgcyA9IE1hdGgubWF4KHN4IHx8IDAsIHN5IHx8IDApO1xuXG4gICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICB0aGlzLmNlbnRlciA9IHRoaXMudW5wcm9qZWN0KG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICBzeCA/IChtYXhYICsgbWluWCkgLyAyIDogdGhpcy54LFxuICAgICAgICAgICAgICAgIHN5ID8gKG1heFkgKyBtaW5ZKSAvIDIgOiB0aGlzLnkpKTtcbiAgICAgICAgICAgIHRoaXMuem9vbSArPSB0aGlzLnNjYWxlWm9vbShzKTtcbiAgICAgICAgICAgIHRoaXMuX3VubW9kaWZpZWQgPSB1bm1vZGlmaWVkO1xuICAgICAgICAgICAgdGhpcy5fY29uc3RyYWluaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5sYXRSYW5nZSkge1xuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLnksXG4gICAgICAgICAgICAgICAgaDIgPSBzaXplLnkgLyAyO1xuXG4gICAgICAgICAgICBpZiAoeSAtIGgyIDwgbWluWSkgeTIgPSBtaW5ZICsgaDI7XG4gICAgICAgICAgICBpZiAoeSArIGgyID4gbWF4WSkgeTIgPSBtYXhZIC0gaDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5sbmdSYW5nZSkge1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgICAgICAgICAgdzIgPSBzaXplLnggLyAyO1xuXG4gICAgICAgICAgICBpZiAoeCAtIHcyIDwgbWluWCkgeDIgPSBtaW5YICsgdzI7XG4gICAgICAgICAgICBpZiAoeCArIHcyID4gbWF4WCkgeDIgPSBtYXhYIC0gdzI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYW4gdGhlIG1hcCBpZiB0aGUgc2NyZWVuIGdvZXMgb2ZmIHRoZSByYW5nZVxuICAgICAgICBpZiAoeDIgIT09IHVuZGVmaW5lZCB8fCB5MiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNlbnRlciA9IHRoaXMudW5wcm9qZWN0KG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICB4MiAhPT0gdW5kZWZpbmVkID8geDIgOiB0aGlzLngsXG4gICAgICAgICAgICAgICAgeTIgIT09IHVuZGVmaW5lZCA/IHkyIDogdGhpcy55KSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gdW5tb2RpZmllZDtcbiAgICAgICAgdGhpcy5fY29uc3RyYWluaW5nID0gZmFsc2U7XG4gICAgfSxcblxuICAgIF9jYWxjUHJvak1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIHBvaW50IHRvIHRoZSBjZW50ZXIgdG9wIGluIGFsdGl0dWRlIHVuaXRzIHVzaW5nIGxhdyBvZiBzaW5lcy5cbiAgICAgICAgdmFyIGhhbGZGb3YgPSBNYXRoLmF0YW4oMC41IC8gdGhpcy5hbHRpdHVkZSk7XG4gICAgICAgIHZhciB0b3BIYWxmU3VyZmFjZURpc3RhbmNlID0gTWF0aC5zaW4oaGFsZkZvdikgKiB0aGlzLmFsdGl0dWRlIC8gTWF0aC5zaW4oTWF0aC5QSSAvIDIgLSB0aGlzLl9waXRjaCAtIGhhbGZGb3YpO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB6IHZhbHVlIG9mIHRoZSBmYXJ0aGVzdCBmcmFnbWVudCB0aGF0IHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgICAgdmFyIGZhclogPSBNYXRoLmNvcyhNYXRoLlBJIC8gMiAtIHRoaXMuX3BpdGNoKSAqIHRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgKyB0aGlzLmFsdGl0dWRlO1xuXG4gICAgICAgIG1hdDQucGVyc3BlY3RpdmUobSwgMiAqIE1hdGguYXRhbigodGhpcy5oZWlnaHQgLyAyKSAvIHRoaXMuYWx0aXR1ZGUpLCB0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHQsIDAuMSwgZmFyWik7XG5cbiAgICAgICAgbWF0NC50cmFuc2xhdGUobSwgbSwgWzAsIDAsIC10aGlzLmFsdGl0dWRlXSk7XG5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlIHJvdGF0ZVgsIHogdmFsdWVzIGFyZSBpbiBwaXhlbCB1bml0cy4gQ29udmVydCB0aGVtIHRvXG4gICAgICAgIC8vIGFsdGl0dWRlIHVuaXRzLiAxIGFsdGl0dWRlIHVuaXQgPSB0aGUgc2NyZWVuIGhlaWdodC5cbiAgICAgICAgbWF0NC5zY2FsZShtLCBtLCBbMSwgLTEsIDEgLyB0aGlzLmhlaWdodF0pO1xuXG4gICAgICAgIG1hdDQucm90YXRlWChtLCBtLCB0aGlzLl9waXRjaCk7XG4gICAgICAgIG1hdDQucm90YXRlWihtLCBtLCB0aGlzLmFuZ2xlKTtcbiAgICAgICAgbWF0NC50cmFuc2xhdGUobSwgbSwgWy10aGlzLngsIC10aGlzLnksIDBdKTtcblxuICAgICAgICB0aGlzLnByb2pNYXRyaXggPSBtO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIEZvbnQgZGF0YSBGcm9tIEhlcnNoZXkgU2ltcGxleCBGb250XG4vLyBodHRwOi8vcGF1bGJvdXJrZS5uZXQvZGF0YWZvcm1hdHMvaGVyc2hleS9cbnZhciBzaW1wbGV4Rm9udCA9IHtcbiAgICBcIiBcIjogWzE2LCBbXV0sXG4gICAgXCIhXCI6IFsxMCwgWzUsIDIxLCA1LCA3LCAtMSwgLTEsIDUsIDIsIDQsIDEsIDUsIDAsIDYsIDEsIDUsIDJdXSxcbiAgICBcIlxcXCJcIjogWzE2LCBbNCwgMjEsIDQsIDE0LCAtMSwgLTEsIDEyLCAyMSwgMTIsIDE0XV0sXG4gICAgXCIjXCI6IFsyMSwgWzExLCAyNSwgNCwgLTcsIC0xLCAtMSwgMTcsIDI1LCAxMCwgLTcsIC0xLCAtMSwgNCwgMTIsIDE4LCAxMiwgLTEsIC0xLCAzLCA2LCAxNywgNl1dLFxuICAgIFwiJFwiOiBbMjAsIFs4LCAyNSwgOCwgLTQsIC0xLCAtMSwgMTIsIDI1LCAxMiwgLTQsIC0xLCAtMSwgMTcsIDE4LCAxNSwgMjAsIDEyLCAyMSwgOCwgMjEsIDUsIDIwLCAzLCAxOCwgMywgMTYsIDQsIDE0LCA1LCAxMywgNywgMTIsIDEzLCAxMCwgMTUsIDksIDE2LCA4LCAxNywgNiwgMTcsIDMsIDE1LCAxLCAxMiwgMCwgOCwgMCwgNSwgMSwgMywgM11dLFxuICAgIFwiJVwiOiBbMjQsIFsyMSwgMjEsIDMsIDAsIC0xLCAtMSwgOCwgMjEsIDEwLCAxOSwgMTAsIDE3LCA5LCAxNSwgNywgMTQsIDUsIDE0LCAzLCAxNiwgMywgMTgsIDQsIDIwLCA2LCAyMSwgOCwgMjEsIDEwLCAyMCwgMTMsIDE5LCAxNiwgMTksIDE5LCAyMCwgMjEsIDIxLCAtMSwgLTEsIDE3LCA3LCAxNSwgNiwgMTQsIDQsIDE0LCAyLCAxNiwgMCwgMTgsIDAsIDIwLCAxLCAyMSwgMywgMjEsIDUsIDE5LCA3LCAxNywgN11dLFxuICAgIFwiJlwiOiBbMjYsIFsyMywgMTIsIDIzLCAxMywgMjIsIDE0LCAyMSwgMTQsIDIwLCAxMywgMTksIDExLCAxNywgNiwgMTUsIDMsIDEzLCAxLCAxMSwgMCwgNywgMCwgNSwgMSwgNCwgMiwgMywgNCwgMywgNiwgNCwgOCwgNSwgOSwgMTIsIDEzLCAxMywgMTQsIDE0LCAxNiwgMTQsIDE4LCAxMywgMjAsIDExLCAyMSwgOSwgMjAsIDgsIDE4LCA4LCAxNiwgOSwgMTMsIDExLCAxMCwgMTYsIDMsIDE4LCAxLCAyMCwgMCwgMjIsIDAsIDIzLCAxLCAyMywgMl1dLFxuICAgIFwiJ1wiOiBbMTAsIFs1LCAxOSwgNCwgMjAsIDUsIDIxLCA2LCAyMCwgNiwgMTgsIDUsIDE2LCA0LCAxNV1dLFxuICAgIFwiKFwiOiBbMTQsIFsxMSwgMjUsIDksIDIzLCA3LCAyMCwgNSwgMTYsIDQsIDExLCA0LCA3LCA1LCAyLCA3LCAtMiwgOSwgLTUsIDExLCAtN11dLFxuICAgIFwiKVwiOiBbMTQsIFszLCAyNSwgNSwgMjMsIDcsIDIwLCA5LCAxNiwgMTAsIDExLCAxMCwgNywgOSwgMiwgNywgLTIsIDUsIC01LCAzLCAtN11dLFxuICAgIFwiKlwiOiBbMTYsIFs4LCAyMSwgOCwgOSwgLTEsIC0xLCAzLCAxOCwgMTMsIDEyLCAtMSwgLTEsIDEzLCAxOCwgMywgMTJdXSxcbiAgICBcIitcIjogWzI2LCBbMTMsIDE4LCAxMywgMCwgLTEsIC0xLCA0LCA5LCAyMiwgOV1dLFxuICAgIFwiLFwiOiBbMTAsIFs2LCAxLCA1LCAwLCA0LCAxLCA1LCAyLCA2LCAxLCA2LCAtMSwgNSwgLTMsIDQsIC00XV0sXG4gICAgXCItXCI6IFsyNiwgWzQsIDksIDIyLCA5XV0sXG4gICAgXCIuXCI6IFsxMCwgWzUsIDIsIDQsIDEsIDUsIDAsIDYsIDEsIDUsIDJdXSxcbiAgICBcIi9cIjogWzIyLCBbMjAsIDI1LCAyLCAtN11dLFxuICAgIFwiMFwiOiBbMjAsIFs5LCAyMSwgNiwgMjAsIDQsIDE3LCAzLCAxMiwgMywgOSwgNCwgNCwgNiwgMSwgOSwgMCwgMTEsIDAsIDE0LCAxLCAxNiwgNCwgMTcsIDksIDE3LCAxMiwgMTYsIDE3LCAxNCwgMjAsIDExLCAyMSwgOSwgMjFdXSxcbiAgICBcIjFcIjogWzIwLCBbNiwgMTcsIDgsIDE4LCAxMSwgMjEsIDExLCAwXV0sXG4gICAgXCIyXCI6IFsyMCwgWzQsIDE2LCA0LCAxNywgNSwgMTksIDYsIDIwLCA4LCAyMSwgMTIsIDIxLCAxNCwgMjAsIDE1LCAxOSwgMTYsIDE3LCAxNiwgMTUsIDE1LCAxMywgMTMsIDEwLCAzLCAwLCAxNywgMF1dLFxuICAgIFwiM1wiOiBbMjAsIFs1LCAyMSwgMTYsIDIxLCAxMCwgMTMsIDEzLCAxMywgMTUsIDEyLCAxNiwgMTEsIDE3LCA4LCAxNywgNiwgMTYsIDMsIDE0LCAxLCAxMSwgMCwgOCwgMCwgNSwgMSwgNCwgMiwgMywgNF1dLFxuICAgIFwiNFwiOiBbMjAsIFsxMywgMjEsIDMsIDcsIDE4LCA3LCAtMSwgLTEsIDEzLCAyMSwgMTMsIDBdXSxcbiAgICBcIjVcIjogWzIwLCBbMTUsIDIxLCA1LCAyMSwgNCwgMTIsIDUsIDEzLCA4LCAxNCwgMTEsIDE0LCAxNCwgMTMsIDE2LCAxMSwgMTcsIDgsIDE3LCA2LCAxNiwgMywgMTQsIDEsIDExLCAwLCA4LCAwLCA1LCAxLCA0LCAyLCAzLCA0XV0sXG4gICAgXCI2XCI6IFsyMCwgWzE2LCAxOCwgMTUsIDIwLCAxMiwgMjEsIDEwLCAyMSwgNywgMjAsIDUsIDE3LCA0LCAxMiwgNCwgNywgNSwgMywgNywgMSwgMTAsIDAsIDExLCAwLCAxNCwgMSwgMTYsIDMsIDE3LCA2LCAxNywgNywgMTYsIDEwLCAxNCwgMTIsIDExLCAxMywgMTAsIDEzLCA3LCAxMiwgNSwgMTAsIDQsIDddXSxcbiAgICBcIjdcIjogWzIwLCBbMTcsIDIxLCA3LCAwLCAtMSwgLTEsIDMsIDIxLCAxNywgMjFdXSxcbiAgICBcIjhcIjogWzIwLCBbOCwgMjEsIDUsIDIwLCA0LCAxOCwgNCwgMTYsIDUsIDE0LCA3LCAxMywgMTEsIDEyLCAxNCwgMTEsIDE2LCA5LCAxNywgNywgMTcsIDQsIDE2LCAyLCAxNSwgMSwgMTIsIDAsIDgsIDAsIDUsIDEsIDQsIDIsIDMsIDQsIDMsIDcsIDQsIDksIDYsIDExLCA5LCAxMiwgMTMsIDEzLCAxNSwgMTQsIDE2LCAxNiwgMTYsIDE4LCAxNSwgMjAsIDEyLCAyMSwgOCwgMjFdXSxcbiAgICBcIjlcIjogWzIwLCBbMTYsIDE0LCAxNSwgMTEsIDEzLCA5LCAxMCwgOCwgOSwgOCwgNiwgOSwgNCwgMTEsIDMsIDE0LCAzLCAxNSwgNCwgMTgsIDYsIDIwLCA5LCAyMSwgMTAsIDIxLCAxMywgMjAsIDE1LCAxOCwgMTYsIDE0LCAxNiwgOSwgMTUsIDQsIDEzLCAxLCAxMCwgMCwgOCwgMCwgNSwgMSwgNCwgM11dLFxuICAgIFwiOlwiOiBbMTAsIFs1LCAxNCwgNCwgMTMsIDUsIDEyLCA2LCAxMywgNSwgMTQsIC0xLCAtMSwgNSwgMiwgNCwgMSwgNSwgMCwgNiwgMSwgNSwgMl1dLFxuICAgIFwiO1wiOiBbMTAsIFs1LCAxNCwgNCwgMTMsIDUsIDEyLCA2LCAxMywgNSwgMTQsIC0xLCAtMSwgNiwgMSwgNSwgMCwgNCwgMSwgNSwgMiwgNiwgMSwgNiwgLTEsIDUsIC0zLCA0LCAtNF1dLFxuICAgIFwiPFwiOiBbMjQsIFsyMCwgMTgsIDQsIDksIDIwLCAwXV0sXG4gICAgXCI9XCI6IFsyNiwgWzQsIDEyLCAyMiwgMTIsIC0xLCAtMSwgNCwgNiwgMjIsIDZdXSxcbiAgICBcIj5cIjogWzI0LCBbNCwgMTgsIDIwLCA5LCA0LCAwXV0sXG4gICAgXCI/XCI6IFsxOCwgWzMsIDE2LCAzLCAxNywgNCwgMTksIDUsIDIwLCA3LCAyMSwgMTEsIDIxLCAxMywgMjAsIDE0LCAxOSwgMTUsIDE3LCAxNSwgMTUsIDE0LCAxMywgMTMsIDEyLCA5LCAxMCwgOSwgNywgLTEsIC0xLCA5LCAyLCA4LCAxLCA5LCAwLCAxMCwgMSwgOSwgMl1dLFxuICAgIFwiQFwiOiBbMjcsIFsxOCwgMTMsIDE3LCAxNSwgMTUsIDE2LCAxMiwgMTYsIDEwLCAxNSwgOSwgMTQsIDgsIDExLCA4LCA4LCA5LCA2LCAxMSwgNSwgMTQsIDUsIDE2LCA2LCAxNywgOCwgLTEsIC0xLCAxMiwgMTYsIDEwLCAxNCwgOSwgMTEsIDksIDgsIDEwLCA2LCAxMSwgNSwgLTEsIC0xLCAxOCwgMTYsIDE3LCA4LCAxNywgNiwgMTksIDUsIDIxLCA1LCAyMywgNywgMjQsIDEwLCAyNCwgMTIsIDIzLCAxNSwgMjIsIDE3LCAyMCwgMTksIDE4LCAyMCwgMTUsIDIxLCAxMiwgMjEsIDksIDIwLCA3LCAxOSwgNSwgMTcsIDQsIDE1LCAzLCAxMiwgMywgOSwgNCwgNiwgNSwgNCwgNywgMiwgOSwgMSwgMTIsIDAsIDE1LCAwLCAxOCwgMSwgMjAsIDIsIDIxLCAzLCAtMSwgLTEsIDE5LCAxNiwgMTgsIDgsIDE4LCA2LCAxOSwgNV1dLFxuICAgIFwiQVwiOiBbMTgsIFs5LCAyMSwgMSwgMCwgLTEsIC0xLCA5LCAyMSwgMTcsIDAsIC0xLCAtMSwgNCwgNywgMTQsIDddXSxcbiAgICBcIkJcIjogWzIxLCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDEzLCAyMSwgMTYsIDIwLCAxNywgMTksIDE4LCAxNywgMTgsIDE1LCAxNywgMTMsIDE2LCAxMiwgMTMsIDExLCAtMSwgLTEsIDQsIDExLCAxMywgMTEsIDE2LCAxMCwgMTcsIDksIDE4LCA3LCAxOCwgNCwgMTcsIDIsIDE2LCAxLCAxMywgMCwgNCwgMF1dLFxuICAgIFwiQ1wiOiBbMjEsIFsxOCwgMTYsIDE3LCAxOCwgMTUsIDIwLCAxMywgMjEsIDksIDIxLCA3LCAyMCwgNSwgMTgsIDQsIDE2LCAzLCAxMywgMywgOCwgNCwgNSwgNSwgMywgNywgMSwgOSwgMCwgMTMsIDAsIDE1LCAxLCAxNywgMywgMTgsIDVdXSxcbiAgICBcIkRcIjogWzIxLCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDExLCAyMSwgMTQsIDIwLCAxNiwgMTgsIDE3LCAxNiwgMTgsIDEzLCAxOCwgOCwgMTcsIDUsIDE2LCAzLCAxNCwgMSwgMTEsIDAsIDQsIDBdXSxcbiAgICBcIkVcIjogWzE5LCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDE3LCAyMSwgLTEsIC0xLCA0LCAxMSwgMTIsIDExLCAtMSwgLTEsIDQsIDAsIDE3LCAwXV0sXG4gICAgXCJGXCI6IFsxOCwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxNywgMjEsIC0xLCAtMSwgNCwgMTEsIDEyLCAxMV1dLFxuICAgIFwiR1wiOiBbMjEsIFsxOCwgMTYsIDE3LCAxOCwgMTUsIDIwLCAxMywgMjEsIDksIDIxLCA3LCAyMCwgNSwgMTgsIDQsIDE2LCAzLCAxMywgMywgOCwgNCwgNSwgNSwgMywgNywgMSwgOSwgMCwgMTMsIDAsIDE1LCAxLCAxNywgMywgMTgsIDUsIDE4LCA4LCAtMSwgLTEsIDEzLCA4LCAxOCwgOF1dLFxuICAgIFwiSFwiOiBbMjIsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCAxOCwgMjEsIDE4LCAwLCAtMSwgLTEsIDQsIDExLCAxOCwgMTFdXSxcbiAgICBcIklcIjogWzgsIFs0LCAyMSwgNCwgMF1dLFxuICAgIFwiSlwiOiBbMTYsIFsxMiwgMjEsIDEyLCA1LCAxMSwgMiwgMTAsIDEsIDgsIDAsIDYsIDAsIDQsIDEsIDMsIDIsIDIsIDUsIDIsIDddXSxcbiAgICBcIktcIjogWzIxLCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgMTgsIDIxLCA0LCA3LCAtMSwgLTEsIDksIDEyLCAxOCwgMF1dLFxuICAgIFwiTFwiOiBbMTcsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAwLCAxNiwgMF1dLFxuICAgIFwiTVwiOiBbMjQsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTIsIDAsIC0xLCAtMSwgMjAsIDIxLCAxMiwgMCwgLTEsIC0xLCAyMCwgMjEsIDIwLCAwXV0sXG4gICAgXCJOXCI6IFsyMiwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxOCwgMCwgLTEsIC0xLCAxOCwgMjEsIDE4LCAwXV0sXG4gICAgXCJPXCI6IFsyMiwgWzksIDIxLCA3LCAyMCwgNSwgMTgsIDQsIDE2LCAzLCAxMywgMywgOCwgNCwgNSwgNSwgMywgNywgMSwgOSwgMCwgMTMsIDAsIDE1LCAxLCAxNywgMywgMTgsIDUsIDE5LCA4LCAxOSwgMTMsIDE4LCAxNiwgMTcsIDE4LCAxNSwgMjAsIDEzLCAyMSwgOSwgMjFdXSxcbiAgICBcIlBcIjogWzIxLCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDEzLCAyMSwgMTYsIDIwLCAxNywgMTksIDE4LCAxNywgMTgsIDE0LCAxNywgMTIsIDE2LCAxMSwgMTMsIDEwLCA0LCAxMF1dLFxuICAgIFwiUVwiOiBbMjIsIFs5LCAyMSwgNywgMjAsIDUsIDE4LCA0LCAxNiwgMywgMTMsIDMsIDgsIDQsIDUsIDUsIDMsIDcsIDEsIDksIDAsIDEzLCAwLCAxNSwgMSwgMTcsIDMsIDE4LCA1LCAxOSwgOCwgMTksIDEzLCAxOCwgMTYsIDE3LCAxOCwgMTUsIDIwLCAxMywgMjEsIDksIDIxLCAtMSwgLTEsIDEyLCA0LCAxOCwgLTJdXSxcbiAgICBcIlJcIjogWzIxLCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDEzLCAyMSwgMTYsIDIwLCAxNywgMTksIDE4LCAxNywgMTgsIDE1LCAxNywgMTMsIDE2LCAxMiwgMTMsIDExLCA0LCAxMSwgLTEsIC0xLCAxMSwgMTEsIDE4LCAwXV0sXG4gICAgXCJTXCI6IFsyMCwgWzE3LCAxOCwgMTUsIDIwLCAxMiwgMjEsIDgsIDIxLCA1LCAyMCwgMywgMTgsIDMsIDE2LCA0LCAxNCwgNSwgMTMsIDcsIDEyLCAxMywgMTAsIDE1LCA5LCAxNiwgOCwgMTcsIDYsIDE3LCAzLCAxNSwgMSwgMTIsIDAsIDgsIDAsIDUsIDEsIDMsIDNdXSxcbiAgICBcIlRcIjogWzE2LCBbOCwgMjEsIDgsIDAsIC0xLCAtMSwgMSwgMjEsIDE1LCAyMV1dLFxuICAgIFwiVVwiOiBbMjIsIFs0LCAyMSwgNCwgNiwgNSwgMywgNywgMSwgMTAsIDAsIDEyLCAwLCAxNSwgMSwgMTcsIDMsIDE4LCA2LCAxOCwgMjFdXSxcbiAgICBcIlZcIjogWzE4LCBbMSwgMjEsIDksIDAsIC0xLCAtMSwgMTcsIDIxLCA5LCAwXV0sXG4gICAgXCJXXCI6IFsyNCwgWzIsIDIxLCA3LCAwLCAtMSwgLTEsIDEyLCAyMSwgNywgMCwgLTEsIC0xLCAxMiwgMjEsIDE3LCAwLCAtMSwgLTEsIDIyLCAyMSwgMTcsIDBdXSxcbiAgICBcIlhcIjogWzIwLCBbMywgMjEsIDE3LCAwLCAtMSwgLTEsIDE3LCAyMSwgMywgMF1dLFxuICAgIFwiWVwiOiBbMTgsIFsxLCAyMSwgOSwgMTEsIDksIDAsIC0xLCAtMSwgMTcsIDIxLCA5LCAxMV1dLFxuICAgIFwiWlwiOiBbMjAsIFsxNywgMjEsIDMsIDAsIC0xLCAtMSwgMywgMjEsIDE3LCAyMSwgLTEsIC0xLCAzLCAwLCAxNywgMF1dLFxuICAgIFwiW1wiOiBbMTQsIFs0LCAyNSwgNCwgLTcsIC0xLCAtMSwgNSwgMjUsIDUsIC03LCAtMSwgLTEsIDQsIDI1LCAxMSwgMjUsIC0xLCAtMSwgNCwgLTcsIDExLCAtN11dLFxuICAgIFwiXFxcXFwiOiBbMTQsIFswLCAyMSwgMTQsIC0zXV0sXG4gICAgXCJdXCI6IFsxNCwgWzksIDI1LCA5LCAtNywgLTEsIC0xLCAxMCwgMjUsIDEwLCAtNywgLTEsIC0xLCAzLCAyNSwgMTAsIDI1LCAtMSwgLTEsIDMsIC03LCAxMCwgLTddXSxcbiAgICBcIl5cIjogWzE2LCBbNiwgMTUsIDgsIDE4LCAxMCwgMTUsIC0xLCAtMSwgMywgMTIsIDgsIDE3LCAxMywgMTIsIC0xLCAtMSwgOCwgMTcsIDgsIDBdXSxcbiAgICBcIl9cIjogWzE2LCBbMCwgLTIsIDE2LCAtMl1dLFxuICAgIFwiYFwiOiBbMTAsIFs2LCAyMSwgNSwgMjAsIDQsIDE4LCA0LCAxNiwgNSwgMTUsIDYsIDE2LCA1LCAxN11dLFxuICAgIFwiYVwiOiBbMTksIFsxNSwgMTQsIDE1LCAwLCAtMSwgLTEsIDE1LCAxMSwgMTMsIDEzLCAxMSwgMTQsIDgsIDE0LCA2LCAxMywgNCwgMTEsIDMsIDgsIDMsIDYsIDQsIDMsIDYsIDEsIDgsIDAsIDExLCAwLCAxMywgMSwgMTUsIDNdXSxcbiAgICBcImJcIjogWzE5LCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMTEsIDYsIDEzLCA4LCAxNCwgMTEsIDE0LCAxMywgMTMsIDE1LCAxMSwgMTYsIDgsIDE2LCA2LCAxNSwgMywgMTMsIDEsIDExLCAwLCA4LCAwLCA2LCAxLCA0LCAzXV0sXG4gICAgXCJjXCI6IFsxOCwgWzE1LCAxMSwgMTMsIDEzLCAxMSwgMTQsIDgsIDE0LCA2LCAxMywgNCwgMTEsIDMsIDgsIDMsIDYsIDQsIDMsIDYsIDEsIDgsIDAsIDExLCAwLCAxMywgMSwgMTUsIDNdXSxcbiAgICBcImRcIjogWzE5LCBbMTUsIDIxLCAxNSwgMCwgLTEsIC0xLCAxNSwgMTEsIDEzLCAxMywgMTEsIDE0LCA4LCAxNCwgNiwgMTMsIDQsIDExLCAzLCA4LCAzLCA2LCA0LCAzLCA2LCAxLCA4LCAwLCAxMSwgMCwgMTMsIDEsIDE1LCAzXV0sXG4gICAgXCJlXCI6IFsxOCwgWzMsIDgsIDE1LCA4LCAxNSwgMTAsIDE0LCAxMiwgMTMsIDEzLCAxMSwgMTQsIDgsIDE0LCA2LCAxMywgNCwgMTEsIDMsIDgsIDMsIDYsIDQsIDMsIDYsIDEsIDgsIDAsIDExLCAwLCAxMywgMSwgMTUsIDNdXSxcbiAgICBcImZcIjogWzEyLCBbMTAsIDIxLCA4LCAyMSwgNiwgMjAsIDUsIDE3LCA1LCAwLCAtMSwgLTEsIDIsIDE0LCA5LCAxNF1dLFxuICAgIFwiZ1wiOiBbMTksIFsxNSwgMTQsIDE1LCAtMiwgMTQsIC01LCAxMywgLTYsIDExLCAtNywgOCwgLTcsIDYsIC02LCAtMSwgLTEsIDE1LCAxMSwgMTMsIDEzLCAxMSwgMTQsIDgsIDE0LCA2LCAxMywgNCwgMTEsIDMsIDgsIDMsIDYsIDQsIDMsIDYsIDEsIDgsIDAsIDExLCAwLCAxMywgMSwgMTUsIDNdXSxcbiAgICBcImhcIjogWzE5LCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMTAsIDcsIDEzLCA5LCAxNCwgMTIsIDE0LCAxNCwgMTMsIDE1LCAxMCwgMTUsIDBdXSxcbiAgICBcImlcIjogWzgsIFszLCAyMSwgNCwgMjAsIDUsIDIxLCA0LCAyMiwgMywgMjEsIC0xLCAtMSwgNCwgMTQsIDQsIDBdXSxcbiAgICBcImpcIjogWzEwLCBbNSwgMjEsIDYsIDIwLCA3LCAyMSwgNiwgMjIsIDUsIDIxLCAtMSwgLTEsIDYsIDE0LCA2LCAtMywgNSwgLTYsIDMsIC03LCAxLCAtN11dLFxuICAgIFwia1wiOiBbMTcsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCAxNCwgMTQsIDQsIDQsIC0xLCAtMSwgOCwgOCwgMTUsIDBdXSxcbiAgICBcImxcIjogWzgsIFs0LCAyMSwgNCwgMF1dLFxuICAgIFwibVwiOiBbMzAsIFs0LCAxNCwgNCwgMCwgLTEsIC0xLCA0LCAxMCwgNywgMTMsIDksIDE0LCAxMiwgMTQsIDE0LCAxMywgMTUsIDEwLCAxNSwgMCwgLTEsIC0xLCAxNSwgMTAsIDE4LCAxMywgMjAsIDE0LCAyMywgMTQsIDI1LCAxMywgMjYsIDEwLCAyNiwgMF1dLFxuICAgIFwiblwiOiBbMTksIFs0LCAxNCwgNCwgMCwgLTEsIC0xLCA0LCAxMCwgNywgMTMsIDksIDE0LCAxMiwgMTQsIDE0LCAxMywgMTUsIDEwLCAxNSwgMF1dLFxuICAgIFwib1wiOiBbMTksIFs4LCAxNCwgNiwgMTMsIDQsIDExLCAzLCA4LCAzLCA2LCA0LCAzLCA2LCAxLCA4LCAwLCAxMSwgMCwgMTMsIDEsIDE1LCAzLCAxNiwgNiwgMTYsIDgsIDE1LCAxMSwgMTMsIDEzLCAxMSwgMTQsIDgsIDE0XV0sXG4gICAgXCJwXCI6IFsxOSwgWzQsIDE0LCA0LCAtNywgLTEsIC0xLCA0LCAxMSwgNiwgMTMsIDgsIDE0LCAxMSwgMTQsIDEzLCAxMywgMTUsIDExLCAxNiwgOCwgMTYsIDYsIDE1LCAzLCAxMywgMSwgMTEsIDAsIDgsIDAsIDYsIDEsIDQsIDNdXSxcbiAgICBcInFcIjogWzE5LCBbMTUsIDE0LCAxNSwgLTcsIC0xLCAtMSwgMTUsIDExLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxuICAgIFwiclwiOiBbMTMsIFs0LCAxNCwgNCwgMCwgLTEsIC0xLCA0LCA4LCA1LCAxMSwgNywgMTMsIDksIDE0LCAxMiwgMTRdXSxcbiAgICBcInNcIjogWzE3LCBbMTQsIDExLCAxMywgMTMsIDEwLCAxNCwgNywgMTQsIDQsIDEzLCAzLCAxMSwgNCwgOSwgNiwgOCwgMTEsIDcsIDEzLCA2LCAxNCwgNCwgMTQsIDMsIDEzLCAxLCAxMCwgMCwgNywgMCwgNCwgMSwgMywgM11dLFxuICAgIFwidFwiOiBbMTIsIFs1LCAyMSwgNSwgNCwgNiwgMSwgOCwgMCwgMTAsIDAsIC0xLCAtMSwgMiwgMTQsIDksIDE0XV0sXG4gICAgXCJ1XCI6IFsxOSwgWzQsIDE0LCA0LCA0LCA1LCAxLCA3LCAwLCAxMCwgMCwgMTIsIDEsIDE1LCA0LCAtMSwgLTEsIDE1LCAxNCwgMTUsIDBdXSxcbiAgICBcInZcIjogWzE2LCBbMiwgMTQsIDgsIDAsIC0xLCAtMSwgMTQsIDE0LCA4LCAwXV0sXG4gICAgXCJ3XCI6IFsyMiwgWzMsIDE0LCA3LCAwLCAtMSwgLTEsIDExLCAxNCwgNywgMCwgLTEsIC0xLCAxMSwgMTQsIDE1LCAwLCAtMSwgLTEsIDE5LCAxNCwgMTUsIDBdXSxcbiAgICBcInhcIjogWzE3LCBbMywgMTQsIDE0LCAwLCAtMSwgLTEsIDE0LCAxNCwgMywgMF1dLFxuICAgIFwieVwiOiBbMTYsIFsyLCAxNCwgOCwgMCwgLTEsIC0xLCAxNCwgMTQsIDgsIDAsIDYsIC00LCA0LCAtNiwgMiwgLTcsIDEsIC03XV0sXG4gICAgXCJ6XCI6IFsxNywgWzE0LCAxNCwgMywgMCwgLTEsIC0xLCAzLCAxNCwgMTQsIDE0LCAtMSwgLTEsIDMsIDAsIDE0LCAwXV0sXG4gICAgXCJ7XCI6IFsxNCwgWzksIDI1LCA3LCAyNCwgNiwgMjMsIDUsIDIxLCA1LCAxOSwgNiwgMTcsIDcsIDE2LCA4LCAxNCwgOCwgMTIsIDYsIDEwLCAtMSwgLTEsIDcsIDI0LCA2LCAyMiwgNiwgMjAsIDcsIDE4LCA4LCAxNywgOSwgMTUsIDksIDEzLCA4LCAxMSwgNCwgOSwgOCwgNywgOSwgNSwgOSwgMywgOCwgMSwgNywgMCwgNiwgLTIsIDYsIC00LCA3LCAtNiwgLTEsIC0xLCA2LCA4LCA4LCA2LCA4LCA0LCA3LCAyLCA2LCAxLCA1LCAtMSwgNSwgLTMsIDYsIC01LCA3LCAtNiwgOSwgLTddXSxcbiAgICBcInxcIjogWzgsIFs0LCAyNSwgNCwgLTddXSxcbiAgICBcIn1cIjogWzE0LCBbNSwgMjUsIDcsIDI0LCA4LCAyMywgOSwgMjEsIDksIDE5LCA4LCAxNywgNywgMTYsIDYsIDE0LCA2LCAxMiwgOCwgMTAsIC0xLCAtMSwgNywgMjQsIDgsIDIyLCA4LCAyMCwgNywgMTgsIDYsIDE3LCA1LCAxNSwgNSwgMTMsIDYsIDExLCAxMCwgOSwgNiwgNywgNSwgNSwgNSwgMywgNiwgMSwgNywgMCwgOCwgLTIsIDgsIC00LCA3LCAtNiwgLTEsIC0xLCA4LCA4LCA2LCA2LCA2LCA0LCA3LCAyLCA4LCAxLCA5LCAtMSwgOSwgLTMsIDgsIC01LCA3LCAtNiwgNSwgLTddXSxcbiAgICBcIn5cIjogWzI0LCBbMywgNiwgMywgOCwgNCwgMTEsIDYsIDEyLCA4LCAxMiwgMTAsIDExLCAxNCwgOCwgMTYsIDcsIDE4LCA3LCAyMCwgOCwgMjEsIDEwLCAtMSwgLTEsIDMsIDgsIDQsIDEwLCA2LCAxMSwgOCwgMTEsIDEwLCAxMCwgMTQsIDcsIDE2LCA2LCAxOCwgNiwgMjAsIDcsIDIxLCAxMCwgMjEsIDEyXV1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGV4dFZlcnRpY2VzKHRleHQsIGxlZnQsIGJhc2VsaW5lLCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMTtcblxuICAgIHZhciBzdHJva2VzID0gW10sXG4gICAgICAgIGksIGxlbiwgaiwgbGVuMiwgZ2x5cGgsIHgsIHksIHByZXY7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSB0ZXh0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGdseXBoID0gc2ltcGxleEZvbnRbdGV4dFtpXV07XG4gICAgICAgIGlmICghZ2x5cGgpIGNvbnRpbnVlO1xuICAgICAgICBwcmV2ID0gbnVsbDtcblxuICAgICAgICBmb3IgKGogPSAwLCBsZW4yID0gZ2x5cGhbMV0ubGVuZ3RoOyBqIDwgbGVuMjsgaiArPSAyKSB7XG4gICAgICAgICAgICBpZiAoZ2x5cGhbMV1bal0gPT09IC0xICYmIGdseXBoWzFdW2ogKyAxXSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gbnVsbDtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gbGVmdCArIGdseXBoWzFdW2pdICogc2NhbGU7XG4gICAgICAgICAgICAgICAgeSA9IGJhc2VsaW5lIC0gZ2x5cGhbMV1baiArIDFdICogc2NhbGU7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlcy5wdXNoKHByZXYueCwgcHJldi55LCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldiA9IHt4OiB4LCB5OiB5fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZWZ0ICs9IGdseXBoWzBdICogc2NhbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cm9rZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIG1hcGJveGdsIGlzIGEgQSBXZWJHTCBKYXZhU2NyaXB0IGludGVyYWN0aXZlIG1hcHMgbGlicmFyeSB0aGF0IGNhbiByZW5kZXJcbiAqIFtNYXBib3ggdmVjdG9yIHRpbGVzXShodHRwczovL3d3dy5tYXBib3guY29tL2Jsb2cvdmVjdG9yLXRpbGVzLykuXG4gKlxuICogQG1vZHVsZSBtYXBib3hnbFxuICogQHN1bW1hcnkgV2ViR0wgSmF2YVNjcmlwdCBtYXAgbGlicmFyeVxuICovXG5cbi8vIGpzaGludCAtVzA3OVxudmFyIG1hcGJveGdsID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxubWFwYm94Z2wuTWFwID0gcmVxdWlyZSgnLi91aS9tYXAnKTtcbm1hcGJveGdsLkNvbnRyb2wgPSByZXF1aXJlKCcuL3VpL2NvbnRyb2wvY29udHJvbCcpO1xubWFwYm94Z2wuTmF2aWdhdGlvbiA9IHJlcXVpcmUoJy4vdWkvY29udHJvbC9uYXZpZ2F0aW9uJyk7XG5tYXBib3hnbC5HZW9sb2NhdGUgPSByZXF1aXJlKCcuL3VpL2NvbnRyb2wvZ2VvbG9jYXRlJyk7XG5tYXBib3hnbC5BdHRyaWJ1dGlvbiA9IHJlcXVpcmUoJy4vdWkvY29udHJvbC9hdHRyaWJ1dGlvbicpO1xubWFwYm94Z2wuUG9wdXAgPSByZXF1aXJlKCcuL3VpL3BvcHVwJyk7XG5cbm1hcGJveGdsLkdlb0pTT05Tb3VyY2UgPSByZXF1aXJlKCcuL3NvdXJjZS9nZW9qc29uX3NvdXJjZScpO1xubWFwYm94Z2wuVmlkZW9Tb3VyY2UgPSByZXF1aXJlKCcuL3NvdXJjZS92aWRlb19zb3VyY2UnKTtcbm1hcGJveGdsLkltYWdlU291cmNlID0gcmVxdWlyZSgnLi9zb3VyY2UvaW1hZ2Vfc291cmNlJyk7XG5cbm1hcGJveGdsLlN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZS9zdHlsZScpO1xuXG5tYXBib3hnbC5MbmdMYXQgPSByZXF1aXJlKCcuL2dlby9sbmdfbGF0Jyk7XG5tYXBib3hnbC5MbmdMYXRCb3VuZHMgPSByZXF1aXJlKCcuL2dlby9sbmdfbGF0X2JvdW5kcycpO1xubWFwYm94Z2wuUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tYXBib3hnbC5FdmVudGVkID0gcmVxdWlyZSgnLi91dGlsL2V2ZW50ZWQnKTtcbm1hcGJveGdsLnV0aWwgPSByZXF1aXJlKCcuL3V0aWwvdXRpbCcpO1xuXG5tYXBib3hnbC5zdXBwb3J0ZWQgPSByZXF1aXJlKCcuL3V0aWwvYnJvd3NlcicpLnN1cHBvcnRlZDtcblxudmFyIGFqYXggPSByZXF1aXJlKCcuL3V0aWwvYWpheCcpO1xubWFwYm94Z2wudXRpbC5nZXRKU09OID0gYWpheC5nZXRKU09OO1xubWFwYm94Z2wudXRpbC5nZXRBcnJheUJ1ZmZlciA9IGFqYXguZ2V0QXJyYXlCdWZmZXI7XG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL3V0aWwvY29uZmlnJyk7XG5tYXBib3hnbC5jb25maWcgPSBjb25maWc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShtYXBib3hnbCwgJ2FjY2Vzc1Rva2VuJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBjb25maWcuQUNDRVNTX1RPS0VOOyB9LFxuICAgIHNldDogZnVuY3Rpb24odG9rZW4pIHsgY29uZmlnLkFDQ0VTU19UT0tFTiA9IHRva2VuOyB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFRpbGVQeXJhbWlkID0gcmVxdWlyZSgnLi4vc291cmNlL3RpbGVfcHlyYW1pZCcpO1xudmFyIHB5cmFtaWQgPSBuZXcgVGlsZVB5cmFtaWQoeyB0aWxlU2l6ZTogNTEyIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBwaXhlbHNUb1RpbGVVbml0cyA9IHJlcXVpcmUoJy4uL3NvdXJjZS9waXhlbHNfdG9fdGlsZV91bml0cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdCYWNrZ3JvdW5kO1xuXG5mdW5jdGlvbiBkcmF3QmFja2dyb3VuZChwYWludGVyLCBzb3VyY2UsIGxheWVyKSB7XG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcbiAgICB2YXIgdHJhbnNmb3JtID0gcGFpbnRlci50cmFuc2Zvcm07XG4gICAgdmFyIGNvbG9yID0gdXRpbC5wcmVtdWx0aXBseShsYXllci5wYWludFsnYmFja2dyb3VuZC1jb2xvciddKTtcbiAgICB2YXIgaW1hZ2UgPSBsYXllci5wYWludFsnYmFja2dyb3VuZC1wYXR0ZXJuJ107XG4gICAgdmFyIG9wYWNpdHkgPSBsYXllci5wYWludFsnYmFja2dyb3VuZC1vcGFjaXR5J107XG4gICAgdmFyIHByb2dyYW07XG5cbiAgICB2YXIgaW1hZ2VQb3NBID0gaW1hZ2UgPyBwYWludGVyLnNwcml0ZUF0bGFzLmdldFBvc2l0aW9uKGltYWdlLmZyb20sIHRydWUpIDogbnVsbDtcbiAgICB2YXIgaW1hZ2VQb3NCID0gaW1hZ2UgPyBwYWludGVyLnNwcml0ZUF0bGFzLmdldFBvc2l0aW9uKGltYWdlLnRvLCB0cnVlKSA6IG51bGw7XG5cbiAgICBwYWludGVyLnNldERlcHRoU3VibGF5ZXIoMCk7XG4gICAgaWYgKGltYWdlUG9zQSAmJiBpbWFnZVBvc0IpIHtcblxuICAgICAgICBpZiAocGFpbnRlci5pc09wYXF1ZVBhc3MpIHJldHVybjtcblxuICAgICAgICAvLyBEcmF3IHRleHR1cmUgZmlsbFxuICAgICAgICBwcm9ncmFtID0gcGFpbnRlci51c2VQcm9ncmFtKCdwYXR0ZXJuJyk7XG4gICAgICAgIGdsLnVuaWZvcm0xaShwcm9ncmFtLnVfaW1hZ2UsIDApO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV9wYXR0ZXJuX3RsX2EsIGltYWdlUG9zQS50bCk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYocHJvZ3JhbS51X3BhdHRlcm5fYnJfYSwgaW1hZ2VQb3NBLmJyKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfcGF0dGVybl90bF9iLCBpbWFnZVBvc0IudGwpO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV9wYXR0ZXJuX2JyX2IsIGltYWdlUG9zQi5icik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfb3BhY2l0eSwgb3BhY2l0eSk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9taXgsIGltYWdlLnQpO1xuXG4gICAgICAgIHBhaW50ZXIuc3ByaXRlQXRsYXMuYmluZChnbCwgdHJ1ZSk7XG5cbiAgICAgICAgcGFpbnRlci50aWxlRXh0ZW50UGF0dGVyblZBTy5iaW5kKGdsLCBwcm9ncmFtLCBwYWludGVyLnRpbGVFeHRlbnRCdWZmZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERyYXcgZmlsbGluZyByZWN0YW5nbGUuXG4gICAgICAgIGlmIChwYWludGVyLmlzT3BhcXVlUGFzcyAhPT0gKGNvbG9yWzNdID09PSAxKSkgcmV0dXJuO1xuXG4gICAgICAgIHByb2dyYW0gPSBwYWludGVyLnVzZVByb2dyYW0oJ2ZpbGwnKTtcbiAgICAgICAgZ2wudW5pZm9ybTRmdihwcm9ncmFtLnVfY29sb3IsIGNvbG9yKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9vcGFjaXR5LCBvcGFjaXR5KTtcbiAgICAgICAgcGFpbnRlci50aWxlRXh0ZW50VkFPLmJpbmQoZ2wsIHByb2dyYW0sIHBhaW50ZXIudGlsZUV4dGVudEJ1ZmZlcik7XG4gICAgfVxuXG4gICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuXG4gICAgLy8gV2UgbmVlZCB0byBkcmF3IHRoZSBiYWNrZ3JvdW5kIGluIHRpbGVzIGluIG9yZGVyIHRvIHVzZSBjYWxjdWxhdGVQb3NNYXRyaXhcbiAgICAvLyB3aGljaCBhcHBsaWVzIHRoZSBwcm9qZWN0aW9uIG1hdHJpeCAodHJhbnNmb3JtLnByb2pNYXRyaXgpLiBPdGhlcndpc2VcbiAgICAvLyB0aGUgZGVwdGggYW5kIHN0ZW5jaWwgYnVmZmVycyBnZXQgaW50byBhIGJhZCBzdGF0ZS5cbiAgICAvLyBUaGlzIGNhbiBiZSByZWZhY3RvcmVkIGludG8gYSBzaW5nbGUgZHJhdyBjYWxsIG9uY2UgZWFyY3V0IGxhbmRzIGFuZFxuICAgIC8vIHdlIGRvbid0IGhhdmUgc28gbXVjaCBnb2luZyBvbiBpbiB0aGUgc3RlbmNpbCBidWZmZXIuXG4gICAgdmFyIGNvb3JkcyA9IHB5cmFtaWQuY292ZXJpbmdUaWxlcyh0cmFuc2Zvcm0pO1xuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY29vcmRzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgIHZhciBjb29yZCA9IGNvb3Jkc1tjXTtcbiAgICAgICAgdmFyIHRpbGVTaXplID0gNTEyO1xuICAgICAgICAvLyB2YXIgcGl4ZWxzVG9UaWxlVW5pdHNCb3VuZCA9IHBpeGVsc1RvVGlsZVVuaXRzLmJpbmQoe2Nvb3JkOmNvb3JkLCB0aWxlU2l6ZTogdGlsZVNpemV9KTtcbiAgICAgICAgaWYgKGltYWdlUG9zQSAmJiBpbWFnZVBvc0IpIHtcbiAgICAgICAgICAgIHZhciBpbWFnZVNpemVTY2FsZWRBID0gW1xuICAgICAgICAgICAgICAgIChpbWFnZVBvc0Euc2l6ZVswXSAqIGltYWdlLmZyb21TY2FsZSksXG4gICAgICAgICAgICAgICAgKGltYWdlUG9zQS5zaXplWzFdICogaW1hZ2UuZnJvbVNjYWxlKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHZhciBpbWFnZVNpemVTY2FsZWRCID0gW1xuICAgICAgICAgICAgICAgIChpbWFnZVBvc0Iuc2l6ZVswXSAqIGltYWdlLnRvU2NhbGUpLFxuICAgICAgICAgICAgICAgIChpbWFnZVBvc0Iuc2l6ZVsxXSAqIGltYWdlLnRvU2NhbGUpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdmFyIHRpbGUgPSB7Y29vcmQ6Y29vcmQsIHRpbGVTaXplOiB0aWxlU2l6ZX07XG5cbiAgICAgICAgICAgIGdsLnVuaWZvcm0yZnYocHJvZ3JhbS51X3BhdHRlcm5zY2FsZV9hLCBbXG4gICAgICAgICAgICAgICAgMSAvIHBpeGVsc1RvVGlsZVVuaXRzKHRpbGUsIGltYWdlU2l6ZVNjYWxlZEFbMF0sIHBhaW50ZXIudHJhbnNmb3JtLnRpbGVab29tKSxcbiAgICAgICAgICAgICAgICAxIC8gcGl4ZWxzVG9UaWxlVW5pdHModGlsZSwgaW1hZ2VTaXplU2NhbGVkQVsxXSwgcGFpbnRlci50cmFuc2Zvcm0udGlsZVpvb20pXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfcGF0dGVybnNjYWxlX2IsIFtcbiAgICAgICAgICAgICAgICAxIC8gcGl4ZWxzVG9UaWxlVW5pdHModGlsZSwgaW1hZ2VTaXplU2NhbGVkQlswXSwgcGFpbnRlci50cmFuc2Zvcm0udGlsZVpvb20pLFxuICAgICAgICAgICAgICAgIDEgLyBwaXhlbHNUb1RpbGVVbml0cyh0aWxlLCBpbWFnZVNpemVTY2FsZWRCWzFdLCBwYWludGVyLnRyYW5zZm9ybS50aWxlWm9vbSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgdmFyIHRpbGVTaXplQXROZWFyZXN0Wm9vbSA9IHRpbGVTaXplICogTWF0aC5wb3coMiwgcGFpbnRlci50cmFuc2Zvcm0udGlsZVpvb20gLSBjb29yZC56KTtcblxuICAgICAgICAgICAgdmFyIG9mZnNldEF4ID0gKCh0aWxlU2l6ZUF0TmVhcmVzdFpvb20gLyBpbWFnZVNpemVTY2FsZWRBWzBdKSAlIDEpICogKGNvb3JkLnggKyBjb29yZC53ICogTWF0aC5wb3coMiwgY29vcmQueikpO1xuICAgICAgICAgICAgdmFyIG9mZnNldEF5ID0gKCh0aWxlU2l6ZUF0TmVhcmVzdFpvb20gLyBpbWFnZVNpemVTY2FsZWRBWzFdKSAlIDEpICogY29vcmQueTtcblxuICAgICAgICAgICAgdmFyIG9mZnNldEJ4ID0gKCh0aWxlU2l6ZUF0TmVhcmVzdFpvb20gLyBpbWFnZVNpemVTY2FsZWRCWzBdKSAlIDEpICogKGNvb3JkLnggKyBjb29yZC53ICogTWF0aC5wb3coMiwgY29vcmQueikpO1xuICAgICAgICAgICAgdmFyIG9mZnNldEJ5ID0gKCh0aWxlU2l6ZUF0TmVhcmVzdFpvb20gLyBpbWFnZVNpemVTY2FsZWRCWzFdKSAlIDEpICogY29vcmQueTtcblxuICAgICAgICAgICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfb2Zmc2V0X2EsIFtvZmZzZXRBeCwgb2Zmc2V0QXldKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0yZnYocHJvZ3JhbS51X29mZnNldF9iLCBbb2Zmc2V0QngsIG9mZnNldEJ5XSk7XG4gICAgICAgIH1cblxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHByb2dyYW0udV9tYXRyaXgsIGZhbHNlLCBwYWludGVyLnRyYW5zZm9ybS5jYWxjdWxhdGVQb3NNYXRyaXgoY29vcmQpKTtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgcGFpbnRlci50aWxlRXh0ZW50QnVmZmVyLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgZ2wuc3RlbmNpbE1hc2soMHgwMCk7XG4gICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4ODAsIDB4ODApO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdDaXJjbGVzO1xuXG5mdW5jdGlvbiBkcmF3Q2lyY2xlcyhwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZHMpIHtcbiAgICBpZiAocGFpbnRlci5pc09wYXF1ZVBhc3MpIHJldHVybjtcblxuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG5cbiAgICBwYWludGVyLnNldERlcHRoU3VibGF5ZXIoMCk7XG4gICAgcGFpbnRlci5kZXB0aE1hc2soZmFsc2UpO1xuXG4gICAgLy8gQWxsb3cgY2lyY2xlcyB0byBiZSBkcmF3biBhY3Jvc3MgYm91bmRhcmllcywgc28gdGhhdFxuICAgIC8vIGxhcmdlIGNpcmNsZXMgYXJlIG5vdCBjbGlwcGVkIHRvIHRpbGVzXG4gICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvb3JkID0gY29vcmRzW2ldO1xuXG4gICAgICAgIHZhciB0aWxlID0gc291cmNlLmdldFRpbGUoY29vcmQpO1xuICAgICAgICB2YXIgYnVja2V0ID0gdGlsZS5nZXRCdWNrZXQobGF5ZXIpO1xuICAgICAgICBpZiAoIWJ1Y2tldCkgY29udGludWU7XG4gICAgICAgIHZhciBidWZmZXJHcm91cHMgPSBidWNrZXQuYnVmZmVyR3JvdXBzLmNpcmNsZTtcbiAgICAgICAgaWYgKCFidWZmZXJHcm91cHMpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBwcm9ncmFtID0gcGFpbnRlci51c2VQcm9ncmFtKCdjaXJjbGUnLCBidWNrZXQuZ2V0UHJvZ3JhbU1hY3JvcygnY2lyY2xlJywgbGF5ZXIpKTtcblxuICAgICAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV9leHRydWRlX3NjYWxlLCBwYWludGVyLnRyYW5zZm9ybS5waXhlbHNUb0dMVW5pdHMpO1xuICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X2JsdXIsIGxheWVyLnBhaW50WydjaXJjbGUtYmx1ciddKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9kZXZpY2VwaXhlbHJhdGlvLCBicm93c2VyLmRldmljZVBpeGVsUmF0aW8pO1xuICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X29wYWNpdHksIGxheWVyLnBhaW50WydjaXJjbGUtb3BhY2l0eSddKTtcblxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHByb2dyYW0udV9tYXRyaXgsIGZhbHNlLCBwYWludGVyLnRyYW5zbGF0ZVBvc01hdHJpeChcbiAgICAgICAgICAgIGNvb3JkLnBvc01hdHJpeCxcbiAgICAgICAgICAgIHRpbGUsXG4gICAgICAgICAgICBsYXllci5wYWludFsnY2lyY2xlLXRyYW5zbGF0ZSddLFxuICAgICAgICAgICAgbGF5ZXIucGFpbnRbJ2NpcmNsZS10cmFuc2xhdGUtYW5jaG9yJ11cbiAgICAgICAgKSk7XG5cbiAgICAgICAgYnVja2V0LnNldFVuaWZvcm1zKGdsLCAnY2lyY2xlJywgcHJvZ3JhbSwgbGF5ZXIsIHt6b29tOiBwYWludGVyLnRyYW5zZm9ybS56b29tfSk7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBidWZmZXJHcm91cHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IGJ1ZmZlckdyb3Vwc1trXTtcbiAgICAgICAgICAgIGdyb3VwLnZhb3NbbGF5ZXIuaWRdLmJpbmQoZ2wsIHByb2dyYW0sIGdyb3VwLmxheW91dC52ZXJ0ZXgsIGdyb3VwLmxheW91dC5lbGVtZW50LCBncm91cC5wYWludFtsYXllci5pZF0pO1xuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgZ3JvdXAubGF5b3V0LmVsZW1lbnQubGVuZ3RoICogMywgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdDb2xsaXNpb25EZWJ1ZztcblxuZnVuY3Rpb24gZHJhd0NvbGxpc2lvbkRlYnVnKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkcykge1xuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG4gICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgdmFyIHByb2dyYW0gPSBwYWludGVyLnVzZVByb2dyYW0oJ2NvbGxpc2lvbmJveCcpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvb3JkID0gY29vcmRzW2ldO1xuICAgICAgICB2YXIgdGlsZSA9IHNvdXJjZS5nZXRUaWxlKGNvb3JkKTtcbiAgICAgICAgdmFyIGJ1Y2tldCA9IHRpbGUuZ2V0QnVja2V0KGxheWVyKTtcbiAgICAgICAgaWYgKCFidWNrZXQpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgYnVmZmVyR3JvdXBzID0gYnVja2V0LmJ1ZmZlckdyb3Vwcy5jb2xsaXNpb25Cb3g7XG5cbiAgICAgICAgaWYgKCFidWZmZXJHcm91cHMgfHwgIWJ1ZmZlckdyb3Vwcy5sZW5ndGgpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgZ3JvdXAgPSBidWZmZXJHcm91cHNbMF07XG4gICAgICAgIGlmIChncm91cC5sYXlvdXQudmVydGV4Lmxlbmd0aCA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9ncmFtLnVfbWF0cml4LCBmYWxzZSwgY29vcmQucG9zTWF0cml4KTtcblxuICAgICAgICBwYWludGVyLmVuYWJsZVRpbGVDbGlwcGluZ01hc2soY29vcmQpO1xuXG4gICAgICAgIHBhaW50ZXIubGluZVdpZHRoKDEpO1xuICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X3NjYWxlLCBNYXRoLnBvdygyLCBwYWludGVyLnRyYW5zZm9ybS56b29tIC0gdGlsZS5jb29yZC56KSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfem9vbSwgcGFpbnRlci50cmFuc2Zvcm0uem9vbSAqIDEwKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9tYXh6b29tLCAodGlsZS5jb29yZC56ICsgMSkgKiAxMCk7XG5cbiAgICAgICAgZ3JvdXAudmFvc1tsYXllci5pZF0uYmluZChnbCwgcHJvZ3JhbSwgZ3JvdXAubGF5b3V0LnZlcnRleCk7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuTElORVMsIDAsIGdyb3VwLmxheW91dC52ZXJ0ZXgubGVuZ3RoKTtcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0ZXh0VmVydGljZXMgPSByZXF1aXJlKCcuLi9saWIvZGVidWd0ZXh0Jyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIG1hdDQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS5tYXQ0O1xudmFyIEVYVEVOVCA9IHJlcXVpcmUoJy4uL2RhdGEvYnVja2V0JykuRVhURU5UO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4uL2RhdGEvYnVmZmVyJyk7XG52YXIgVmVydGV4QXJyYXlPYmplY3QgPSByZXF1aXJlKCcuL3ZlcnRleF9hcnJheV9vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkcmF3RGVidWc7XG5cbmZ1bmN0aW9uIGRyYXdEZWJ1ZyhwYWludGVyLCBzb3VyY2UsIGNvb3Jkcykge1xuICAgIGlmIChwYWludGVyLmlzT3BhcXVlUGFzcykgcmV0dXJuO1xuICAgIGlmICghcGFpbnRlci5vcHRpb25zLmRlYnVnKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkcmF3RGVidWdUaWxlKHBhaW50ZXIsIHNvdXJjZSwgY29vcmRzW2ldKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdEZWJ1Z1RpbGUocGFpbnRlciwgc291cmNlLCBjb29yZCkge1xuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG5cbiAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgcGFpbnRlci5saW5lV2lkdGgoMSAqIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyk7XG5cbiAgICB2YXIgcG9zTWF0cml4ID0gY29vcmQucG9zTWF0cml4O1xuICAgIHZhciBwcm9ncmFtID0gcGFpbnRlci51c2VQcm9ncmFtKCdkZWJ1ZycpO1xuXG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9ncmFtLnVfbWF0cml4LCBmYWxzZSwgcG9zTWF0cml4KTtcbiAgICBnbC51bmlmb3JtNGYocHJvZ3JhbS51X2NvbG9yLCAxLCAwLCAwLCAxKTtcbiAgICBwYWludGVyLmRlYnVnVkFPLmJpbmQoZ2wsIHByb2dyYW0sIHBhaW50ZXIuZGVidWdCdWZmZXIpO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuTElORV9TVFJJUCwgMCwgcGFpbnRlci5kZWJ1Z0J1ZmZlci5sZW5ndGgpO1xuXG4gICAgdmFyIHZlcnRpY2VzID0gdGV4dFZlcnRpY2VzKGNvb3JkLnRvU3RyaW5nKCksIDUwLCAyMDAsIDUpO1xuICAgIHZhciBkZWJ1Z1RleHRBcnJheSA9IG5ldyBwYWludGVyLlBvc0FycmF5KCk7XG4gICAgZm9yICh2YXIgdiA9IDA7IHYgPCB2ZXJ0aWNlcy5sZW5ndGg7IHYgKz0gMikge1xuICAgICAgICBkZWJ1Z1RleHRBcnJheS5lbXBsYWNlQmFjayh2ZXJ0aWNlc1t2XSwgdmVydGljZXNbdiArIDFdKTtcbiAgICB9XG4gICAgdmFyIGRlYnVnVGV4dEJ1ZmZlciA9IG5ldyBCdWZmZXIoZGVidWdUZXh0QXJyYXkuc2VyaWFsaXplKCksIHBhaW50ZXIuUG9zQXJyYXkuc2VyaWFsaXplKCksIEJ1ZmZlci5CdWZmZXJUeXBlLlZFUlRFWCk7XG4gICAgdmFyIGRlYnVnVGV4dFZBTyA9IG5ldyBWZXJ0ZXhBcnJheU9iamVjdCgpO1xuICAgIGRlYnVnVGV4dFZBTy5iaW5kKGdsLCBwcm9ncmFtLCBkZWJ1Z1RleHRCdWZmZXIpO1xuICAgIGdsLnVuaWZvcm00Zihwcm9ncmFtLnVfY29sb3IsIDEsIDEsIDEsIDEpO1xuXG4gICAgLy8gRHJhdyB0aGUgaGFsbyB3aXRoIG11bHRpcGxlIDFweCBsaW5lcyBpbnN0ZWFkIG9mIG9uZSB3aWRlciBsaW5lIGJlY2F1c2VcbiAgICAvLyB0aGUgZ2wgc3BlYyBkb2Vzbid0IGd1YXJhbnRlZSBzdXBwb3J0IGZvciBsaW5lcyB3aXRoIHdpZHRoID4gMS5cbiAgICB2YXIgdGlsZVNpemUgPSBzb3VyY2UuZ2V0VGlsZShjb29yZCkudGlsZVNpemU7XG4gICAgdmFyIG9uZVBpeGVsID0gRVhURU5UIC8gKE1hdGgucG93KDIsIHBhaW50ZXIudHJhbnNmb3JtLnpvb20gLSBjb29yZC56KSAqIHRpbGVTaXplKTtcbiAgICB2YXIgdHJhbnNsYXRpb25zID0gW1stMSwgLTFdLCBbLTEsIDFdLCBbMSwgLTFdLCBbMSwgMV1dO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNsYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0cmFuc2xhdGlvbiA9IHRyYW5zbGF0aW9uc1tpXTtcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9ncmFtLnVfbWF0cml4LCBmYWxzZSwgbWF0NC50cmFuc2xhdGUoW10sIHBvc01hdHJpeCwgW29uZVBpeGVsICogdHJhbnNsYXRpb25bMF0sIG9uZVBpeGVsICogdHJhbnNsYXRpb25bMV0sIDBdKSk7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuTElORVMsIDAsIGRlYnVnVGV4dEJ1ZmZlci5sZW5ndGgpO1xuICAgIH1cblxuICAgIGdsLnVuaWZvcm00Zihwcm9ncmFtLnVfY29sb3IsIDAsIDAsIDAsIDEpO1xuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYocHJvZ3JhbS51X21hdHJpeCwgZmFsc2UsIHBvc01hdHJpeCk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5MSU5FUywgMCwgZGVidWdUZXh0QnVmZmVyLmxlbmd0aCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgcGl4ZWxzVG9UaWxlVW5pdHMgPSByZXF1aXJlKCcuLi9zb3VyY2UvcGl4ZWxzX3RvX3RpbGVfdW5pdHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkcmF3O1xuXG5mdW5jdGlvbiBkcmF3KHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkcykge1xuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG4gICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cbiAgICB2YXIgY29sb3IgPSB1dGlsLnByZW11bHRpcGx5KGxheWVyLnBhaW50WydmaWxsLWNvbG9yJ10pO1xuICAgIHZhciBpbWFnZSA9IGxheWVyLnBhaW50WydmaWxsLXBhdHRlcm4nXTtcbiAgICB2YXIgc3Ryb2tlQ29sb3IgPSB1dGlsLnByZW11bHRpcGx5KGxheWVyLnBhaW50WydmaWxsLW91dGxpbmUtY29sb3InXSk7XG4gICAgdmFyIG9wYWNpdHkgPSBsYXllci5wYWludFsnZmlsbC1vcGFjaXR5J107XG5cbiAgICAvLyBEcmF3IGZpbGxcbiAgICBpZiAoaW1hZ2UgPyAhcGFpbnRlci5pc09wYXF1ZVBhc3MgOiBwYWludGVyLmlzT3BhcXVlUGFzcyA9PT0gKGNvbG9yWzNdID09PSAxICYmIG9wYWNpdHkgPT09IDEpKSB7XG4gICAgICAgIC8vIE9uY2Ugd2Ugc3dpdGNoIHRvIGVhcmN1dCBkcmF3aW5nIHdlIGNhbiBwdWxsIG1vc3Qgb2YgdGhlIFdlYkdMIHNldHVwXG4gICAgICAgIC8vIG91dHNpZGUgb2YgdGhpcyBjb29yZHMgbG9vcC5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRyYXdGaWxsKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEcmF3IHN0cm9rZVxuICAgIGlmICghcGFpbnRlci5pc09wYXF1ZVBhc3MgJiYgbGF5ZXIucGFpbnRbJ2ZpbGwtYW50aWFsaWFzJ10pIHtcbiAgICAgICAgaWYgKHN0cm9rZUNvbG9yIHx8ICFsYXllci5wYWludFsnZmlsbC1wYXR0ZXJuJ10pIHtcbiAgICAgICAgICAgIHZhciBvdXRsaW5lUHJvZ3JhbSA9IHBhaW50ZXIudXNlUHJvZ3JhbSgnb3V0bGluZScpO1xuICAgICAgICAgICAgcGFpbnRlci5saW5lV2lkdGgoMik7XG4gICAgICAgICAgICBwYWludGVyLmRlcHRoTWFzayhmYWxzZSk7XG5cbiAgICAgICAgICAgIGlmIChzdHJva2VDb2xvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGRlZmluZWQgYSBkaWZmZXJlbnQgY29sb3IgZm9yIHRoZSBmaWxsIG91dGxpbmUsIHdlIGFyZVxuICAgICAgICAgICAgICAgIC8vIGdvaW5nIHRvIGlnbm9yZSB0aGUgYml0cyBpbiAweDA3IGFuZCBqdXN0IGNhcmUgYWJvdXQgdGhlIGdsb2JhbFxuICAgICAgICAgICAgICAgIC8vIGNsaXBwaW5nIG1hc2suXG4gICAgICAgICAgICAgICAgcGFpbnRlci5zZXREZXB0aFN1YmxheWVyKDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIG9ubHkgd2FudCB0byBkcmF3RmlsbCB0aGUgYW50aWFsaWFzZWQgcGFydHMgdGhhdCBhcmVcbiAgICAgICAgICAgICAgICAvLyAqb3V0c2lkZSogdGhlIGN1cnJlbnQgc2hhcGUuIFRoaXMgaXMgaW1wb3J0YW50IGluIGNhc2UgdGhlIGZpbGxcbiAgICAgICAgICAgICAgICAvLyBvciBzdHJva2UgY29sb3IgaXMgdHJhbnNsdWNlbnQuIElmIHdlIHdvdWxkbid0IGNsaXAgdG8gb3V0c2lkZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHNoYXBlLCBzb21lIHBpeGVscyBmcm9tIHRoZSBvdXRsaW5lIHN0cm9rZSBvdmVybGFwcGVkXG4gICAgICAgICAgICAgICAgLy8gdGhlIChub24tYW50aWFsaWFzZWQpIGZpbGwuXG4gICAgICAgICAgICAgICAgcGFpbnRlci5zZXREZXB0aFN1YmxheWVyKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2wudW5pZm9ybTJmKG91dGxpbmVQcm9ncmFtLnVfd29ybGQsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCk7XG4gICAgICAgICAgICBnbC51bmlmb3JtNGZ2KG91dGxpbmVQcm9ncmFtLnVfY29sb3IsIHN0cm9rZUNvbG9yID8gc3Ryb2tlQ29sb3IgOiBjb2xvcik7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWYob3V0bGluZVByb2dyYW0udV9vcGFjaXR5LCBvcGFjaXR5KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb29yZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBkcmF3U3Ryb2tlKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgb3V0bGluZVBhdHRlcm5Qcm9ncmFtID0gcGFpbnRlci51c2VQcm9ncmFtKCdvdXRsaW5lcGF0dGVybicpO1xuICAgICAgICAgICAgcGFpbnRlci5saW5lV2lkdGgoMik7XG4gICAgICAgICAgICBwYWludGVyLmRlcHRoTWFzayhmYWxzZSk7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIG9ubHkgd2FudCB0byBkcmF3RmlsbCB0aGUgYW50aWFsaWFzZWQgcGFydHMgdGhhdCBhcmVcbiAgICAgICAgICAgIC8vICpvdXRzaWRlKiB0aGUgY3VycmVudCBzaGFwZS4gVGhpcyBpcyBpbXBvcnRhbnQgaW4gY2FzZSB0aGUgZmlsbFxuICAgICAgICAgICAgLy8gb3Igc3Ryb2tlIGNvbG9yIGlzIHRyYW5zbHVjZW50LiBJZiB3ZSB3b3VsZG4ndCBjbGlwIHRvIG91dHNpZGVcbiAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHNoYXBlLCBzb21lIHBpeGVscyBmcm9tIHRoZSBvdXRsaW5lIHN0cm9rZSBvdmVybGFwcGVkXG4gICAgICAgICAgICAvLyB0aGUgKG5vbi1hbnRpYWxpYXNlZCkgZmlsbC5cbiAgICAgICAgICAgIHBhaW50ZXIuc2V0RGVwdGhTdWJsYXllcigwKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0yZihvdXRsaW5lUGF0dGVyblByb2dyYW0udV93b3JsZCwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjb29yZHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBkcmF3U3Ryb2tlKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkc1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhd0ZpbGwocGFpbnRlciwgc291cmNlLCBsYXllciwgY29vcmQpIHtcbiAgICB2YXIgdGlsZSA9IHNvdXJjZS5nZXRUaWxlKGNvb3JkKTtcbiAgICB2YXIgYnVja2V0ID0gdGlsZS5nZXRCdWNrZXQobGF5ZXIpO1xuICAgIGlmICghYnVja2V0KSByZXR1cm47XG4gICAgdmFyIGJ1ZmZlckdyb3VwcyA9IGJ1Y2tldC5idWZmZXJHcm91cHMuZmlsbDtcbiAgICBpZiAoIWJ1ZmZlckdyb3VwcykgcmV0dXJuO1xuXG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcblxuICAgIHZhciBjb2xvciA9IHV0aWwucHJlbXVsdGlwbHkobGF5ZXIucGFpbnRbJ2ZpbGwtY29sb3InXSk7XG4gICAgdmFyIGltYWdlID0gbGF5ZXIucGFpbnRbJ2ZpbGwtcGF0dGVybiddO1xuICAgIHZhciBvcGFjaXR5ID0gbGF5ZXIucGFpbnRbJ2ZpbGwtb3BhY2l0eSddO1xuXG4gICAgdmFyIHBvc01hdHJpeCA9IGNvb3JkLnBvc01hdHJpeDtcbiAgICB2YXIgdHJhbnNsYXRlZFBvc01hdHJpeCA9IHBhaW50ZXIudHJhbnNsYXRlUG9zTWF0cml4KHBvc01hdHJpeCwgdGlsZSwgbGF5ZXIucGFpbnRbJ2ZpbGwtdHJhbnNsYXRlJ10sIGxheWVyLnBhaW50WydmaWxsLXRyYW5zbGF0ZS1hbmNob3InXSk7XG5cbiAgICAvLyBEcmF3IHRoZSBzdGVuY2lsIG1hc2suXG4gICAgcGFpbnRlci5zZXREZXB0aFN1YmxheWVyKDEpO1xuXG4gICAgLy8gV2UncmUgb25seSBkcmF3RmlsbGluZyB0byB0aGUgZmlyc3Qgc2V2ZW4gYml0cyAoPT0gc3VwcG9ydCBhIG1heGltdW0gb2ZcbiAgICAvLyA4IG92ZXJsYXBwaW5nIHBvbHlnb25zIGluIG9uZSBwbGFjZSBiZWZvcmUgd2UgZ2V0IHJlbmRlcmluZyBlcnJvcnMpLlxuICAgIGdsLnN0ZW5jaWxNYXNrKDB4MDcpO1xuICAgIGdsLmNsZWFyKGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XG5cbiAgICAvLyBEcmF3IGZyb250IGZhY2luZyB0cmlhbmdsZXMuIFdoZXJldmVyIHRoZSAweDgwIGJpdCBpcyAxLCB3ZSBhcmVcbiAgICAvLyBpbmNyZWFzaW5nIHRoZSBsb3dlciA3IGJpdHMgYnkgb25lIGlmIHRoZSB0cmlhbmdsZSBpcyBhIGZyb250LWZhY2luZ1xuICAgIC8vIHRyaWFuZ2xlLiBUaGlzIG1lYW5zIHRoYXQgYWxsIHZpc2libGUgcG9seWdvbnMgc2hvdWxkIGJlIGluIENDV1xuICAgIC8vIG9yaWVudGF0aW9uLCB3aGlsZSBhbGwgaG9sZXMgKHNlZSBiZWxvdykgYXJlIGluIENXIG9yaWVudGF0aW9uLlxuICAgIHBhaW50ZXIuZW5hYmxlVGlsZUNsaXBwaW5nTWFzayhjb29yZCk7XG5cbiAgICAvLyBXaGVuIHdlIGRvIGEgbm9uemVybyBmaWxsLCB3ZSBjb3VudCB0aGUgbnVtYmVyIG9mIHRpbWVzIGEgcGl4ZWwgaXNcbiAgICAvLyBjb3ZlcmVkIGJ5IGEgY291bnRlcmNsb2Nrd2lzZSBwb2x5Z29uLCBhbmQgc3VidHJhY3QgdGhlIG51bWJlciBvZlxuICAgIC8vIHRpbWVzIGl0IGlzIFwidW5jb3ZlcmVkXCIgYnkgYSBjbG9ja3dpc2UgcG9seWdvbi5cbiAgICBnbC5zdGVuY2lsT3BTZXBhcmF0ZShnbC5GUk9OVCwgZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuSU5DUl9XUkFQKTtcbiAgICBnbC5zdGVuY2lsT3BTZXBhcmF0ZShnbC5CQUNLLCBnbC5LRUVQLCBnbC5LRUVQLCBnbC5ERUNSX1dSQVApO1xuXG4gICAgLy8gV2hlbiBkcmF3RmlsbGluZyBhIHNoYXBlLCB3ZSBmaXJzdCBkcmF3RmlsbCBhbGwgc2hhcGVzIHRvIHRoZSBzdGVuY2lsIGJ1ZmZlclxuICAgIC8vIGFuZCBpbmNyZW1lbnRpbmcgYWxsIGFyZWFzIHdoZXJlIHBvbHlnb25zIGFyZVxuICAgIGdsLmNvbG9yTWFzayhmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG4gICAgcGFpbnRlci5kZXB0aE1hc2soZmFsc2UpO1xuXG4gICAgLy8gRHJhdyB0aGUgYWN0dWFsIHRyaWFuZ2xlIGZhbiBpbnRvIHRoZSBzdGVuY2lsIGJ1ZmZlci5cbiAgICB2YXIgZmlsbFByb2dyYW0gPSBwYWludGVyLnVzZVByb2dyYW0oJ2ZpbGwnKTtcbiAgICBnbC51bmlmb3JtTWF0cml4NGZ2KGZpbGxQcm9ncmFtLnVfbWF0cml4LCBmYWxzZSwgdHJhbnNsYXRlZFBvc01hdHJpeCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlckdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ3JvdXAgPSBidWZmZXJHcm91cHNbaV07XG4gICAgICAgIGdyb3VwLnZhb3NbbGF5ZXIuaWRdLmJpbmQoZ2wsIGZpbGxQcm9ncmFtLCBncm91cC5sYXlvdXQudmVydGV4LCBncm91cC5sYXlvdXQuZWxlbWVudCk7XG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGdyb3VwLmxheW91dC5lbGVtZW50Lmxlbmd0aCAqIDMsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIHRoZSBzdGVuY2lsIG1hc2sgaW4gdGhlIHN0ZW5jaWwgYnVmZmVyLCB3ZSBjYW4gc3RhcnRcbiAgICAvLyB3cml0aW5nIHRvIHRoZSBjb2xvciBidWZmZXIuXG4gICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuICAgIHBhaW50ZXIuZGVwdGhNYXNrKHRydWUpO1xuXG4gICAgLy8gRnJvbSBub3cgb24sIHdlIGRvbid0IHdhbnQgdG8gdXBkYXRlIHRoZSBzdGVuY2lsIGJ1ZmZlciBhbnltb3JlLlxuICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5LRUVQKTtcbiAgICBnbC5zdGVuY2lsTWFzaygweDApO1xuICAgIHZhciBwcm9ncmFtO1xuXG4gICAgaWYgKGltYWdlKSB7XG4gICAgICAgIC8vIERyYXcgdGV4dHVyZSBmaWxsXG4gICAgICAgIHByb2dyYW0gPSBwYWludGVyLnVzZVByb2dyYW0oJ3BhdHRlcm4nKTtcbiAgICAgICAgc2V0UGF0dGVybihpbWFnZSwgb3BhY2l0eSwgdGlsZSwgY29vcmQsIHBhaW50ZXIsIHByb2dyYW0pO1xuXG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgICAgICBwYWludGVyLnNwcml0ZUF0bGFzLmJpbmQoZ2wsIHRydWUpO1xuXG4gICAgICAgIHBhaW50ZXIudGlsZUV4dGVudFBhdHRlcm5WQU8uYmluZChnbCwgcHJvZ3JhbSwgcGFpbnRlci50aWxlRXh0ZW50QnVmZmVyKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERyYXcgZmlsbGluZyByZWN0YW5nbGUuXG4gICAgICAgIHByb2dyYW0gPSBwYWludGVyLnVzZVByb2dyYW0oJ2ZpbGwnKTtcbiAgICAgICAgZ2wudW5pZm9ybTRmdihmaWxsUHJvZ3JhbS51X2NvbG9yLCBjb2xvcik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihmaWxsUHJvZ3JhbS51X29wYWNpdHksIG9wYWNpdHkpO1xuICAgICAgICBwYWludGVyLnRpbGVFeHRlbnRWQU8uYmluZChnbCwgcHJvZ3JhbSwgcGFpbnRlci50aWxlRXh0ZW50QnVmZmVyKTtcbiAgICB9XG5cbiAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHByb2dyYW0udV9tYXRyaXgsIGZhbHNlLCBwb3NNYXRyaXgpO1xuXG4gICAgLy8gT25seSBkcmF3IHJlZ2lvbnMgdGhhdCB3ZSBtYXJrZWRcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5OT1RFUVVBTCwgMHgwLCAweDA3KTtcblxuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIHBhaW50ZXIudGlsZUV4dGVudEJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgZ2wuc3RlbmNpbE1hc2soMHgwMCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdTdHJva2UocGFpbnRlciwgc291cmNlLCBsYXllciwgY29vcmQpIHtcbiAgICB2YXIgdGlsZSA9IHNvdXJjZS5nZXRUaWxlKGNvb3JkKTtcbiAgICB2YXIgYnVja2V0ID0gdGlsZS5nZXRCdWNrZXQobGF5ZXIpO1xuICAgIGlmICghYnVja2V0KSByZXR1cm47XG5cbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuICAgIHZhciBidWZmZXJHcm91cHMgPSBidWNrZXQuYnVmZmVyR3JvdXBzLmZpbGw7XG5cbiAgICB2YXIgaW1hZ2UgPSBsYXllci5wYWludFsnZmlsbC1wYXR0ZXJuJ107XG4gICAgdmFyIG9wYWNpdHkgPSBsYXllci5wYWludFsnZmlsbC1vcGFjaXR5J107XG4gICAgdmFyIHByb2dyYW0gPSBpbWFnZSA/IHBhaW50ZXIudXNlUHJvZ3JhbSgnb3V0bGluZXBhdHRlcm4nKSA6IHBhaW50ZXIudXNlUHJvZ3JhbSgnb3V0bGluZScpO1xuXG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9ncmFtLnVfbWF0cml4LCBmYWxzZSwgcGFpbnRlci50cmFuc2xhdGVQb3NNYXRyaXgoXG4gICAgICAgIGNvb3JkLnBvc01hdHJpeCxcbiAgICAgICAgdGlsZSxcbiAgICAgICAgbGF5ZXIucGFpbnRbJ2ZpbGwtdHJhbnNsYXRlJ10sXG4gICAgICAgIGxheWVyLnBhaW50WydmaWxsLXRyYW5zbGF0ZS1hbmNob3InXVxuICAgICkpO1xuXG4gICAgaWYgKGltYWdlKSB7IHNldFBhdHRlcm4oaW1hZ2UsIG9wYWNpdHksIHRpbGUsIGNvb3JkLCBwYWludGVyLCBwcm9ncmFtKTsgfVxuXG4gICAgcGFpbnRlci5lbmFibGVUaWxlQ2xpcHBpbmdNYXNrKGNvb3JkKTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYnVmZmVyR3JvdXBzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBncm91cCA9IGJ1ZmZlckdyb3Vwc1trXTtcbiAgICAgICAgZ3JvdXAuc2Vjb25kVmFvc1tsYXllci5pZF0uYmluZChnbCwgcHJvZ3JhbSwgZ3JvdXAubGF5b3V0LnZlcnRleCwgZ3JvdXAubGF5b3V0LmVsZW1lbnQyKTtcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLkxJTkVTLCBncm91cC5sYXlvdXQuZWxlbWVudDIubGVuZ3RoICogMiwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBzZXRQYXR0ZXJuKGltYWdlLCBvcGFjaXR5LCB0aWxlLCBjb29yZCwgcGFpbnRlciwgcHJvZ3JhbSkge1xuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG5cbiAgICB2YXIgaW1hZ2VQb3NBID0gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS5mcm9tLCB0cnVlKTtcbiAgICB2YXIgaW1hZ2VQb3NCID0gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS50bywgdHJ1ZSk7XG4gICAgaWYgKCFpbWFnZVBvc0EgfHwgIWltYWdlUG9zQikgcmV0dXJuO1xuXG5cbiAgICBnbC51bmlmb3JtMWkocHJvZ3JhbS51X2ltYWdlLCAwKTtcbiAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV9wYXR0ZXJuX3RsX2EsIGltYWdlUG9zQS50bCk7XG4gICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfcGF0dGVybl9icl9hLCBpbWFnZVBvc0EuYnIpO1xuICAgIGdsLnVuaWZvcm0yZnYocHJvZ3JhbS51X3BhdHRlcm5fdGxfYiwgaW1hZ2VQb3NCLnRsKTtcbiAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV9wYXR0ZXJuX2JyX2IsIGltYWdlUG9zQi5icik7XG4gICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9vcGFjaXR5LCBvcGFjaXR5KTtcbiAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X21peCwgaW1hZ2UudCk7XG5cbiAgICB2YXIgaW1hZ2VTaXplU2NhbGVkQSA9IFtcbiAgICAgICAgKGltYWdlUG9zQS5zaXplWzBdICogaW1hZ2UuZnJvbVNjYWxlKSxcbiAgICAgICAgKGltYWdlUG9zQS5zaXplWzFdICogaW1hZ2UuZnJvbVNjYWxlKVxuICAgIF07XG4gICAgdmFyIGltYWdlU2l6ZVNjYWxlZEIgPSBbXG4gICAgICAgIChpbWFnZVBvc0Iuc2l6ZVswXSAqIGltYWdlLnRvU2NhbGUpLFxuICAgICAgICAoaW1hZ2VQb3NCLnNpemVbMV0gKiBpbWFnZS50b1NjYWxlKVxuICAgIF07XG5cbiAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV9wYXR0ZXJuc2NhbGVfYSwgW1xuICAgICAgICAxIC8gcGl4ZWxzVG9UaWxlVW5pdHModGlsZSwgaW1hZ2VTaXplU2NhbGVkQVswXSwgcGFpbnRlci50cmFuc2Zvcm0udGlsZVpvb20pLFxuICAgICAgICAxIC8gcGl4ZWxzVG9UaWxlVW5pdHModGlsZSwgaW1hZ2VTaXplU2NhbGVkQVsxXSwgcGFpbnRlci50cmFuc2Zvcm0udGlsZVpvb20pXG4gICAgXSk7XG5cbiAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV9wYXR0ZXJuc2NhbGVfYiwgW1xuICAgICAgICAxIC8gcGl4ZWxzVG9UaWxlVW5pdHModGlsZSwgaW1hZ2VTaXplU2NhbGVkQlswXSwgcGFpbnRlci50cmFuc2Zvcm0udGlsZVpvb20pLFxuICAgICAgICAxIC8gcGl4ZWxzVG9UaWxlVW5pdHModGlsZSwgaW1hZ2VTaXplU2NhbGVkQlsxXSwgcGFpbnRlci50cmFuc2Zvcm0udGlsZVpvb20pXG4gICAgXSk7XG5cbiAgICB2YXIgdGlsZVNpemVBdE5lYXJlc3Rab29tID0gdGlsZS50aWxlU2l6ZSAqIE1hdGgucG93KDIsIHBhaW50ZXIudHJhbnNmb3JtLnRpbGVab29tIC0gdGlsZS5jb29yZC56KTtcblxuICAgIC8vIHNoaWZ0IGltYWdlcyB0byBtYXRjaCBhdCB0aWxlIGJvdW5kYXJpZXNcbiAgICB2YXIgb2Zmc2V0QXggPSAoKHRpbGVTaXplQXROZWFyZXN0Wm9vbSAvIGltYWdlU2l6ZVNjYWxlZEFbMF0pICUgMSkgKiAodGlsZS5jb29yZC54ICsgY29vcmQudyAqIE1hdGgucG93KDIsIHRpbGUuY29vcmQueikpO1xuICAgIHZhciBvZmZzZXRBeSA9ICgodGlsZVNpemVBdE5lYXJlc3Rab29tIC8gaW1hZ2VTaXplU2NhbGVkQVsxXSkgJSAxKSAqIHRpbGUuY29vcmQueTtcblxuICAgIHZhciBvZmZzZXRCeCA9ICgodGlsZVNpemVBdE5lYXJlc3Rab29tIC8gaW1hZ2VTaXplU2NhbGVkQlswXSkgJSAxKSAqICh0aWxlLmNvb3JkLnggKyBjb29yZC53ICogTWF0aC5wb3coMiwgdGlsZS5jb29yZC56KSk7XG4gICAgdmFyIG9mZnNldEJ5ID0gKCh0aWxlU2l6ZUF0TmVhcmVzdFpvb20gLyBpbWFnZVNpemVTY2FsZWRCWzFdKSAlIDEpICogdGlsZS5jb29yZC55O1xuXG4gICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfb2Zmc2V0X2EsIFtvZmZzZXRBeCwgb2Zmc2V0QXldKTtcbiAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV9vZmZzZXRfYiwgW29mZnNldEJ4LCBvZmZzZXRCeV0pO1xuXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgcGFpbnRlci5zcHJpdGVBdGxhcy5iaW5kKGdsLCB0cnVlKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXInKTtcbnZhciBtYXQyID0gcmVxdWlyZSgnZ2wtbWF0cml4JykubWF0MjtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgcGl4ZWxzVG9UaWxlVW5pdHMgPSByZXF1aXJlKCcuLi9zb3VyY2UvcGl4ZWxzX3RvX3RpbGVfdW5pdHMnKTtcblxuLyoqXG4gKiBEcmF3IGEgbGluZS4gVW5kZXIgdGhlIGhvb2QgdGhpcyB3aWxsIHJlYWQgZWxlbWVudHMgZnJvbVxuICogYSB0aWxlLCBkYXNoIHRleHR1cmVzIGZyb20gYSBsaW5lQXRsYXMsIGFuZCBzdHlsZSBwcm9wZXJ0aWVzIGZyb20gYSBsYXllci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWludGVyXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NNYXRyaXhcbiAqIEBwYXJhbSB7VGlsZX0gdGlsZVxuICogQHJldHVybnMge3VuZGVmaW5lZH0gZHJhd3Mgd2l0aCB0aGUgcGFpbnRlclxuICogQHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkcmF3TGluZShwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZHMpIHtcbiAgICBpZiAocGFpbnRlci5pc09wYXF1ZVBhc3MpIHJldHVybjtcbiAgICBwYWludGVyLnNldERlcHRoU3VibGF5ZXIoMCk7XG4gICAgcGFpbnRlci5kZXB0aE1hc2soZmFsc2UpO1xuXG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcbiAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcblxuICAgIC8vIGRvbid0IGRyYXcgemVyby13aWR0aCBsaW5lc1xuICAgIGlmIChsYXllci5wYWludFsnbGluZS13aWR0aCddIDw9IDApIHJldHVybjtcblxuICAgIC8vIHRoZSBkaXN0YW5jZSBvdmVyIHdoaWNoIHRoZSBsaW5lIGVkZ2UgZmFkZXMgb3V0LlxuICAgIC8vIFJldGluYSBkZXZpY2VzIG5lZWQgYSBzbWFsbGVyIGRpc3RhbmNlIHRvIGF2b2lkIGFsaWFzaW5nLlxuICAgIHZhciBhbnRpYWxpYXNpbmcgPSAxIC8gYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvO1xuXG4gICAgdmFyIGJsdXIgPSBsYXllci5wYWludFsnbGluZS1ibHVyJ10gKyBhbnRpYWxpYXNpbmc7XG4gICAgdmFyIGVkZ2VXaWR0aCA9IGxheWVyLnBhaW50WydsaW5lLXdpZHRoJ10gLyAyO1xuICAgIHZhciBpbnNldCA9IC0xO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBzaGlmdCA9IDA7XG5cbiAgICBpZiAobGF5ZXIucGFpbnRbJ2xpbmUtZ2FwLXdpZHRoJ10gPiAwKSB7XG4gICAgICAgIGluc2V0ID0gbGF5ZXIucGFpbnRbJ2xpbmUtZ2FwLXdpZHRoJ10gLyAyICsgYW50aWFsaWFzaW5nICogMC41O1xuICAgICAgICBlZGdlV2lkdGggPSBsYXllci5wYWludFsnbGluZS13aWR0aCddO1xuXG4gICAgICAgIC8vIHNoaWZ0IG91dGVyIGxpbmVzIGhhbGYgYSBwaXhlbCB0b3dhcmRzIHRoZSBtaWRkbGUgdG8gZWxpbWluYXRlIHRoZSBjcmFja1xuICAgICAgICBvZmZzZXQgPSBpbnNldCAtIGFudGlhbGlhc2luZyAvIDI7XG4gICAgfVxuXG4gICAgdmFyIG91dHNldCA9IG9mZnNldCArIGVkZ2VXaWR0aCArIGFudGlhbGlhc2luZyAvIDIgKyBzaGlmdDtcbiAgICB2YXIgY29sb3IgPSB1dGlsLnByZW11bHRpcGx5KGxheWVyLnBhaW50WydsaW5lLWNvbG9yJ10pO1xuXG4gICAgdmFyIHRyID0gcGFpbnRlci50cmFuc2Zvcm07XG5cbiAgICB2YXIgYW50aWFsaWFzaW5nTWF0cml4ID0gbWF0Mi5jcmVhdGUoKTtcbiAgICBtYXQyLnNjYWxlKGFudGlhbGlhc2luZ01hdHJpeCwgYW50aWFsaWFzaW5nTWF0cml4LCBbMSwgTWF0aC5jb3ModHIuX3BpdGNoKV0pO1xuICAgIG1hdDIucm90YXRlKGFudGlhbGlhc2luZ01hdHJpeCwgYW50aWFsaWFzaW5nTWF0cml4LCBwYWludGVyLnRyYW5zZm9ybS5hbmdsZSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgaG93IG11Y2ggbG9uZ2VyIHRoZSByZWFsIHdvcmxkIGRpc3RhbmNlIGlzIGF0IHRoZSB0b3Agb2YgdGhlIHNjcmVlblxuICAgIC8vIHRoYW4gYXQgdGhlIG1pZGRsZSBvZiB0aGUgc2NyZWVuLlxuICAgIHZhciB0b3BlZGdlbGVuZ3RoID0gTWF0aC5zcXJ0KHRyLmhlaWdodCAqIHRyLmhlaWdodCAvIDQgICogKDEgKyB0ci5hbHRpdHVkZSAqIHRyLmFsdGl0dWRlKSk7XG4gICAgdmFyIHggPSB0ci5oZWlnaHQgLyAyICogTWF0aC50YW4odHIuX3BpdGNoKTtcbiAgICB2YXIgZXh0cmEgPSAodG9wZWRnZWxlbmd0aCArIHgpIC8gdG9wZWRnZWxlbmd0aCAtIDE7XG5cbiAgICB2YXIgZGFzaGFycmF5ID0gbGF5ZXIucGFpbnRbJ2xpbmUtZGFzaGFycmF5J107XG4gICAgdmFyIGltYWdlID0gbGF5ZXIucGFpbnRbJ2xpbmUtcGF0dGVybiddO1xuICAgIHZhciBwcm9ncmFtLCBwb3NBLCBwb3NCLCBpbWFnZVBvc0EsIGltYWdlUG9zQjtcblxuICAgIGlmIChkYXNoYXJyYXkpIHtcbiAgICAgICAgcHJvZ3JhbSA9IHBhaW50ZXIudXNlUHJvZ3JhbSgnbGluZXNkZnBhdHRlcm4nKTtcblxuICAgICAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV9saW5ld2lkdGgsIFsgb3V0c2V0LCBpbnNldCBdKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9ibHVyLCBibHVyKTtcbiAgICAgICAgZ2wudW5pZm9ybTRmdihwcm9ncmFtLnVfY29sb3IsIGNvbG9yKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9vcGFjaXR5LCBsYXllci5wYWludFsnbGluZS1vcGFjaXR5J10pO1xuXG4gICAgICAgIHBvc0EgPSBwYWludGVyLmxpbmVBdGxhcy5nZXREYXNoKGRhc2hhcnJheS5mcm9tLCBsYXllci5sYXlvdXRbJ2xpbmUtY2FwJ10gPT09ICdyb3VuZCcpO1xuICAgICAgICBwb3NCID0gcGFpbnRlci5saW5lQXRsYXMuZ2V0RGFzaChkYXNoYXJyYXkudG8sIGxheWVyLmxheW91dFsnbGluZS1jYXAnXSA9PT0gJ3JvdW5kJyk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTFpKHByb2dyYW0udV9pbWFnZSwgMCk7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgICAgICBwYWludGVyLmxpbmVBdGxhcy5iaW5kKGdsKTtcblxuICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X3RleF95X2EsIHBvc0EueSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfdGV4X3lfYiwgcG9zQi55KTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9taXgsIGRhc2hhcnJheS50KTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9leHRyYSwgZXh0cmEpO1xuICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X29mZnNldCwgLWxheWVyLnBhaW50WydsaW5lLW9mZnNldCddKTtcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDJmdihwcm9ncmFtLnVfYW50aWFsaWFzaW5nbWF0cml4LCBmYWxzZSwgYW50aWFsaWFzaW5nTWF0cml4KTtcblxuICAgIH0gZWxzZSBpZiAoaW1hZ2UpIHtcbiAgICAgICAgaW1hZ2VQb3NBID0gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS5mcm9tLCB0cnVlKTtcbiAgICAgICAgaW1hZ2VQb3NCID0gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS50bywgdHJ1ZSk7XG4gICAgICAgIGlmICghaW1hZ2VQb3NBIHx8ICFpbWFnZVBvc0IpIHJldHVybjtcblxuICAgICAgICBwcm9ncmFtID0gcGFpbnRlci51c2VQcm9ncmFtKCdsaW5lcGF0dGVybicpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaShwcm9ncmFtLnVfaW1hZ2UsIDApO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICAgICAgcGFpbnRlci5zcHJpdGVBdGxhcy5iaW5kKGdsLCB0cnVlKTtcblxuICAgICAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV9saW5ld2lkdGgsIFsgb3V0c2V0LCBpbnNldCBdKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9ibHVyLCBibHVyKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfcGF0dGVybl90bF9hLCBpbWFnZVBvc0EudGwpO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV9wYXR0ZXJuX2JyX2EsIGltYWdlUG9zQS5icik7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYocHJvZ3JhbS51X3BhdHRlcm5fdGxfYiwgaW1hZ2VQb3NCLnRsKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfcGF0dGVybl9icl9iLCBpbWFnZVBvc0IuYnIpO1xuICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X2ZhZGUsIGltYWdlLnQpO1xuICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X29wYWNpdHksIGxheWVyLnBhaW50WydsaW5lLW9wYWNpdHknXSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfZXh0cmEsIGV4dHJhKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9vZmZzZXQsIC1sYXllci5wYWludFsnbGluZS1vZmZzZXQnXSk7XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYocHJvZ3JhbS51X2FudGlhbGlhc2luZ21hdHJpeCwgZmFsc2UsIGFudGlhbGlhc2luZ01hdHJpeCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9ncmFtID0gcGFpbnRlci51c2VQcm9ncmFtKCdsaW5lJyk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfbGluZXdpZHRoLCBbIG91dHNldCwgaW5zZXQgXSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfYmx1ciwgYmx1cik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfZXh0cmEsIGV4dHJhKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9vZmZzZXQsIC1sYXllci5wYWludFsnbGluZS1vZmZzZXQnXSk7XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYocHJvZ3JhbS51X2FudGlhbGlhc2luZ21hdHJpeCwgZmFsc2UsIGFudGlhbGlhc2luZ01hdHJpeCk7XG4gICAgICAgIGdsLnVuaWZvcm00ZnYocHJvZ3JhbS51X2NvbG9yLCBjb2xvcik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfb3BhY2l0eSwgbGF5ZXIucGFpbnRbJ2xpbmUtb3BhY2l0eSddKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGNvb3Jkcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgY29vcmQgPSBjb29yZHNba107XG4gICAgICAgIHZhciB0aWxlID0gc291cmNlLmdldFRpbGUoY29vcmQpO1xuICAgICAgICB2YXIgYnVja2V0ID0gdGlsZS5nZXRCdWNrZXQobGF5ZXIpO1xuICAgICAgICBpZiAoIWJ1Y2tldCkgY29udGludWU7XG4gICAgICAgIHZhciBidWZmZXJHcm91cHMgPSBidWNrZXQuYnVmZmVyR3JvdXBzLmxpbmU7XG4gICAgICAgIGlmICghYnVmZmVyR3JvdXBzKSBjb250aW51ZTtcblxuICAgICAgICBwYWludGVyLmVuYWJsZVRpbGVDbGlwcGluZ01hc2soY29vcmQpO1xuXG4gICAgICAgIC8vIHNldCB1bmlmb3JtcyB0aGF0IGFyZSBkaWZmZXJlbnQgZm9yIGVhY2ggdGlsZVxuICAgICAgICB2YXIgcG9zTWF0cml4ID0gcGFpbnRlci50cmFuc2xhdGVQb3NNYXRyaXgoY29vcmQucG9zTWF0cml4LCB0aWxlLCBsYXllci5wYWludFsnbGluZS10cmFuc2xhdGUnXSwgbGF5ZXIucGFpbnRbJ2xpbmUtdHJhbnNsYXRlLWFuY2hvciddKTtcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9ncmFtLnVfbWF0cml4LCBmYWxzZSwgcG9zTWF0cml4KTtcblxuICAgICAgICB2YXIgcmF0aW8gPSAxIC8gcGl4ZWxzVG9UaWxlVW5pdHModGlsZSwgMSwgcGFpbnRlci50cmFuc2Zvcm0uem9vbSk7XG5cbiAgICAgICAgaWYgKGRhc2hhcnJheSkge1xuICAgICAgICAgICAgdmFyIHdpZHRoQSA9IHBvc0Eud2lkdGggKiBkYXNoYXJyYXkuZnJvbVNjYWxlO1xuICAgICAgICAgICAgdmFyIHdpZHRoQiA9IHBvc0Iud2lkdGggKiBkYXNoYXJyYXkudG9TY2FsZTtcbiAgICAgICAgICAgIHZhciBzY2FsZUEgPSBbMSAvIHBpeGVsc1RvVGlsZVVuaXRzKHRpbGUsIHdpZHRoQSwgcGFpbnRlci50cmFuc2Zvcm0udGlsZVpvb20pLCAtcG9zQS5oZWlnaHQgLyAyXTtcbiAgICAgICAgICAgIHZhciBzY2FsZUIgPSBbMSAvIHBpeGVsc1RvVGlsZVVuaXRzKHRpbGUsIHdpZHRoQiwgcGFpbnRlci50cmFuc2Zvcm0udGlsZVpvb20pLCAtcG9zQi5oZWlnaHQgLyAyXTtcbiAgICAgICAgICAgIHZhciBnYW1tYSA9IHBhaW50ZXIubGluZUF0bGFzLndpZHRoIC8gKE1hdGgubWluKHdpZHRoQSwgd2lkdGhCKSAqIDI1NiAqIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbykgLyAyO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9yYXRpbywgcmF0aW8pO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfcGF0dGVybnNjYWxlX2EsIHNjYWxlQSk7XG4gICAgICAgICAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV9wYXR0ZXJuc2NhbGVfYiwgc2NhbGVCKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfc2RmZ2FtbWEsIGdhbW1hKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGltYWdlKSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X3JhdGlvLCByYXRpbyk7XG4gICAgICAgICAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV9wYXR0ZXJuX3NpemVfYSwgW1xuICAgICAgICAgICAgICAgIHBpeGVsc1RvVGlsZVVuaXRzKHRpbGUsIGltYWdlUG9zQS5zaXplWzBdICogaW1hZ2UuZnJvbVNjYWxlLCBwYWludGVyLnRyYW5zZm9ybS50aWxlWm9vbSksXG4gICAgICAgICAgICAgICAgaW1hZ2VQb3NCLnNpemVbMV1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfcGF0dGVybl9zaXplX2IsIFtcbiAgICAgICAgICAgICAgICBwaXhlbHNUb1RpbGVVbml0cyh0aWxlLCBpbWFnZVBvc0Iuc2l6ZVswXSAqIGltYWdlLnRvU2NhbGUsIHBhaW50ZXIudHJhbnNmb3JtLnRpbGVab29tKSxcbiAgICAgICAgICAgICAgICBpbWFnZVBvc0Iuc2l6ZVsxXVxuICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfcmF0aW8sIHJhdGlvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyR3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBidWZmZXJHcm91cHNbaV07XG4gICAgICAgICAgICBncm91cC52YW9zW2xheWVyLmlkXS5iaW5kKGdsLCBwcm9ncmFtLCBncm91cC5sYXlvdXQudmVydGV4LCBncm91cC5sYXlvdXQuZWxlbWVudCk7XG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBncm91cC5sYXlvdXQuZWxlbWVudC5sZW5ndGggKiAzLCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgU3RydWN0QXJyYXlUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9zdHJ1Y3RfYXJyYXknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkcmF3UmFzdGVyO1xuXG5mdW5jdGlvbiBkcmF3UmFzdGVyKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkcykge1xuICAgIGlmIChwYWludGVyLmlzT3BhcXVlUGFzcykgcmV0dXJuO1xuXG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcblxuICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICBwYWludGVyLmRlcHRoTWFzayh0cnVlKTtcblxuICAgIC8vIENoYW5nZSBkZXB0aCBmdW5jdGlvbiB0byBwcmV2ZW50IGRvdWJsZSBkcmF3aW5nIGluIGFyZWFzIHdoZXJlIHRpbGVzIG92ZXJsYXAuXG4gICAgZ2wuZGVwdGhGdW5jKGdsLkxFU1MpO1xuXG4gICAgdmFyIG1pblRpbGVaID0gY29vcmRzLmxlbmd0aCAmJiBjb29yZHNbMF0uejtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb29yZCA9IGNvb3Jkc1tpXTtcbiAgICAgICAgLy8gc2V0IHRoZSBsb3dlciB6b29tIGxldmVsIHRvIHN1YmxheWVyIDAsIGFuZCBoaWdoZXIgem9vbSBsZXZlbHMgdG8gaGlnaGVyIHN1YmxheWVyc1xuICAgICAgICBwYWludGVyLnNldERlcHRoU3VibGF5ZXIoY29vcmQueiAtIG1pblRpbGVaKTtcbiAgICAgICAgZHJhd1Jhc3RlclRpbGUocGFpbnRlciwgc291cmNlLCBsYXllciwgY29vcmQpO1xuICAgIH1cblxuICAgIGdsLmRlcHRoRnVuYyhnbC5MRVFVQUwpO1xufVxuXG5kcmF3UmFzdGVyLlJhc3RlckJvdW5kc0FycmF5ID0gbmV3IFN0cnVjdEFycmF5VHlwZSh7XG4gICAgbWVtYmVyczogW1xuICAgICAgICB7IG5hbWU6ICdhX3BvcycsIHR5cGU6ICdJbnQxNicsIGNvbXBvbmVudHM6IDIgfSxcbiAgICAgICAgeyBuYW1lOiAnYV90ZXh0dXJlX3BvcycsIHR5cGU6ICdJbnQxNicsIGNvbXBvbmVudHM6IDIgfVxuICAgIF1cbn0pO1xuXG5mdW5jdGlvbiBkcmF3UmFzdGVyVGlsZShwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZCkge1xuXG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcblxuICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcblxuICAgIHZhciB0aWxlID0gc291cmNlLmdldFRpbGUoY29vcmQpO1xuICAgIHZhciBwb3NNYXRyaXggPSBwYWludGVyLnRyYW5zZm9ybS5jYWxjdWxhdGVQb3NNYXRyaXgoY29vcmQsIHNvdXJjZS5tYXh6b29tKTtcblxuICAgIHZhciBwcm9ncmFtID0gcGFpbnRlci51c2VQcm9ncmFtKCdyYXN0ZXInKTtcbiAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHByb2dyYW0udV9tYXRyaXgsIGZhbHNlLCBwb3NNYXRyaXgpO1xuXG4gICAgLy8gY29sb3IgcGFyYW1ldGVyc1xuICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfYnJpZ2h0bmVzc19sb3csIGxheWVyLnBhaW50WydyYXN0ZXItYnJpZ2h0bmVzcy1taW4nXSk7XG4gICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9icmlnaHRuZXNzX2hpZ2gsIGxheWVyLnBhaW50WydyYXN0ZXItYnJpZ2h0bmVzcy1tYXgnXSk7XG4gICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9zYXR1cmF0aW9uX2ZhY3Rvciwgc2F0dXJhdGlvbkZhY3RvcihsYXllci5wYWludFsncmFzdGVyLXNhdHVyYXRpb24nXSkpO1xuICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfY29udHJhc3RfZmFjdG9yLCBjb250cmFzdEZhY3RvcihsYXllci5wYWludFsncmFzdGVyLWNvbnRyYXN0J10pKTtcbiAgICBnbC51bmlmb3JtM2Z2KHByb2dyYW0udV9zcGluX3dlaWdodHMsIHNwaW5XZWlnaHRzKGxheWVyLnBhaW50WydyYXN0ZXItaHVlLXJvdGF0ZSddKSk7XG5cbiAgICB2YXIgcGFyZW50VGlsZSA9IHRpbGUuc291cmNlICYmIHRpbGUuc291cmNlLl9weXJhbWlkLmZpbmRMb2FkZWRQYXJlbnQoY29vcmQsIDAsIHt9KSxcbiAgICAgICAgb3BhY2l0aWVzID0gZ2V0T3BhY2l0aWVzKHRpbGUsIHBhcmVudFRpbGUsIGxheWVyLCBwYWludGVyLnRyYW5zZm9ybSk7XG5cbiAgICB2YXIgcGFyZW50U2NhbGVCeSwgcGFyZW50VEw7XG5cbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aWxlLnRleHR1cmUpO1xuXG4gICAgaWYgKHBhcmVudFRpbGUpIHtcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMSk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHBhcmVudFRpbGUudGV4dHVyZSk7XG5cbiAgICAgICAgcGFyZW50U2NhbGVCeSA9IE1hdGgucG93KDIsIHBhcmVudFRpbGUuY29vcmQueiAtIHRpbGUuY29vcmQueik7XG4gICAgICAgIHBhcmVudFRMID0gW3RpbGUuY29vcmQueCAqIHBhcmVudFNjYWxlQnkgJSAxLCB0aWxlLmNvb3JkLnkgKiBwYXJlbnRTY2FsZUJ5ICUgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3BhY2l0aWVzWzFdID0gMDtcbiAgICB9XG5cbiAgICAvLyBjcm9zcy1mYWRlIHBhcmFtZXRlcnNcbiAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV90bF9wYXJlbnQsIHBhcmVudFRMIHx8IFswLCAwXSk7XG4gICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9zY2FsZV9wYXJlbnQsIHBhcmVudFNjYWxlQnkgfHwgMSk7XG4gICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9idWZmZXJfc2NhbGUsIDEpO1xuICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfb3BhY2l0eTAsIG9wYWNpdGllc1swXSk7XG4gICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9vcGFjaXR5MSwgb3BhY2l0aWVzWzFdKTtcbiAgICBnbC51bmlmb3JtMWkocHJvZ3JhbS51X2ltYWdlMCwgMCk7XG4gICAgZ2wudW5pZm9ybTFpKHByb2dyYW0udV9pbWFnZTEsIDEpO1xuXG4gICAgdmFyIGJ1ZmZlciA9IHRpbGUuYm91bmRzQnVmZmVyIHx8IHBhaW50ZXIucmFzdGVyQm91bmRzQnVmZmVyO1xuICAgIHZhciB2YW8gPSB0aWxlLmJvdW5kc1ZBTyB8fCBwYWludGVyLnJhc3RlckJvdW5kc1ZBTztcbiAgICB2YW8uYmluZChnbCwgcHJvZ3JhbSwgYnVmZmVyKTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCBidWZmZXIubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gc3BpbldlaWdodHMoYW5nbGUpIHtcbiAgICBhbmdsZSAqPSBNYXRoLlBJIC8gMTgwO1xuICAgIHZhciBzID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIHJldHVybiBbXG4gICAgICAgICgyICogYyArIDEpIC8gMyxcbiAgICAgICAgKC1NYXRoLnNxcnQoMykgKiBzIC0gYyArIDEpIC8gMyxcbiAgICAgICAgKE1hdGguc3FydCgzKSAqIHMgLSBjICsgMSkgLyAzXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gY29udHJhc3RGYWN0b3IoY29udHJhc3QpIHtcbiAgICByZXR1cm4gY29udHJhc3QgPiAwID9cbiAgICAgICAgMSAvICgxIC0gY29udHJhc3QpIDpcbiAgICAgICAgMSArIGNvbnRyYXN0O1xufVxuXG5mdW5jdGlvbiBzYXR1cmF0aW9uRmFjdG9yKHNhdHVyYXRpb24pIHtcbiAgICByZXR1cm4gc2F0dXJhdGlvbiA+IDAgP1xuICAgICAgICAxIC0gMSAvICgxLjAwMSAtIHNhdHVyYXRpb24pIDpcbiAgICAgICAgLXNhdHVyYXRpb247XG59XG5cbmZ1bmN0aW9uIGdldE9wYWNpdGllcyh0aWxlLCBwYXJlbnRUaWxlLCBsYXllciwgdHJhbnNmb3JtKSB7XG4gICAgdmFyIG9wYWNpdHkgPSBbMSwgMF07XG4gICAgdmFyIGZhZGVEdXJhdGlvbiA9IGxheWVyLnBhaW50WydyYXN0ZXItZmFkZS1kdXJhdGlvbiddO1xuXG4gICAgaWYgKHRpbGUuc291cmNlICYmIGZhZGVEdXJhdGlvbiA+IDApIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgIHZhciBzaW5jZVRpbGUgPSAobm93IC0gdGlsZS50aW1lQWRkZWQpIC8gZmFkZUR1cmF0aW9uO1xuICAgICAgICB2YXIgc2luY2VQYXJlbnQgPSBwYXJlbnRUaWxlID8gKG5vdyAtIHBhcmVudFRpbGUudGltZUFkZGVkKSAvIGZhZGVEdXJhdGlvbiA6IC0xO1xuXG4gICAgICAgIHZhciBpZGVhbFogPSB0aWxlLnNvdXJjZS5fcHlyYW1pZC5jb3ZlcmluZ1pvb21MZXZlbCh0cmFuc2Zvcm0pO1xuICAgICAgICB2YXIgcGFyZW50RnVydGhlciA9IHBhcmVudFRpbGUgPyBNYXRoLmFicyhwYXJlbnRUaWxlLmNvb3JkLnogLSBpZGVhbFopID4gTWF0aC5hYnModGlsZS5jb29yZC56IC0gaWRlYWxaKSA6IGZhbHNlO1xuXG4gICAgICAgIGlmICghcGFyZW50VGlsZSB8fCBwYXJlbnRGdXJ0aGVyKSB7XG4gICAgICAgICAgICAvLyBpZiBubyBwYXJlbnQgb3IgcGFyZW50IGlzIG9sZGVyXG4gICAgICAgICAgICBvcGFjaXR5WzBdID0gdXRpbC5jbGFtcChzaW5jZVRpbGUsIDAsIDEpO1xuICAgICAgICAgICAgb3BhY2l0eVsxXSA9IDEgLSBvcGFjaXR5WzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFyZW50IGlzIHlvdW5nZXIsIHpvb21pbmcgb3V0XG4gICAgICAgICAgICBvcGFjaXR5WzBdID0gdXRpbC5jbGFtcCgxIC0gc2luY2VQYXJlbnQsIDAsIDEpO1xuICAgICAgICAgICAgb3BhY2l0eVsxXSA9IDEgLSBvcGFjaXR5WzBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG9wID0gbGF5ZXIucGFpbnRbJ3Jhc3Rlci1vcGFjaXR5J107XG4gICAgb3BhY2l0eVswXSAqPSBvcDtcbiAgICBvcGFjaXR5WzFdICo9IG9wO1xuXG4gICAgcmV0dXJuIG9wYWNpdHk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgZHJhd0NvbGxpc2lvbkRlYnVnID0gcmVxdWlyZSgnLi9kcmF3X2NvbGxpc2lvbl9kZWJ1ZycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBwaXhlbHNUb1RpbGVVbml0cyA9IHJlcXVpcmUoJy4uL3NvdXJjZS9waXhlbHNfdG9fdGlsZV91bml0cycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd1N5bWJvbHM7XG5cbmZ1bmN0aW9uIGRyYXdTeW1ib2xzKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkcykge1xuICAgIGlmIChwYWludGVyLmlzT3BhcXVlUGFzcykgcmV0dXJuO1xuXG4gICAgdmFyIGRyYXdBY3Jvc3NFZGdlcyA9ICEobGF5ZXIubGF5b3V0Wyd0ZXh0LWFsbG93LW92ZXJsYXAnXSB8fCBsYXllci5sYXlvdXRbJ2ljb24tYWxsb3ctb3ZlcmxhcCddIHx8XG4gICAgICAgIGxheWVyLmxheW91dFsndGV4dC1pZ25vcmUtcGxhY2VtZW50J10gfHwgbGF5ZXIubGF5b3V0WydpY29uLWlnbm9yZS1wbGFjZW1lbnQnXSk7XG5cbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuXG4gICAgLy8gRGlzYWJsZSB0aGUgc3RlbmNpbCB0ZXN0IHNvIHRoYXQgbGFiZWxzIGFyZW4ndCBjbGlwcGVkIHRvIHRpbGUgYm91bmRhcmllcy5cbiAgICAvL1xuICAgIC8vIExheWVycyB3aXRoIGZlYXR1cmVzIHRoYXQgbWF5IGJlIGRyYXduIG92ZXJsYXBwaW5nIGFyZW4ndCBjbGlwcGVkLiBUaGVzZVxuICAgIC8vIGxheWVycyBhcmUgc29ydGVkIGluIHRoZSB5IGRpcmVjdGlvbiwgYW5kIHRvIGRyYXcgdGhlIGNvcnJlY3Qgb3JkZXJpbmcgbmVhclxuICAgIC8vIHRpbGUgZWRnZXMgdGhlIGljb25zIGFyZSBpbmNsdWRlZCBpbiBib3RoIHRpbGVzIGFuZCBjbGlwcGVkIHdoZW4gZHJhd2luZy5cbiAgICBpZiAoZHJhd0Fjcm9zc0VkZ2VzKSB7XG4gICAgICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICB9XG5cbiAgICBwYWludGVyLnNldERlcHRoU3VibGF5ZXIoMCk7XG4gICAgcGFpbnRlci5kZXB0aE1hc2soZmFsc2UpO1xuICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cbiAgICBkcmF3TGF5ZXJTeW1ib2xzKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3JkcywgZmFsc2UsXG4gICAgICAgICAgICBsYXllci5wYWludFsnaWNvbi10cmFuc2xhdGUnXSxcbiAgICAgICAgICAgIGxheWVyLnBhaW50WydpY29uLXRyYW5zbGF0ZS1hbmNob3InXSxcbiAgICAgICAgICAgIGxheWVyLmxheW91dFsnaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnQnXSxcbiAgICAgICAgICAgIGxheWVyLmxheW91dFsnaWNvbi1zaXplJ10sXG4gICAgICAgICAgICBsYXllci5wYWludFsnaWNvbi1oYWxvLXdpZHRoJ10sXG4gICAgICAgICAgICBsYXllci5wYWludFsnaWNvbi1oYWxvLWNvbG9yJ10sXG4gICAgICAgICAgICBsYXllci5wYWludFsnaWNvbi1oYWxvLWJsdXInXSxcbiAgICAgICAgICAgIGxheWVyLnBhaW50WydpY29uLW9wYWNpdHknXSxcbiAgICAgICAgICAgIGxheWVyLnBhaW50WydpY29uLWNvbG9yJ10pO1xuXG4gICAgZHJhd0xheWVyU3ltYm9scyhwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZHMsIHRydWUsXG4gICAgICAgICAgICBsYXllci5wYWludFsndGV4dC10cmFuc2xhdGUnXSxcbiAgICAgICAgICAgIGxheWVyLnBhaW50Wyd0ZXh0LXRyYW5zbGF0ZS1hbmNob3InXSxcbiAgICAgICAgICAgIGxheWVyLmxheW91dFsndGV4dC1yb3RhdGlvbi1hbGlnbm1lbnQnXSxcbiAgICAgICAgICAgIGxheWVyLmxheW91dFsndGV4dC1zaXplJ10sXG4gICAgICAgICAgICBsYXllci5wYWludFsndGV4dC1oYWxvLXdpZHRoJ10sXG4gICAgICAgICAgICBsYXllci5wYWludFsndGV4dC1oYWxvLWNvbG9yJ10sXG4gICAgICAgICAgICBsYXllci5wYWludFsndGV4dC1oYWxvLWJsdXInXSxcbiAgICAgICAgICAgIGxheWVyLnBhaW50Wyd0ZXh0LW9wYWNpdHknXSxcbiAgICAgICAgICAgIGxheWVyLnBhaW50Wyd0ZXh0LWNvbG9yJ10pO1xuXG4gICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuXG4gICAgZHJhd0NvbGxpc2lvbkRlYnVnKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkcyk7XG59XG5cbmZ1bmN0aW9uIGRyYXdMYXllclN5bWJvbHMocGFpbnRlciwgc291cmNlLCBsYXllciwgY29vcmRzLCBpc1RleHQsXG4gICAgICAgIHRyYW5zbGF0ZSxcbiAgICAgICAgdHJhbnNsYXRlQW5jaG9yLFxuICAgICAgICByb3RhdGlvbkFsaWdubWVudCxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgaGFsb1dpZHRoLFxuICAgICAgICBoYWxvQ29sb3IsXG4gICAgICAgIGhhbG9CbHVyLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBjb2xvcikge1xuXG4gICAgaGFsb0NvbG9yID0gdXRpbC5wcmVtdWx0aXBseShoYWxvQ29sb3IpO1xuICAgIGNvbG9yID0gdXRpbC5wcmVtdWx0aXBseShjb2xvcik7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgdGlsZSA9IHNvdXJjZS5nZXRUaWxlKGNvb3Jkc1tqXSk7XG4gICAgICAgIHZhciBidWNrZXQgPSB0aWxlLmdldEJ1Y2tldChsYXllcik7XG4gICAgICAgIGlmICghYnVja2V0KSBjb250aW51ZTtcbiAgICAgICAgdmFyIGJvdGhCdWZmZXJHcm91cHMgPSBidWNrZXQuYnVmZmVyR3JvdXBzO1xuICAgICAgICB2YXIgYnVmZmVyR3JvdXBzID0gaXNUZXh0ID8gYm90aEJ1ZmZlckdyb3Vwcy5nbHlwaCA6IGJvdGhCdWZmZXJHcm91cHMuaWNvbjtcbiAgICAgICAgaWYgKCFidWZmZXJHcm91cHMubGVuZ3RoKSBjb250aW51ZTtcblxuICAgICAgICBwYWludGVyLmVuYWJsZVRpbGVDbGlwcGluZ01hc2soY29vcmRzW2pdKTtcbiAgICAgICAgZHJhd1N5bWJvbChwYWludGVyLCBsYXllciwgY29vcmRzW2pdLnBvc01hdHJpeCwgdGlsZSwgYnVja2V0LCBidWZmZXJHcm91cHMsIGlzVGV4dCxcbiAgICAgICAgICAgICAgICBpc1RleHQgfHwgYnVja2V0LnNkZkljb25zLCAhaXNUZXh0ICYmIGJ1Y2tldC5pY29uc05lZWRMaW5lYXIsXG4gICAgICAgICAgICAgICAgaXNUZXh0ID8gYnVja2V0LmFkanVzdGVkVGV4dFNpemUgOiBidWNrZXQuYWRqdXN0ZWRJY29uU2l6ZSwgYnVja2V0LmZvbnRzdGFjayxcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGUsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlQW5jaG9yLFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uQWxpZ25tZW50LFxuICAgICAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAgICAgaGFsb1dpZHRoLFxuICAgICAgICAgICAgICAgIGhhbG9Db2xvcixcbiAgICAgICAgICAgICAgICBoYWxvQmx1cixcbiAgICAgICAgICAgICAgICBvcGFjaXR5LFxuICAgICAgICAgICAgICAgIGNvbG9yKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdTeW1ib2wocGFpbnRlciwgbGF5ZXIsIHBvc01hdHJpeCwgdGlsZSwgYnVja2V0LCBidWZmZXJHcm91cHMsIGlzVGV4dCwgc2RmLCBpY29uc05lZWRMaW5lYXIsIGFkanVzdGVkU2l6ZSwgZm9udHN0YWNrLFxuICAgICAgICB0cmFuc2xhdGUsXG4gICAgICAgIHRyYW5zbGF0ZUFuY2hvcixcbiAgICAgICAgcm90YXRpb25BbGlnbm1lbnQsXG4gICAgICAgIHNpemUsXG4gICAgICAgIGhhbG9XaWR0aCxcbiAgICAgICAgaGFsb0NvbG9yLFxuICAgICAgICBoYWxvQmx1cixcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgY29sb3IpIHtcbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuICAgIHZhciB0ciA9IHBhaW50ZXIudHJhbnNmb3JtO1xuICAgIHZhciBhbGlnbmVkV2l0aE1hcCA9IHJvdGF0aW9uQWxpZ25tZW50ID09PSAnbWFwJztcblxuICAgIHZhciBkZWZhdWx0U2l6ZSA9IGlzVGV4dCA/IDI0IDogMTtcbiAgICB2YXIgZm9udFNjYWxlID0gc2l6ZSAvIGRlZmF1bHRTaXplO1xuXG4gICAgdmFyIGV4dHJ1ZGVTY2FsZSwgcywgZ2FtbWFTY2FsZTtcbiAgICBpZiAoYWxpZ25lZFdpdGhNYXApIHtcbiAgICAgICAgcyA9IHBpeGVsc1RvVGlsZVVuaXRzKHRpbGUsIDEsIHBhaW50ZXIudHJhbnNmb3JtLnpvb20pICogZm9udFNjYWxlO1xuICAgICAgICBnYW1tYVNjYWxlID0gMSAvIE1hdGguY29zKHRyLl9waXRjaCk7XG4gICAgICAgIGV4dHJ1ZGVTY2FsZSA9IFtzLCBzXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzID0gcGFpbnRlci50cmFuc2Zvcm0uYWx0aXR1ZGUgKiBmb250U2NhbGU7XG4gICAgICAgIGdhbW1hU2NhbGUgPSAxO1xuICAgICAgICBleHRydWRlU2NhbGUgPSBbIHRyLnBpeGVsc1RvR0xVbml0c1swXSAqIHMsIHRyLnBpeGVsc1RvR0xVbml0c1sxXSAqIHNdO1xuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSBob3cgbXVjaCBsb25nZXIgdGhlIHJlYWwgd29ybGQgZGlzdGFuY2UgaXMgYXQgdGhlIHRvcCBvZiB0aGUgc2NyZWVuXG4gICAgLy8gdGhhbiBhdCB0aGUgbWlkZGxlIG9mIHRoZSBzY3JlZW4uXG4gICAgdmFyIHRvcGVkZ2VsZW5ndGggPSBNYXRoLnNxcnQodHIuaGVpZ2h0ICogdHIuaGVpZ2h0IC8gNCAgKiAoMSArIHRyLmFsdGl0dWRlICogdHIuYWx0aXR1ZGUpKTtcbiAgICB2YXIgeCA9IHRyLmhlaWdodCAvIDIgKiBNYXRoLnRhbih0ci5fcGl0Y2gpO1xuICAgIHZhciBleHRyYSA9ICh0b3BlZGdlbGVuZ3RoICsgeCkgLyB0b3BlZGdlbGVuZ3RoIC0gMTtcblxuICAgIGlmICghaXNUZXh0ICYmICFwYWludGVyLnN0eWxlLnNwcml0ZS5sb2FkZWQoKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHByb2dyYW0gPSBwYWludGVyLnVzZVByb2dyYW0oc2RmID8gJ3NkZicgOiAnaWNvbicpO1xuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYocHJvZ3JhbS51X21hdHJpeCwgZmFsc2UsIHBhaW50ZXIudHJhbnNsYXRlUG9zTWF0cml4KHBvc01hdHJpeCwgdGlsZSwgdHJhbnNsYXRlLCB0cmFuc2xhdGVBbmNob3IpKTtcbiAgICBnbC51bmlmb3JtMWkocHJvZ3JhbS51X3NrZXdlZCwgYWxpZ25lZFdpdGhNYXApO1xuICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfZXh0cmEsIGV4dHJhKTtcbiAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV9leHRydWRlX3NjYWxlLCBleHRydWRlU2NhbGUpO1xuXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgZ2wudW5pZm9ybTFpKHByb2dyYW0udV90ZXh0dXJlLCAwKTtcblxuICAgIGlmIChpc1RleHQpIHtcbiAgICAgICAgLy8gdXNlIHRoZSBmb25zdGFjayB1c2VkIHdoZW4gcGFyc2luZyB0aGUgdGlsZSwgbm90IHRoZSBmb250c3RhY2tcbiAgICAgICAgLy8gYXQgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCAobGF5b3V0Wyd0ZXh0LWZvbnQnXSkuXG4gICAgICAgIHZhciBnbHlwaEF0bGFzID0gZm9udHN0YWNrICYmIHBhaW50ZXIuZ2x5cGhTb3VyY2UuZ2V0R2x5cGhBdGxhcyhmb250c3RhY2spO1xuICAgICAgICBpZiAoIWdseXBoQXRsYXMpIHJldHVybjtcblxuICAgICAgICBnbHlwaEF0bGFzLnVwZGF0ZVRleHR1cmUoZ2wpO1xuICAgICAgICBnbC51bmlmb3JtMmYocHJvZ3JhbS51X3RleHNpemUsIGdseXBoQXRsYXMud2lkdGggLyA0LCBnbHlwaEF0bGFzLmhlaWdodCAvIDQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtYXBNb3ZpbmcgPSBwYWludGVyLm9wdGlvbnMucm90YXRpbmcgfHwgcGFpbnRlci5vcHRpb25zLnpvb21pbmc7XG4gICAgICAgIHZhciBpY29uU2NhbGVkID0gZm9udFNjYWxlICE9PSAxIHx8IGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyAhPT0gcGFpbnRlci5zcHJpdGVBdGxhcy5waXhlbFJhdGlvIHx8IGljb25zTmVlZExpbmVhcjtcbiAgICAgICAgdmFyIGljb25UcmFuc2Zvcm1lZCA9IGFsaWduZWRXaXRoTWFwIHx8IHBhaW50ZXIudHJhbnNmb3JtLnBpdGNoO1xuICAgICAgICBwYWludGVyLnNwcml0ZUF0bGFzLmJpbmQoZ2wsIHNkZiB8fCBtYXBNb3ZpbmcgfHwgaWNvblNjYWxlZCB8fCBpY29uVHJhbnNmb3JtZWQpO1xuICAgICAgICBnbC51bmlmb3JtMmYocHJvZ3JhbS51X3RleHNpemUsIHBhaW50ZXIuc3ByaXRlQXRsYXMud2lkdGggLyA0LCBwYWludGVyLnNwcml0ZUF0bGFzLmhlaWdodCAvIDQpO1xuICAgIH1cblxuICAgIC8vIGFkanVzdCBtaW4vbWF4IHpvb21zIGZvciB2YXJpYWJsZSBmb250IHNpemVzXG4gICAgdmFyIHpvb21BZGp1c3QgPSBNYXRoLmxvZyhzaXplIC8gYWRqdXN0ZWRTaXplKSAvIE1hdGguTE4yIHx8IDA7XG4gICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV96b29tLCAocGFpbnRlci50cmFuc2Zvcm0uem9vbSAtIHpvb21BZGp1c3QpICogMTApOyAvLyBjdXJyZW50IHpvb20gbGV2ZWxcblxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTEpO1xuICAgIHBhaW50ZXIuZnJhbWVIaXN0b3J5LmJpbmQoZ2wpO1xuICAgIGdsLnVuaWZvcm0xaShwcm9ncmFtLnVfZmFkZXRleHR1cmUsIDEpO1xuXG4gICAgdmFyIGdyb3VwO1xuXG4gICAgaWYgKHNkZikge1xuICAgICAgICB2YXIgc2RmUHggPSA4O1xuICAgICAgICB2YXIgYmx1ck9mZnNldCA9IDEuMTk7XG4gICAgICAgIHZhciBoYWxvT2Zmc2V0ID0gNjtcbiAgICAgICAgdmFyIGdhbW1hID0gMC4xMDUgKiBkZWZhdWx0U2l6ZSAvIHNpemUgLyBicm93c2VyLmRldmljZVBpeGVsUmF0aW87XG5cbiAgICAgICAgaWYgKGhhbG9XaWR0aCkge1xuICAgICAgICAgICAgLy8gRHJhdyBoYWxvIHVuZGVybmVhdGggdGhlIHRleHQuXG4gICAgICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X2dhbW1hLCAoaGFsb0JsdXIgKiBibHVyT2Zmc2V0IC8gZm9udFNjYWxlIC8gc2RmUHggKyBnYW1tYSkgKiBnYW1tYVNjYWxlKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm00ZnYocHJvZ3JhbS51X2NvbG9yLCBoYWxvQ29sb3IpO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9vcGFjaXR5LCBvcGFjaXR5KTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfYnVmZmVyLCAoaGFsb09mZnNldCAtIGhhbG9XaWR0aCAvIGZvbnRTY2FsZSkgLyBzZGZQeCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYnVmZmVyR3JvdXBzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAgPSBidWZmZXJHcm91cHNbal07XG4gICAgICAgICAgICAgICAgZ3JvdXAudmFvc1tsYXllci5pZF0uYmluZChnbCwgcHJvZ3JhbSwgZ3JvdXAubGF5b3V0LnZlcnRleCwgZ3JvdXAubGF5b3V0LmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGdyb3VwLmxheW91dC5lbGVtZW50Lmxlbmd0aCAqIDMsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfZ2FtbWEsIGdhbW1hICogZ2FtbWFTY2FsZSk7XG4gICAgICAgIGdsLnVuaWZvcm00ZnYocHJvZ3JhbS51X2NvbG9yLCBjb2xvcik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfb3BhY2l0eSwgb3BhY2l0eSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfYnVmZmVyLCAoMjU2IC0gNjQpIC8gMjU2KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlckdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZ3JvdXAgPSBidWZmZXJHcm91cHNbaV07XG4gICAgICAgICAgICBncm91cC52YW9zW2xheWVyLmlkXS5iaW5kKGdsLCBwcm9ncmFtLCBncm91cC5sYXlvdXQudmVydGV4LCBncm91cC5sYXlvdXQuZWxlbWVudCk7XG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBncm91cC5sYXlvdXQuZWxlbWVudC5sZW5ndGggKiAzLCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfb3BhY2l0eSwgb3BhY2l0eSk7XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYnVmZmVyR3JvdXBzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBncm91cCA9IGJ1ZmZlckdyb3Vwc1trXTtcbiAgICAgICAgICAgIGdyb3VwLnZhb3NbbGF5ZXIuaWRdLmJpbmQoZ2wsIHByb2dyYW0sIGdyb3VwLmxheW91dC52ZXJ0ZXgsIGdyb3VwLmxheW91dC5lbGVtZW50KTtcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGdyb3VwLmxheW91dC5lbGVtZW50Lmxlbmd0aCAqIDMsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBGcmFtZUhpc3Rvcnk7XG5cbmZ1bmN0aW9uIEZyYW1lSGlzdG9yeSgpIHtcbiAgICB0aGlzLmNoYW5nZVRpbWVzID0gbmV3IEZsb2F0NjRBcnJheSgyNTYpO1xuICAgIHRoaXMuY2hhbmdlT3BhY2l0aWVzID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICB0aGlzLm9wYWNpdGllcyA9IG5ldyBVaW50OENsYW1wZWRBcnJheSgyNTYpO1xuICAgIHRoaXMuYXJyYXkgPSBuZXcgVWludDhBcnJheSh0aGlzLm9wYWNpdGllcy5idWZmZXIpO1xuXG4gICAgdGhpcy5mYWRlRHVyYXRpb24gPSAzMDA7XG4gICAgdGhpcy5wcmV2aW91c1pvb20gPSAwO1xuICAgIHRoaXMuZmlyc3RGcmFtZSA9IHRydWU7XG59XG5cbkZyYW1lSGlzdG9yeS5wcm90b3R5cGUucmVjb3JkID0gZnVuY3Rpb24oem9vbSkge1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgaWYgKHRoaXMuZmlyc3RGcmFtZSkge1xuICAgICAgICBub3cgPSAwO1xuICAgICAgICB0aGlzLmZpcnN0RnJhbWUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB6b29tID0gTWF0aC5mbG9vcih6b29tICogMTApO1xuXG4gICAgdmFyIHo7XG4gICAgaWYgKHpvb20gPCB0aGlzLnByZXZpb3VzWm9vbSkge1xuICAgICAgICBmb3IgKHogPSB6b29tICsgMTsgeiA8PSB0aGlzLnByZXZpb3VzWm9vbTsgeisrKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVRpbWVzW3pdID0gbm93O1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VPcGFjaXRpZXNbel0gPSB0aGlzLm9wYWNpdGllc1t6XTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoeiA9IHpvb207IHogPiB0aGlzLnByZXZpb3VzWm9vbTsgei0tKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVRpbWVzW3pdID0gbm93O1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VPcGFjaXRpZXNbel0gPSB0aGlzLm9wYWNpdGllc1t6XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoeiA9IDA7IHogPCAyNTY7IHorKykge1xuICAgICAgICB2YXIgdGltZVNpbmNlID0gbm93IC0gdGhpcy5jaGFuZ2VUaW1lc1t6XTtcbiAgICAgICAgdmFyIG9wYWNpdHlDaGFuZ2UgPSB0aW1lU2luY2UgLyB0aGlzLmZhZGVEdXJhdGlvbiAqIDI1NTtcbiAgICAgICAgaWYgKHogPD0gem9vbSkge1xuICAgICAgICAgICAgdGhpcy5vcGFjaXRpZXNbel0gPSB0aGlzLmNoYW5nZU9wYWNpdGllc1t6XSArIG9wYWNpdHlDaGFuZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wYWNpdGllc1t6XSA9IHRoaXMuY2hhbmdlT3BhY2l0aWVzW3pdIC0gb3BhY2l0eUNoYW5nZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgdGhpcy5wcmV2aW91c1pvb20gPSB6b29tO1xufTtcblxuRnJhbWVIaXN0b3J5LnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oZ2wpIHtcbiAgICBpZiAoIXRoaXMudGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuQUxQSEEsIDI1NiwgMSwgMCwgZ2wuQUxQSEEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuYXJyYXkpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgaWYgKHRoaXMuY2hhbmdlZCkge1xuICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCAyNTYsIDEsIGdsLkFMUEhBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLmFycmF5KTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lQXRsYXM7XG5cbi8qKlxuICogQSBMaW5lQXRsYXMgbGV0cyB1cyByZXVzZSByZW5kZXJlZCBkYXNoZWQgbGluZXNcbiAqIGJ5IHdyaXRpbmcgbWFueSBvZiB0aGVtIHRvIGEgdGV4dHVyZSBhbmQgdGhlbiBmZXRjaGluZyB0aGVpciBwb3NpdGlvbnNcbiAqIHVzaW5nIC5nZXREYXNoLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gTGluZUF0bGFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5uZXh0Um93ID0gMDtcblxuICAgIHRoaXMuYnl0ZXMgPSA0O1xuICAgIHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCAqIHRoaXMuYnl0ZXMpO1xuXG4gICAgdGhpcy5wb3NpdGlvbnMgPSB7fTtcbn1cblxuTGluZUF0bGFzLnByb3RvdHlwZS5zZXRTcHJpdGUgPSBmdW5jdGlvbihzcHJpdGUpIHtcbiAgICB0aGlzLnNwcml0ZSA9IHNwcml0ZTtcbn07XG5cbi8qKlxuICogR2V0IG9yIGNyZWF0ZSBhIGRhc2ggbGluZSBwYXR0ZXJuLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZGFzaGFycmF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJvdW5kIHdoZXRoZXIgdG8gYWRkIGNpcmNsZSBjYXBzIGluIGJldHdlZW4gZGFzaCBzZWdtZW50c1xuICogQHJldHVybnMge09iamVjdH0gcG9zaXRpb24gb2YgZGFzaCB0ZXh0dXJlIGluIHsgeSwgaGVpZ2h0LCB3aWR0aCB9XG4gKiBAcHJpdmF0ZVxuICovXG5MaW5lQXRsYXMucHJvdG90eXBlLmdldERhc2ggPSBmdW5jdGlvbihkYXNoYXJyYXksIHJvdW5kKSB7XG4gICAgdmFyIGtleSA9IGRhc2hhcnJheS5qb2luKFwiLFwiKSArIHJvdW5kO1xuXG4gICAgaWYgKCF0aGlzLnBvc2l0aW9uc1trZXldKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25zW2tleV0gPSB0aGlzLmFkZERhc2goZGFzaGFycmF5LCByb3VuZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uc1trZXldO1xufTtcblxuTGluZUF0bGFzLnByb3RvdHlwZS5hZGREYXNoID0gZnVuY3Rpb24oZGFzaGFycmF5LCByb3VuZCkge1xuXG4gICAgdmFyIG4gPSByb3VuZCA/IDcgOiAwO1xuICAgIHZhciBoZWlnaHQgPSAyICogbiArIDE7XG4gICAgdmFyIG9mZnNldCA9IDEyODtcblxuICAgIGlmICh0aGlzLm5leHRSb3cgKyBoZWlnaHQgPiB0aGlzLmhlaWdodCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0xpbmVBdGxhcyBvdXQgb2Ygc3BhY2UnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXNoYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoICs9IGRhc2hhcnJheVtpXTtcbiAgICB9XG5cbiAgICB2YXIgc3RyZXRjaCA9IHRoaXMud2lkdGggLyBsZW5ndGg7XG4gICAgdmFyIGhhbGZXaWR0aCA9IHN0cmV0Y2ggLyAyO1xuXG4gICAgLy8gSWYgZGFzaGFycmF5IGhhcyBhbiBvZGQgbGVuZ3RoLCBib3RoIHRoZSBmaXJzdCBhbmQgbGFzdCBwYXJ0c1xuICAgIC8vIGFyZSBkYXNoZXMgYW5kIHNob3VsZCBiZSBqb2luZWQgc2VhbWxlc3NseS5cbiAgICB2YXIgb2RkTGVuZ3RoID0gZGFzaGFycmF5Lmxlbmd0aCAlIDIgPT09IDE7XG5cbiAgICBmb3IgKHZhciB5ID0gLW47IHkgPD0gbjsgeSsrKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLm5leHRSb3cgKyBuICsgeTtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy53aWR0aCAqIHJvdztcblxuICAgICAgICB2YXIgbGVmdCA9IG9kZExlbmd0aCA/IC1kYXNoYXJyYXlbZGFzaGFycmF5Lmxlbmd0aCAtIDFdIDogMDtcbiAgICAgICAgdmFyIHJpZ2h0ID0gZGFzaGFycmF5WzBdO1xuICAgICAgICB2YXIgcGFydEluZGV4ID0gMTtcblxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMud2lkdGg7IHgrKykge1xuXG4gICAgICAgICAgICB3aGlsZSAocmlnaHQgPCB4IC8gc3RyZXRjaCkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0ICsgZGFzaGFycmF5W3BhcnRJbmRleF07XG5cbiAgICAgICAgICAgICAgICBpZiAob2RkTGVuZ3RoICYmIHBhcnRJbmRleCA9PT0gZGFzaGFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgKz0gZGFzaGFycmF5WzBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcnRJbmRleCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGlzdExlZnQgPSBNYXRoLmFicyh4IC0gbGVmdCAqIHN0cmV0Y2gpO1xuICAgICAgICAgICAgdmFyIGRpc3RSaWdodCA9IE1hdGguYWJzKHggLSByaWdodCAqIHN0cmV0Y2gpO1xuICAgICAgICAgICAgdmFyIGRpc3QgPSBNYXRoLm1pbihkaXN0TGVmdCwgZGlzdFJpZ2h0KTtcbiAgICAgICAgICAgIHZhciBpbnNpZGUgPSAocGFydEluZGV4ICUgMikgPT09IDE7XG4gICAgICAgICAgICB2YXIgc2lnbmVkRGlzdGFuY2U7XG5cbiAgICAgICAgICAgIGlmIChyb3VuZCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBjaXJjbGUgY2Fwc1xuICAgICAgICAgICAgICAgIHZhciBkaXN0TWlkZGxlID0gbiA/IHkgLyBuICogKGhhbGZXaWR0aCArIDEpIDogMDtcbiAgICAgICAgICAgICAgICBpZiAoaW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0RWRnZSA9IGhhbGZXaWR0aCAtIE1hdGguYWJzKGRpc3RNaWRkbGUpO1xuICAgICAgICAgICAgICAgICAgICBzaWduZWREaXN0YW5jZSA9IE1hdGguc3FydChkaXN0ICogZGlzdCArIGRpc3RFZGdlICogZGlzdEVkZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25lZERpc3RhbmNlID0gaGFsZldpZHRoIC0gTWF0aC5zcXJ0KGRpc3QgKiBkaXN0ICsgZGlzdE1pZGRsZSAqIGRpc3RNaWRkbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2lnbmVkRGlzdGFuY2UgPSAoaW5zaWRlID8gMSA6IC0xKSAqIGRpc3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YVszICsgKGluZGV4ICsgeCkgKiA0XSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgc2lnbmVkRGlzdGFuY2UgKyBvZmZzZXQpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwb3MgPSB7XG4gICAgICAgIHk6ICh0aGlzLm5leHRSb3cgKyBuICsgMC41KSAvIHRoaXMuaGVpZ2h0LFxuICAgICAgICBoZWlnaHQ6IDIgKiBuIC8gdGhpcy5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBsZW5ndGhcbiAgICB9O1xuXG4gICAgdGhpcy5uZXh0Um93ICs9IGhlaWdodDtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiBwb3M7XG59O1xuXG5MaW5lQXRsYXMucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihnbCkge1xuICAgIGlmICghdGhpcy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuUkVQRUFUKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuUkVQRUFUKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLmRhdGEpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcblxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgbWF0NCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDQ7XG52YXIgRnJhbWVIaXN0b3J5ID0gcmVxdWlyZSgnLi9mcmFtZV9oaXN0b3J5Jyk7XG52YXIgVGlsZVB5cmFtaWQgPSByZXF1aXJlKCcuLi9zb3VyY2UvdGlsZV9weXJhbWlkJyk7XG52YXIgRVhURU5UID0gcmVxdWlyZSgnLi4vZGF0YS9idWNrZXQnKS5FWFRFTlQ7XG52YXIgcGl4ZWxzVG9UaWxlVW5pdHMgPSByZXF1aXJlKCcuLi9zb3VyY2UvcGl4ZWxzX3RvX3RpbGVfdW5pdHMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgU3RydWN0QXJyYXlUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9zdHJ1Y3RfYXJyYXknKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuLi9kYXRhL2J1ZmZlcicpO1xudmFyIFZlcnRleEFycmF5T2JqZWN0ID0gcmVxdWlyZSgnLi92ZXJ0ZXhfYXJyYXlfb2JqZWN0Jyk7XG52YXIgUmFzdGVyQm91bmRzQXJyYXkgPSByZXF1aXJlKCcuL2RyYXdfcmFzdGVyJykuUmFzdGVyQm91bmRzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFpbnRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IHBhaW50ZXIgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Q2FudmFzfSBnbCBhbiBleHBlcmltZW50YWwtd2ViZ2wgZHJhd2luZyBjb250ZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBQYWludGVyKGdsLCB0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cbiAgICB0aGlzLnJldXNhYmxlVGV4dHVyZXMgPSB7fTtcbiAgICB0aGlzLnByZUZib3MgPSB7fTtcblxuICAgIHRoaXMuZnJhbWVIaXN0b3J5ID0gbmV3IEZyYW1lSGlzdG9yeSgpO1xuXG4gICAgdGhpcy5zZXR1cCgpO1xuXG4gICAgLy8gV2l0aGluIGVhY2ggbGF5ZXIgdGhlcmUgYXJlIG11bHRpcGxlIGRpc3RpbmN0IHotcGxhbmVzIHRoYXQgY2FuIGJlIGRyYXduIHRvLlxuICAgIC8vIFRoaXMgaXMgaW1wbGVtZW50ZWQgdXNpbmcgdGhlIFdlYkdMIGRlcHRoIGJ1ZmZlci5cbiAgICB0aGlzLm51bVN1YmxheWVycyA9IFRpbGVQeXJhbWlkLm1heFVuZGVyem9vbWluZyArIFRpbGVQeXJhbWlkLm1heE92ZXJ6b29taW5nICsgMTtcbiAgICB0aGlzLmRlcHRoRXBzaWxvbiA9IDEgLyBNYXRoLnBvdygyLCAxNik7XG5cbiAgICB0aGlzLmxpbmVXaWR0aFJhbmdlID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLkFMSUFTRURfTElORV9XSURUSF9SQU5HRSk7XG59XG5cbnV0aWwuZXh0ZW5kKFBhaW50ZXIucHJvdG90eXBlLCByZXF1aXJlKCcuL3BhaW50ZXIvdXNlX3Byb2dyYW0nKSk7XG5cbi8qXG4gKiBVcGRhdGUgdGhlIEdMIHZpZXdwb3J0LCBwcm9qZWN0aW9uIG1hdHJpeCwgYW5kIHRyYW5zZm9ybXMgdG8gY29tcGVuc2F0ZVxuICogZm9yIGEgbmV3IHdpZHRoIGFuZCBoZWlnaHQgdmFsdWUuXG4gKi9cblBhaW50ZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoICogYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxufTtcblxuUGFpbnRlci5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgZ2wudmVyYm9zZSA9IHRydWU7XG5cbiAgICAvLyBXZSBhcmUgYmxlbmRpbmcgdGhlIG5ldyBwaXhlbHMgKmJlaGluZCogdGhlIGV4aXN0aW5nIHBpeGVscy4gVGhhdCB3YXkgd2UgY2FuXG4gICAgLy8gZHJhdyBmcm9udC10by1iYWNrIGFuZCB1c2UgdGhlbiBzdGVuY2lsIGJ1ZmZlciB0byBjdWxsIG9wYXF1ZSBwaXhlbHMgZWFybHkuXG4gICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcblxuICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuXG4gICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgIGdsLmRlcHRoRnVuYyhnbC5MRVFVQUwpO1xuXG4gICAgdGhpcy5fZGVwdGhNYXNrID0gZmFsc2U7XG4gICAgZ2wuZGVwdGhNYXNrKGZhbHNlKTtcblxuICAgIHZhciBQb3NBcnJheSA9IHRoaXMuUG9zQXJyYXkgPSBuZXcgU3RydWN0QXJyYXlUeXBlKHtcbiAgICAgICAgbWVtYmVyczogW3sgbmFtZTogJ2FfcG9zJywgdHlwZTogJ0ludDE2JywgY29tcG9uZW50czogMiB9XVxuICAgIH0pO1xuXG4gICAgdmFyIHRpbGVFeHRlbnRBcnJheSA9IG5ldyBQb3NBcnJheSgpO1xuICAgIHRpbGVFeHRlbnRBcnJheS5lbXBsYWNlQmFjaygwLCAwKTtcbiAgICB0aWxlRXh0ZW50QXJyYXkuZW1wbGFjZUJhY2soRVhURU5ULCAwKTtcbiAgICB0aWxlRXh0ZW50QXJyYXkuZW1wbGFjZUJhY2soMCwgRVhURU5UKTtcbiAgICB0aWxlRXh0ZW50QXJyYXkuZW1wbGFjZUJhY2soRVhURU5ULCBFWFRFTlQpO1xuICAgIHRoaXMudGlsZUV4dGVudEJ1ZmZlciA9IG5ldyBCdWZmZXIodGlsZUV4dGVudEFycmF5LnNlcmlhbGl6ZSgpLCBQb3NBcnJheS5zZXJpYWxpemUoKSwgQnVmZmVyLkJ1ZmZlclR5cGUuVkVSVEVYKTtcbiAgICB0aGlzLnRpbGVFeHRlbnRWQU8gPSBuZXcgVmVydGV4QXJyYXlPYmplY3QoKTtcbiAgICB0aGlzLnRpbGVFeHRlbnRQYXR0ZXJuVkFPID0gbmV3IFZlcnRleEFycmF5T2JqZWN0KCk7XG5cbiAgICB2YXIgZGVidWdBcnJheSA9IG5ldyBQb3NBcnJheSgpO1xuICAgIGRlYnVnQXJyYXkuZW1wbGFjZUJhY2soMCwgMCk7XG4gICAgZGVidWdBcnJheS5lbXBsYWNlQmFjayhFWFRFTlQsIDApO1xuICAgIGRlYnVnQXJyYXkuZW1wbGFjZUJhY2soRVhURU5ULCBFWFRFTlQpO1xuICAgIGRlYnVnQXJyYXkuZW1wbGFjZUJhY2soMCwgRVhURU5UKTtcbiAgICBkZWJ1Z0FycmF5LmVtcGxhY2VCYWNrKDAsIDApO1xuICAgIHRoaXMuZGVidWdCdWZmZXIgPSBuZXcgQnVmZmVyKGRlYnVnQXJyYXkuc2VyaWFsaXplKCksIFBvc0FycmF5LnNlcmlhbGl6ZSgpLCBCdWZmZXIuQnVmZmVyVHlwZS5WRVJURVgpO1xuICAgIHRoaXMuZGVidWdWQU8gPSBuZXcgVmVydGV4QXJyYXlPYmplY3QoKTtcblxuICAgIHZhciByYXN0ZXJCb3VuZHNBcnJheSA9IG5ldyBSYXN0ZXJCb3VuZHNBcnJheSgpO1xuICAgIHJhc3RlckJvdW5kc0FycmF5LmVtcGxhY2VCYWNrKDAsIDAsIDAsIDApO1xuICAgIHJhc3RlckJvdW5kc0FycmF5LmVtcGxhY2VCYWNrKEVYVEVOVCwgMCwgMzI3NjcsIDApO1xuICAgIHJhc3RlckJvdW5kc0FycmF5LmVtcGxhY2VCYWNrKDAsIEVYVEVOVCwgMCwgMzI3NjcpO1xuICAgIHJhc3RlckJvdW5kc0FycmF5LmVtcGxhY2VCYWNrKEVYVEVOVCwgRVhURU5ULCAzMjc2NywgMzI3NjcpO1xuICAgIHRoaXMucmFzdGVyQm91bmRzQnVmZmVyID0gbmV3IEJ1ZmZlcihyYXN0ZXJCb3VuZHNBcnJheS5zZXJpYWxpemUoKSwgUmFzdGVyQm91bmRzQXJyYXkuc2VyaWFsaXplKCksIEJ1ZmZlci5CdWZmZXJUeXBlLlZFUlRFWCk7XG4gICAgdGhpcy5yYXN0ZXJCb3VuZHNWQU8gPSBuZXcgVmVydGV4QXJyYXlPYmplY3QoKTtcbn07XG5cbi8qXG4gKiBSZXNldCB0aGUgY29sb3IgYnVmZmVycyBvZiB0aGUgZHJhd2luZyBjYW52YXMuXG4gKi9cblBhaW50ZXIucHJvdG90eXBlLmNsZWFyQ29sb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG59O1xuXG4vKlxuICogUmVzZXQgdGhlIGRyYXdpbmcgY2FudmFzIGJ5IGNsZWFyaW5nIHRoZSBzdGVuY2lsIGJ1ZmZlciBzbyB0aGF0IHdlIGNhbiBkcmF3XG4gKiBuZXcgdGlsZXMgYXQgdGhlIHNhbWUgbG9jYXRpb24sIHdoaWxlIHJldGFpbmluZyBwcmV2aW91c2x5IGRyYXduIHBpeGVscy5cbiAqL1xuUGFpbnRlci5wcm90b3R5cGUuY2xlYXJTdGVuY2lsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5jbGVhclN0ZW5jaWwoMHgwKTtcbiAgICBnbC5zdGVuY2lsTWFzaygweEZGKTtcbiAgICBnbC5jbGVhcihnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xufTtcblxuUGFpbnRlci5wcm90b3R5cGUuY2xlYXJEZXB0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuY2xlYXJEZXB0aCgxKTtcbiAgICB0aGlzLmRlcHRoTWFzayh0cnVlKTtcbiAgICBnbC5jbGVhcihnbC5ERVBUSF9CVUZGRVJfQklUKTtcbn07XG5cblBhaW50ZXIucHJvdG90eXBlLl9yZW5kZXJUaWxlQ2xpcHBpbmdNYXNrcyA9IGZ1bmN0aW9uKGNvb3Jkcykge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgICB0aGlzLmRlcHRoTWFzayhmYWxzZSk7XG4gICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcblxuICAgIC8vIE9ubHkgd3JpdGUgY2xpcHBpbmcgSURzIHRvIHRoZSBsYXN0IDUgYml0cy4gVGhlIGZpcnN0IHRocmVlIGFyZSB1c2VkIGZvciBkcmF3aW5nIGZpbGxzLlxuICAgIGdsLnN0ZW5jaWxNYXNrKDB4RjgpO1xuICAgIC8vIFRlc3RzIHdpbGwgYWx3YXlzIHBhc3MsIGFuZCByZWYgdmFsdWUgd2lsbCBiZSB3cml0dGVuIHRvIHN0ZW5jaWwgYnVmZmVyLlxuICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5SRVBMQUNFKTtcblxuICAgIHZhciBpZE5leHQgPSAxO1xuICAgIHRoaXMuX3RpbGVDbGlwcGluZ01hc2tJRHMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29vcmQgPSBjb29yZHNbaV07XG4gICAgICAgIHZhciBpZCA9IHRoaXMuX3RpbGVDbGlwcGluZ01hc2tJRHNbY29vcmQuaWRdID0gKGlkTmV4dCsrKSA8PCAzO1xuXG4gICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkFMV0FZUywgaWQsIDB4RjgpO1xuXG4gICAgICAgIHZhciBwcm9ncmFtID0gdGhpcy51c2VQcm9ncmFtKCdmaWxsJyk7XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYocHJvZ3JhbS51X21hdHJpeCwgZmFsc2UsIGNvb3JkLnBvc01hdHJpeCk7XG5cbiAgICAgICAgLy8gRHJhdyB0aGUgY2xpcHBpbmcgbWFza1xuICAgICAgICB0aGlzLnRpbGVFeHRlbnRWQU8uYmluZChnbCwgcHJvZ3JhbSwgdGhpcy50aWxlRXh0ZW50QnVmZmVyKTtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgdGhpcy50aWxlRXh0ZW50QnVmZmVyLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgZ2wuc3RlbmNpbE1hc2soMHgwMCk7XG4gICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuICAgIHRoaXMuZGVwdGhNYXNrKHRydWUpO1xuICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbn07XG5cblBhaW50ZXIucHJvdG90eXBlLmVuYWJsZVRpbGVDbGlwcGluZ01hc2sgPSBmdW5jdGlvbihjb29yZCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIHRoaXMuX3RpbGVDbGlwcGluZ01hc2tJRHNbY29vcmQuaWRdLCAweEY4KTtcbn07XG5cbi8vIE92ZXJyaWRkZW4gYnkgaGVhZGxlc3MgdGVzdHMuXG5QYWludGVyLnByb3RvdHlwZS5wcmVwYXJlQnVmZmVycyA9IGZ1bmN0aW9uKCkge307XG5QYWludGVyLnByb3RvdHlwZS5iaW5kRGVmYXVsdEZyYW1lYnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xufTtcblxudmFyIGRyYXcgPSB7XG4gICAgc3ltYm9sOiByZXF1aXJlKCcuL2RyYXdfc3ltYm9sJyksXG4gICAgY2lyY2xlOiByZXF1aXJlKCcuL2RyYXdfY2lyY2xlJyksXG4gICAgbGluZTogcmVxdWlyZSgnLi9kcmF3X2xpbmUnKSxcbiAgICBmaWxsOiByZXF1aXJlKCcuL2RyYXdfZmlsbCcpLFxuICAgIHJhc3RlcjogcmVxdWlyZSgnLi9kcmF3X3Jhc3RlcicpLFxuICAgIGJhY2tncm91bmQ6IHJlcXVpcmUoJy4vZHJhd19iYWNrZ3JvdW5kJyksXG4gICAgZGVidWc6IHJlcXVpcmUoJy4vZHJhd19kZWJ1ZycpXG59O1xuXG5QYWludGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdGhpcy5saW5lQXRsYXMgPSBzdHlsZS5saW5lQXRsYXM7XG5cbiAgICB0aGlzLnNwcml0ZUF0bGFzID0gc3R5bGUuc3ByaXRlQXRsYXM7XG4gICAgdGhpcy5zcHJpdGVBdGxhcy5zZXRTcHJpdGUoc3R5bGUuc3ByaXRlKTtcblxuICAgIHRoaXMuZ2x5cGhTb3VyY2UgPSBzdHlsZS5nbHlwaFNvdXJjZTtcblxuICAgIHRoaXMuZnJhbWVIaXN0b3J5LnJlY29yZCh0aGlzLnRyYW5zZm9ybS56b29tKTtcblxuICAgIHRoaXMucHJlcGFyZUJ1ZmZlcnMoKTtcbiAgICB0aGlzLmNsZWFyQ29sb3IoKTtcbiAgICB0aGlzLmNsZWFyRGVwdGgoKTtcblxuICAgIHRoaXMuc2hvd092ZXJkcmF3SW5zcGVjdG9yKG9wdGlvbnMuc2hvd092ZXJkcmF3SW5zcGVjdG9yKTtcblxuICAgIHRoaXMuZGVwdGhSYW5nZSA9IChzdHlsZS5fb3JkZXIubGVuZ3RoICsgMikgKiB0aGlzLm51bVN1YmxheWVycyAqIHRoaXMuZGVwdGhFcHNpbG9uO1xuXG4gICAgdGhpcy5yZW5kZXJQYXNzKHtpc09wYXF1ZVBhc3M6IHRydWV9KTtcbiAgICB0aGlzLnJlbmRlclBhc3Moe2lzT3BhcXVlUGFzczogZmFsc2V9KTtcbn07XG5cblBhaW50ZXIucHJvdG90eXBlLnJlbmRlclBhc3MgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGdyb3VwcyA9IHRoaXMuc3R5bGUuX2dyb3VwcztcbiAgICB2YXIgaXNPcGFxdWVQYXNzID0gb3B0aW9ucy5pc09wYXF1ZVBhc3M7XG4gICAgdGhpcy5jdXJyZW50TGF5ZXIgPSBpc09wYXF1ZVBhc3MgPyB0aGlzLnN0eWxlLl9vcmRlci5sZW5ndGggOiAtMTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1tpc09wYXF1ZVBhc3MgPyBncm91cHMubGVuZ3RoIC0gMSAtIGkgOiBpXTtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc3R5bGUuc291cmNlc1tncm91cC5zb3VyY2VdO1xuXG4gICAgICAgIHZhciBqO1xuICAgICAgICB2YXIgY29vcmRzID0gW107XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGNvb3JkcyA9IHNvdXJjZS5nZXRWaXNpYmxlQ29vcmRpbmF0ZXMoKTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb29yZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb29yZHNbal0ucG9zTWF0cml4ID0gdGhpcy50cmFuc2Zvcm0uY2FsY3VsYXRlUG9zTWF0cml4KGNvb3Jkc1tqXSwgc291cmNlLm1heHpvb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGVhclN0ZW5jaWwoKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UucHJlcGFyZSkgc291cmNlLnByZXBhcmUoKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaXNUaWxlQ2xpcHBlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclRpbGVDbGlwcGluZ01hc2tzKGNvb3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNPcGFxdWVQYXNzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3Nob3dPdmVyZHJhd0luc3BlY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2wuZGlzYWJsZSh0aGlzLmdsLkJMRU5EKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNPcGFxdWVQYXNzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuQkxFTkQpO1xuICAgICAgICAgICAgdGhpcy5pc09wYXF1ZVBhc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvb3Jkcy5yZXZlcnNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ3JvdXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IGdyb3VwW2lzT3BhcXVlUGFzcyA/IGdyb3VwLmxlbmd0aCAtIDEgLSBqIDogal07XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRMYXllciArPSBpc09wYXF1ZVBhc3MgPyAtMSA6IDE7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckxheWVyKHRoaXMsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBkcmF3LmRlYnVnKHRoaXMsIHNvdXJjZSwgY29vcmRzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblBhaW50ZXIucHJvdG90eXBlLmRlcHRoTWFzayA9IGZ1bmN0aW9uKG1hc2spIHtcbiAgICBpZiAobWFzayAhPT0gdGhpcy5fZGVwdGhNYXNrKSB7XG4gICAgICAgIHRoaXMuX2RlcHRoTWFzayA9IG1hc2s7XG4gICAgICAgIHRoaXMuZ2wuZGVwdGhNYXNrKG1hc2spO1xuICAgIH1cbn07XG5cblBhaW50ZXIucHJvdG90eXBlLnJlbmRlckxheWVyID0gZnVuY3Rpb24ocGFpbnRlciwgc291cmNlLCBsYXllciwgY29vcmRzKSB7XG4gICAgaWYgKGxheWVyLmlzSGlkZGVuKHRoaXMudHJhbnNmb3JtLnpvb20pKSByZXR1cm47XG4gICAgaWYgKGxheWVyLnR5cGUgIT09ICdiYWNrZ3JvdW5kJyAmJiAhY29vcmRzLmxlbmd0aCkgcmV0dXJuO1xuICAgIHRoaXMuaWQgPSBsYXllci5pZDtcbiAgICBkcmF3W2xheWVyLnR5cGVdKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkcyk7XG59O1xuXG5QYWludGVyLnByb3RvdHlwZS5zZXREZXB0aFN1YmxheWVyID0gZnVuY3Rpb24obikge1xuICAgIHZhciBmYXJEZXB0aCA9IDEgLSAoKDEgKyB0aGlzLmN1cnJlbnRMYXllcikgKiB0aGlzLm51bVN1YmxheWVycyArIG4pICogdGhpcy5kZXB0aEVwc2lsb247XG4gICAgdmFyIG5lYXJEZXB0aCA9IGZhckRlcHRoIC0gMSArIHRoaXMuZGVwdGhSYW5nZTtcbiAgICB0aGlzLmdsLmRlcHRoUmFuZ2UobmVhckRlcHRoLCBmYXJEZXB0aCk7XG59O1xuXG5QYWludGVyLnByb3RvdHlwZS50cmFuc2xhdGVQb3NNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgsIHRpbGUsIHRyYW5zbGF0ZSwgYW5jaG9yKSB7XG4gICAgaWYgKCF0cmFuc2xhdGVbMF0gJiYgIXRyYW5zbGF0ZVsxXSkgcmV0dXJuIG1hdHJpeDtcblxuICAgIGlmIChhbmNob3IgPT09ICd2aWV3cG9ydCcpIHtcbiAgICAgICAgdmFyIHNpbkEgPSBNYXRoLnNpbigtdGhpcy50cmFuc2Zvcm0uYW5nbGUpO1xuICAgICAgICB2YXIgY29zQSA9IE1hdGguY29zKC10aGlzLnRyYW5zZm9ybS5hbmdsZSk7XG4gICAgICAgIHRyYW5zbGF0ZSA9IFtcbiAgICAgICAgICAgIHRyYW5zbGF0ZVswXSAqIGNvc0EgLSB0cmFuc2xhdGVbMV0gKiBzaW5BLFxuICAgICAgICAgICAgdHJhbnNsYXRlWzBdICogc2luQSArIHRyYW5zbGF0ZVsxXSAqIGNvc0FcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNsYXRpb24gPSBbXG4gICAgICAgIHBpeGVsc1RvVGlsZVVuaXRzKHRpbGUsIHRyYW5zbGF0ZVswXSwgdGhpcy50cmFuc2Zvcm0uem9vbSksXG4gICAgICAgIHBpeGVsc1RvVGlsZVVuaXRzKHRpbGUsIHRyYW5zbGF0ZVsxXSwgdGhpcy50cmFuc2Zvcm0uem9vbSksXG4gICAgICAgIDBcbiAgICBdO1xuXG4gICAgdmFyIHRyYW5zbGF0ZWRNYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICBtYXQ0LnRyYW5zbGF0ZSh0cmFuc2xhdGVkTWF0cml4LCBtYXRyaXgsIHRyYW5zbGF0aW9uKTtcbiAgICByZXR1cm4gdHJhbnNsYXRlZE1hdHJpeDtcbn07XG5cblBhaW50ZXIucHJvdG90eXBlLnNhdmVUZXh0dXJlID0gZnVuY3Rpb24odGV4dHVyZSkge1xuICAgIHZhciB0ZXh0dXJlcyA9IHRoaXMucmV1c2FibGVUZXh0dXJlc1t0ZXh0dXJlLnNpemVdO1xuICAgIGlmICghdGV4dHVyZXMpIHtcbiAgICAgICAgdGhpcy5yZXVzYWJsZVRleHR1cmVzW3RleHR1cmUuc2l6ZV0gPSBbdGV4dHVyZV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dHVyZXMucHVzaCh0ZXh0dXJlKTtcbiAgICB9XG59O1xuXG5cblBhaW50ZXIucHJvdG90eXBlLmdldFRleHR1cmUgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdmFyIHRleHR1cmVzID0gdGhpcy5yZXVzYWJsZVRleHR1cmVzW3NpemVdO1xuICAgIHJldHVybiB0ZXh0dXJlcyAmJiB0ZXh0dXJlcy5sZW5ndGggPiAwID8gdGV4dHVyZXMucG9wKCkgOiBudWxsO1xufTtcblxuUGFpbnRlci5wcm90b3R5cGUubGluZVdpZHRoID0gZnVuY3Rpb24od2lkdGgpIHtcbiAgICB0aGlzLmdsLmxpbmVXaWR0aCh1dGlsLmNsYW1wKHdpZHRoLCB0aGlzLmxpbmVXaWR0aFJhbmdlWzBdLCB0aGlzLmxpbmVXaWR0aFJhbmdlWzFdKSk7XG59O1xuXG5QYWludGVyLnByb3RvdHlwZS5zaG93T3ZlcmRyYXdJbnNwZWN0b3IgPSBmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgaWYgKCFlbmFibGVkICYmICF0aGlzLl9zaG93T3ZlcmRyYXdJbnNwZWN0b3IpIHJldHVybjtcbiAgICB0aGlzLl9zaG93T3ZlcmRyYXdJbnNwZWN0b3IgPSBlbmFibGVkO1xuXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuQ09OU1RBTlRfQ09MT1IsIGdsLk9ORSk7XG4gICAgICAgIHZhciBudW1PdmVyZHJhd1N0ZXBzID0gODtcbiAgICAgICAgdmFyIGEgPSAxIC8gbnVtT3ZlcmRyYXdTdGVwcztcbiAgICAgICAgZ2wuYmxlbmRDb2xvcihhLCBhLCBhLCAwKTtcbiAgICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAxKTtcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG5cbi8vIHJlYWRGaWxlU3luYyBjYWxscyBtdXN0IGJlIHdyaXR0ZW4gb3V0IGxvbmctZm9ybSBmb3IgYnJmcy5cbnZhciBkZWZpbml0aW9ucyA9IHtcbiAgICBkZWJ1Zzoge1xuICAgICAgICBmcmFnbWVudFNvdXJjZTogXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG51bmlmb3JtIGxvd3AgdmVjNCB1X2NvbG9yO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdV9jb2xvcjtcXG59XFxuXCIsXG4gICAgICAgIHZlcnRleFNvdXJjZTogXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuXFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoYV9wb3MsIHN0ZXAoMzI3NjcuMCwgYV9wb3MueCksIDEpO1xcbn1cXG5cIlxuICAgIH0sXG4gICAgZmlsbDoge1xuICAgICAgICBmcmFnbWVudFNvdXJjZTogXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG51bmlmb3JtIGxvd3AgdmVjNCB1X2NvbG9yO1xcbnVuaWZvcm0gbG93cCBmbG9hdCB1X29wYWNpdHk7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB1X2NvbG9yICogdV9vcGFjaXR5O1xcblxcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cXG5cIixcbiAgICAgICAgdmVydGV4U291cmNlOiBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3BvcywgMCwgMSk7XFxufVxcblwiXG4gICAgfSxcbiAgICBjaXJjbGU6IHtcbiAgICAgICAgZnJhZ21lbnRTb3VyY2U6IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudW5pZm9ybSBsb3dwIGZsb2F0IHVfYmx1cjtcXG51bmlmb3JtIGxvd3AgZmxvYXQgdV9vcGFjaXR5O1xcblxcbnZhcnlpbmcgbG93cCB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyB2ZWMyIHZfZXh0cnVkZTtcXG52YXJ5aW5nIGxvd3AgZmxvYXQgdl9hbnRpYWxpYXNibHVyO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZmxvYXQgdCA9IHNtb290aHN0ZXAoMS4wIC0gbWF4KHVfYmx1ciwgdl9hbnRpYWxpYXNibHVyKSwgMS4wLCBsZW5ndGgodl9leHRydWRlKSk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZfY29sb3IgKiAoMS4wIC0gdCkgKiB1X29wYWNpdHk7XFxuXFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVxcblwiLFxuICAgICAgICB2ZXJ0ZXhTb3VyY2U6IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIHZlYzIgdV9leHRydWRlX3NjYWxlO1xcbnVuaWZvcm0gZmxvYXQgdV9kZXZpY2VwaXhlbHJhdGlvO1xcblxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcblxcbiNpZmRlZiBBVFRSSUJVVEVfQV9DT0xPUlxcbmF0dHJpYnV0ZSBsb3dwIHZlYzQgYV9jb2xvcjtcXG4jZWxpZiBkZWZpbmVkIEFUVFJJQlVURV9aT09NX0ZVTkNUSU9OX0FfQ09MT1IwXFxudW5pZm9ybSBsb3dwIGZsb2F0IHVfY29sb3JfdDtcXG5hdHRyaWJ1dGUgbG93cCB2ZWM0IGFfY29sb3IwO1xcbmF0dHJpYnV0ZSBsb3dwIHZlYzQgYV9jb2xvcjE7XFxuYXR0cmlidXRlIGxvd3AgdmVjNCBhX2NvbG9yMjtcXG5hdHRyaWJ1dGUgbG93cCB2ZWM0IGFfY29sb3IzO1xcbiNlbHNlXFxudW5pZm9ybSBsb3dwIHZlYzQgYV9jb2xvcjtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgQVRUUklCVVRFX0FfUkFESVVTXFxuYXR0cmlidXRlIG1lZGl1bXAgZmxvYXQgYV9yYWRpdXM7XFxuI2VsaWYgZGVmaW5lZCBBVFRSSUJVVEVfWk9PTV9GVU5DVElPTl9BX1JBRElVU1xcbnVuaWZvcm0gbG93cCBmbG9hdCB1X3JhZGl1c190O1xcbmF0dHJpYnV0ZSBtZWRpdW1wIHZlYzQgYV9yYWRpdXM7XFxuI2Vsc2VcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgYV9yYWRpdXM7XFxuI2VuZGlmXFxuXFxudmFyeWluZyB2ZWMyIHZfZXh0cnVkZTtcXG52YXJ5aW5nIGxvd3AgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgbG93cCBmbG9hdCB2X2FudGlhbGlhc2JsdXI7XFxuXFxuZmxvYXQgZXZhbHVhdGVfem9vbV9mdW5jdGlvbl8xKGNvbnN0IHZlYzQgdmFsdWVzLCBjb25zdCBmbG9hdCB0KSB7XFxuICAgIGlmICh0IDwgMS4wKSB7XFxuICAgICAgICByZXR1cm4gbWl4KHZhbHVlc1swXSwgdmFsdWVzWzFdLCB0KTtcXG4gICAgfSBlbHNlIGlmICh0IDwgMi4wKSB7XFxuICAgICAgICByZXR1cm4gbWl4KHZhbHVlc1sxXSwgdmFsdWVzWzJdLCB0IC0gMS4wKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBtaXgodmFsdWVzWzJdLCB2YWx1ZXNbM10sIHQgLSAyLjApO1xcbiAgICB9XFxufVxcblxcbnZlYzQgZXZhbHVhdGVfem9vbV9mdW5jdGlvbl80KGNvbnN0IHZlYzQgdmFsdWUwLCBjb25zdCB2ZWM0IHZhbHVlMSwgY29uc3QgdmVjNCB2YWx1ZTIsIGNvbnN0IHZlYzQgdmFsdWUzLCBjb25zdCBmbG9hdCB0KSB7XFxuICAgIGlmICh0IDwgMS4wKSB7XFxuICAgICAgICByZXR1cm4gbWl4KHZhbHVlMCwgdmFsdWUxLCB0KTtcXG4gICAgfSBlbHNlIGlmICh0IDwgMi4wKSB7XFxuICAgICAgICByZXR1cm4gbWl4KHZhbHVlMSwgdmFsdWUyLCB0IC0gMS4wKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBtaXgodmFsdWUyLCB2YWx1ZTMsIHQgLSAyLjApO1xcbiAgICB9XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFxuI2lmZGVmIEFUVFJJQlVURV9BX1JBRElVU1xcbiAgICBtZWRpdW1wIGZsb2F0IHJhZGl1cyA9IGFfcmFkaXVzIC8gMTAuMDtcXG4jZWxpZiBkZWZpbmVkIEFUVFJJQlVURV9aT09NX0ZVTkNUSU9OX0FfUkFESVVTXFxuICAgIG1lZGl1bXAgZmxvYXQgcmFkaXVzID0gZXZhbHVhdGVfem9vbV9mdW5jdGlvbl8xKGFfcmFkaXVzLCB1X3JhZGl1c190KSAvIDEwLjA7XFxuI2Vsc2VcXG4gICAgbWVkaXVtcCBmbG9hdCByYWRpdXMgPSBhX3JhZGl1cztcXG4jZW5kaWZcXG5cXG4gICAgLy8gdW5lbmNvZGUgdGhlIGV4dHJ1c2lvbiB2ZWN0b3IgdGhhdCB3ZSBzbnVjayBpbnRvIHRoZSBhX3BvcyB2ZWN0b3JcXG4gICAgdl9leHRydWRlID0gdmVjMihtb2QoYV9wb3MsIDIuMCkgKiAyLjAgLSAxLjApO1xcblxcbiAgICB2ZWMyIGV4dHJ1ZGUgPSB2X2V4dHJ1ZGUgKiByYWRpdXMgKiB1X2V4dHJ1ZGVfc2NhbGU7XFxuICAgIC8vIG11bHRpcGx5IGFfcG9zIGJ5IDAuNSwgc2luY2Ugd2UgaGFkIGl0ICogMiBpbiBvcmRlciB0byBzbmVha1xcbiAgICAvLyBpbiBleHRydXNpb24gZGF0YVxcbiAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChmbG9vcihhX3BvcyAqIDAuNSksIDAsIDEpO1xcblxcbiAgICAvLyBnbF9Qb3NpdGlvbiBpcyBkaXZpZGVkIGJ5IGdsX1Bvc2l0aW9uLncgYWZ0ZXIgdGhpcyBzaGFkZXIgcnVucy5cXG4gICAgLy8gTXVsdGlwbHkgdGhlIGV4dHJ1ZGUgYnkgaXQgc28gdGhhdCBpdCBpc24ndCBhZmZlY3RlZCBieSBpdC5cXG4gICAgZ2xfUG9zaXRpb24ueHkgKz0gZXh0cnVkZSAqIGdsX1Bvc2l0aW9uLnc7XFxuXFxuI2lmZGVmIEFUVFJJQlVURV9BX0NPTE9SXFxuICAgIHZfY29sb3IgPSBhX2NvbG9yIC8gMjU1LjA7XFxuI2VsaWYgZGVmaW5lZCBBVFRSSUJVVEVfWk9PTV9GVU5DVElPTl9BX0NPTE9SMFxcbiAgICB2X2NvbG9yID0gZXZhbHVhdGVfem9vbV9mdW5jdGlvbl80KGFfY29sb3IwLCBhX2NvbG9yMSwgYV9jb2xvcjIsIGFfY29sb3IzLCB1X2NvbG9yX3QpIC8gMjU1LjA7XFxuI2Vsc2VcXG4gICAgdl9jb2xvciA9IGFfY29sb3I7XFxuI2VuZGlmXFxuXFxuICAgIC8vIFRoaXMgaXMgYSBtaW5pbXVtIGJsdXIgZGlzdGFuY2UgdGhhdCBzZXJ2ZXMgYXMgYSBmYXV4LWFudGlhbGlhc2luZyBmb3JcXG4gICAgLy8gdGhlIGNpcmNsZS4gc2luY2UgYmx1ciBpcyBhIHJhdGlvIG9mIHRoZSBjaXJjbGUncyBzaXplIGFuZCB0aGUgaW50ZW50IGlzXFxuICAgIC8vIHRvIGtlZXAgdGhlIGJsdXIgYXQgcm91Z2hseSAxcHgsIHRoZSB0d28gYXJlIGludmVyc2VseSByZWxhdGVkLlxcbiAgICB2X2FudGlhbGlhc2JsdXIgPSAxLjAgLyB1X2RldmljZXBpeGVscmF0aW8gLyByYWRpdXM7XFxufVxcblwiXG4gICAgfSxcbiAgICBsaW5lOiB7XG4gICAgICAgIGZyYWdtZW50U291cmNlOiBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnVuaWZvcm0gdmVjMiB1X2xpbmV3aWR0aDtcXG51bmlmb3JtIGxvd3AgdmVjNCB1X2NvbG9yO1xcbnVuaWZvcm0gbG93cCBmbG9hdCB1X29wYWNpdHk7XFxudW5pZm9ybSBmbG9hdCB1X2JsdXI7XFxuXFxudmFyeWluZyB2ZWMyIHZfbm9ybWFsO1xcbnZhcnlpbmcgZmxvYXQgdl9saW5lc29mYXI7XFxudmFyeWluZyBmbG9hdCB2X2dhbW1hX3NjYWxlO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBvZiB0aGUgcGl4ZWwgZnJvbSB0aGUgbGluZSBpbiBwaXhlbHMuXFxuICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgodl9ub3JtYWwpICogdV9saW5ld2lkdGgucztcXG5cXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBhbnRpYWxpYXNpbmcgZmFkZSBmYWN0b3IuIFRoaXMgaXMgZWl0aGVyIHdoZW4gZmFkaW5nIGluXFxuICAgIC8vIHRoZSBsaW5lIGluIGNhc2Ugb2YgYW4gb2Zmc2V0IGxpbmUgKHZfbGluZXdpZHRoLnQpIG9yIHdoZW4gZmFkaW5nIG91dFxcbiAgICAvLyAodl9saW5ld2lkdGgucylcXG4gICAgZmxvYXQgYmx1ciA9IHVfYmx1ciAqIHZfZ2FtbWFfc2NhbGU7XFxuICAgIGZsb2F0IGFscGhhID0gY2xhbXAobWluKGRpc3QgLSAodV9saW5ld2lkdGgudCAtIGJsdXIpLCB1X2xpbmV3aWR0aC5zIC0gZGlzdCkgLyBibHVyLCAwLjAsIDEuMCk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHVfY29sb3IgKiAoYWxwaGEgKiB1X29wYWNpdHkpO1xcblxcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cXG5cIixcbiAgICAgICAgdmVydGV4U291cmNlOiBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXG4vLyBmbG9vcigxMjcgLyAyKSA9PSA2My4wXFxuLy8gdGhlIG1heGltdW0gYWxsb3dlZCBtaXRlciBsaW1pdCBpcyAyLjAgYXQgdGhlIG1vbWVudC4gdGhlIGV4dHJ1ZGUgbm9ybWFsIGlzXFxuLy8gc3RvcmVkIGluIGEgYnl0ZSAoLTEyOC4uMTI3KS4gd2Ugc2NhbGUgcmVndWxhciBub3JtYWxzIHVwIHRvIGxlbmd0aCA2MywgYnV0XFxuLy8gdGhlcmUgYXJlIGFsc28gXFxcInNwZWNpYWxcXFwiIG5vcm1hbHMgdGhhdCBoYXZlIGEgYmlnZ2VyIGxlbmd0aCAob2YgdXAgdG8gMTI2IGluXFxuLy8gdGhpcyBjYXNlKS5cXG4vLyAjZGVmaW5lIHNjYWxlIDYzLjBcXG4jZGVmaW5lIHNjYWxlIDAuMDE1ODczMDE2XFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzQgYV9kYXRhO1xcblxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfcmF0aW87XFxudW5pZm9ybSBtZWRpdW1wIHZlYzIgdV9saW5ld2lkdGg7XFxudW5pZm9ybSBmbG9hdCB1X2V4dHJhO1xcbnVuaWZvcm0gbWF0MiB1X2FudGlhbGlhc2luZ21hdHJpeDtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9vZmZzZXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZfbm9ybWFsO1xcbnZhcnlpbmcgZmxvYXQgdl9saW5lc29mYXI7XFxudmFyeWluZyBmbG9hdCB2X2dhbW1hX3NjYWxlO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjMiBhX2V4dHJ1ZGUgPSBhX2RhdGEueHkgLSAxMjguMDtcXG4gICAgZmxvYXQgYV9kaXJlY3Rpb24gPSBtb2QoYV9kYXRhLnosIDQuMCkgLSAxLjA7XFxuXFxuICAgIC8vIFdlIHN0b3JlIHRoZSB0ZXh0dXJlIG5vcm1hbHMgaW4gdGhlIG1vc3QgaW5zaWduaWZpY2FudCBiaXRcXG4gICAgLy8gdHJhbnNmb3JtIHkgc28gdGhhdCAwID0+IC0xIGFuZCAxID0+IDFcXG4gICAgLy8gSW4gdGhlIHRleHR1cmUgbm9ybWFsLCB4IGlzIDAgaWYgdGhlIG5vcm1hbCBwb2ludHMgc3RyYWlnaHQgdXAvZG93biBhbmQgMSBpZiBpdCdzIGEgcm91bmQgY2FwXFxuICAgIC8vIHkgaXMgMSBpZiB0aGUgbm9ybWFsIHBvaW50cyB1cCwgYW5kIC0xIGlmIGl0IHBvaW50cyBkb3duXFxuICAgIG1lZGl1bXAgdmVjMiBub3JtYWwgPSBtb2QoYV9wb3MsIDIuMCk7XFxuICAgIG5vcm1hbC55ID0gc2lnbihub3JtYWwueSAtIDAuNSk7XFxuICAgIHZfbm9ybWFsID0gbm9ybWFsO1xcblxcbiAgICAvLyBTY2FsZSB0aGUgZXh0cnVzaW9uIHZlY3RvciBkb3duIHRvIGEgbm9ybWFsIGFuZCB0aGVuIHVwIGJ5IHRoZSBsaW5lIHdpZHRoXFxuICAgIC8vIG9mIHRoaXMgdmVydGV4LlxcbiAgICBtZWRpdW1wIHZlYzQgZGlzdCA9IHZlYzQodV9saW5ld2lkdGgucyAqIGFfZXh0cnVkZSAqIHNjYWxlLCAwLjAsIDAuMCk7XFxuXFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgb2Zmc2V0IHdoZW4gZHJhd2luZyBhIGxpbmUgdGhhdCBpcyB0byB0aGUgc2lkZSBvZiB0aGUgYWN0dWFsIGxpbmUuXFxuICAgIC8vIFdlIGRvIHRoaXMgYnkgY3JlYXRpbmcgYSB2ZWN0b3IgdGhhdCBwb2ludHMgdG93YXJkcyB0aGUgZXh0cnVkZSwgYnV0IHJvdGF0ZVxcbiAgICAvLyBpdCB3aGVuIHdlJ3JlIGRyYXdpbmcgcm91bmQgZW5kIHBvaW50cyAoYV9kaXJlY3Rpb24gPSAtMSBvciAxKSBzaW5jZSB0aGVpclxcbiAgICAvLyBleHRydWRlIHZlY3RvciBwb2ludHMgaW4gYW5vdGhlciBkaXJlY3Rpb24uXFxuICAgIG1lZGl1bXAgZmxvYXQgdSA9IDAuNSAqIGFfZGlyZWN0aW9uO1xcbiAgICBtZWRpdW1wIGZsb2F0IHQgPSAxLjAgLSBhYnModSk7XFxuICAgIG1lZGl1bXAgdmVjMiBvZmZzZXQgPSB1X29mZnNldCAqIGFfZXh0cnVkZSAqIHNjYWxlICogbm9ybWFsLnkgKiBtYXQyKHQsIC11LCB1LCB0KTtcXG5cXG4gICAgLy8gUmVtb3ZlIHRoZSB0ZXh0dXJlIG5vcm1hbCBiaXQgb2YgdGhlIHBvc2l0aW9uIGJlZm9yZSBzY2FsaW5nIGl0IHdpdGggdGhlXFxuICAgIC8vIG1vZGVsL3ZpZXcgbWF0cml4LlxcbiAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChmbG9vcihhX3BvcyAqIDAuNSkgKyAob2Zmc2V0ICsgZGlzdC54eSkgLyB1X3JhdGlvLCAwLjAsIDEuMCk7XFxuXFxuICAgIC8vIHBvc2l0aW9uIG9mIHkgb24gdGhlIHNjcmVlblxcbiAgICBmbG9hdCB5ID0gZ2xfUG9zaXRpb24ueSAvIGdsX1Bvc2l0aW9uLnc7XFxuXFxuICAgIC8vIGhvdyBtdWNoIGZlYXR1cmVzIGFyZSBzcXVpc2hlZCBpbiB0aGUgeSBkaXJlY3Rpb24gYnkgdGhlIHRpbHRcXG4gICAgZmxvYXQgc3F1aXNoX3NjYWxlID0gbGVuZ3RoKGFfZXh0cnVkZSkgLyBsZW5ndGgodV9hbnRpYWxpYXNpbmdtYXRyaXggKiBhX2V4dHJ1ZGUpO1xcblxcbiAgICAvLyBob3cgbXVjaCBmZWF0dXJlcyBhcmUgc3F1aXNoZWQgaW4gYWxsIGRpcmVjdGlvbnMgYnkgdGhlIHBlcnNwZWN0aXZlbmVzc1xcbiAgICBmbG9hdCBwZXJzcGVjdGl2ZV9zY2FsZSA9IDEuMCAvICgxLjAgLSBtaW4oeSAqIHVfZXh0cmEsIDAuOSkpO1xcblxcbiAgICB2X2dhbW1hX3NjYWxlID0gcGVyc3BlY3RpdmVfc2NhbGUgKiBzcXVpc2hfc2NhbGU7XFxufVxcblwiXG4gICAgfSxcbiAgICBsaW5lcGF0dGVybjoge1xuICAgICAgICBmcmFnbWVudFNvdXJjZTogXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG51bmlmb3JtIHZlYzIgdV9saW5ld2lkdGg7XFxudW5pZm9ybSBmbG9hdCB1X3BvaW50O1xcbnVuaWZvcm0gZmxvYXQgdV9ibHVyO1xcblxcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fc2l6ZV9hO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fc2l6ZV9iO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fdGxfYTtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX2JyX2E7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl90bF9iO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fYnJfYjtcXG51bmlmb3JtIGZsb2F0IHVfZmFkZTtcXG51bmlmb3JtIGZsb2F0IHVfb3BhY2l0eTtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcblxcbnZhcnlpbmcgdmVjMiB2X25vcm1hbDtcXG52YXJ5aW5nIGZsb2F0IHZfbGluZXNvZmFyO1xcbnZhcnlpbmcgZmxvYXQgdl9nYW1tYV9zY2FsZTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2Ugb2YgdGhlIHBpeGVsIGZyb20gdGhlIGxpbmUgaW4gcGl4ZWxzLlxcbiAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKHZfbm9ybWFsKSAqIHVfbGluZXdpZHRoLnM7XFxuXFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgYW50aWFsaWFzaW5nIGZhZGUgZmFjdG9yLiBUaGlzIGlzIGVpdGhlciB3aGVuIGZhZGluZyBpblxcbiAgICAvLyB0aGUgbGluZSBpbiBjYXNlIG9mIGFuIG9mZnNldCBsaW5lICh2X2xpbmV3aWR0aC50KSBvciB3aGVuIGZhZGluZyBvdXRcXG4gICAgLy8gKHZfbGluZXdpZHRoLnMpXFxuICAgIGZsb2F0IGJsdXIgPSB1X2JsdXIgKiB2X2dhbW1hX3NjYWxlO1xcbiAgICBmbG9hdCBhbHBoYSA9IGNsYW1wKG1pbihkaXN0IC0gKHVfbGluZXdpZHRoLnQgLSBibHVyKSwgdV9saW5ld2lkdGgucyAtIGRpc3QpIC8gYmx1ciwgMC4wLCAxLjApO1xcblxcbiAgICBmbG9hdCB4X2EgPSBtb2Qodl9saW5lc29mYXIgLyB1X3BhdHRlcm5fc2l6ZV9hLngsIDEuMCk7XFxuICAgIGZsb2F0IHhfYiA9IG1vZCh2X2xpbmVzb2ZhciAvIHVfcGF0dGVybl9zaXplX2IueCwgMS4wKTtcXG4gICAgZmxvYXQgeV9hID0gMC41ICsgKHZfbm9ybWFsLnkgKiB1X2xpbmV3aWR0aC5zIC8gdV9wYXR0ZXJuX3NpemVfYS55KTtcXG4gICAgZmxvYXQgeV9iID0gMC41ICsgKHZfbm9ybWFsLnkgKiB1X2xpbmV3aWR0aC5zIC8gdV9wYXR0ZXJuX3NpemVfYi55KTtcXG4gICAgdmVjMiBwb3MgPSBtaXgodV9wYXR0ZXJuX3RsX2EsIHVfcGF0dGVybl9icl9hLCB2ZWMyKHhfYSwgeV9hKSk7XFxuICAgIHZlYzIgcG9zMiA9IG1peCh1X3BhdHRlcm5fdGxfYiwgdV9wYXR0ZXJuX2JyX2IsIHZlYzIoeF9iLCB5X2IpKTtcXG5cXG4gICAgdmVjNCBjb2xvciA9IG1peCh0ZXh0dXJlMkQodV9pbWFnZSwgcG9zKSwgdGV4dHVyZTJEKHVfaW1hZ2UsIHBvczIpLCB1X2ZhZGUpO1xcblxcbiAgICBhbHBoYSAqPSB1X29wYWNpdHk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yICogYWxwaGE7XFxuXFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVxcblwiLFxuICAgICAgICB2ZXJ0ZXhTb3VyY2U6IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbi8vIGZsb29yKDEyNyAvIDIpID09IDYzLjBcXG4vLyB0aGUgbWF4aW11bSBhbGxvd2VkIG1pdGVyIGxpbWl0IGlzIDIuMCBhdCB0aGUgbW9tZW50LiB0aGUgZXh0cnVkZSBub3JtYWwgaXNcXG4vLyBzdG9yZWQgaW4gYSBieXRlICgtMTI4Li4xMjcpLiB3ZSBzY2FsZSByZWd1bGFyIG5vcm1hbHMgdXAgdG8gbGVuZ3RoIDYzLCBidXRcXG4vLyB0aGVyZSBhcmUgYWxzbyBcXFwic3BlY2lhbFxcXCIgbm9ybWFscyB0aGF0IGhhdmUgYSBiaWdnZXIgbGVuZ3RoIChvZiB1cCB0byAxMjYgaW5cXG4vLyB0aGlzIGNhc2UpLlxcbi8vICNkZWZpbmUgc2NhbGUgNjMuMFxcbiNkZWZpbmUgc2NhbGUgMC4wMTU4NzMwMTZcXG5cXG4vLyBXZSBzY2FsZSB0aGUgZGlzdGFuY2UgYmVmb3JlIGFkZGluZyBpdCB0byB0aGUgYnVmZmVycyBzbyB0aGF0IHdlIGNhbiBzdG9yZVxcbi8vIGxvbmcgZGlzdGFuY2VzIGZvciBsb25nIHNlZ21lbnRzLiBVc2UgdGhpcyB2YWx1ZSB0byB1bnNjYWxlIHRoZSBkaXN0YW5jZS5cXG4jZGVmaW5lIExJTkVfRElTVEFOQ0VfU0NBTEUgMi4wXFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzQgYV9kYXRhO1xcblxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9yYXRpbztcXG51bmlmb3JtIG1lZGl1bXAgdmVjMiB1X2xpbmV3aWR0aDtcXG51bmlmb3JtIGZsb2F0IHVfZXh0cmE7XFxudW5pZm9ybSBtYXQyIHVfYW50aWFsaWFzaW5nbWF0cml4O1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X29mZnNldDtcXG5cXG52YXJ5aW5nIHZlYzIgdl9ub3JtYWw7XFxudmFyeWluZyBmbG9hdCB2X2xpbmVzb2ZhcjtcXG52YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWMyIGFfZXh0cnVkZSA9IGFfZGF0YS54eSAtIDEyOC4wO1xcbiAgICBmbG9hdCBhX2RpcmVjdGlvbiA9IG1vZChhX2RhdGEueiwgNC4wKSAtIDEuMDtcXG4gICAgZmxvYXQgYV9saW5lc29mYXIgPSAoZmxvb3IoYV9kYXRhLnogLyA0LjApICsgYV9kYXRhLncgKiA2NC4wKSAqIExJTkVfRElTVEFOQ0VfU0NBTEU7XFxuXFxuICAgIC8vIFdlIHN0b3JlIHRoZSB0ZXh0dXJlIG5vcm1hbHMgaW4gdGhlIG1vc3QgaW5zaWduaWZpY2FudCBiaXRcXG4gICAgLy8gdHJhbnNmb3JtIHkgc28gdGhhdCAwID0+IC0xIGFuZCAxID0+IDFcXG4gICAgLy8gSW4gdGhlIHRleHR1cmUgbm9ybWFsLCB4IGlzIDAgaWYgdGhlIG5vcm1hbCBwb2ludHMgc3RyYWlnaHQgdXAvZG93biBhbmQgMSBpZiBpdCdzIGEgcm91bmQgY2FwXFxuICAgIC8vIHkgaXMgMSBpZiB0aGUgbm9ybWFsIHBvaW50cyB1cCwgYW5kIC0xIGlmIGl0IHBvaW50cyBkb3duXFxuICAgIG1lZGl1bXAgdmVjMiBub3JtYWwgPSBtb2QoYV9wb3MsIDIuMCk7XFxuICAgIG5vcm1hbC55ID0gc2lnbihub3JtYWwueSAtIDAuNSk7XFxuICAgIHZfbm9ybWFsID0gbm9ybWFsO1xcblxcbiAgICAvLyBTY2FsZSB0aGUgZXh0cnVzaW9uIHZlY3RvciBkb3duIHRvIGEgbm9ybWFsIGFuZCB0aGVuIHVwIGJ5IHRoZSBsaW5lIHdpZHRoXFxuICAgIC8vIG9mIHRoaXMgdmVydGV4LlxcbiAgICBtZWRpdW1wIHZlYzIgZXh0cnVkZSA9IGFfZXh0cnVkZSAqIHNjYWxlO1xcbiAgICBtZWRpdW1wIHZlYzIgZGlzdCA9IHVfbGluZXdpZHRoLnMgKiBleHRydWRlO1xcblxcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG9mZnNldCB3aGVuIGRyYXdpbmcgYSBsaW5lIHRoYXQgaXMgdG8gdGhlIHNpZGUgb2YgdGhlIGFjdHVhbCBsaW5lLlxcbiAgICAvLyBXZSBkbyB0aGlzIGJ5IGNyZWF0aW5nIGEgdmVjdG9yIHRoYXQgcG9pbnRzIHRvd2FyZHMgdGhlIGV4dHJ1ZGUsIGJ1dCByb3RhdGVcXG4gICAgLy8gaXQgd2hlbiB3ZSdyZSBkcmF3aW5nIHJvdW5kIGVuZCBwb2ludHMgKGFfZGlyZWN0aW9uID0gLTEgb3IgMSkgc2luY2UgdGhlaXJcXG4gICAgLy8gZXh0cnVkZSB2ZWN0b3IgcG9pbnRzIGluIGFub3RoZXIgZGlyZWN0aW9uLlxcbiAgICBtZWRpdW1wIGZsb2F0IHUgPSAwLjUgKiBhX2RpcmVjdGlvbjtcXG4gICAgbWVkaXVtcCBmbG9hdCB0ID0gMS4wIC0gYWJzKHUpO1xcbiAgICBtZWRpdW1wIHZlYzIgb2Zmc2V0ID0gdV9vZmZzZXQgKiBhX2V4dHJ1ZGUgKiBzY2FsZSAqIG5vcm1hbC55ICogbWF0Mih0LCAtdSwgdSwgdCk7XFxuXFxuICAgIC8vIFJlbW92ZSB0aGUgdGV4dHVyZSBub3JtYWwgYml0IG9mIHRoZSBwb3NpdGlvbiBiZWZvcmUgc2NhbGluZyBpdCB3aXRoIHRoZVxcbiAgICAvLyBtb2RlbC92aWV3IG1hdHJpeC5cXG4gICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoZmxvb3IoYV9wb3MgKiAwLjUpICsgKG9mZnNldCArIGRpc3QueHkpIC8gdV9yYXRpbywgMC4wLCAxLjApO1xcbiAgICB2X2xpbmVzb2ZhciA9IGFfbGluZXNvZmFyO1xcblxcbiAgICAvLyBwb3NpdGlvbiBvZiB5IG9uIHRoZSBzY3JlZW5cXG4gICAgZmxvYXQgeSA9IGdsX1Bvc2l0aW9uLnkgLyBnbF9Qb3NpdGlvbi53O1xcblxcbiAgICAvLyBob3cgbXVjaCBmZWF0dXJlcyBhcmUgc3F1aXNoZWQgaW4gdGhlIHkgZGlyZWN0aW9uIGJ5IHRoZSB0aWx0XFxuICAgIGZsb2F0IHNxdWlzaF9zY2FsZSA9IGxlbmd0aChhX2V4dHJ1ZGUpIC8gbGVuZ3RoKHVfYW50aWFsaWFzaW5nbWF0cml4ICogYV9leHRydWRlKTtcXG5cXG4gICAgLy8gaG93IG11Y2ggZmVhdHVyZXMgYXJlIHNxdWlzaGVkIGluIGFsbCBkaXJlY3Rpb25zIGJ5IHRoZSBwZXJzcGVjdGl2ZW5lc3NcXG4gICAgZmxvYXQgcGVyc3BlY3RpdmVfc2NhbGUgPSAxLjAgLyAoMS4wIC0gbWluKHkgKiB1X2V4dHJhLCAwLjkpKTtcXG5cXG4gICAgdl9nYW1tYV9zY2FsZSA9IHBlcnNwZWN0aXZlX3NjYWxlICogc3F1aXNoX3NjYWxlO1xcbn1cXG5cIlxuICAgIH0sXG4gICAgbGluZXNkZnBhdHRlcm46IHtcbiAgICAgICAgZnJhZ21lbnRTb3VyY2U6IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudW5pZm9ybSB2ZWMyIHVfbGluZXdpZHRoO1xcbnVuaWZvcm0gbG93cCB2ZWM0IHVfY29sb3I7XFxudW5pZm9ybSBsb3dwIGZsb2F0IHVfb3BhY2l0eTtcXG51bmlmb3JtIGZsb2F0IHVfYmx1cjtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnVuaWZvcm0gZmxvYXQgdV9zZGZnYW1tYTtcXG51bmlmb3JtIGZsb2F0IHVfbWl4O1xcblxcbnZhcnlpbmcgdmVjMiB2X25vcm1hbDtcXG52YXJ5aW5nIHZlYzIgdl90ZXhfYTtcXG52YXJ5aW5nIHZlYzIgdl90ZXhfYjtcXG52YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIG9mIHRoZSBwaXhlbCBmcm9tIHRoZSBsaW5lIGluIHBpeGVscy5cXG4gICAgZmxvYXQgZGlzdCA9IGxlbmd0aCh2X25vcm1hbCkgKiB1X2xpbmV3aWR0aC5zO1xcblxcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGFudGlhbGlhc2luZyBmYWRlIGZhY3Rvci4gVGhpcyBpcyBlaXRoZXIgd2hlbiBmYWRpbmcgaW5cXG4gICAgLy8gdGhlIGxpbmUgaW4gY2FzZSBvZiBhbiBvZmZzZXQgbGluZSAodl9saW5ld2lkdGgudCkgb3Igd2hlbiBmYWRpbmcgb3V0XFxuICAgIC8vICh2X2xpbmV3aWR0aC5zKVxcbiAgICBmbG9hdCBibHVyID0gdV9ibHVyICogdl9nYW1tYV9zY2FsZTtcXG4gICAgZmxvYXQgYWxwaGEgPSBjbGFtcChtaW4oZGlzdCAtICh1X2xpbmV3aWR0aC50IC0gYmx1ciksIHVfbGluZXdpZHRoLnMgLSBkaXN0KSAvIGJsdXIsIDAuMCwgMS4wKTtcXG5cXG4gICAgZmxvYXQgc2RmZGlzdF9hID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4X2EpLmE7XFxuICAgIGZsb2F0IHNkZmRpc3RfYiA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleF9iKS5hO1xcbiAgICBmbG9hdCBzZGZkaXN0ID0gbWl4KHNkZmRpc3RfYSwgc2RmZGlzdF9iLCB1X21peCk7XFxuICAgIGFscGhhICo9IHNtb290aHN0ZXAoMC41IC0gdV9zZGZnYW1tYSwgMC41ICsgdV9zZGZnYW1tYSwgc2RmZGlzdCk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHVfY29sb3IgKiAoYWxwaGEgKiB1X29wYWNpdHkpO1xcblxcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cXG5cIixcbiAgICAgICAgdmVydGV4U291cmNlOiBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXG4vLyBmbG9vcigxMjcgLyAyKSA9PSA2My4wXFxuLy8gdGhlIG1heGltdW0gYWxsb3dlZCBtaXRlciBsaW1pdCBpcyAyLjAgYXQgdGhlIG1vbWVudC4gdGhlIGV4dHJ1ZGUgbm9ybWFsIGlzXFxuLy8gc3RvcmVkIGluIGEgYnl0ZSAoLTEyOC4uMTI3KS4gd2Ugc2NhbGUgcmVndWxhciBub3JtYWxzIHVwIHRvIGxlbmd0aCA2MywgYnV0XFxuLy8gdGhlcmUgYXJlIGFsc28gXFxcInNwZWNpYWxcXFwiIG5vcm1hbHMgdGhhdCBoYXZlIGEgYmlnZ2VyIGxlbmd0aCAob2YgdXAgdG8gMTI2IGluXFxuLy8gdGhpcyBjYXNlKS5cXG4vLyAjZGVmaW5lIHNjYWxlIDYzLjBcXG4jZGVmaW5lIHNjYWxlIDAuMDE1ODczMDE2XFxuXFxuLy8gV2Ugc2NhbGUgdGhlIGRpc3RhbmNlIGJlZm9yZSBhZGRpbmcgaXQgdG8gdGhlIGJ1ZmZlcnMgc28gdGhhdCB3ZSBjYW4gc3RvcmVcXG4vLyBsb25nIGRpc3RhbmNlcyBmb3IgbG9uZyBzZWdtZW50cy4gVXNlIHRoaXMgdmFsdWUgdG8gdW5zY2FsZSB0aGUgZGlzdGFuY2UuXFxuI2RlZmluZSBMSU5FX0RJU1RBTkNFX1NDQUxFIDIuMFxcblxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfZGF0YTtcXG5cXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzIgdV9saW5ld2lkdGg7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfcmF0aW87XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybnNjYWxlX2E7XFxudW5pZm9ybSBmbG9hdCB1X3RleF95X2E7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybnNjYWxlX2I7XFxudW5pZm9ybSBmbG9hdCB1X3RleF95X2I7XFxudW5pZm9ybSBmbG9hdCB1X2V4dHJhO1xcbnVuaWZvcm0gbWF0MiB1X2FudGlhbGlhc2luZ21hdHJpeDtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9vZmZzZXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZfbm9ybWFsO1xcbnZhcnlpbmcgdmVjMiB2X3RleF9hO1xcbnZhcnlpbmcgdmVjMiB2X3RleF9iO1xcbnZhcnlpbmcgZmxvYXQgdl9nYW1tYV9zY2FsZTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZlYzIgYV9leHRydWRlID0gYV9kYXRhLnh5IC0gMTI4LjA7XFxuICAgIGZsb2F0IGFfZGlyZWN0aW9uID0gbW9kKGFfZGF0YS56LCA0LjApIC0gMS4wO1xcbiAgICBmbG9hdCBhX2xpbmVzb2ZhciA9IChmbG9vcihhX2RhdGEueiAvIDQuMCkgKyBhX2RhdGEudyAqIDY0LjApICogTElORV9ESVNUQU5DRV9TQ0FMRTtcXG5cXG4gICAgLy8gV2Ugc3RvcmUgdGhlIHRleHR1cmUgbm9ybWFscyBpbiB0aGUgbW9zdCBpbnNpZ25pZmljYW50IGJpdFxcbiAgICAvLyB0cmFuc2Zvcm0geSBzbyB0aGF0IDAgPT4gLTEgYW5kIDEgPT4gMVxcbiAgICAvLyBJbiB0aGUgdGV4dHVyZSBub3JtYWwsIHggaXMgMCBpZiB0aGUgbm9ybWFsIHBvaW50cyBzdHJhaWdodCB1cC9kb3duIGFuZCAxIGlmIGl0J3MgYSByb3VuZCBjYXBcXG4gICAgLy8geSBpcyAxIGlmIHRoZSBub3JtYWwgcG9pbnRzIHVwLCBhbmQgLTEgaWYgaXQgcG9pbnRzIGRvd25cXG4gICAgbWVkaXVtcCB2ZWMyIG5vcm1hbCA9IG1vZChhX3BvcywgMi4wKTtcXG4gICAgbm9ybWFsLnkgPSBzaWduKG5vcm1hbC55IC0gMC41KTtcXG4gICAgdl9ub3JtYWwgPSBub3JtYWw7XFxuXFxuICAgIC8vIFNjYWxlIHRoZSBleHRydXNpb24gdmVjdG9yIGRvd24gdG8gYSBub3JtYWwgYW5kIHRoZW4gdXAgYnkgdGhlIGxpbmUgd2lkdGhcXG4gICAgLy8gb2YgdGhpcyB2ZXJ0ZXguXFxuICAgIG1lZGl1bXAgdmVjNCBkaXN0ID0gdmVjNCh1X2xpbmV3aWR0aC5zICogYV9leHRydWRlICogc2NhbGUsIDAuMCwgMC4wKTtcXG5cXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBvZmZzZXQgd2hlbiBkcmF3aW5nIGEgbGluZSB0aGF0IGlzIHRvIHRoZSBzaWRlIG9mIHRoZSBhY3R1YWwgbGluZS5cXG4gICAgLy8gV2UgZG8gdGhpcyBieSBjcmVhdGluZyBhIHZlY3RvciB0aGF0IHBvaW50cyB0b3dhcmRzIHRoZSBleHRydWRlLCBidXQgcm90YXRlXFxuICAgIC8vIGl0IHdoZW4gd2UncmUgZHJhd2luZyByb3VuZCBlbmQgcG9pbnRzIChhX2RpcmVjdGlvbiA9IC0xIG9yIDEpIHNpbmNlIHRoZWlyXFxuICAgIC8vIGV4dHJ1ZGUgdmVjdG9yIHBvaW50cyBpbiBhbm90aGVyIGRpcmVjdGlvbi5cXG4gICAgbWVkaXVtcCBmbG9hdCB1ID0gMC41ICogYV9kaXJlY3Rpb247XFxuICAgIG1lZGl1bXAgZmxvYXQgdCA9IDEuMCAtIGFicyh1KTtcXG4gICAgbWVkaXVtcCB2ZWMyIG9mZnNldCA9IHVfb2Zmc2V0ICogYV9leHRydWRlICogc2NhbGUgKiBub3JtYWwueSAqIG1hdDIodCwgLXUsIHUsIHQpO1xcblxcbiAgICAvLyBSZW1vdmUgdGhlIHRleHR1cmUgbm9ybWFsIGJpdCBvZiB0aGUgcG9zaXRpb24gYmVmb3JlIHNjYWxpbmcgaXQgd2l0aCB0aGVcXG4gICAgLy8gbW9kZWwvdmlldyBtYXRyaXguXFxuICAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGZsb29yKGFfcG9zICogMC41KSArIChvZmZzZXQgKyBkaXN0Lnh5KSAvIHVfcmF0aW8sIDAuMCwgMS4wKTtcXG5cXG4gICAgdl90ZXhfYSA9IHZlYzIoYV9saW5lc29mYXIgKiB1X3BhdHRlcm5zY2FsZV9hLngsIG5vcm1hbC55ICogdV9wYXR0ZXJuc2NhbGVfYS55ICsgdV90ZXhfeV9hKTtcXG4gICAgdl90ZXhfYiA9IHZlYzIoYV9saW5lc29mYXIgKiB1X3BhdHRlcm5zY2FsZV9iLngsIG5vcm1hbC55ICogdV9wYXR0ZXJuc2NhbGVfYi55ICsgdV90ZXhfeV9iKTtcXG5cXG4gICAgLy8gcG9zaXRpb24gb2YgeSBvbiB0aGUgc2NyZWVuXFxuICAgIGZsb2F0IHkgPSBnbF9Qb3NpdGlvbi55IC8gZ2xfUG9zaXRpb24udztcXG5cXG4gICAgLy8gaG93IG11Y2ggZmVhdHVyZXMgYXJlIHNxdWlzaGVkIGluIHRoZSB5IGRpcmVjdGlvbiBieSB0aGUgdGlsdFxcbiAgICBmbG9hdCBzcXVpc2hfc2NhbGUgPSBsZW5ndGgoYV9leHRydWRlKSAvIGxlbmd0aCh1X2FudGlhbGlhc2luZ21hdHJpeCAqIGFfZXh0cnVkZSk7XFxuXFxuICAgIC8vIGhvdyBtdWNoIGZlYXR1cmVzIGFyZSBzcXVpc2hlZCBpbiBhbGwgZGlyZWN0aW9ucyBieSB0aGUgcGVyc3BlY3RpdmVuZXNzXFxuICAgIGZsb2F0IHBlcnNwZWN0aXZlX3NjYWxlID0gMS4wIC8gKDEuMCAtIG1pbih5ICogdV9leHRyYSwgMC45KSk7XFxuXFxuICAgIHZfZ2FtbWFfc2NhbGUgPSBwZXJzcGVjdGl2ZV9zY2FsZSAqIHNxdWlzaF9zY2FsZTtcXG59XFxuXCJcbiAgICB9LFxuICAgIG91dGxpbmU6IHtcbiAgICAgICAgZnJhZ21lbnRTb3VyY2U6IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudW5pZm9ybSBsb3dwIHZlYzQgdV9jb2xvcjtcXG51bmlmb3JtIGxvd3AgZmxvYXQgdV9vcGFjaXR5O1xcblxcbnZhcnlpbmcgdmVjMiB2X3BvcztcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgodl9wb3MgLSBnbF9GcmFnQ29vcmQueHkpO1xcbiAgICBmbG9hdCBhbHBoYSA9IHNtb290aHN0ZXAoMS4wLCAwLjAsIGRpc3QpO1xcbiAgICBnbF9GcmFnQ29sb3IgPSB1X2NvbG9yICogKGFscGhhICogdV9vcGFjaXR5KTtcXG5cXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XFxuXCIsXG4gICAgICAgIHZlcnRleFNvdXJjZTogXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuXFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gdmVjMiB1X3dvcmxkO1xcblxcbnZhcnlpbmcgdmVjMiB2X3BvcztcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGFfcG9zLCAwLCAxKTtcXG4gICAgdl9wb3MgPSAoZ2xfUG9zaXRpb24ueHkvZ2xfUG9zaXRpb24udyArIDEuMCkgLyAyLjAgKiB1X3dvcmxkO1xcbn1cXG5cIlxuICAgIH0sXG4gICAgb3V0bGluZXBhdHRlcm46IHtcbiAgICAgICAgZnJhZ21lbnRTb3VyY2U6IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudW5pZm9ybSBmbG9hdCB1X29wYWNpdHk7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl90bF9hO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fYnJfYTtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX3RsX2I7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9icl9iO1xcbnVuaWZvcm0gZmxvYXQgdV9taXg7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG5cXG52YXJ5aW5nIHZlYzIgdl9wb3NfYTtcXG52YXJ5aW5nIHZlYzIgdl9wb3NfYjtcXG52YXJ5aW5nIHZlYzIgdl9wb3M7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWMyIGltYWdlY29vcmQgPSBtb2Qodl9wb3NfYSwgMS4wKTtcXG4gICAgdmVjMiBwb3MgPSBtaXgodV9wYXR0ZXJuX3RsX2EsIHVfcGF0dGVybl9icl9hLCBpbWFnZWNvb3JkKTtcXG4gICAgdmVjNCBjb2xvcjEgPSB0ZXh0dXJlMkQodV9pbWFnZSwgcG9zKTtcXG5cXG4gICAgdmVjMiBpbWFnZWNvb3JkX2IgPSBtb2Qodl9wb3NfYiwgMS4wKTtcXG4gICAgdmVjMiBwb3MyID0gbWl4KHVfcGF0dGVybl90bF9iLCB1X3BhdHRlcm5fYnJfYiwgaW1hZ2Vjb29yZF9iKTtcXG4gICAgdmVjNCBjb2xvcjIgPSB0ZXh0dXJlMkQodV9pbWFnZSwgcG9zMik7XFxuXFxuICAgIC8vIGZpbmQgZGlzdGFuY2UgdG8gb3V0bGluZSBmb3IgYWxwaGEgaW50ZXJwb2xhdGlvblxcblxcbiAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKHZfcG9zIC0gZ2xfRnJhZ0Nvb3JkLnh5KTtcXG4gICAgZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKDEuMCwgMC4wLCBkaXN0KTtcXG4gICAgXFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IG1peChjb2xvcjEsIGNvbG9yMiwgdV9taXgpICogYWxwaGEgKiB1X29wYWNpdHk7XFxuXFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVxcblwiLFxuICAgICAgICB2ZXJ0ZXhTb3VyY2U6IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5zY2FsZV9hO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5zY2FsZV9iO1xcbnVuaWZvcm0gdmVjMiB1X29mZnNldF9hO1xcbnVuaWZvcm0gdmVjMiB1X29mZnNldF9iO1xcblxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcblxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIHZlYzIgdV93b3JsZDtcXG5cXG52YXJ5aW5nIHZlYzIgdl9wb3NfYTtcXG52YXJ5aW5nIHZlYzIgdl9wb3NfYjtcXG52YXJ5aW5nIHZlYzIgdl9wb3M7XFxuXFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3BvcywgMCwgMSk7XFxuICAgIHZfcG9zX2EgPSB1X3BhdHRlcm5zY2FsZV9hICogYV9wb3MgKyB1X29mZnNldF9hO1xcbiAgICB2X3Bvc19iID0gdV9wYXR0ZXJuc2NhbGVfYiAqIGFfcG9zICsgdV9vZmZzZXRfYjtcXG4gICAgdl9wb3MgPSAoZ2xfUG9zaXRpb24ueHkvZ2xfUG9zaXRpb24udyArIDEuMCkgLyAyLjAgKiB1X3dvcmxkO1xcbn1cXG5cIlxuICAgIH0sXG4gICAgcGF0dGVybjoge1xuICAgICAgICBmcmFnbWVudFNvdXJjZTogXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG51bmlmb3JtIGZsb2F0IHVfb3BhY2l0eTtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX3RsX2E7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9icl9hO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fdGxfYjtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX2JyX2I7XFxudW5pZm9ybSBmbG9hdCB1X21peDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcblxcbnZhcnlpbmcgdmVjMiB2X3Bvc19hO1xcbnZhcnlpbmcgdmVjMiB2X3Bvc19iO1xcblxcbnZvaWQgbWFpbigpIHtcXG5cXG4gICAgdmVjMiBpbWFnZWNvb3JkID0gbW9kKHZfcG9zX2EsIDEuMCk7XFxuICAgIHZlYzIgcG9zID0gbWl4KHVfcGF0dGVybl90bF9hLCB1X3BhdHRlcm5fYnJfYSwgaW1hZ2Vjb29yZCk7XFxuICAgIHZlYzQgY29sb3IxID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHBvcyk7XFxuXFxuICAgIHZlYzIgaW1hZ2Vjb29yZF9iID0gbW9kKHZfcG9zX2IsIDEuMCk7XFxuICAgIHZlYzIgcG9zMiA9IG1peCh1X3BhdHRlcm5fdGxfYiwgdV9wYXR0ZXJuX2JyX2IsIGltYWdlY29vcmRfYik7XFxuICAgIHZlYzQgY29sb3IyID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHBvczIpO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBtaXgoY29sb3IxLCBjb2xvcjIsIHVfbWl4KSAqIHVfb3BhY2l0eTtcXG5cXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XFxuXCIsXG4gICAgICAgIHZlcnRleFNvdXJjZTogXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5zY2FsZV9hO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5zY2FsZV9iO1xcbnVuaWZvcm0gdmVjMiB1X29mZnNldF9hO1xcbnVuaWZvcm0gdmVjMiB1X29mZnNldF9iO1xcblxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcblxcbnZhcnlpbmcgdmVjMiB2X3Bvc19hO1xcbnZhcnlpbmcgdmVjMiB2X3Bvc19iO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoYV9wb3MsIDAsIDEpO1xcbiAgICB2X3Bvc19hID0gdV9wYXR0ZXJuc2NhbGVfYSAqIGFfcG9zICsgdV9vZmZzZXRfYTtcXG4gICAgdl9wb3NfYiA9IHVfcGF0dGVybnNjYWxlX2IgKiBhX3BvcyArIHVfb2Zmc2V0X2I7XFxufVxcblwiXG4gICAgfSxcbiAgICByYXN0ZXI6IHtcbiAgICAgICAgZnJhZ21lbnRTb3VyY2U6IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudW5pZm9ybSBmbG9hdCB1X29wYWNpdHkwO1xcbnVuaWZvcm0gZmxvYXQgdV9vcGFjaXR5MTtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlMDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlMTtcXG52YXJ5aW5nIHZlYzIgdl9wb3MwO1xcbnZhcnlpbmcgdmVjMiB2X3BvczE7XFxuXFxudW5pZm9ybSBmbG9hdCB1X2JyaWdodG5lc3NfbG93O1xcbnVuaWZvcm0gZmxvYXQgdV9icmlnaHRuZXNzX2hpZ2g7XFxuXFxudW5pZm9ybSBmbG9hdCB1X3NhdHVyYXRpb25fZmFjdG9yO1xcbnVuaWZvcm0gZmxvYXQgdV9jb250cmFzdF9mYWN0b3I7XFxudW5pZm9ybSB2ZWMzIHVfc3Bpbl93ZWlnaHRzO1xcblxcbnZvaWQgbWFpbigpIHtcXG5cXG4gICAgLy8gcmVhZCBhbmQgY3Jvc3MtZmFkZSBjb2xvcnMgZnJvbSB0aGUgbWFpbiBhbmQgcGFyZW50IHRpbGVzXFxuICAgIHZlYzQgY29sb3IwID0gdGV4dHVyZTJEKHVfaW1hZ2UwLCB2X3BvczApO1xcbiAgICB2ZWM0IGNvbG9yMSA9IHRleHR1cmUyRCh1X2ltYWdlMSwgdl9wb3MxKTtcXG4gICAgdmVjNCBjb2xvciA9IGNvbG9yMCAqIHVfb3BhY2l0eTAgKyBjb2xvcjEgKiB1X29wYWNpdHkxO1xcbiAgICB2ZWMzIHJnYiA9IGNvbG9yLnJnYjtcXG5cXG4gICAgLy8gc3BpblxcbiAgICByZ2IgPSB2ZWMzKFxcbiAgICAgICAgZG90KHJnYiwgdV9zcGluX3dlaWdodHMueHl6KSxcXG4gICAgICAgIGRvdChyZ2IsIHVfc3Bpbl93ZWlnaHRzLnp4eSksXFxuICAgICAgICBkb3QocmdiLCB1X3NwaW5fd2VpZ2h0cy55engpKTtcXG5cXG4gICAgLy8gc2F0dXJhdGlvblxcbiAgICBmbG9hdCBhdmVyYWdlID0gKGNvbG9yLnIgKyBjb2xvci5nICsgY29sb3IuYikgLyAzLjA7XFxuICAgIHJnYiArPSAoYXZlcmFnZSAtIHJnYikgKiB1X3NhdHVyYXRpb25fZmFjdG9yO1xcblxcbiAgICAvLyBjb250cmFzdFxcbiAgICByZ2IgPSAocmdiIC0gMC41KSAqIHVfY29udHJhc3RfZmFjdG9yICsgMC41O1xcblxcbiAgICAvLyBicmlnaHRuZXNzXFxuICAgIHZlYzMgdV9oaWdoX3ZlYyA9IHZlYzModV9icmlnaHRuZXNzX2xvdywgdV9icmlnaHRuZXNzX2xvdywgdV9icmlnaHRuZXNzX2xvdyk7XFxuICAgIHZlYzMgdV9sb3dfdmVjID0gdmVjMyh1X2JyaWdodG5lc3NfaGlnaCwgdV9icmlnaHRuZXNzX2hpZ2gsIHVfYnJpZ2h0bmVzc19oaWdoKTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChtaXgodV9oaWdoX3ZlYywgdV9sb3dfdmVjLCByZ2IpLCBjb2xvci5hKTtcXG5cXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XFxuXCIsXG4gICAgICAgIHZlcnRleFNvdXJjZTogXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gdmVjMiB1X3RsX3BhcmVudDtcXG51bmlmb3JtIGZsb2F0IHVfc2NhbGVfcGFyZW50O1xcbnVuaWZvcm0gZmxvYXQgdV9idWZmZXJfc2NhbGU7XFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzIgYV90ZXh0dXJlX3BvcztcXG5cXG52YXJ5aW5nIHZlYzIgdl9wb3MwO1xcbnZhcnlpbmcgdmVjMiB2X3BvczE7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3BvcywgMCwgMSk7XFxuICAgIHZfcG9zMCA9ICgoKGFfdGV4dHVyZV9wb3MgLyAzMjc2Ny4wKSAtIDAuNSkgLyB1X2J1ZmZlcl9zY2FsZSApICsgMC41O1xcbiAgICB2X3BvczEgPSAodl9wb3MwICogdV9zY2FsZV9wYXJlbnQpICsgdV90bF9wYXJlbnQ7XFxufVxcblwiXG4gICAgfSxcbiAgICBpY29uOiB7XG4gICAgICAgIGZyYWdtZW50U291cmNlOiBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ZhZGV0ZXh0dXJlO1xcbnVuaWZvcm0gbG93cCBmbG9hdCB1X29wYWNpdHk7XFxuXFxudmFyeWluZyB2ZWMyIHZfdGV4O1xcbnZhcnlpbmcgdmVjMiB2X2ZhZGVfdGV4O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgbG93cCBmbG9hdCBhbHBoYSA9IHRleHR1cmUyRCh1X2ZhZGV0ZXh0dXJlLCB2X2ZhZGVfdGV4KS5hICogdV9vcGFjaXR5O1xcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X3RleCkgKiBhbHBoYTtcXG5cXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XFxuXCIsXG4gICAgICAgIHZlcnRleFNvdXJjZTogXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzIgYV9vZmZzZXQ7XFxuYXR0cmlidXRlIHZlYzQgYV9kYXRhMTtcXG5hdHRyaWJ1dGUgdmVjNCBhX2RhdGEyO1xcblxcblxcbi8vIG1hdHJpeCBpcyBmb3IgdGhlIHZlcnRleCBwb3NpdGlvbiwgZXhtYXRyaXggaXMgZm9yIHJvdGF0aW5nIGFuZCBwcm9qZWN0aW5nXFxuLy8gdGhlIGV4dHJ1c2lvbiB2ZWN0b3IuXFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcblxcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X3pvb207XFxudW5pZm9ybSBib29sIHVfc2tld2VkO1xcbnVuaWZvcm0gZmxvYXQgdV9leHRyYTtcXG51bmlmb3JtIHZlYzIgdV9leHRydWRlX3NjYWxlO1xcblxcbnVuaWZvcm0gdmVjMiB1X3RleHNpemU7XFxuXFxudmFyeWluZyB2ZWMyIHZfdGV4O1xcbnZhcnlpbmcgdmVjMiB2X2ZhZGVfdGV4O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjMiBhX3RleCA9IGFfZGF0YTEueHk7XFxuICAgIG1lZGl1bXAgZmxvYXQgYV9sYWJlbG1pbnpvb20gPSBhX2RhdGExWzJdO1xcbiAgICBtZWRpdW1wIHZlYzIgYV96b29tID0gYV9kYXRhMi5zdDtcXG4gICAgbWVkaXVtcCBmbG9hdCBhX21pbnpvb20gPSBhX3pvb21bMF07XFxuICAgIG1lZGl1bXAgZmxvYXQgYV9tYXh6b29tID0gYV96b29tWzFdO1xcblxcbiAgICAvLyB1X3pvb20gaXMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBhZGp1c3RlZCBmb3IgdGhlIGNoYW5nZSBpbiBmb250IHNpemVcXG4gICAgbWVkaXVtcCBmbG9hdCB6ID0gMi4wIC0gc3RlcChhX21pbnpvb20sIHVfem9vbSkgLSAoMS4wIC0gc3RlcChhX21heHpvb20sIHVfem9vbSkpO1xcblxcbiAgICB2ZWMyIGV4dHJ1ZGUgPSB1X2V4dHJ1ZGVfc2NhbGUgKiAoYV9vZmZzZXQgLyA2NC4wKTtcXG4gICAgaWYgKHVfc2tld2VkKSB7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3BvcyArIGV4dHJ1ZGUsIDAsIDEpO1xcbiAgICAgICAgZ2xfUG9zaXRpb24ueiArPSB6ICogZ2xfUG9zaXRpb24udztcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGFfcG9zLCAwLCAxKSArIHZlYzQoZXh0cnVkZSwgMCwgMCk7XFxuICAgIH1cXG5cXG4gICAgdl90ZXggPSBhX3RleCAvIHVfdGV4c2l6ZTtcXG4gICAgdl9mYWRlX3RleCA9IHZlYzIoYV9sYWJlbG1pbnpvb20gLyAyNTUuMCwgMC4wKTtcXG59XFxuXCJcbiAgICB9LFxuICAgIHNkZjoge1xuICAgICAgICBmcmFnbWVudFNvdXJjZTogXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9mYWRldGV4dHVyZTtcXG51bmlmb3JtIGxvd3AgdmVjNCB1X2NvbG9yO1xcbnVuaWZvcm0gbG93cCBmbG9hdCB1X29wYWNpdHk7XFxudW5pZm9ybSBsb3dwIGZsb2F0IHVfYnVmZmVyO1xcbnVuaWZvcm0gbG93cCBmbG9hdCB1X2dhbW1hO1xcblxcbnZhcnlpbmcgdmVjMiB2X3RleDtcXG52YXJ5aW5nIHZlYzIgdl9mYWRlX3RleDtcXG52YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBsb3dwIGZsb2F0IGRpc3QgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X3RleCkuYTtcXG4gICAgbG93cCBmbG9hdCBmYWRlX2FscGhhID0gdGV4dHVyZTJEKHVfZmFkZXRleHR1cmUsIHZfZmFkZV90ZXgpLmE7XFxuICAgIGxvd3AgZmxvYXQgZ2FtbWEgPSB1X2dhbW1hICogdl9nYW1tYV9zY2FsZTtcXG4gICAgbG93cCBmbG9hdCBhbHBoYSA9IHNtb290aHN0ZXAodV9idWZmZXIgLSBnYW1tYSwgdV9idWZmZXIgKyBnYW1tYSwgZGlzdCkgKiBmYWRlX2FscGhhO1xcbiAgICBnbF9GcmFnQ29sb3IgPSB1X2NvbG9yICogKGFscGhhICogdV9vcGFjaXR5KTtcXG5cXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XFxuXCIsXG4gICAgICAgIHZlcnRleFNvdXJjZTogXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzIgYV9vZmZzZXQ7XFxuYXR0cmlidXRlIHZlYzQgYV9kYXRhMTtcXG5hdHRyaWJ1dGUgdmVjNCBhX2RhdGEyO1xcblxcblxcbi8vIG1hdHJpeCBpcyBmb3IgdGhlIHZlcnRleCBwb3NpdGlvbiwgZXhtYXRyaXggaXMgZm9yIHJvdGF0aW5nIGFuZCBwcm9qZWN0aW5nXFxuLy8gdGhlIGV4dHJ1c2lvbiB2ZWN0b3IuXFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcblxcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X3pvb207XFxudW5pZm9ybSBib29sIHVfc2tld2VkO1xcbnVuaWZvcm0gZmxvYXQgdV9leHRyYTtcXG51bmlmb3JtIHZlYzIgdV9leHRydWRlX3NjYWxlO1xcblxcbnVuaWZvcm0gdmVjMiB1X3RleHNpemU7XFxuXFxudmFyeWluZyB2ZWMyIHZfdGV4O1xcbnZhcnlpbmcgdmVjMiB2X2ZhZGVfdGV4O1xcbnZhcnlpbmcgZmxvYXQgdl9nYW1tYV9zY2FsZTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZlYzIgYV90ZXggPSBhX2RhdGExLnh5O1xcbiAgICBtZWRpdW1wIGZsb2F0IGFfbGFiZWxtaW56b29tID0gYV9kYXRhMVsyXTtcXG4gICAgbWVkaXVtcCB2ZWMyIGFfem9vbSA9IGFfZGF0YTIuc3Q7XFxuICAgIG1lZGl1bXAgZmxvYXQgYV9taW56b29tID0gYV96b29tWzBdO1xcbiAgICBtZWRpdW1wIGZsb2F0IGFfbWF4em9vbSA9IGFfem9vbVsxXTtcXG5cXG4gICAgLy8gdV96b29tIGlzIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgYWRqdXN0ZWQgZm9yIHRoZSBjaGFuZ2UgaW4gZm9udCBzaXplXFxuICAgIG1lZGl1bXAgZmxvYXQgeiA9IDIuMCAtIHN0ZXAoYV9taW56b29tLCB1X3pvb20pIC0gKDEuMCAtIHN0ZXAoYV9tYXh6b29tLCB1X3pvb20pKTtcXG5cXG4gICAgdmVjMiBleHRydWRlID0gdV9leHRydWRlX3NjYWxlICogKGFfb2Zmc2V0IC8gNjQuMCk7XFxuICAgIGlmICh1X3NrZXdlZCkge1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoYV9wb3MgKyBleHRydWRlLCAwLCAxKTtcXG4gICAgICAgIGdsX1Bvc2l0aW9uLnogKz0geiAqIGdsX1Bvc2l0aW9uLnc7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3BvcywgMCwgMSkgKyB2ZWM0KGV4dHJ1ZGUsIDAsIDApO1xcbiAgICB9XFxuXFxuICAgIC8vIHBvc2l0aW9uIG9mIHkgb24gdGhlIHNjcmVlblxcbiAgICBmbG9hdCB5ID0gZ2xfUG9zaXRpb24ueSAvIGdsX1Bvc2l0aW9uLnc7XFxuICAgIC8vIGhvdyBtdWNoIGZlYXR1cmVzIGFyZSBzcXVpc2hlZCBpbiBhbGwgZGlyZWN0aW9ucyBieSB0aGUgcGVyc3BlY3RpdmVuZXNzXFxuICAgIGZsb2F0IHBlcnNwZWN0aXZlX3NjYWxlID0gMS4wIC8gKDEuMCAtIHkgKiB1X2V4dHJhKTtcXG4gICAgdl9nYW1tYV9zY2FsZSA9IHBlcnNwZWN0aXZlX3NjYWxlO1xcblxcbiAgICB2X3RleCA9IGFfdGV4IC8gdV90ZXhzaXplO1xcbiAgICB2X2ZhZGVfdGV4ID0gdmVjMihhX2xhYmVsbWluem9vbSAvIDI1NS4wLCAwLjApO1xcbn1cXG5cIlxuICAgIH0sXG4gICAgY29sbGlzaW9uYm94OiB7XG4gICAgICAgIGZyYWdtZW50U291cmNlOiBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnVuaWZvcm0gZmxvYXQgdV96b29tO1xcbnVuaWZvcm0gZmxvYXQgdV9tYXh6b29tO1xcblxcbnZhcnlpbmcgZmxvYXQgdl9tYXhfem9vbTtcXG52YXJ5aW5nIGZsb2F0IHZfcGxhY2VtZW50X3pvb207XFxuXFxudm9pZCBtYWluKCkge1xcblxcbiAgICBmbG9hdCBhbHBoYSA9IDAuNTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDEuMCwgMC4wLCAxLjApICogYWxwaGE7XFxuXFxuICAgIGlmICh2X3BsYWNlbWVudF96b29tID4gdV96b29tKSB7XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCwgMC4wLCAwLjAsIDEuMCkgKiBhbHBoYTtcXG4gICAgfVxcblxcbiAgICBpZiAodV96b29tID49IHZfbWF4X3pvb20pIHtcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKSAqIGFscGhhICogMC4yNTtcXG4gICAgfVxcblxcbiAgICBpZiAodl9wbGFjZW1lbnRfem9vbSA+PSB1X21heHpvb20pIHtcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDEuMCwgMS4wKSAqIGFscGhhICogMC4yO1xcbiAgICB9XFxufVxcblwiLFxuICAgICAgICB2ZXJ0ZXhTb3VyY2U6IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfZXh0cnVkZTtcXG5hdHRyaWJ1dGUgdmVjMiBhX2RhdGE7XFxuXFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV9zY2FsZTtcXG5cXG52YXJ5aW5nIGZsb2F0IHZfbWF4X3pvb207XFxudmFyeWluZyBmbG9hdCB2X3BsYWNlbWVudF96b29tO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGFfcG9zICsgYV9leHRydWRlIC8gdV9zY2FsZSwgMC4wLCAxLjApO1xcblxcbiAgICAgdl9tYXhfem9vbSA9IGFfZGF0YS54O1xcbiAgICAgdl9wbGFjZW1lbnRfem9vbSA9IGFfZGF0YS55O1xcbn1cXG5cIlxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLl9jcmVhdGVQcm9ncmFtID0gZnVuY3Rpb24obmFtZSwgbWFjcm9zKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICB2YXIgZGVmaW5pdGlvbiA9IGRlZmluaXRpb25zW25hbWVdO1xuXG4gICAgdmFyIGRlZmluZXMgPSAnJztcbiAgICBpZiAobWFjcm9zKSB7XG4gICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgbWFjcm9zLmxlbmd0aDsgbSsrKSB7XG4gICAgICAgICAgICBkZWZpbmVzICs9ICcjZGVmaW5lICcgKyBtYWNyb3NbbV0gKyAnXFxuJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgIGdsLnNoYWRlclNvdXJjZShmcmFnbWVudFNoYWRlciwgZGVmaW5lcyArIGRlZmluaXRpb24uZnJhZ21lbnRTb3VyY2UpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICAgIGFzc2VydChnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSwgZ2wuZ2V0U2hhZGVySW5mb0xvZyhmcmFnbWVudFNoYWRlcikpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG5cbiAgICB2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpO1xuICAgIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIGRlZmluZXMgKyBkZWZpbml0aW9uLnZlcnRleFNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICAgIGFzc2VydChnbC5nZXRTaGFkZXJQYXJhbWV0ZXIodmVydGV4U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUyksIGdsLmdldFNoYWRlckluZm9Mb2codmVydGV4U2hhZGVyKSk7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG5cbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBhc3NlcnQoZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyksIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcblxuICAgIHZhciBhdHRyaWJ1dGVzID0ge307XG4gICAgdmFyIG51bUF0dHJpYnV0ZXMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkFDVElWRV9BVFRSSUJVVEVTKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUF0dHJpYnV0ZXM7IGkrKykge1xuICAgICAgICB2YXIgYXR0cmlidXRlID0gZ2wuZ2V0QWN0aXZlQXR0cmliKHByb2dyYW0sIGkpO1xuICAgICAgICBhdHRyaWJ1dGVzW2F0dHJpYnV0ZS5uYW1lXSA9IGk7XG4gICAgfVxuXG4gICAgdmFyIHVuaWZvcm1zID0ge307XG4gICAgdmFyIG51bVVuaWZvcm1zID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMpO1xuICAgIGZvciAodmFyIHVpID0gMDsgdWkgPCBudW1Vbmlmb3JtczsgdWkrKykge1xuICAgICAgICB2YXIgdW5pZm9ybSA9IGdsLmdldEFjdGl2ZVVuaWZvcm0ocHJvZ3JhbSwgdWkpO1xuICAgICAgICB1bmlmb3Jtc1t1bmlmb3JtLm5hbWVdID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm0ubmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgcHJvZ3JhbTogcHJvZ3JhbSxcbiAgICAgICAgZGVmaW5pdGlvbjogZGVmaW5pdGlvbixcbiAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgICAgbnVtQXR0cmlidXRlczogbnVtQXR0cmlidXRlc1xuICAgIH0sIGF0dHJpYnV0ZXMsIHVuaWZvcm1zKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLl9jcmVhdGVQcm9ncmFtQ2FjaGVkID0gZnVuY3Rpb24obmFtZSwgbWFjcm9zKSB7XG4gICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUgfHwge307XG4gICAgaWYgKHRoaXMuX3Nob3dPdmVyZHJhd0luc3BlY3Rvcikge1xuICAgICAgICBtYWNyb3MgPSBtYWNyb3MgfHwgW107XG4gICAgICAgIG1hY3Jvcy5wdXNoKCdPVkVSRFJBV19JTlNQRUNUT1InKTtcbiAgICB9XG4gICAgdmFyIGtleSA9IEpTT04uc3RyaW5naWZ5KHtuYW1lOiBuYW1lLCBtYWNyb3M6IG1hY3Jvc30pO1xuICAgIGlmICghdGhpcy5jYWNoZVtrZXldKSB7XG4gICAgICAgIHRoaXMuY2FjaGVba2V5XSA9IHRoaXMuX2NyZWF0ZVByb2dyYW0obmFtZSwgbWFjcm9zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVba2V5XTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnVzZVByb2dyYW0gPSBmdW5jdGlvbiAobmV4dFByb2dyYW1OYW1lLCBtYWNyb3MpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdmFyIG5leHRQcm9ncmFtID0gdGhpcy5fY3JlYXRlUHJvZ3JhbUNhY2hlZChuZXh0UHJvZ3JhbU5hbWUsIG1hY3Jvcyk7XG4gICAgdmFyIHByZXZpb3VzUHJvZ3JhbSA9IHRoaXMuY3VycmVudFByb2dyYW07XG5cbiAgICBpZiAocHJldmlvdXNQcm9ncmFtICE9PSBuZXh0UHJvZ3JhbSkge1xuICAgICAgICBnbC51c2VQcm9ncmFtKG5leHRQcm9ncmFtLnByb2dyYW0pO1xuICAgICAgICB0aGlzLmN1cnJlbnRQcm9ncmFtID0gbmV4dFByb2dyYW07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRQcm9ncmFtO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlcnRleEFycmF5T2JqZWN0O1xuXG5mdW5jdGlvbiBWZXJ0ZXhBcnJheU9iamVjdCgpIHtcbiAgICB0aGlzLmJvdW5kUHJvZ3JhbSA9IG51bGw7XG4gICAgdGhpcy5ib3VuZFZlcnRleEJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5ib3VuZFZlcnRleEJ1ZmZlcjIgPSBudWxsO1xuICAgIHRoaXMuYm91bmRFbGVtZW50QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLnZhbyA9IG51bGw7XG59XG5cbnZhciByZXBvcnRlZCA9IGZhbHNlO1xuXG5WZXJ0ZXhBcnJheU9iamVjdC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGdsLCBwcm9ncmFtLCB2ZXJ0ZXhCdWZmZXIsIGVsZW1lbnRCdWZmZXIsIHZlcnRleEJ1ZmZlcjIpIHtcblxuICAgIHZhciBleHQgPSBnbC5leHRWZXJ0ZXhBcnJheU9iamVjdDtcbiAgICBpZiAoZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXh0ID0gZ2wuZXh0VmVydGV4QXJyYXlPYmplY3QgPSBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdmVydGV4X2FycmF5X29iamVjdFwiKTtcbiAgICB9XG5cbiAgICBpZiAoZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy52YW8pIHRoaXMudmFvID0gZXh0LmNyZWF0ZVZlcnRleEFycmF5T0VTKCk7XG4gICAgICAgIGV4dC5iaW5kVmVydGV4QXJyYXlPRVModGhpcy52YW8pO1xuICAgIH0gZWxzZSBpZiAoIXJlcG9ydGVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignTm90IHVzaW5nIFZlcnRleEFycmF5T2JqZWN0IGV4dGVuc2lvbi4nKTtcbiAgICAgICAgcmVwb3J0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5ib3VuZFByb2dyYW0pIHtcblxuICAgICAgICB2YXIgbnVtUHJldkF0dHJpYnV0ZXMgPSBleHQgPyAwIDogKGdsLmN1cnJlbnROdW1BdHRyaWJ1dGVzIHx8IDApO1xuICAgICAgICB2YXIgbnVtTmV4dEF0dHJpYnV0ZXMgPSBwcm9ncmFtLm51bUF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIC8vIEVuYWJsZSBhbGwgYXR0cmlidXRlcyBmb3IgdGhlIG5ldyBwcm9ncmFtLlxuICAgICAgICBmb3IgKGkgPSBudW1QcmV2QXR0cmlidXRlczsgaSA8IG51bU5leHRBdHRyaWJ1dGVzOyBpKyspIHtcbiAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFleHQpIHtcbiAgICAgICAgICAgIC8vIERpc2FibGUgYWxsIGF0dHJpYnV0ZXMgZnJvbSB0aGUgcHJldmlvdXMgcHJvZ3JhbSB0aGF0IGFyZW4ndCB1c2VkIGluXG4gICAgICAgICAgICAvLyB0aGUgbmV3IHByb2dyYW0uIE5vdGU6IGF0dHJpYnV0ZSBpbmRpY2VzIGFyZSAqbm90KiBwcm9ncmFtIHNwZWNpZmljIVxuICAgICAgICAgICAgLy8gV2ViR0wgYnJlYWtzIGlmIHlvdSBkaXNhYmxlIGF0dHJpYnV0ZSAwLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwMzA1MjMxXG4gICAgICAgICAgICBhc3NlcnQoaSA+IDApO1xuICAgICAgICAgICAgZm9yIChpID0gbnVtTmV4dEF0dHJpYnV0ZXM7IGkgPCBudW1QcmV2QXR0cmlidXRlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2wuY3VycmVudE51bUF0dHJpYnV0ZXMgPSBudW1OZXh0QXR0cmlidXRlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZlcnRleEJ1ZmZlci5iaW5kKGdsKTtcbiAgICAgICAgdmVydGV4QnVmZmVyLnNldFZlcnRleEF0dHJpYlBvaW50ZXJzKGdsLCBwcm9ncmFtKTtcbiAgICAgICAgaWYgKHZlcnRleEJ1ZmZlcjIpIHtcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlcjIuYmluZChnbCk7XG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXIyLnNldFZlcnRleEF0dHJpYlBvaW50ZXJzKGdsLCBwcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudEJ1ZmZlcikge1xuICAgICAgICAgICAgZWxlbWVudEJ1ZmZlci5iaW5kKGdsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHQpIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBhcmd1bWVudHMgc28gdGhhdCB3ZSBjYW4gdmVyaWZ5IHRoZW0gd2hlbiB0aGUgdmFvIGlzIGJvdW5kIGFnYWluXG4gICAgICAgICAgICB0aGlzLmJvdW5kUHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgICAgICB0aGlzLmJvdW5kVmVydGV4QnVmZmVyID0gdmVydGV4QnVmZmVyO1xuICAgICAgICAgICAgdGhpcy5ib3VuZFZlcnRleEJ1ZmZlcjIgPSB2ZXJ0ZXhCdWZmZXIyO1xuICAgICAgICAgICAgdGhpcy5ib3VuZEVsZW1lbnRCdWZmZXIgPSBlbGVtZW50QnVmZmVyO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB2ZXJpZnkgdGhhdCBiaW5kIHdhcyBjYWxsZWQgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHNcbiAgICAgICAgYXNzZXJ0KHRoaXMuYm91bmRQcm9ncmFtID09PSBwcm9ncmFtLCAndHJ5aW5nIHRvIGJpbmQgYSBWQU8gdG8gYSBkaWZmZXJlbnQgc2hhZGVyJyk7XG4gICAgICAgIGFzc2VydCh0aGlzLmJvdW5kVmVydGV4QnVmZmVyID09PSB2ZXJ0ZXhCdWZmZXIsICd0cnlpbmcgdG8gYmluZCBhIFZBTyB0byBhIGRpZmZlcmVudCB2ZXJ0ZXggYnVmZmVyJyk7XG4gICAgICAgIGFzc2VydCh0aGlzLmJvdW5kVmVydGV4QnVmZmVyMiA9PT0gdmVydGV4QnVmZmVyMiwgJ3RyeWluZyB0byBiaW5kIGEgVkFPIHRvIGEgZGlmZmVyZW50IHZlcnRleCBidWZmZXInKTtcbiAgICAgICAgYXNzZXJ0KHRoaXMuYm91bmRFbGVtZW50QnVmZmVyID09PSBlbGVtZW50QnVmZmVyLCAndHJ5aW5nIHRvIGJpbmQgYSBWQU8gdG8gYSBkaWZmZXJlbnQgZWxlbWVudCBidWZmZXInKTtcbiAgICB9XG59O1xuXG5WZXJ0ZXhBcnJheU9iamVjdC5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24oZ2wpIHtcbiAgICB2YXIgZXh0ID0gZ2wuZXh0VmVydGV4QXJyYXlPYmplY3Q7XG4gICAgaWYgKGV4dCkge1xuICAgICAgICBleHQuYmluZFZlcnRleEFycmF5T0VTKG51bGwpO1xuICAgIH1cbn07XG5cblZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oZ2wpIHtcbiAgICB2YXIgZXh0ID0gZ2wuZXh0VmVydGV4QXJyYXlPYmplY3Q7XG4gICAgaWYgKGV4dCAmJiB0aGlzLnZhbykge1xuICAgICAgICBleHQuZGVsZXRlVmVydGV4QXJyYXlPRVModGhpcy52YW8pO1xuICAgICAgICB0aGlzLnZhbyA9IG51bGw7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgVGlsZVB5cmFtaWQgPSByZXF1aXJlKCcuL3RpbGVfcHlyYW1pZCcpO1xudmFyIFNvdXJjZSA9IHJlcXVpcmUoJy4vc291cmNlJyk7XG52YXIgdXJsUmVzb2x2ZSA9IHJlcXVpcmUoJ3Jlc29sdmUtdXJsJyk7XG52YXIgRVhURU5UID0gcmVxdWlyZSgnLi4vZGF0YS9idWNrZXQnKS5FWFRFTlQ7XG5cbm1vZHVsZS5leHBvcnRzID0gR2VvSlNPTlNvdXJjZTtcblxuLyoqXG4gKiBDcmVhdGUgYSBHZW9KU09OIGRhdGEgc291cmNlIGluc3RhbmNlIGdpdmVuIGFuIG9wdGlvbnMgb2JqZWN0XG4gKiBAY2xhc3MgR2VvSlNPTlNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBvcHRpb25zLmRhdGEgQSBHZW9KU09OIGRhdGEgb2JqZWN0IG9yIFVSTCB0byBpdC4gVGhlIGxhdHRlciBpcyBwcmVmZXJhYmxlIGluIGNhc2Ugb2YgbGFyZ2UgR2VvSlNPTiBmaWxlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXh6b29tPTE4XSBNYXhpbXVtIHpvb20gdG8gcHJlc2VydmUgZGV0YWlsIGF0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmJ1ZmZlcl0gVGlsZSBidWZmZXIgb24gZWFjaCBzaWRlIGluIHBpeGVscy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50b2xlcmFuY2VdIFNpbXBsaWZpY2F0aW9uIHRvbGVyYW5jZSAoaGlnaGVyIG1lYW5zIHNpbXBsZXIpIGluIHBpeGVscy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jbHVzdGVyXSBJZiB0aGUgZGF0YSBpcyBhIGNvbGxlY3Rpb24gb2YgcG9pbnQgZmVhdHVyZXMsIHNldHRpbmcgdGhpcyB0byB0cnVlIGNsdXN0ZXJzIHRoZSBwb2ludHMgYnkgcmFkaXVzIGludG8gZ3JvdXBzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNsdXN0ZXJSYWRpdXM9NTBdIFJhZGl1cyBvZiBlYWNoIGNsdXN0ZXIgd2hlbiBjbHVzdGVyaW5nIHBvaW50cywgaW4gcGl4ZWxzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNsdXN0ZXJNYXhab29tXSBNYXggem9vbSB0byBjbHVzdGVyIHBvaW50cyBvbi4gRGVmYXVsdHMgdG8gb25lIHpvb20gbGVzcyB0aGFuIGBtYXh6b29tYCAoc28gdGhhdCBsYXN0IHpvb20gZmVhdHVyZXMgYXJlIG5vdCBjbHVzdGVyZWQpLlxuXG4gKiBAZXhhbXBsZVxuICogdmFyIHNvdXJjZU9iaiA9IG5ldyBtYXBib3hnbC5HZW9KU09OU291cmNlKHtcbiAqICAgIGRhdGE6IHtcbiAqICAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICAgICAgIFwiZmVhdHVyZXNcIjogW3tcbiAqICAgICAgICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFtcbiAqICAgICAgICAgICAgICAgICAgICAtNzYuNTMwNjMyOTcyNzE3MjksXG4gKiAgICAgICAgICAgICAgICAgICAgMzkuMTgxNzQwNzc5OTQxMDhcbiAqICAgICAgICAgICAgICAgIF1cbiAqICAgICAgICAgICAgfVxuICogICAgICAgIH1dXG4gKiAgICB9XG4gKiB9KTtcbiAqIG1hcC5hZGRTb3VyY2UoJ3NvbWUgaWQnLCBzb3VyY2VPYmopOyAvLyBhZGRcbiAqIG1hcC5yZW1vdmVTb3VyY2UoJ3NvbWUgaWQnKTsgIC8vIHJlbW92ZVxuICovXG5mdW5jdGlvbiBHZW9KU09OU291cmNlKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuX2RhdGEgPSBvcHRpb25zLmRhdGE7XG5cbiAgICBpZiAob3B0aW9ucy5tYXh6b29tICE9PSB1bmRlZmluZWQpIHRoaXMubWF4em9vbSA9IG9wdGlvbnMubWF4em9vbTtcblxuICAgIHZhciBzY2FsZSA9IEVYVEVOVCAvIHRoaXMudGlsZVNpemU7XG5cbiAgICB0aGlzLmdlb2pzb25WdE9wdGlvbnMgPSB7XG4gICAgICAgIGJ1ZmZlcjogKG9wdGlvbnMuYnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJ1ZmZlciA6IDEyOCkgKiBzY2FsZSxcbiAgICAgICAgdG9sZXJhbmNlOiAob3B0aW9ucy50b2xlcmFuY2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudG9sZXJhbmNlIDogMC4zNzUpICogc2NhbGUsXG4gICAgICAgIGV4dGVudDogRVhURU5ULFxuICAgICAgICBtYXhab29tOiB0aGlzLm1heHpvb21cbiAgICB9O1xuXG4gICAgdGhpcy5jbHVzdGVyID0gb3B0aW9ucy5jbHVzdGVyIHx8IGZhbHNlO1xuICAgIHRoaXMuc3VwZXJjbHVzdGVyT3B0aW9ucyA9IHtcbiAgICAgICAgbWF4Wm9vbTogTWF0aC5taW4ob3B0aW9ucy5jbHVzdGVyTWF4Wm9vbSwgdGhpcy5tYXh6b29tIC0gMSkgfHwgKHRoaXMubWF4em9vbSAtIDEpLFxuICAgICAgICBleHRlbnQ6IEVYVEVOVCxcbiAgICAgICAgcmFkaXVzOiAob3B0aW9ucy5jbHVzdGVyUmFkaXVzIHx8IDUwKSAqIHNjYWxlLFxuICAgICAgICBsb2c6IGZhbHNlXG4gICAgfTtcblxuICAgIHRoaXMuX3B5cmFtaWQgPSBuZXcgVGlsZVB5cmFtaWQoe1xuICAgICAgICB0aWxlU2l6ZTogdGhpcy50aWxlU2l6ZSxcbiAgICAgICAgbWluem9vbTogdGhpcy5taW56b29tLFxuICAgICAgICBtYXh6b29tOiB0aGlzLm1heHpvb20sXG4gICAgICAgIHJlcGFyc2VPdmVyc2NhbGVkOiB0cnVlLFxuICAgICAgICBsb2FkOiB0aGlzLl9sb2FkVGlsZS5iaW5kKHRoaXMpLFxuICAgICAgICBhYm9ydDogdGhpcy5fYWJvcnRUaWxlLmJpbmQodGhpcyksXG4gICAgICAgIHVubG9hZDogdGhpcy5fdW5sb2FkVGlsZS5iaW5kKHRoaXMpLFxuICAgICAgICBhZGQ6IHRoaXMuX2FkZFRpbGUuYmluZCh0aGlzKSxcbiAgICAgICAgcmVtb3ZlOiB0aGlzLl9yZW1vdmVUaWxlLmJpbmQodGhpcyksXG4gICAgICAgIHJlZG9QbGFjZW1lbnQ6IHRoaXMuX3JlZG9UaWxlUGxhY2VtZW50LmJpbmQodGhpcylcbiAgICB9KTtcbn1cblxuR2VvSlNPTlNvdXJjZS5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoRXZlbnRlZCwgLyoqIEBsZW5kcyBHZW9KU09OU291cmNlLnByb3RvdHlwZSAqL3tcbiAgICBtaW56b29tOiAwLFxuICAgIG1heHpvb206IDE4LFxuICAgIHRpbGVTaXplOiA1MTIsXG4gICAgX2RpcnR5OiB0cnVlLFxuICAgIGlzVGlsZUNsaXBwZWQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgc291cmNlIGdlb2pzb24gZGF0YSBhbmQgcmVyZW5kZXIgbWFwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGRhdGEgQSBHZW9KU09OIGRhdGEgb2JqZWN0IG9yIFVSTCB0byBpdC4gVGhlIGxhdHRlciBpcyBwcmVmZXJhYmxlIGluIGNhc2Ugb2YgbGFyZ2UgR2VvSlNPTiBmaWxlcy5cbiAgICAgKiBAcmV0dXJucyB7R2VvSlNPTlNvdXJjZX0gdGhpc1xuICAgICAqL1xuICAgIHNldERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmZpcmUoJ2NoYW5nZScpO1xuXG4gICAgICAgIGlmICh0aGlzLm1hcClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRoaXMubWFwLnRyYW5zZm9ybSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgfSxcblxuICAgIGxvYWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkZWQgJiYgdGhpcy5fcHlyYW1pZC5sb2FkZWQoKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVEYXRhKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbG9hZGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9weXJhbWlkLnVwZGF0ZSh0aGlzLnVzZWQsIHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVsb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xvYWRlZCkge1xuICAgICAgICAgICAgdGhpcy5fcHlyYW1pZC5yZWxvYWQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2dlb2pzb24nLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5fZGF0YVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBnZXRWaXNpYmxlQ29vcmRpbmF0ZXM6IFNvdXJjZS5fZ2V0VmlzaWJsZUNvb3JkaW5hdGVzLFxuICAgIGdldFRpbGU6IFNvdXJjZS5fZ2V0VGlsZSxcblxuICAgIHF1ZXJ5UmVuZGVyZWRGZWF0dXJlczogU291cmNlLl9xdWVyeVJlbmRlcmVkVmVjdG9yRmVhdHVyZXMsXG4gICAgcXVlcnlTb3VyY2VGZWF0dXJlczogU291cmNlLl9xdWVyeVNvdXJjZUZlYXR1cmVzLFxuXG4gICAgX3VwZGF0ZURhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHRpbGVTaXplOiB0aGlzLnRpbGVTaXplLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLmlkLFxuICAgICAgICAgICAgZ2VvanNvblZ0T3B0aW9uczogdGhpcy5nZW9qc29uVnRPcHRpb25zLFxuICAgICAgICAgICAgY2x1c3RlcjogdGhpcy5jbHVzdGVyLFxuICAgICAgICAgICAgc3VwZXJjbHVzdGVyT3B0aW9uczogdGhpcy5zdXBlcmNsdXN0ZXJPcHRpb25zXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBvcHRpb25zLnVybCA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgPyB1cmxSZXNvbHZlKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBkYXRhKSA6IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndvcmtlcklEID0gdGhpcy5kaXNwYXRjaGVyLnNlbmQoJ3BhcnNlIGdlb2pzb24nLCBvcHRpb25zLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIHtlcnJvcjogZXJyfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3B5cmFtaWQucmVsb2FkKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2UnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICBfbG9hZFRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdmFyIG92ZXJzY2FsaW5nID0gdGlsZS5jb29yZC56ID4gdGhpcy5tYXh6b29tID8gTWF0aC5wb3coMiwgdGlsZS5jb29yZC56IC0gdGhpcy5tYXh6b29tKSA6IDE7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICB1aWQ6IHRpbGUudWlkLFxuICAgICAgICAgICAgY29vcmQ6IHRpbGUuY29vcmQsXG4gICAgICAgICAgICB6b29tOiB0aWxlLmNvb3JkLnosXG4gICAgICAgICAgICBtYXhab29tOiB0aGlzLm1heHpvb20sXG4gICAgICAgICAgICB0aWxlU2l6ZTogdGhpcy50aWxlU2l6ZSxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgICAgICAgIG92ZXJzY2FsaW5nOiBvdmVyc2NhbGluZyxcbiAgICAgICAgICAgIGFuZ2xlOiB0aGlzLm1hcC50cmFuc2Zvcm0uYW5nbGUsXG4gICAgICAgICAgICBwaXRjaDogdGhpcy5tYXAudHJhbnNmb3JtLnBpdGNoLFxuICAgICAgICAgICAgc2hvd0NvbGxpc2lvbkJveGVzOiB0aGlzLm1hcC5zaG93Q29sbGlzaW9uQm94ZXNcbiAgICAgICAgfTtcblxuICAgICAgICB0aWxlLndvcmtlcklEID0gdGhpcy5kaXNwYXRjaGVyLnNlbmQoJ2xvYWQgZ2VvanNvbiB0aWxlJywgcGFyYW1zLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcblxuICAgICAgICAgICAgdGlsZS51bmxvYWRWZWN0b3JEYXRhKHRoaXMubWFwLnBhaW50ZXIpO1xuXG4gICAgICAgICAgICBpZiAodGlsZS5hYm9ydGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgndGlsZS5lcnJvcicsIHt0aWxlOiB0aWxlfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aWxlLmxvYWRWZWN0b3JEYXRhKGRhdGEsIHRoaXMubWFwLnN0eWxlKTtcblxuICAgICAgICAgICAgaWYgKHRpbGUucmVkb1doZW5Eb25lKSB7XG4gICAgICAgICAgICAgICAgdGlsZS5yZWRvV2hlbkRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aWxlLnJlZG9QbGFjZW1lbnQodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZmlyZSgndGlsZS5sb2FkJywge3RpbGU6IHRpbGV9KTtcblxuICAgICAgICB9LmJpbmQodGhpcyksIHRoaXMud29ya2VySUQpO1xuICAgIH0sXG5cbiAgICBfYWJvcnRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRpbGUuYWJvcnRlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIF9hZGRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRoaXMuZmlyZSgndGlsZS5hZGQnLCB7dGlsZTogdGlsZX0pO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3RpbGUucmVtb3ZlJywge3RpbGU6IHRpbGV9KTtcbiAgICB9LFxuXG4gICAgX3VubG9hZFRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGlsZS51bmxvYWRWZWN0b3JEYXRhKHRoaXMubWFwLnBhaW50ZXIpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIuc2VuZCgncmVtb3ZlIHRpbGUnLCB7IHVpZDogdGlsZS51aWQsIHNvdXJjZTogdGhpcy5pZCB9LCBudWxsLCB0aWxlLndvcmtlcklEKTtcbiAgICB9LFxuXG4gICAgcmVkb1BsYWNlbWVudDogU291cmNlLnJlZG9QbGFjZW1lbnQsXG5cbiAgICBfcmVkb1RpbGVQbGFjZW1lbnQ6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGlsZS5yZWRvUGxhY2VtZW50KHRoaXMpO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xudmFyIFZlY3RvclRpbGVGZWF0dXJlID0gcmVxdWlyZSgndmVjdG9yLXRpbGUnKS5WZWN0b3JUaWxlRmVhdHVyZTtcbnZhciBFWFRFTlQgPSByZXF1aXJlKCcuLi9kYXRhL2J1Y2tldCcpLkVYVEVOVDtcblxubW9kdWxlLmV4cG9ydHMgPSBHZW9KU09OV3JhcHBlcjtcblxuLy8gY29uZm9ybSB0byB2ZWN0b3J0aWxlIGFwaVxuZnVuY3Rpb24gR2VvSlNPTldyYXBwZXIoZmVhdHVyZXMpIHtcbiAgICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXM7XG4gICAgdGhpcy5sZW5ndGggPSBmZWF0dXJlcy5sZW5ndGg7XG4gICAgdGhpcy5leHRlbnQgPSBFWFRFTlQ7XG59XG5cbkdlb0pTT05XcmFwcGVyLnByb3RvdHlwZS5mZWF0dXJlID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBuZXcgRmVhdHVyZVdyYXBwZXIodGhpcy5mZWF0dXJlc1tpXSk7XG59O1xuXG5mdW5jdGlvbiBGZWF0dXJlV3JhcHBlcihmZWF0dXJlKSB7XG4gICAgdGhpcy50eXBlID0gZmVhdHVyZS50eXBlO1xuICAgIHRoaXMucmF3R2VvbWV0cnkgPSBmZWF0dXJlLnR5cGUgPT09IDEgPyBbZmVhdHVyZS5nZW9tZXRyeV0gOiBmZWF0dXJlLmdlb21ldHJ5O1xuICAgIHRoaXMucHJvcGVydGllcyA9IGZlYXR1cmUudGFncztcbiAgICB0aGlzLmV4dGVudCA9IEVYVEVOVDtcbn1cblxuRmVhdHVyZVdyYXBwZXIucHJvdG90eXBlLmxvYWRHZW9tZXRyeSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByaW5ncyA9IHRoaXMucmF3R2VvbWV0cnk7XG4gICAgdGhpcy5nZW9tZXRyeSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmluZyA9IHJpbmdzW2ldLFxuICAgICAgICAgICAgbmV3UmluZyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpbmcubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIG5ld1JpbmcucHVzaChuZXcgUG9pbnQocmluZ1tqXVswXSwgcmluZ1tqXVsxXSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2VvbWV0cnkucHVzaChuZXdSaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnk7XG59O1xuXG5GZWF0dXJlV3JhcHBlci5wcm90b3R5cGUuYmJveCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5nZW9tZXRyeSkgdGhpcy5sb2FkR2VvbWV0cnkoKTtcblxuICAgIHZhciByaW5ncyA9IHRoaXMuZ2VvbWV0cnksXG4gICAgICAgIHgxID0gSW5maW5pdHksXG4gICAgICAgIHgyID0gLUluZmluaXR5LFxuICAgICAgICB5MSA9IEluZmluaXR5LFxuICAgICAgICB5MiA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSByaW5nc1tpXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpbmcubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBjb29yZCA9IHJpbmdbal07XG5cbiAgICAgICAgICAgIHgxID0gTWF0aC5taW4oeDEsIGNvb3JkLngpO1xuICAgICAgICAgICAgeDIgPSBNYXRoLm1heCh4MiwgY29vcmQueCk7XG4gICAgICAgICAgICB5MSA9IE1hdGgubWluKHkxLCBjb29yZC55KTtcbiAgICAgICAgICAgIHkyID0gTWF0aC5tYXgoeTIsIGNvb3JkLnkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5Ml07XG59O1xuXG5GZWF0dXJlV3JhcHBlci5wcm90b3R5cGUudG9HZW9KU09OID0gVmVjdG9yVGlsZUZlYXR1cmUucHJvdG90eXBlLnRvR2VvSlNPTjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBUaWxlID0gcmVxdWlyZSgnLi90aWxlJyk7XG52YXIgVGlsZUNvb3JkID0gcmVxdWlyZSgnLi90aWxlX2Nvb3JkJyk7XG52YXIgTG5nTGF0ID0gcmVxdWlyZSgnLi4vZ2VvL2xuZ19sYXQnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZCcpO1xudmFyIGFqYXggPSByZXF1aXJlKCcuLi91dGlsL2FqYXgnKTtcbnZhciBFWFRFTlQgPSByZXF1aXJlKCcuLi9kYXRhL2J1Y2tldCcpLkVYVEVOVDtcbnZhciBSYXN0ZXJCb3VuZHNBcnJheSA9IHJlcXVpcmUoJy4uL3JlbmRlci9kcmF3X3Jhc3RlcicpLlJhc3RlckJvdW5kc0FycmF5O1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4uL2RhdGEvYnVmZmVyJyk7XG52YXIgVmVydGV4QXJyYXlPYmplY3QgPSByZXF1aXJlKCcuLi9yZW5kZXIvdmVydGV4X2FycmF5X29iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlU291cmNlO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBJbWFnZSBzb3VyY2UgaW5zdGFuY2UgZ2l2ZW4gYW4gb3B0aW9ucyBvYmplY3RcbiAqIEBjbGFzcyBJbWFnZVNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudXJsIEEgc3RyaW5nIFVSTCBvZiBhbiBpbWFnZSBmaWxlXG4gKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLmNvb3JkaW5hdGVzIEZvdXIgZ2VvZ3JhcGhpY2FsIFtsbmcsIGxhdF0gY29vcmRpbmF0ZXMgaW4gY2xvY2t3aXNlIG9yZGVyIGRlZmluaW5nIHRoZSBjb3JuZXJzIChzdGFydGluZyB3aXRoIHRvcCBsZWZ0KSBvZiB0aGUgaW1hZ2UuIERvZXMgbm90IGhhdmUgdG8gYmUgYSByZWN0YW5nbGUuXG4gKiBAZXhhbXBsZVxuICogdmFyIHNvdXJjZU9iaiA9IG5ldyBtYXBib3hnbC5JbWFnZVNvdXJjZSh7XG4gKiAgICB1cmw6ICdodHRwczovL3d3dy5tYXBib3guY29tL2ltYWdlcy9mb28ucG5nJyxcbiAqICAgIGNvb3JkaW5hdGVzOiBbXG4gKiAgICAgICAgWy03Ni41NDMzNTczNzIyODM5NCwgMzkuMTg1Nzk5MDcyMjk3NDhdLFxuICogICAgICAgIFstNzYuNTI4MDM2NTk0MzkwODcsIDM5LjE4MzgzNjQ4NDc1ODddLFxuICogICAgICAgIFstNzYuNTI5NTM4NjMxNDM5MiwgMzkuMTc2ODMzOTI1MDc2MDZdLFxuICogICAgICAgIFstNzYuNTQ1MjAyNzMyMDg2MTgsIDM5LjE3ODc2MzQ0MTA2NjQyXVxuICogICAgXVxuICogfSk7XG4gKiBtYXAuYWRkU291cmNlKCdzb21lIGlkJywgc291cmNlT2JqKTsgLy8gYWRkXG4gKiBtYXAucmVtb3ZlU291cmNlKCdzb21lIGlkJyk7ICAvLyByZW1vdmVcbiAqL1xuZnVuY3Rpb24gSW1hZ2VTb3VyY2Uob3B0aW9ucykge1xuICAgIHRoaXMudXJscyA9IG9wdGlvbnMudXJscztcbiAgICB0aGlzLmNvb3JkaW5hdGVzID0gb3B0aW9ucy5jb29yZGluYXRlcztcblxuICAgIGFqYXguZ2V0SW1hZ2Uob3B0aW9ucy51cmwsIGZ1bmN0aW9uKGVyciwgaW1hZ2UpIHtcbiAgICAgICAgLy8gQFRPRE8gaGFuZGxlIGVycm9ycyB2aWEgZXZlbnQuXG4gICAgICAgIGlmIChlcnIpIHJldHVybjtcblxuICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG5cbiAgICAgICAgdGhpcy5pbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLm1hcC5fcmVyZW5kZXIoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLl9sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aGlzLm1hcCkge1xuICAgICAgICAgICAgdGhpcy5zZXRDb29yZGluYXRlcyhvcHRpb25zLmNvb3JkaW5hdGVzKTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG59XG5cbkltYWdlU291cmNlLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChFdmVudGVkLCAvKiogQGxlbmRzIEltYWdlU291cmNlLnByb3RvdHlwZSAqLyB7XG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICAgICAgaWYgKHRoaXMuaW1hZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29vcmRpbmF0ZXModGhpcy5jb29yZGluYXRlcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGltYWdlIGNvb3JkaW5hdGVzIGFuZCByZXJlbmRlciBtYXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvb3JkaW5hdGVzIEZvdXIgZ2VvZ3JhcGhpY2FsIFtsbmcsIGxhdF0gY29vcmRpbmF0ZXMgaW4gY2xvY2t3aXNlIG9yZGVyIGRlZmluaW5nIHRoZSBjb3JuZXJzIChzdGFydGluZyB3aXRoIHRvcCBsZWZ0KSBvZiB0aGUgaW1hZ2UuIERvZXMgbm90IGhhdmUgdG8gYmUgYSByZWN0YW5nbGUuXG4gICAgICogQHJldHVybnMge0ltYWdlU291cmNlfSB0aGlzXG4gICAgICovXG4gICAgc2V0Q29vcmRpbmF0ZXM6IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHRoaXMuY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlcztcblxuICAgICAgICAvLyBDYWxjdWxhdGUgd2hpY2ggbWVyY2F0b3IgdGlsZSBpcyBzdWl0YWJsZSBmb3IgcmVuZGVyaW5nIHRoZSBpbWFnZSBpblxuICAgICAgICAvLyBhbmQgY3JlYXRlIGEgYnVmZmVyIHdpdGggdGhlIGNvcm5lciBjb29yZGluYXRlcy4gVGhlc2UgY29vcmRpbmF0ZXNcbiAgICAgICAgLy8gbWF5IGJlIG91dHNpZGUgdGhlIHRpbGUsIGJlY2F1c2UgcmFzdGVyIHRpbGVzIGFyZW4ndCBjbGlwcGVkIHdoZW4gcmVuZGVyaW5nLlxuXG4gICAgICAgIHZhciBtYXAgPSB0aGlzLm1hcDtcbiAgICAgICAgdmFyIGNvcm5lclowQ29vcmRzID0gY29vcmRpbmF0ZXMubWFwKGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwLnRyYW5zZm9ybS5sb2NhdGlvbkNvb3JkaW5hdGUoTG5nTGF0LmNvbnZlcnQoY29vcmQpKS56b29tVG8oMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBjZW50ZXJDb29yZCA9IHRoaXMuY2VudGVyQ29vcmQgPSB1dGlsLmdldENvb3JkaW5hdGVzQ2VudGVyKGNvcm5lclowQ29vcmRzKTtcbiAgICAgICAgY2VudGVyQ29vcmQuY29sdW1uID0gTWF0aC5yb3VuZChjZW50ZXJDb29yZC5jb2x1bW4pO1xuICAgICAgICBjZW50ZXJDb29yZC5yb3cgPSBNYXRoLnJvdW5kKGNlbnRlckNvb3JkLnJvdyk7XG5cbiAgICAgICAgdmFyIHRpbGVDb29yZHMgPSBjb3JuZXJaMENvb3Jkcy5tYXAoZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgICAgIHZhciB6b29tZWRDb29yZCA9IGNvb3JkLnpvb21UbyhjZW50ZXJDb29yZC56b29tKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgoem9vbWVkQ29vcmQuY29sdW1uIC0gY2VudGVyQ29vcmQuY29sdW1uKSAqIEVYVEVOVCksXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgoem9vbWVkQ29vcmQucm93IC0gY2VudGVyQ29vcmQucm93KSAqIEVYVEVOVCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgbWF4SW50MTYgPSAzMjc2NztcbiAgICAgICAgdmFyIGFycmF5ID0gbmV3IFJhc3RlckJvdW5kc0FycmF5KCk7XG4gICAgICAgIGFycmF5LmVtcGxhY2VCYWNrKHRpbGVDb29yZHNbMF0ueCwgdGlsZUNvb3Jkc1swXS55LCAwLCAwKTtcbiAgICAgICAgYXJyYXkuZW1wbGFjZUJhY2sodGlsZUNvb3Jkc1sxXS54LCB0aWxlQ29vcmRzWzFdLnksIG1heEludDE2LCAwKTtcbiAgICAgICAgYXJyYXkuZW1wbGFjZUJhY2sodGlsZUNvb3Jkc1szXS54LCB0aWxlQ29vcmRzWzNdLnksIDAsIG1heEludDE2KTtcbiAgICAgICAgYXJyYXkuZW1wbGFjZUJhY2sodGlsZUNvb3Jkc1syXS54LCB0aWxlQ29vcmRzWzJdLnksIG1heEludDE2LCBtYXhJbnQxNik7XG5cbiAgICAgICAgdGhpcy50aWxlID0gbmV3IFRpbGUobmV3IFRpbGVDb29yZChjZW50ZXJDb29yZC56b29tLCBjZW50ZXJDb29yZC5jb2x1bW4sIGNlbnRlckNvb3JkLnJvdykpO1xuICAgICAgICB0aGlzLnRpbGUuYnVja2V0cyA9IHt9O1xuXG4gICAgICAgIHRoaXMudGlsZS5ib3VuZHNCdWZmZXIgPSBuZXcgQnVmZmVyKGFycmF5LnNlcmlhbGl6ZSgpLCBSYXN0ZXJCb3VuZHNBcnJheS5zZXJpYWxpemUoKSwgQnVmZmVyLkJ1ZmZlclR5cGUuVkVSVEVYKTtcbiAgICAgICAgdGhpcy50aWxlLmJvdW5kc1ZBTyA9IG5ldyBWZXJ0ZXhBcnJheU9iamVjdCgpO1xuXG4gICAgICAgIHRoaXMuZmlyZSgnY2hhbmdlJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGxvYWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlICYmIHRoaXMuaW1hZ2UuY29tcGxldGU7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9LFxuXG4gICAgcmVsb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH0sXG5cbiAgICBwcmVwYXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQgfHwgIXRoaXMubG9hZGVkKCkpIHJldHVybjtcblxuICAgICAgICB2YXIgcGFpbnRlciA9IHRoaXMubWFwLnBhaW50ZXI7XG4gICAgICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG5cbiAgICAgICAgaWYgKCF0aGlzLnRpbGUudGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy50aWxlLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRpbGUudGV4dHVyZSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5pbWFnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRpbGUudGV4dHVyZSk7XG4gICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuaW1hZ2UpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFZpc2libGVDb29yZGluYXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbGUpIHJldHVybiBbdGhpcy50aWxlLmNvb3JkXTtcbiAgICAgICAgZWxzZSByZXR1cm4gW107XG4gICAgfSxcblxuICAgIGdldFRpbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlO1xuICAgIH0sXG5cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgICAgIHVybHM6IHRoaXMudXJscyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiB0aGlzLmNvb3JkaW5hdGVzXG4gICAgICAgIH07XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCdWNrZXQgPSByZXF1aXJlKCcuLi9kYXRhL2J1Y2tldCcpO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgcGl4ZWwgdmFsdWUgYXQgYSB0aGUgZ2l2ZW4gem9vbSBsZXZlbCB0byB0aWxlIHVuaXRzLlxuICpcbiAqIFRoZSBzaGFkZXJzIG1vc3RseSBjYWxjdWxhdGUgZXZlcnl0aGluZyBpbiB0aWxlIHVuaXRzIHNvIHN0eWxlXG4gKiBwcm9wZXJ0aWVzIG5lZWQgdG8gYmUgY29udmVydGVkIGZyb20gcGl4ZWxzIHRvIHRpbGUgdW5pdHMgdXNpbmcgdGhpcy5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgYSB0cmFuc2xhdGlvbiBieSAzMCBwaXhlbHMgYXQgem9vbSA2LjUgd2lsbCBiZSBhXG4gKiB0cmFuc2xhdGlvbiBieSBwaXhlbHNUb1RpbGVVbml0cygzMCwgNi41KSB0aWxlIHVuaXRzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0aWxlIGEge1RpbGUgb2JqZWN0fSB3aWxsIHdvcmsgd2VsbCwgYnV0IGFueSBvYmplY3QgdGhhdCBmb2xsb3dzIHRoZSBmb3JtYXQge2Nvb3JkOiB7VGlsZUNvcmQgb2JqZWN0fSwgdGlsZVNpemU6IHtudW1iZXJ9fSB3aWxsIHdvcmtcbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gelxuICogQHJldHVybnMge251bWJlcn0gdmFsdWUgaW4gdGlsZSB1bml0c1xuICogQHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aWxlLCBwaXhlbFZhbHVlLCB6KSB7XG4gICAgcmV0dXJuIHBpeGVsVmFsdWUgKiAoQnVja2V0LkVYVEVOVCAvICh0aWxlLnRpbGVTaXplICogTWF0aC5wb3coMiwgeiAtIHRpbGUuY29vcmQueikpKTtcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4Jyk7XG52YXIgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZCcpO1xudmFyIFNvdXJjZSA9IHJlcXVpcmUoJy4vc291cmNlJyk7XG52YXIgbm9ybWFsaXplVVJMID0gcmVxdWlyZSgnLi4vdXRpbC9tYXBib3gnKS5ub3JtYWxpemVUaWxlVVJMO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhc3RlclRpbGVTb3VyY2U7XG5cbmZ1bmN0aW9uIFJhc3RlclRpbGVTb3VyY2Uob3B0aW9ucykge1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMsIHV0aWwucGljayhvcHRpb25zLCBbJ3VybCcsICd0aWxlU2l6ZSddKSk7XG5cbiAgICBTb3VyY2UuX2xvYWRUaWxlSlNPTi5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5SYXN0ZXJUaWxlU291cmNlLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChFdmVudGVkLCB7XG4gICAgbWluem9vbTogMCxcbiAgICBtYXh6b29tOiAyMixcbiAgICByb3VuZFpvb206IHRydWUsXG4gICAgdGlsZVNpemU6IDUxMixcbiAgICBfbG9hZGVkOiBmYWxzZSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgfSxcblxuICAgIGxvYWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9weXJhbWlkICYmIHRoaXMuX3B5cmFtaWQubG9hZGVkKCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICh0aGlzLl9weXJhbWlkKSB7XG4gICAgICAgICAgICB0aGlzLl9weXJhbWlkLnVwZGF0ZSh0aGlzLnVzZWQsIHRyYW5zZm9ybSwgdGhpcy5tYXAuc3R5bGUucmFzdGVyRmFkZUR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBub29wXG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAncmFzdGVyJyxcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgICB0aWxlU2l6ZTogdGhpcy50aWxlU2l6ZVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBnZXRWaXNpYmxlQ29vcmRpbmF0ZXM6IFNvdXJjZS5fZ2V0VmlzaWJsZUNvb3JkaW5hdGVzLFxuICAgIGdldFRpbGU6IFNvdXJjZS5fZ2V0VGlsZSxcblxuICAgIF9sb2FkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB2YXIgdXJsID0gbm9ybWFsaXplVVJMKHRpbGUuY29vcmQudXJsKHRoaXMudGlsZXMpLCB0aGlzLnVybCwgdGhpcy50aWxlU2l6ZSk7XG5cbiAgICAgICAgdGlsZS5yZXF1ZXN0ID0gYWpheC5nZXRJbWFnZSh1cmwsIGRvbmUuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgZnVuY3Rpb24gZG9uZShlcnIsIGltZykge1xuICAgICAgICAgICAgZGVsZXRlIHRpbGUucmVxdWVzdDtcblxuICAgICAgICAgICAgaWYgKHRpbGUuYWJvcnRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aWxlLmVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgndGlsZS5lcnJvcicsIHt0aWxlOiB0aWxlLCBlcnJvcjogZXJyfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLm1hcC5wYWludGVyLmdsO1xuICAgICAgICAgICAgdGlsZS50ZXh0dXJlID0gdGhpcy5tYXAucGFpbnRlci5nZXRUZXh0dXJlKGltZy53aWR0aCk7XG4gICAgICAgICAgICBpZiAodGlsZS50ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGlsZS50ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGltZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbGUudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aWxlLnRleHR1cmUpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1QpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBpbWcpO1xuICAgICAgICAgICAgICAgIHRpbGUudGV4dHVyZS5zaXplID0gaW1nLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG5cbiAgICAgICAgICAgIHRpbGUudGltZUFkZGVkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB0aGlzLm1hcC5hbmltYXRpb25Mb29wLnNldCh0aGlzLnN0eWxlLnJhc3RlckZhZGVEdXJhdGlvbik7XG5cbiAgICAgICAgICAgIHRpbGUuc291cmNlID0gdGhpcztcbiAgICAgICAgICAgIHRpbGUubG9hZGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5maXJlKCd0aWxlLmxvYWQnLCB7dGlsZTogdGlsZX0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9hYm9ydFRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGlsZS5hYm9ydGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGlsZS5yZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aWxlLnJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aWxlLnJlcXVlc3Q7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2FkZFRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGhpcy5maXJlKCd0aWxlLmFkZCcsIHt0aWxlOiB0aWxlfSk7XG4gICAgfSxcblxuICAgIF9yZW1vdmVUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRoaXMuZmlyZSgndGlsZS5yZW1vdmUnLCB7dGlsZTogdGlsZX0pO1xuICAgIH0sXG5cbiAgICBfdW5sb2FkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICBpZiAodGlsZS50ZXh0dXJlKSB0aGlzLm1hcC5wYWludGVyLnNhdmVUZXh0dXJlKHRpbGUudGV4dHVyZSk7XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgYWpheCA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheCcpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXInKTtcbnZhciBUaWxlUHlyYW1pZCA9IHJlcXVpcmUoJy4vdGlsZV9weXJhbWlkJyk7XG52YXIgbm9ybWFsaXplVVJMID0gcmVxdWlyZSgnLi4vdXRpbC9tYXBib3gnKS5ub3JtYWxpemVTb3VyY2VVUkw7XG52YXIgVGlsZUNvb3JkID0gcmVxdWlyZSgnLi90aWxlX2Nvb3JkJyk7XG5cbmV4cG9ydHMuX2xvYWRUaWxlSlNPTiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgbG9hZGVkID0gZnVuY3Rpb24oZXJyLCB0aWxlSlNPTikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2Vycm9yJywge2Vycm9yOiBlcnJ9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHV0aWwuZXh0ZW5kKHRoaXMsIHV0aWwucGljayh0aWxlSlNPTixcbiAgICAgICAgICAgIFsndGlsZXMnLCAnbWluem9vbScsICdtYXh6b29tJywgJ2F0dHJpYnV0aW9uJ10pKTtcblxuICAgICAgICBpZiAodGlsZUpTT04udmVjdG9yX2xheWVycykge1xuICAgICAgICAgICAgdGhpcy52ZWN0b3JMYXllcnMgPSB0aWxlSlNPTi52ZWN0b3JfbGF5ZXJzO1xuICAgICAgICAgICAgdGhpcy52ZWN0b3JMYXllcklkcyA9IHRoaXMudmVjdG9yTGF5ZXJzLm1hcChmdW5jdGlvbihsYXllcikgeyByZXR1cm4gbGF5ZXIuaWQ7IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcHlyYW1pZCA9IG5ldyBUaWxlUHlyYW1pZCh7XG4gICAgICAgICAgICB0aWxlU2l6ZTogdGhpcy50aWxlU2l6ZSxcbiAgICAgICAgICAgIG1pbnpvb206IHRoaXMubWluem9vbSxcbiAgICAgICAgICAgIG1heHpvb206IHRoaXMubWF4em9vbSxcbiAgICAgICAgICAgIHJvdW5kWm9vbTogdGhpcy5yb3VuZFpvb20sXG4gICAgICAgICAgICByZXBhcnNlT3ZlcnNjYWxlZDogdGhpcy5yZXBhcnNlT3ZlcnNjYWxlZCxcbiAgICAgICAgICAgIGxvYWQ6IHRoaXMuX2xvYWRUaWxlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBhYm9ydDogdGhpcy5fYWJvcnRUaWxlLmJpbmQodGhpcyksXG4gICAgICAgICAgICB1bmxvYWQ6IHRoaXMuX3VubG9hZFRpbGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGFkZDogdGhpcy5fYWRkVGlsZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgcmVtb3ZlOiB0aGlzLl9yZW1vdmVUaWxlLmJpbmQodGhpcyksXG4gICAgICAgICAgICByZWRvUGxhY2VtZW50OiB0aGlzLl9yZWRvVGlsZVBsYWNlbWVudCA/IHRoaXMuX3JlZG9UaWxlUGxhY2VtZW50LmJpbmQodGhpcykgOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5maXJlKCdsb2FkJyk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgaWYgKG9wdGlvbnMudXJsKSB7XG4gICAgICAgIGFqYXguZ2V0SlNPTihub3JtYWxpemVVUkwob3B0aW9ucy51cmwpLCBsb2FkZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJyb3dzZXIuZnJhbWUobG9hZGVkLmJpbmQodGhpcywgbnVsbCwgb3B0aW9ucykpO1xuICAgIH1cbn07XG5cbmV4cG9ydHMucmVkb1BsYWNlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fcHlyYW1pZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlkcyA9IHRoaXMuX3B5cmFtaWQub3JkZXJlZElEcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0aWxlID0gdGhpcy5fcHlyYW1pZC5nZXRUaWxlKGlkc1tpXSk7XG4gICAgICAgIHRoaXMuX3JlZG9UaWxlUGxhY2VtZW50KHRpbGUpO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuX2dldFRpbGUgPSBmdW5jdGlvbihjb29yZCkge1xuICAgIHJldHVybiB0aGlzLl9weXJhbWlkLmdldFRpbGUoY29vcmQuaWQpO1xufTtcblxuZXhwb3J0cy5fZ2V0VmlzaWJsZUNvb3JkaW5hdGVzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9weXJhbWlkKSByZXR1cm4gW107XG4gICAgZWxzZSByZXR1cm4gdGhpcy5fcHlyYW1pZC5yZW5kZXJlZElEcygpLm1hcChUaWxlQ29vcmQuZnJvbUlEKTtcbn07XG5cbmZ1bmN0aW9uIHNvcnRUaWxlc0luKGEsIGIpIHtcbiAgICB2YXIgY29vcmRBID0gYS50aWxlLmNvb3JkO1xuICAgIHZhciBjb29yZEIgPSBiLnRpbGUuY29vcmQ7XG4gICAgcmV0dXJuIChjb29yZEEueiAtIGNvb3JkQi56KSB8fCAoY29vcmRBLnkgLSBjb29yZEIueSkgfHwgKGNvb3JkQS54IC0gY29vcmRCLngpO1xufVxuXG5mdW5jdGlvbiBtZXJnZVJlbmRlcmVkRmVhdHVyZUxheWVycyh0aWxlcykge1xuICAgIHZhciByZXN1bHQgPSB0aWxlc1swXSB8fCB7fTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0aWxlID0gdGlsZXNbaV07XG4gICAgICAgIGZvciAodmFyIGxheWVySUQgaW4gdGlsZSkge1xuICAgICAgICAgICAgdmFyIHRpbGVGZWF0dXJlcyA9IHRpbGVbbGF5ZXJJRF07XG4gICAgICAgICAgICB2YXIgcmVzdWx0RmVhdHVyZXMgPSByZXN1bHRbbGF5ZXJJRF07XG4gICAgICAgICAgICBpZiAocmVzdWx0RmVhdHVyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdEZlYXR1cmVzID0gcmVzdWx0W2xheWVySURdID0gdGlsZUZlYXR1cmVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBmID0gMDsgZiA8IHRpbGVGZWF0dXJlcy5sZW5ndGg7IGYrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRGZWF0dXJlcy5wdXNoKHRpbGVGZWF0dXJlc1tmXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydHMuX3F1ZXJ5UmVuZGVyZWRWZWN0b3JGZWF0dXJlcyA9IGZ1bmN0aW9uKHF1ZXJ5R2VvbWV0cnksIHBhcmFtcywgem9vbSwgYmVhcmluZykge1xuICAgIGlmICghdGhpcy5fcHlyYW1pZClcbiAgICAgICAgcmV0dXJuIHt9O1xuXG4gICAgdmFyIHRpbGVzSW4gPSB0aGlzLl9weXJhbWlkLnRpbGVzSW4ocXVlcnlHZW9tZXRyeSk7XG5cbiAgICB0aWxlc0luLnNvcnQoc29ydFRpbGVzSW4pO1xuXG4gICAgdmFyIHN0eWxlTGF5ZXJzID0gdGhpcy5tYXAuc3R5bGUuX2xheWVycztcblxuICAgIHZhciByZW5kZXJlZEZlYXR1cmVMYXllcnMgPSBbXTtcbiAgICBmb3IgKHZhciByID0gMDsgciA8IHRpbGVzSW4ubGVuZ3RoOyByKyspIHtcbiAgICAgICAgdmFyIHRpbGVJbiA9IHRpbGVzSW5bcl07XG4gICAgICAgIGlmICghdGlsZUluLnRpbGUuZmVhdHVyZUluZGV4KSBjb250aW51ZTtcblxuICAgICAgICByZW5kZXJlZEZlYXR1cmVMYXllcnMucHVzaCh0aWxlSW4udGlsZS5mZWF0dXJlSW5kZXgucXVlcnkoe1xuICAgICAgICAgICAgcXVlcnlHZW9tZXRyeTogdGlsZUluLnF1ZXJ5R2VvbWV0cnksXG4gICAgICAgICAgICBzY2FsZTogdGlsZUluLnNjYWxlLFxuICAgICAgICAgICAgdGlsZVNpemU6IHRpbGVJbi50aWxlLnRpbGVTaXplLFxuICAgICAgICAgICAgYmVhcmluZzogYmVhcmluZyxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICAgIH0sIHN0eWxlTGF5ZXJzKSk7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZVJlbmRlcmVkRmVhdHVyZUxheWVycyhyZW5kZXJlZEZlYXR1cmVMYXllcnMpO1xufTtcblxuZXhwb3J0cy5fcXVlcnlTb3VyY2VGZWF0dXJlcyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIGlmICghdGhpcy5fcHlyYW1pZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHB5cmFtaWQgPSB0aGlzLl9weXJhbWlkO1xuICAgIHZhciB0aWxlcyA9IHB5cmFtaWQucmVuZGVyZWRJRHMoKS5tYXAoZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHB5cmFtaWQuZ2V0VGlsZShpZCk7XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICB2YXIgZGF0YVRpbGVzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGlsZSA9IHRpbGVzW2ldO1xuICAgICAgICB2YXIgZGF0YUlEID0gbmV3IFRpbGVDb29yZChNYXRoLm1pbih0aWxlLnNvdXJjZU1heFpvb20sIHRpbGUuY29vcmQueiksIHRpbGUuY29vcmQueCwgdGlsZS5jb29yZC55LCAwKS5pZDtcbiAgICAgICAgaWYgKCFkYXRhVGlsZXNbZGF0YUlEXSkge1xuICAgICAgICAgICAgZGF0YVRpbGVzW2RhdGFJRF0gPSB0cnVlO1xuICAgICAgICAgICAgdGlsZS5xdWVyeVNvdXJjZUZlYXR1cmVzKHJlc3VsdCwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKlxuICogQ3JlYXRlIGEgdGlsZWQgZGF0YSBzb3VyY2UgaW5zdGFuY2UgZ2l2ZW4gYW4gb3B0aW9ucyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudHlwZSBFaXRoZXIgYHJhc3RlcmAgb3IgYHZlY3RvcmAuXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51cmwgQSB0aWxlIHNvdXJjZSBVUkwuIFRoaXMgc2hvdWxkIGVpdGhlciBiZSBgbWFwYm94Oi8ve21hcGlkfWAgb3IgYSBmdWxsIGBodHRwW3NdYCB1cmwgdGhhdCBwb2ludHMgdG8gYSBUaWxlSlNPTiBlbmRwb2ludC5cbiAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbnMudGlsZXMgQW4gYXJyYXkgb2YgdGlsZSBzb3VyY2VzLiBJZiBgdXJsYCBpcyBub3Qgc3BlY2lmaWVkLCBgdGlsZXNgIGNhbiBiZSB1c2VkIGluc3RlYWQgdG8gc3BlY2lmeSB0aWxlIHNvdXJjZXMsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLiBPdGhlciBUaWxlSlNPTiBrZXlzIHN1Y2ggYXMgYG1pbnpvb21gIGFuZCBgbWF4em9vbWAgY2FuIGJlIHNwZWNpZmllZCBpbiBhIHNvdXJjZSBvYmplY3QgaWYgYHRpbGVzYCBpcyB1c2VkLlxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuaWQgQW4gb3B0aW9uYWwgYGlkYCB0byBhc3NpZ24gdG8gdGhlIHNvdXJjZVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRpbGVTaXplPTUxMl0gT3B0aW9uYWwgdGlsZSBzaXplICh3aWR0aCBhbmQgaGVpZ2h0IGluIHBpeGVscywgYXNzdW1pbmcgdGlsZXMgYXJlIHNxdWFyZSkuIFRoaXMgb3B0aW9uIGlzIG9ubHkgY29uZmlndXJhYmxlIGZvciByYXN0ZXIgc291cmNlc1xuICogQGV4YW1wbGVcbiAqIHZhciBzb3VyY2VPYmogPSBuZXcgbWFwYm94Z2wuU291cmNlLmNyZWF0ZSh7XG4gKiAgICB0eXBlOiAndmVjdG9yJyxcbiAqICAgIHVybDogJ21hcGJveDovL21hcGJveC5tYXBib3gtc3RyZWV0cy12NSdcbiAqIH0pO1xuICogbWFwLmFkZFNvdXJjZSgnc29tZSBpZCcsIHNvdXJjZU9iaik7IC8vIGFkZFxuICogbWFwLnJlbW92ZVNvdXJjZSgnc29tZSBpZCcpOyAgLy8gcmVtb3ZlXG4gKi9cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgLy8gVGhpcyBpcyBub3QgYXQgZmlsZSBzY29wZSBpbiBvcmRlciB0byBhdm9pZCBhIGNpcmN1bGFyIHJlcXVpcmUuXG4gICAgdmFyIHNvdXJjZXMgPSB7XG4gICAgICAgIHZlY3RvcjogcmVxdWlyZSgnLi92ZWN0b3JfdGlsZV9zb3VyY2UnKSxcbiAgICAgICAgcmFzdGVyOiByZXF1aXJlKCcuL3Jhc3Rlcl90aWxlX3NvdXJjZScpLFxuICAgICAgICBnZW9qc29uOiByZXF1aXJlKCcuL2dlb2pzb25fc291cmNlJyksXG4gICAgICAgIHZpZGVvOiByZXF1aXJlKCcuL3ZpZGVvX3NvdXJjZScpLFxuICAgICAgICBpbWFnZTogcmVxdWlyZSgnLi9pbWFnZV9zb3VyY2UnKVxuICAgIH07XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pcyhzb3VyY2UpID8gc291cmNlIDogbmV3IHNvdXJjZXNbc291cmNlLnR5cGVdKHNvdXJjZSk7XG59O1xuXG5leHBvcnRzLmlzID0gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgLy8gVGhpcyBpcyBub3QgYXQgZmlsZSBzY29wZSBpbiBvcmRlciB0byBhdm9pZCBhIGNpcmN1bGFyIHJlcXVpcmUuXG4gICAgdmFyIHNvdXJjZXMgPSB7XG4gICAgICAgIHZlY3RvcjogcmVxdWlyZSgnLi92ZWN0b3JfdGlsZV9zb3VyY2UnKSxcbiAgICAgICAgcmFzdGVyOiByZXF1aXJlKCcuL3Jhc3Rlcl90aWxlX3NvdXJjZScpLFxuICAgICAgICBnZW9qc29uOiByZXF1aXJlKCcuL2dlb2pzb25fc291cmNlJyksXG4gICAgICAgIHZpZGVvOiByZXF1aXJlKCcuL3ZpZGVvX3NvdXJjZScpLFxuICAgICAgICBpbWFnZTogcmVxdWlyZSgnLi9pbWFnZV9zb3VyY2UnKVxuICAgIH07XG5cbiAgICBmb3IgKHZhciB0eXBlIGluIHNvdXJjZXMpIHtcbiAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIHNvdXJjZXNbdHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBCdWNrZXQgPSByZXF1aXJlKCcuLi9kYXRhL2J1Y2tldCcpO1xudmFyIEZlYXR1cmVJbmRleCA9IHJlcXVpcmUoJy4uL2RhdGEvZmVhdHVyZV9pbmRleCcpO1xudmFyIHZ0ID0gcmVxdWlyZSgndmVjdG9yLXRpbGUnKTtcbnZhciBQcm90b2J1ZiA9IHJlcXVpcmUoJ3BiZicpO1xudmFyIEdlb0pTT05GZWF0dXJlID0gcmVxdWlyZSgnLi4vdXRpbC92ZWN0b3J0aWxlX3RvX2dlb2pzb24nKTtcbnZhciBmZWF0dXJlRmlsdGVyID0gcmVxdWlyZSgnZmVhdHVyZS1maWx0ZXInKTtcbnZhciBDb2xsaXNpb25UaWxlID0gcmVxdWlyZSgnLi4vc3ltYm9sL2NvbGxpc2lvbl90aWxlJyk7XG52YXIgQ29sbGlzaW9uQm94QXJyYXkgPSByZXF1aXJlKCcuLi9zeW1ib2wvY29sbGlzaW9uX2JveCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGU7XG5cbi8qKlxuICogQSB0aWxlIG9iamVjdCBpcyB0aGUgY29tYmluYXRpb24gb2YgYSBDb29yZGluYXRlLCB3aGljaCBkZWZpbmVzXG4gKiBpdHMgcGxhY2UsIGFzIHdlbGwgYXMgYSB1bmlxdWUgSUQgYW5kIGRhdGEgdHJhY2tpbmcgZm9yIGl0cyBjb250ZW50XG4gKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZFxuICogQHBhcmFtIHtudW1iZXJ9IHNpemVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFRpbGUoY29vcmQsIHNpemUsIHNvdXJjZU1heFpvb20pIHtcbiAgICB0aGlzLmNvb3JkID0gY29vcmQ7XG4gICAgdGhpcy51aWQgPSB1dGlsLnVuaXF1ZUlkKCk7XG4gICAgdGhpcy5sb2FkZWQgPSBmYWxzZTsgLy8gVE9ETyByZW5hbWUgbG9hZGVkXG4gICAgdGhpcy5pc1VubG9hZGVkID0gZmFsc2U7XG4gICAgdGhpcy51c2VzID0gMDtcbiAgICB0aGlzLnRpbGVTaXplID0gc2l6ZTtcbiAgICB0aGlzLnNvdXJjZU1heFpvb20gPSBzb3VyY2VNYXhab29tO1xuICAgIHRoaXMuYnVja2V0cyA9IHt9O1xufVxuXG5UaWxlLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgZGF0YSBvYmplY3Qgd2l0aCBhICdidWZmZXJzJyBwcm9wZXJ0eSwgbG9hZCBpdCBpbnRvXG4gICAgICogdGhpcyB0aWxlJ3MgZWxlbWVudEdyb3VwcyBhbmQgYnVmZmVycyBwcm9wZXJ0aWVzIGFuZCBzZXQgbG9hZGVkXG4gICAgICogdG8gdHJ1ZS4gSWYgdGhlIGRhdGEgaXMgbnVsbCwgbGlrZSBpbiB0aGUgY2FzZSBvZiBhbiBlbXB0eVxuICAgICAqIEdlb0pTT04gdGlsZSwgbm8tb3AgYnV0IHN0aWxsIHNldCBsb2FkZWQgdG8gdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBsb2FkVmVjdG9yRGF0YTogZnVuY3Rpb24oZGF0YSwgc3R5bGUpIHtcbiAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIGVtcHR5IEdlb0pTT04gdGlsZVxuICAgICAgICBpZiAoIWRhdGEpIHJldHVybjtcblxuICAgICAgICB0aGlzLmNvbGxpc2lvbkJveEFycmF5ID0gbmV3IENvbGxpc2lvbkJveEFycmF5KGRhdGEuY29sbGlzaW9uQm94QXJyYXkpO1xuICAgICAgICB0aGlzLmNvbGxpc2lvblRpbGUgPSBuZXcgQ29sbGlzaW9uVGlsZShkYXRhLmNvbGxpc2lvblRpbGUsIHRoaXMuY29sbGlzaW9uQm94QXJyYXkpO1xuICAgICAgICB0aGlzLmZlYXR1cmVJbmRleCA9IG5ldyBGZWF0dXJlSW5kZXgoZGF0YS5mZWF0dXJlSW5kZXgsIGRhdGEucmF3VGlsZURhdGEsIHRoaXMuY29sbGlzaW9uVGlsZSk7XG4gICAgICAgIHRoaXMucmF3VGlsZURhdGEgPSBkYXRhLnJhd1RpbGVEYXRhO1xuICAgICAgICB0aGlzLmJ1Y2tldHMgPSB1bnNlcmlhbGl6ZUJ1Y2tldHMoZGF0YS5idWNrZXRzLCBzdHlsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdpdmVuIGEgZGF0YSBvYmplY3QgYW5kIGEgR0wgcGFpbnRlciwgZGVzdHJveSBhbmQgcmUtY3JlYXRlXG4gICAgICogYWxsIG9mIGl0cyBidWZmZXJzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhaW50ZXJcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmVsb2FkU3ltYm9sRGF0YTogZnVuY3Rpb24oZGF0YSwgcGFpbnRlciwgc3R5bGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNVbmxvYWRlZCkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuY29sbGlzaW9uVGlsZSA9IG5ldyBDb2xsaXNpb25UaWxlKGRhdGEuY29sbGlzaW9uVGlsZSwgdGhpcy5jb2xsaXNpb25Cb3hBcnJheSk7XG4gICAgICAgIHRoaXMuZmVhdHVyZUluZGV4LnNldENvbGxpc2lvblRpbGUodGhpcy5jb2xsaXNpb25UaWxlKTtcblxuICAgICAgICAvLyBEZXN0cm95IGFuZCBkZWxldGUgZXhpc3Rpbmcgc3ltYm9sIGJ1Y2tldHNcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5idWNrZXRzKSB7XG4gICAgICAgICAgICB2YXIgYnVja2V0ID0gdGhpcy5idWNrZXRzW2lkXTtcbiAgICAgICAgICAgIGlmIChidWNrZXQudHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICBidWNrZXQuZGVzdHJveShwYWludGVyLmdsKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5idWNrZXRzW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBuZXcgc3ltYm9sIGJ1Y2tldHNcbiAgICAgICAgdXRpbC5leHRlbmQodGhpcy5idWNrZXRzLCB1bnNlcmlhbGl6ZUJ1Y2tldHMoZGF0YS5idWNrZXRzLCBzdHlsZSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHN1cmUgdGhhdCB0aGlzIHRpbGUgZG9lc24ndCBvd24gYW55IGRhdGEgd2l0aGluIGEgZ2l2ZW5cbiAgICAgKiBwYWludGVyLCBzbyB0aGF0IGl0IGRvZXNuJ3QgY29uc3VtZSBhbnkgbWVtb3J5IG9yIG1haW50YWluXG4gICAgICogYW55IHJlZmVyZW5jZXMgdG8gdGhlIHBhaW50ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhaW50ZXIgZ2wgcGFpbnRlciBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdW5sb2FkVmVjdG9yRGF0YTogZnVuY3Rpb24ocGFpbnRlcikge1xuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLmJ1Y2tldHMpIHtcbiAgICAgICAgICAgIHZhciBidWNrZXQgPSB0aGlzLmJ1Y2tldHNbaWRdO1xuICAgICAgICAgICAgYnVja2V0LmRlc3Ryb3kocGFpbnRlci5nbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbGxpc2lvbkJveEFycmF5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb2xsaXNpb25UaWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mZWF0dXJlSW5kZXggPSBudWxsO1xuICAgICAgICB0aGlzLnJhd1RpbGVEYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5idWNrZXRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1VubG9hZGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgcmVkb1BsYWNlbWVudDogZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5sb2FkZWQgfHwgdGhpcy5yZWRvaW5nUGxhY2VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnJlZG9XaGVuRG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlZG9pbmdQbGFjZW1lbnQgPSB0cnVlO1xuXG4gICAgICAgIHNvdXJjZS5kaXNwYXRjaGVyLnNlbmQoJ3JlZG8gcGxhY2VtZW50Jywge1xuICAgICAgICAgICAgdWlkOiB0aGlzLnVpZCxcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLmlkLFxuICAgICAgICAgICAgYW5nbGU6IHNvdXJjZS5tYXAudHJhbnNmb3JtLmFuZ2xlLFxuICAgICAgICAgICAgcGl0Y2g6IHNvdXJjZS5tYXAudHJhbnNmb3JtLnBpdGNoLFxuICAgICAgICAgICAgc2hvd0NvbGxpc2lvbkJveGVzOiBzb3VyY2UubWFwLnNob3dDb2xsaXNpb25Cb3hlc1xuICAgICAgICB9LCBkb25lLmJpbmQodGhpcyksIHRoaXMud29ya2VySUQpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGRvbmUoXywgZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5yZWxvYWRTeW1ib2xEYXRhKGRhdGEsIHNvdXJjZS5tYXAucGFpbnRlciwgc291cmNlLm1hcC5zdHlsZSk7XG4gICAgICAgICAgICBzb3VyY2UuZmlyZSgndGlsZS5sb2FkJywge3RpbGU6IHRoaXN9KTtcblxuICAgICAgICAgICAgdGhpcy5yZWRvaW5nUGxhY2VtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWRvV2hlbkRvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZG9QbGFjZW1lbnQoc291cmNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZG9XaGVuRG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldEJ1Y2tldDogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVja2V0cyAmJiB0aGlzLmJ1Y2tldHNbbGF5ZXIucmVmIHx8IGxheWVyLmlkXTtcbiAgICB9LFxuXG4gICAgcXVlcnlTb3VyY2VGZWF0dXJlczogZnVuY3Rpb24ocmVzdWx0LCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJhd1RpbGVEYXRhKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCF0aGlzLnZ0TGF5ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnZ0TGF5ZXJzID0gbmV3IHZ0LlZlY3RvclRpbGUobmV3IFByb3RvYnVmKG5ldyBVaW50OEFycmF5KHRoaXMucmF3VGlsZURhdGEpKSkubGF5ZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy52dExheWVycy5fZ2VvanNvblRpbGVMYXllciB8fCB0aGlzLnZ0TGF5ZXJzW3BhcmFtcy5zb3VyY2VMYXllcl07XG5cbiAgICAgICAgaWYgKCFsYXllcikgcmV0dXJuO1xuXG4gICAgICAgIHZhciBmaWx0ZXIgPSBmZWF0dXJlRmlsdGVyKHBhcmFtcy5maWx0ZXIpO1xuICAgICAgICB2YXIgY29vcmQgPSB7IHo6IHRoaXMuY29vcmQueiwgeDogdGhpcy5jb29yZC54LCB5OiB0aGlzLmNvb3JkLnkgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZSA9IGxheWVyLmZlYXR1cmUoaSk7XG4gICAgICAgICAgICBpZiAoZmlsdGVyKGZlYXR1cmUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdlb2pzb25GZWF0dXJlID0gbmV3IEdlb0pTT05GZWF0dXJlKGZlYXR1cmUsIHRoaXMuY29vcmQueiwgdGhpcy5jb29yZC54LCB0aGlzLmNvb3JkLnkpO1xuICAgICAgICAgICAgICAgIGdlb2pzb25GZWF0dXJlLnRpbGUgPSBjb29yZDtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW9qc29uRmVhdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5mdW5jdGlvbiB1bnNlcmlhbGl6ZUJ1Y2tldHMoaW5wdXQsIHN0eWxlKSB7XG4gICAgdmFyIG91dHB1dCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxheWVyID0gc3R5bGUuZ2V0TGF5ZXIoaW5wdXRbaV0ubGF5ZXJJZCk7XG4gICAgICAgIGlmICghbGF5ZXIpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBidWNrZXQgPSBCdWNrZXQuY3JlYXRlKHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGxheWVyOiBsYXllcixcbiAgICAgICAgICAgIGNoaWxkTGF5ZXJzOiBpbnB1dFtpXS5jaGlsZExheWVySWRzXG4gICAgICAgICAgICAgICAgLm1hcChzdHlsZS5nZXRMYXllci5iaW5kKHN0eWxlKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGxheWVyKSB7IHJldHVybiBsYXllcjsgfSlcbiAgICAgICAgfSwgaW5wdXRbaV0pKTtcbiAgICAgICAgb3V0cHV0W2J1Y2tldC5pZF0gPSBidWNrZXQ7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBDb29yZGluYXRlID0gcmVxdWlyZSgnLi4vZ2VvL2Nvb3JkaW5hdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaWxlQ29vcmQ7XG5cbmZ1bmN0aW9uIFRpbGVDb29yZCh6LCB4LCB5LCB3KSB7XG4gICAgYXNzZXJ0KCFpc05hTih6KSAmJiB6ID49IDAgJiYgeiAlIDEgPT09IDApO1xuICAgIGFzc2VydCghaXNOYU4oeCkgJiYgeCA+PSAwICYmIHggJSAxID09PSAwKTtcbiAgICBhc3NlcnQoIWlzTmFOKHkpICYmIHkgPj0gMCAmJiB5ICUgMSA9PT0gMCk7XG5cbiAgICBpZiAoaXNOYU4odykpIHcgPSAwO1xuXG4gICAgdGhpcy56ID0gK3o7XG4gICAgdGhpcy54ID0gK3g7XG4gICAgdGhpcy55ID0gK3k7XG4gICAgdGhpcy53ID0gK3c7XG5cbiAgICAvLyBjYWxjdWxhdGUgaWRcbiAgICB3ICo9IDI7XG4gICAgaWYgKHcgPCAwKSB3ID0gdyAqIC0xIC0gMTtcbiAgICB2YXIgZGltID0gMSA8PCB0aGlzLno7XG4gICAgdGhpcy5pZCA9ICgoZGltICogZGltICogdyArIGRpbSAqIHRoaXMueSArIHRoaXMueCkgKiAzMikgKyB0aGlzLno7XG5cbiAgICAvLyBmb3IgY2FjaGluZyBwb3MgbWF0cml4IGNhbGN1bGF0aW9uIHdoZW4gcmVuZGVyaW5nXG4gICAgdGhpcy5wb3NNYXRyaXggPSBudWxsO1xufVxuXG5UaWxlQ29vcmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMueiArIFwiL1wiICsgdGhpcy54ICsgXCIvXCIgKyB0aGlzLnk7XG59O1xuXG5UaWxlQ29vcmQucHJvdG90eXBlLnRvQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uKHNvdXJjZU1heFpvb20pIHtcbiAgICB2YXIgem9vbSA9IE1hdGgubWluKHRoaXMueiwgc291cmNlTWF4Wm9vbSk7XG4gICAgdmFyIHRpbGVTY2FsZSA9IE1hdGgucG93KDIsIHpvb20pO1xuICAgIHZhciByb3cgPSB0aGlzLnk7XG4gICAgdmFyIGNvbHVtbiA9IHRoaXMueCArIHRpbGVTY2FsZSAqIHRoaXMudztcbiAgICByZXR1cm4gbmV3IENvb3JkaW5hdGUoY29sdW1uLCByb3csIHpvb20pO1xufTtcblxuLy8gUGFyc2UgYSBwYWNrZWQgaW50ZWdlciBpZCBpbnRvIGEgVGlsZUNvb3JkIG9iamVjdFxuVGlsZUNvb3JkLmZyb21JRCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIHogPSBpZCAlIDMyLCBkaW0gPSAxIDw8IHo7XG4gICAgdmFyIHh5ID0gKChpZCAtIHopIC8gMzIpO1xuICAgIHZhciB4ID0geHkgJSBkaW0sIHkgPSAoKHh5IC0geCkgLyBkaW0pICUgZGltO1xuICAgIHZhciB3ID0gTWF0aC5mbG9vcih4eSAvIChkaW0gKiBkaW0pKTtcbiAgICBpZiAodyAlIDIgIT09IDApIHcgPSB3ICogLTEgLSAxO1xuICAgIHcgLz0gMjtcbiAgICByZXR1cm4gbmV3IFRpbGVDb29yZCh6LCB4LCB5LCB3KTtcbn07XG5cbi8vIGdpdmVuIGEgbGlzdCBvZiB1cmxzLCBjaG9vc2UgYSB1cmwgdGVtcGxhdGUgYW5kIHJldHVybiBhIHRpbGUgVVJMXG5UaWxlQ29vcmQucHJvdG90eXBlLnVybCA9IGZ1bmN0aW9uKHVybHMsIHNvdXJjZU1heFpvb20pIHtcbiAgICByZXR1cm4gdXJsc1sodGhpcy54ICsgdGhpcy55KSAlIHVybHMubGVuZ3RoXVxuICAgICAgICAucmVwbGFjZSgne3ByZWZpeH0nLCAodGhpcy54ICUgMTYpLnRvU3RyaW5nKDE2KSArICh0aGlzLnkgJSAxNikudG9TdHJpbmcoMTYpKVxuICAgICAgICAucmVwbGFjZSgne3p9JywgTWF0aC5taW4odGhpcy56LCBzb3VyY2VNYXhab29tIHx8IHRoaXMueikpXG4gICAgICAgIC5yZXBsYWNlKCd7eH0nLCB0aGlzLngpXG4gICAgICAgIC5yZXBsYWNlKCd7eX0nLCB0aGlzLnkpO1xufTtcblxuLy8gUmV0dXJuIHRoZSBjb29yZGluYXRlIG9mIHRoZSBwYXJlbnQgdGlsZVxuVGlsZUNvb3JkLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbihzb3VyY2VNYXhab29tKSB7XG4gICAgaWYgKHRoaXMueiA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyB0aGUgaWQgcmVwcmVzZW50cyBhbiBvdmVyc2NhbGVkIHRpbGUsIHJldHVybiB0aGUgc2FtZSBjb29yZGluYXRlcyB3aXRoIGEgbG93ZXIgelxuICAgIGlmICh0aGlzLnogPiBzb3VyY2VNYXhab29tKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGlsZUNvb3JkKHRoaXMueiAtIDEsIHRoaXMueCwgdGhpcy55LCB0aGlzLncpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVGlsZUNvb3JkKHRoaXMueiAtIDEsIE1hdGguZmxvb3IodGhpcy54IC8gMiksIE1hdGguZmxvb3IodGhpcy55IC8gMiksIHRoaXMudyk7XG59O1xuXG5UaWxlQ29vcmQucHJvdG90eXBlLndyYXBwZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFRpbGVDb29yZCh0aGlzLnosIHRoaXMueCwgdGhpcy55LCAwKTtcbn07XG5cbi8vIFJldHVybiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHRpbGUncyBjaGlsZHJlblxuVGlsZUNvb3JkLnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uKHNvdXJjZU1heFpvb20pIHtcblxuICAgIGlmICh0aGlzLnogPj0gc291cmNlTWF4Wm9vbSkge1xuICAgICAgICAvLyByZXR1cm4gYSBzaW5nbGUgdGlsZSBjb29yZCByZXByZXNlbnRpbmcgYSBhbiBvdmVyc2NhbGVkIHRpbGVcbiAgICAgICAgcmV0dXJuIFtuZXcgVGlsZUNvb3JkKHRoaXMueiArIDEsIHRoaXMueCwgdGhpcy55LCB0aGlzLncpXTtcbiAgICB9XG5cbiAgICB2YXIgeiA9IHRoaXMueiArIDE7XG4gICAgdmFyIHggPSB0aGlzLnggKiAyO1xuICAgIHZhciB5ID0gdGhpcy55ICogMjtcbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgVGlsZUNvb3JkKHosIHgsIHksIHRoaXMudyksXG4gICAgICAgIG5ldyBUaWxlQ29vcmQoeiwgeCArIDEsIHksIHRoaXMudyksXG4gICAgICAgIG5ldyBUaWxlQ29vcmQoeiwgeCwgeSArIDEsIHRoaXMudyksXG4gICAgICAgIG5ldyBUaWxlQ29vcmQoeiwgeCArIDEsIHkgKyAxLCB0aGlzLncpXG4gICAgXTtcbn07XG5cbi8vIFRha2VuIGZyb20gcG9seW1hcHMgc3JjL0xheWVyLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2ltcGxlZ2VvL3BvbHltYXBzL2Jsb2IvbWFzdGVyL3NyYy9MYXllci5qcyNMMzMzLUwzODNcblxuZnVuY3Rpb24gZWRnZShhLCBiKSB7XG4gICAgaWYgKGEucm93ID4gYi5yb3cpIHsgdmFyIHQgPSBhOyBhID0gYjsgYiA9IHQ7IH1cbiAgICByZXR1cm4ge1xuICAgICAgICB4MDogYS5jb2x1bW4sXG4gICAgICAgIHkwOiBhLnJvdyxcbiAgICAgICAgeDE6IGIuY29sdW1uLFxuICAgICAgICB5MTogYi5yb3csXG4gICAgICAgIGR4OiBiLmNvbHVtbiAtIGEuY29sdW1uLFxuICAgICAgICBkeTogYi5yb3cgLSBhLnJvd1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIHNjYW5TcGFucyhlMCwgZTEsIHltaW4sIHltYXgsIHNjYW5MaW5lKSB7XG4gICAgdmFyIHkwID0gTWF0aC5tYXgoeW1pbiwgTWF0aC5mbG9vcihlMS55MCkpO1xuICAgIHZhciB5MSA9IE1hdGgubWluKHltYXgsIE1hdGguY2VpbChlMS55MSkpO1xuXG4gICAgLy8gc29ydCBlZGdlcyBieSB4LWNvb3JkaW5hdGVcbiAgICBpZiAoKGUwLngwID09PSBlMS54MCAmJiBlMC55MCA9PT0gZTEueTApID9cbiAgICAgICAgICAgIChlMC54MCArIGUxLmR5IC8gZTAuZHkgKiBlMC5keCA8IGUxLngxKSA6XG4gICAgICAgICAgICAoZTAueDEgLSBlMS5keSAvIGUwLmR5ICogZTAuZHggPCBlMS54MCkpIHtcbiAgICAgICAgdmFyIHQgPSBlMDsgZTAgPSBlMTsgZTEgPSB0O1xuICAgIH1cblxuICAgIC8vIHNjYW4gbGluZXMhXG4gICAgdmFyIG0wID0gZTAuZHggLyBlMC5keTtcbiAgICB2YXIgbTEgPSBlMS5keCAvIGUxLmR5O1xuICAgIHZhciBkMCA9IGUwLmR4ID4gMDsgLy8gdXNlIHkgKyAxIHRvIGNvbXB1dGUgeDBcbiAgICB2YXIgZDEgPSBlMS5keCA8IDA7IC8vIHVzZSB5ICsgMSB0byBjb21wdXRlIHgxXG4gICAgZm9yICh2YXIgeSA9IHkwOyB5IDwgeTE7IHkrKykge1xuICAgICAgICB2YXIgeDAgPSBtMCAqIE1hdGgubWF4KDAsIE1hdGgubWluKGUwLmR5LCB5ICsgZDAgLSBlMC55MCkpICsgZTAueDA7XG4gICAgICAgIHZhciB4MSA9IG0xICogTWF0aC5tYXgoMCwgTWF0aC5taW4oZTEuZHksIHkgKyBkMSAtIGUxLnkwKSkgKyBlMS54MDtcbiAgICAgICAgc2NhbkxpbmUoTWF0aC5mbG9vcih4MSksIE1hdGguY2VpbCh4MCksIHkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2NhblRyaWFuZ2xlKGEsIGIsIGMsIHltaW4sIHltYXgsIHNjYW5MaW5lKSB7XG4gICAgdmFyIGFiID0gZWRnZShhLCBiKSxcbiAgICAgICAgYmMgPSBlZGdlKGIsIGMpLFxuICAgICAgICBjYSA9IGVkZ2UoYywgYSk7XG5cbiAgICB2YXIgdDtcblxuICAgIC8vIHNvcnQgZWRnZXMgYnkgeS1sZW5ndGhcbiAgICBpZiAoYWIuZHkgPiBiYy5keSkgeyB0ID0gYWI7IGFiID0gYmM7IGJjID0gdDsgfVxuICAgIGlmIChhYi5keSA+IGNhLmR5KSB7IHQgPSBhYjsgYWIgPSBjYTsgY2EgPSB0OyB9XG4gICAgaWYgKGJjLmR5ID4gY2EuZHkpIHsgdCA9IGJjOyBiYyA9IGNhOyBjYSA9IHQ7IH1cblxuICAgIC8vIHNjYW4gc3BhbiEgc2NhbiBzcGFuIVxuICAgIGlmIChhYi5keSkgc2NhblNwYW5zKGNhLCBhYiwgeW1pbiwgeW1heCwgc2NhbkxpbmUpO1xuICAgIGlmIChiYy5keSkgc2NhblNwYW5zKGNhLCBiYywgeW1pbiwgeW1heCwgc2NhbkxpbmUpO1xufVxuXG5UaWxlQ29vcmQuY292ZXIgPSBmdW5jdGlvbih6LCBib3VuZHMsIGFjdHVhbFopIHtcbiAgICB2YXIgdGlsZXMgPSAxIDw8IHo7XG4gICAgdmFyIHQgPSB7fTtcblxuICAgIGZ1bmN0aW9uIHNjYW5MaW5lKHgwLCB4MSwgeSkge1xuICAgICAgICB2YXIgeCwgd3gsIGNvb3JkO1xuICAgICAgICBpZiAoeSA+PSAwICYmIHkgPD0gdGlsZXMpIHtcbiAgICAgICAgICAgIGZvciAoeCA9IHgwOyB4IDwgeDE7IHgrKykge1xuICAgICAgICAgICAgICAgIHd4ID0gKHggJSB0aWxlcyArIHRpbGVzKSAlIHRpbGVzO1xuICAgICAgICAgICAgICAgIGNvb3JkID0gbmV3IFRpbGVDb29yZChhY3R1YWxaLCB3eCwgeSwgTWF0aC5mbG9vcih4IC8gdGlsZXMpKTtcbiAgICAgICAgICAgICAgICB0W2Nvb3JkLmlkXSA9IGNvb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGl2aWRlIHRoZSBzY3JlZW4gdXAgaW4gdHdvIHRyaWFuZ2xlcyBhbmQgc2NhbiBlYWNoIG9mIHRoZW06XG4gICAgLy8gKy0tLS9cbiAgICAvLyB8IC8gfFxuICAgIC8vIC8tLS0rXG4gICAgc2NhblRyaWFuZ2xlKGJvdW5kc1swXSwgYm91bmRzWzFdLCBib3VuZHNbMl0sIDAsIHRpbGVzLCBzY2FuTGluZSk7XG4gICAgc2NhblRyaWFuZ2xlKGJvdW5kc1syXSwgYm91bmRzWzNdLCBib3VuZHNbMF0sIDAsIHRpbGVzLCBzY2FuTGluZSk7XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXModCkubWFwKGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiB0W2lkXTtcbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUaWxlID0gcmVxdWlyZSgnLi90aWxlJyk7XG52YXIgVGlsZUNvb3JkID0gcmVxdWlyZSgnLi90aWxlX2Nvb3JkJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xudmFyIENhY2hlID0gcmVxdWlyZSgnLi4vdXRpbC9scnVfY2FjaGUnKTtcbnZhciBDb29yZGluYXRlID0gcmVxdWlyZSgnLi4vZ2VvL2Nvb3JkaW5hdGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgRVhURU5UID0gcmVxdWlyZSgnLi4vZGF0YS9idWNrZXQnKS5FWFRFTlQ7XG5cbm1vZHVsZS5leHBvcnRzID0gVGlsZVB5cmFtaWQ7XG5cbi8qKlxuICogQSB0aWxlIHB5cmFtaWQgaXMgYSBzcGVjaWFsaXplZCBjYWNoZSBhbmQgZGF0YXN0cnVjdHVyZVxuICogdGhhdCBjb250YWlucyB0aWxlcy4gSXQncyB1c2VkIGJ5IHNvdXJjZXMgdG8gbWFuYWdlIHRoZWlyXG4gKiBkYXRhLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50aWxlU2l6ZVxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubWluem9vbVxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubWF4em9vbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVGlsZVB5cmFtaWQob3B0aW9ucykge1xuICAgIHRoaXMudGlsZVNpemUgPSBvcHRpb25zLnRpbGVTaXplO1xuICAgIHRoaXMubWluem9vbSA9IG9wdGlvbnMubWluem9vbTtcbiAgICB0aGlzLm1heHpvb20gPSBvcHRpb25zLm1heHpvb207XG4gICAgdGhpcy5yb3VuZFpvb20gPSBvcHRpb25zLnJvdW5kWm9vbTtcbiAgICB0aGlzLnJlcGFyc2VPdmVyc2NhbGVkID0gb3B0aW9ucy5yZXBhcnNlT3ZlcnNjYWxlZDtcblxuICAgIHRoaXMuX2xvYWQgPSBvcHRpb25zLmxvYWQ7XG4gICAgdGhpcy5fYWJvcnQgPSBvcHRpb25zLmFib3J0O1xuICAgIHRoaXMuX3VubG9hZCA9IG9wdGlvbnMudW5sb2FkO1xuICAgIHRoaXMuX2FkZCA9IG9wdGlvbnMuYWRkO1xuICAgIHRoaXMuX3JlbW92ZSA9IG9wdGlvbnMucmVtb3ZlO1xuICAgIHRoaXMuX3JlZG9QbGFjZW1lbnQgPSBvcHRpb25zLnJlZG9QbGFjZW1lbnQ7XG5cbiAgICB0aGlzLl90aWxlcyA9IHt9O1xuICAgIHRoaXMuX2NhY2hlID0gbmV3IENhY2hlKDAsIGZ1bmN0aW9uKHRpbGUpIHsgcmV0dXJuIHRoaXMuX3VubG9hZCh0aWxlKTsgfS5iaW5kKHRoaXMpKTtcblxuICAgIHRoaXMuX2ZpbHRlclJlbmRlcmVkID0gdGhpcy5fZmlsdGVyUmVuZGVyZWQuYmluZCh0aGlzKTtcbn1cblxuXG5UaWxlUHlyYW1pZC5tYXhPdmVyem9vbWluZyA9IDEwO1xuVGlsZVB5cmFtaWQubWF4VW5kZXJ6b29taW5nID0gMztcblxuVGlsZVB5cmFtaWQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENvbmZpcm0gdGhhdCBldmVyeSB0cmFja2VkIHRpbGUgaXMgbG9hZGVkLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIGFsbCB0aWxlcyBhcmUgbG9hZGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLl90aWxlcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90aWxlc1t0XS5sb2FkZWQgJiYgIXRoaXMuX3RpbGVzW3RdLmVycm9yZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWxsIHRpbGUgaWRzIG9yZGVyZWQgd2l0aCB6LW9yZGVyLCBhbmQgY2FzdCB0byBudW1iZXJzXG4gICAgICogQHJldHVybnMge0FycmF5PG51bWJlcj59IGlkc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb3JkZXJlZElEczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl90aWxlcykubWFwKE51bWJlcikuc29ydChjb21wYXJlS2V5Wm9vbSk7XG4gICAgfSxcblxuICAgIHJlbmRlcmVkSURzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JkZXJlZElEcygpLmZpbHRlcih0aGlzLl9maWx0ZXJSZW5kZXJlZCk7XG4gICAgfSxcblxuICAgIF9maWx0ZXJSZW5kZXJlZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGVzW2lkXS5sb2FkZWQgJiYgIXRoaXMuX2NvdmVyZWRUaWxlc1tpZF07XG4gICAgfSxcblxuICAgIHJlbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlLnJlc2V0KCk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWQodGhpcy5fdGlsZXNbaV0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHNwZWNpZmljIHRpbGUgYnkgaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGlkIHRpbGUgaWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRUaWxlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZXNbaWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHpvb20gbGV2ZWwgYWRqdXN0ZWQgZm9yIHRoZSBkaWZmZXJlbmNlIGluIG1hcCBhbmQgc291cmNlIHRpbGVzaXplc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB6b29tIGxldmVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRab29tOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybS56b29tICsgTWF0aC5sb2codHJhbnNmb3JtLnRpbGVTaXplIC8gdGhpcy50aWxlU2l6ZSkgLyBNYXRoLkxOMjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgem9vbSBsZXZlbCB0aGF0IHdpbGwgY292ZXIgYWxsIHRpbGVzIGluIGEgZ2l2ZW4gdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHpvb20gbGV2ZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvdmVyaW5nWm9vbUxldmVsOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnJvdW5kWm9vbSA/IE1hdGgucm91bmQgOiBNYXRoLmZsb29yKSh0aGlzLmdldFpvb20odHJhbnNmb3JtKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgdHJhbnNmb3JtLCByZXR1cm4gYWxsIGNvb3JkaW5hdGVzIHRoYXQgY291bGQgY292ZXIgdGhhdFxuICAgICAqIHRyYW5zZm9ybSBmb3IgYSBjb3ZlcmluZyB6b29tIGxldmVsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8VGlsZT59IHRpbGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb3ZlcmluZ1RpbGVzOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgdmFyIHogPSB0aGlzLmNvdmVyaW5nWm9vbUxldmVsKHRyYW5zZm9ybSk7XG4gICAgICAgIHZhciBhY3R1YWxaID0gejtcblxuICAgICAgICBpZiAoeiA8IHRoaXMubWluem9vbSkgcmV0dXJuIFtdO1xuICAgICAgICBpZiAoeiA+IHRoaXMubWF4em9vbSkgeiA9IHRoaXMubWF4em9vbTtcblxuICAgICAgICB2YXIgdHIgPSB0cmFuc2Zvcm0sXG4gICAgICAgICAgICB0aWxlQ2VudGVyID0gdHIubG9jYXRpb25Db29yZGluYXRlKHRyLmNlbnRlcikuX3pvb21Ubyh6KSxcbiAgICAgICAgICAgIGNlbnRlclBvaW50ID0gbmV3IFBvaW50KHRpbGVDZW50ZXIuY29sdW1uIC0gMC41LCB0aWxlQ2VudGVyLnJvdyAtIDAuNSk7XG5cbiAgICAgICAgcmV0dXJuIFRpbGVDb29yZC5jb3Zlcih6LCBbXG4gICAgICAgICAgICB0ci5wb2ludENvb3JkaW5hdGUobmV3IFBvaW50KDAsIDApKS5fem9vbVRvKHopLFxuICAgICAgICAgICAgdHIucG9pbnRDb29yZGluYXRlKG5ldyBQb2ludCh0ci53aWR0aCwgMCkpLl96b29tVG8oeiksXG4gICAgICAgICAgICB0ci5wb2ludENvb3JkaW5hdGUobmV3IFBvaW50KHRyLndpZHRoLCB0ci5oZWlnaHQpKS5fem9vbVRvKHopLFxuICAgICAgICAgICAgdHIucG9pbnRDb29yZGluYXRlKG5ldyBQb2ludCgwLCB0ci5oZWlnaHQpKS5fem9vbVRvKHopXG4gICAgICAgIF0sIHRoaXMucmVwYXJzZU92ZXJzY2FsZWQgPyBhY3R1YWxaIDogeikuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gY2VudGVyUG9pbnQuZGlzdChhKSAtIGNlbnRlclBvaW50LmRpc3QoYik7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmaW5kIGNoaWxkcmVuIG9mIHRoZSBnaXZlbiB0aWxlICh1cCB0byBtYXhDb3ZlcmluZ1pvb20pIHRoYXQgYXJlIGFscmVhZHkgbG9hZGVkO1xuICAgICAqIGFkZHMgZm91bmQgdGlsZXMgdG8gcmV0YWluIG9iamVjdDsgcmV0dXJucyB0cnVlIGlmIGFueSBjaGlsZCBpcyBmb3VuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4Q292ZXJpbmdab29tXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXRhaW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgb3BlcmF0aW9uIHdhcyBjb21wbGV0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZmluZExvYWRlZENoaWxkcmVuOiBmdW5jdGlvbihjb29yZCwgbWF4Q292ZXJpbmdab29tLCByZXRhaW4pIHtcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgICAgIHZhciB0aWxlID0gdGhpcy5fdGlsZXNbaWRdO1xuXG4gICAgICAgICAgICAvLyBvbmx5IGNvbnNpZGVyIGxvYWRlZCB0aWxlcyBvbiBoaWdoZXIgem9vbSBsZXZlbHMgKHVwIHRvIG1heENvdmVyaW5nWm9vbSlcbiAgICAgICAgICAgIGlmIChyZXRhaW5baWRdIHx8ICF0aWxlLmxvYWRlZCB8fCB0aWxlLmNvb3JkLnogPD0gY29vcmQueiB8fCB0aWxlLmNvb3JkLnogPiBtYXhDb3ZlcmluZ1pvb20pIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBkaXNyZWdhcmQgdGlsZXMgdGhhdCBhcmUgbm90IGRlc2NlbmRhbnRzIG9mIHRoZSBnaXZlbiB0aWxlIGNvb3JkaW5hdGVcbiAgICAgICAgICAgIHZhciB6MiA9IE1hdGgucG93KDIsIE1hdGgubWluKHRpbGUuY29vcmQueiwgdGhpcy5tYXh6b29tKSAtIE1hdGgubWluKGNvb3JkLnosIHRoaXMubWF4em9vbSkpO1xuICAgICAgICAgICAgaWYgKE1hdGguZmxvb3IodGlsZS5jb29yZC54IC8gejIpICE9PSBjb29yZC54IHx8XG4gICAgICAgICAgICAgICAgTWF0aC5mbG9vcih0aWxlLmNvb3JkLnkgLyB6MikgIT09IGNvb3JkLnkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIGZvdW5kIGxvYWRlZCBjaGlsZFxuICAgICAgICAgICAgcmV0YWluW2lkXSA9IHRydWU7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBwYXJlbnRzOyByZXRhaW4gdGhlIHRvcG1vc3QgbG9hZGVkIG9uZSBpZiBmb3VuZFxuICAgICAgICAgICAgd2hpbGUgKHRpbGUgJiYgdGlsZS5jb29yZC56IC0gMSA+IGNvb3JkLnopIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50SWQgPSB0aWxlLmNvb3JkLnBhcmVudCh0aGlzLm1heHpvb20pLmlkO1xuICAgICAgICAgICAgICAgIHRpbGUgPSB0aGlzLl90aWxlc1twYXJlbnRJZF07XG5cbiAgICAgICAgICAgICAgICBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmV0YWluW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0YWluW3BhcmVudElkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBhIGxvYWRlZCBwYXJlbnQgb2YgdGhlIGdpdmVuIHRpbGUgKHVwIHRvIG1pbkNvdmVyaW5nWm9vbSk7XG4gICAgICogYWRkcyB0aGUgZm91bmQgdGlsZSB0byByZXRhaW4gb2JqZWN0IGFuZCByZXR1cm5zIHRoZSB0aWxlIGlmIGZvdW5kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbkNvdmVyaW5nWm9vbVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV0YWluXG4gICAgICogQHJldHVybnMge1RpbGV9IHRpbGUgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmaW5kTG9hZGVkUGFyZW50OiBmdW5jdGlvbihjb29yZCwgbWluQ292ZXJpbmdab29tLCByZXRhaW4pIHtcbiAgICAgICAgZm9yICh2YXIgeiA9IGNvb3JkLnogLSAxOyB6ID49IG1pbkNvdmVyaW5nWm9vbTsgei0tKSB7XG4gICAgICAgICAgICBjb29yZCA9IGNvb3JkLnBhcmVudCh0aGlzLm1heHpvb20pO1xuICAgICAgICAgICAgdmFyIHRpbGUgPSB0aGlzLl90aWxlc1tjb29yZC5pZF07XG4gICAgICAgICAgICBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgIHJldGFpbltjb29yZC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlLmhhcyhjb29yZC5pZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRpbGUoY29vcmQpO1xuICAgICAgICAgICAgICAgIHJldGFpbltjb29yZC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aWxlc1tjb29yZC5pZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplcyB0aGUgdGlsZSBjYWNoZSBiYXNlZCBvbiB0aGUgY3VycmVudCB2aWV3cG9ydCdzIHNpemUuXG4gICAgICpcbiAgICAgKiBMYXJnZXIgdmlld3BvcnRzIHVzZSBtb3JlIHRpbGVzIGFuZCBuZWVkIGxhcmdlciBjYWNoZXMuIExhcmdlciB2aWV3cG9ydHNcbiAgICAgKiBhcmUgbW9yZSBsaWtlbHkgdG8gYmUgZm91bmQgb24gZGV2aWNlcyB3aXRoIG1vcmUgbWVtb3J5IGFuZCBvbiBwYWdlcyB3aGVyZVxuICAgICAqIHRoZSBtYXAgaXMgbW9yZSBpbXBvcnRhbnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZUNhY2hlU2l6ZTogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciB3aWR0aEluVGlsZXMgPSBNYXRoLmNlaWwodHJhbnNmb3JtLndpZHRoIC8gdHJhbnNmb3JtLnRpbGVTaXplKSArIDE7XG4gICAgICAgIHZhciBoZWlnaHRJblRpbGVzID0gTWF0aC5jZWlsKHRyYW5zZm9ybS5oZWlnaHQgLyB0cmFuc2Zvcm0udGlsZVNpemUpICsgMTtcbiAgICAgICAgdmFyIGFwcHJveFRpbGVzSW5WaWV3ID0gd2lkdGhJblRpbGVzICogaGVpZ2h0SW5UaWxlcztcbiAgICAgICAgdmFyIGNvbW1vblpvb21SYW5nZSA9IDU7XG4gICAgICAgIHRoaXMuX2NhY2hlLnNldE1heFNpemUoTWF0aC5mbG9vcihhcHByb3hUaWxlc0luVmlldyAqIGNvbW1vblpvb21SYW5nZSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRpbGVzIHRoYXQgYXJlIG91dHNpZGUgdGhlIHZpZXdwb3J0IGFuZCBhZGRzIG5ldyB0aWxlcyB0aGF0XG4gICAgICogYXJlIGluc2lkZSB0aGUgdmlld3BvcnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKHVzZWQsIHRyYW5zZm9ybSwgZmFkZUR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgY29vcmQ7XG4gICAgICAgIHZhciB0aWxlO1xuXG4gICAgICAgIHRoaXMudXBkYXRlQ2FjaGVTaXplKHRyYW5zZm9ybSk7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBvdmVyem9vbWluZy91bmRlcnpvb21pbmcgYW1vdW50cy5cbiAgICAgICAgdmFyIHpvb20gPSAodGhpcy5yb3VuZFpvb20gPyBNYXRoLnJvdW5kIDogTWF0aC5mbG9vcikodGhpcy5nZXRab29tKHRyYW5zZm9ybSkpO1xuICAgICAgICB2YXIgbWluQ292ZXJpbmdab29tID0gTWF0aC5tYXgoem9vbSAtIFRpbGVQeXJhbWlkLm1heE92ZXJ6b29taW5nLCB0aGlzLm1pbnpvb20pO1xuICAgICAgICB2YXIgbWF4Q292ZXJpbmdab29tID0gTWF0aC5tYXgoem9vbSArIFRpbGVQeXJhbWlkLm1heFVuZGVyem9vbWluZywgIHRoaXMubWluem9vbSk7XG5cbiAgICAgICAgLy8gUmV0YWluIGlzIGEgbGlzdCBvZiB0aWxlcyB0aGF0IHdlIHNob3VsZG4ndCBkZWxldGUsIGV2ZW4gaWYgdGhleSBhcmUgbm90XG4gICAgICAgIC8vIHRoZSBtb3N0IGlkZWFsIHRpbGUgZm9yIHRoZSBjdXJyZW50IHZpZXdwb3J0LiBUaGlzIG1heSBpbmNsdWRlIHRpbGVzIGxpa2VcbiAgICAgICAgLy8gcGFyZW50IG9yIGNoaWxkIHRpbGVzIHRoYXQgYXJlICphbHJlYWR5KiBsb2FkZWQuXG4gICAgICAgIHZhciByZXRhaW4gPSB7fTtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgIC8vIENvdmVyZWQgaXMgYSBsaXN0IG9mIHJldGFpbmVkIHRpbGVzIHdobydzIGFyZWFzIGFyZSBmdWxsIGNvdmVyZWQgYnkgb3RoZXIsXG4gICAgICAgIC8vIGJldHRlciwgcmV0YWluZWQgdGlsZXMuIFRoZXkgYXJlIG5vdCBkcmF3biBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9jb3ZlcmVkVGlsZXMgPSB7fTtcblxuICAgICAgICB2YXIgcmVxdWlyZWQgPSB1c2VkID8gdGhpcy5jb3ZlcmluZ1RpbGVzKHRyYW5zZm9ybSkgOiBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlcXVpcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb29yZCA9IHJlcXVpcmVkW2ldO1xuICAgICAgICAgICAgdGlsZSA9IHRoaXMuYWRkVGlsZShjb29yZCk7XG5cbiAgICAgICAgICAgIHJldGFpbltjb29yZC5pZF0gPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAodGlsZS5sb2FkZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIFRoZSB0aWxlIHdlIHJlcXVpcmUgaXMgbm90IHlldCBsb2FkZWQuXG4gICAgICAgICAgICAvLyBSZXRhaW4gY2hpbGQgb3IgcGFyZW50IHRpbGVzIHRoYXQgY292ZXIgdGhlIHNhbWUgYXJlYS5cbiAgICAgICAgICAgIGlmICghdGhpcy5maW5kTG9hZGVkQ2hpbGRyZW4oY29vcmQsIG1heENvdmVyaW5nWm9vbSwgcmV0YWluKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluZExvYWRlZFBhcmVudChjb29yZCwgbWluQ292ZXJpbmdab29tLCByZXRhaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcmVudHNGb3JGYWRpbmcgPSB7fTtcblxuICAgICAgICB2YXIgaWRzID0gT2JqZWN0LmtleXMocmV0YWluKTtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBpZHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBpZCA9IGlkc1trXTtcbiAgICAgICAgICAgIGNvb3JkID0gVGlsZUNvb3JkLmZyb21JRChpZCk7XG4gICAgICAgICAgICB0aWxlID0gdGhpcy5fdGlsZXNbaWRdO1xuICAgICAgICAgICAgaWYgKHRpbGUgJiYgdGlsZS50aW1lQWRkZWQgPiBub3cgLSAoZmFkZUR1cmF0aW9uIHx8IDApKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB0aWxlIGlzIHN0aWxsIGZhZGluZyBpbi4gRmluZCB0aWxlcyB0byBjcm9zcy1mYWRlIHdpdGggaXQuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZExvYWRlZENoaWxkcmVuKGNvb3JkLCBtYXhDb3ZlcmluZ1pvb20sIHJldGFpbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0YWluW2lkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZmluZExvYWRlZFBhcmVudChjb29yZCwgbWluQ292ZXJpbmdab29tLCBwYXJlbnRzRm9yRmFkaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmYWRlZFBhcmVudDtcbiAgICAgICAgZm9yIChmYWRlZFBhcmVudCBpbiBwYXJlbnRzRm9yRmFkaW5nKSB7XG4gICAgICAgICAgICBpZiAoIXJldGFpbltmYWRlZFBhcmVudF0pIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIHRpbGUgaXMgb25seSBuZWVkZWQgZm9yIGZhZGluZywgbWFyayBpdCBhcyBjb3ZlcmVkIHNvIHRoYXQgaXQgaXNuJ3QgcmVuZGVyZWQgb24gaXQncyBvd24uXG4gICAgICAgICAgICAgICAgdGhpcy5fY292ZXJlZFRpbGVzW2ZhZGVkUGFyZW50XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChmYWRlZFBhcmVudCBpbiBwYXJlbnRzRm9yRmFkaW5nKSB7XG4gICAgICAgICAgICByZXRhaW5bZmFkZWRQYXJlbnRdID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgdGlsZXMgd2UgZG9uJ3QgbmVlZCBhbnltb3JlLlxuICAgICAgICB2YXIgcmVtb3ZlID0gdXRpbC5rZXlzRGlmZmVyZW5jZSh0aGlzLl90aWxlcywgcmV0YWluKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVUaWxlKCtyZW1vdmVbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHRpbGUsIGdpdmVuIGl0cyBjb29yZGluYXRlLCB0byB0aGUgcHlyYW1pZC5cbiAgICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkXG4gICAgICogQHJldHVybnMge0Nvb3JkaW5hdGV9IHRoZSBjb29yZGluYXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWRkVGlsZTogZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgdmFyIHRpbGUgPSB0aGlzLl90aWxlc1tjb29yZC5pZF07XG4gICAgICAgIGlmICh0aWxlKVxuICAgICAgICAgICAgcmV0dXJuIHRpbGU7XG5cbiAgICAgICAgdmFyIHdyYXBwZWQgPSBjb29yZC53cmFwcGVkKCk7XG4gICAgICAgIHRpbGUgPSB0aGlzLl90aWxlc1t3cmFwcGVkLmlkXTtcblxuICAgICAgICBpZiAoIXRpbGUpIHtcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLl9jYWNoZS5nZXQod3JhcHBlZC5pZCk7XG4gICAgICAgICAgICBpZiAodGlsZSAmJiB0aGlzLl9yZWRvUGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVkb1BsYWNlbWVudCh0aWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGlsZSkge1xuICAgICAgICAgICAgdmFyIHpvb20gPSBjb29yZC56O1xuICAgICAgICAgICAgdmFyIG92ZXJzY2FsaW5nID0gem9vbSA+IHRoaXMubWF4em9vbSA/IE1hdGgucG93KDIsIHpvb20gLSB0aGlzLm1heHpvb20pIDogMTtcbiAgICAgICAgICAgIHRpbGUgPSBuZXcgVGlsZSh3cmFwcGVkLCB0aGlzLnRpbGVTaXplICogb3ZlcnNjYWxpbmcsIHRoaXMubWF4em9vbSk7XG4gICAgICAgICAgICB0aGlzLl9sb2FkKHRpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGlsZS51c2VzKys7XG4gICAgICAgIHRoaXMuX3RpbGVzW2Nvb3JkLmlkXSA9IHRpbGU7XG4gICAgICAgIHRoaXMuX2FkZCh0aWxlLCBjb29yZCk7XG5cbiAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHRpbGUsIGdpdmVuIGl0cyBpZCwgZnJvbSB0aGUgcHlyYW1pZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gaWQgdGlsZSBpZFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9IG5vdGhpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJlbW92ZVRpbGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHZhciB0aWxlID0gdGhpcy5fdGlsZXNbaWRdO1xuICAgICAgICBpZiAoIXRpbGUpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdGlsZS51c2VzLS07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl90aWxlc1tpZF07XG4gICAgICAgIHRoaXMuX3JlbW92ZSh0aWxlKTtcblxuICAgICAgICBpZiAodGlsZS51c2VzID4gMClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBpZiAodGlsZS5sb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlLmFkZCh0aWxlLmNvb3JkLndyYXBwZWQoKS5pZCwgdGlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hYm9ydCh0aWxlKTtcbiAgICAgICAgICAgIHRoaXMuX3VubG9hZCh0aWxlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIHRpbGVzIGZyb20gdGhpcyBweXJhbWlkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjbGVhclRpbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fdGlsZXMpXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVRpbGUoaWQpO1xuICAgICAgICB0aGlzLl9jYWNoZS5yZXNldCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggdGhyb3VnaCBvdXIgY3VycmVudCB0aWxlcyBhbmQgYXR0ZW1wdCB0byBmaW5kIHRoZSB0aWxlcyB0aGF0XG4gICAgICogY292ZXIgdGhlIGdpdmVuIGJvdW5kcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5PENvb3JkaW5hdGU+fSBxdWVyeUdlb21ldHJ5IGNvb3JkaW5hdGVzIG9mIHRoZSBjb3JuZXJzIG9mIGJvdW5kaW5nIHJlY3RhbmdsZVxuICAgICAqIEByZXR1cm5zIHtBcnJheTxPYmplY3Q+fSByZXN1bHQgaXRlbXMgaGF2ZSB7dGlsZSwgbWluWCwgbWF4WCwgbWluWSwgbWF4WX0sIHdoZXJlIG1pbi9tYXggYm91bmRpbmcgdmFsdWVzIGFyZSB0aGUgZ2l2ZW4gYm91bmRzIHRyYW5zZm9ybWVkIGluIGludG8gdGhlIGNvb3JkaW5hdGUgc3BhY2Ugb2YgdGhpcyB0aWxlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGlsZXNJbjogZnVuY3Rpb24ocXVlcnlHZW9tZXRyeSkge1xuICAgICAgICB2YXIgdGlsZVJlc3VsdHMgPSB7fTtcbiAgICAgICAgdmFyIGlkcyA9IHRoaXMub3JkZXJlZElEcygpO1xuXG4gICAgICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuICAgICAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcbiAgICAgICAgdmFyIHogPSBxdWVyeUdlb21ldHJ5WzBdLnpvb207XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBxdWVyeUdlb21ldHJ5Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHF1ZXJ5R2VvbWV0cnlba107XG4gICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgcC5jb2x1bW4pO1xuICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHAucm93KTtcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBwLmNvbHVtbik7XG4gICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgcC5yb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0aWxlID0gdGhpcy5fdGlsZXNbaWRzW2ldXTtcbiAgICAgICAgICAgIHZhciBjb29yZCA9IFRpbGVDb29yZC5mcm9tSUQoaWRzW2ldKTtcblxuICAgICAgICAgICAgdmFyIHRpbGVTcGFjZUJvdW5kcyA9IFtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlVG9UaWxlUG9pbnQoY29vcmQsIHRpbGUuc291cmNlTWF4Wm9vbSwgbmV3IENvb3JkaW5hdGUobWluWCwgbWluWSwgeikpLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVUb1RpbGVQb2ludChjb29yZCwgdGlsZS5zb3VyY2VNYXhab29tLCBuZXcgQ29vcmRpbmF0ZShtYXhYLCBtYXhZLCB6KSlcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGlmICh0aWxlU3BhY2VCb3VuZHNbMF0ueCA8IEVYVEVOVCAmJiB0aWxlU3BhY2VCb3VuZHNbMF0ueSA8IEVYVEVOVCAmJlxuICAgICAgICAgICAgICAgIHRpbGVTcGFjZUJvdW5kc1sxXS54ID49IDAgJiYgdGlsZVNwYWNlQm91bmRzWzFdLnkgPj0gMCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHRpbGVTcGFjZVF1ZXJ5R2VvbWV0cnkgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHF1ZXJ5R2VvbWV0cnkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGlsZVNwYWNlUXVlcnlHZW9tZXRyeS5wdXNoKGNvb3JkaW5hdGVUb1RpbGVQb2ludChjb29yZCwgdGlsZS5zb3VyY2VNYXhab29tLCBxdWVyeUdlb21ldHJ5W2pdKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRpbGVSZXN1bHQgPSB0aWxlUmVzdWx0c1t0aWxlLmNvb3JkLmlkXTtcbiAgICAgICAgICAgICAgICBpZiAodGlsZVJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbGVSZXN1bHQgPSB0aWxlUmVzdWx0c1t0aWxlLmNvb3JkLmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGU6IHRpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeUdlb21ldHJ5OiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlOiBNYXRoLnBvdygyLCB0aGlzLnRyYW5zZm9ybS56b29tIC0gdGlsZS5jb29yZC56KVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdyYXBwZWQgdGlsZXMgc2hhcmUgb25lIHRpbGVSZXN1bHQgb2JqZWN0IGJ1dCBjYW4gaGF2ZSBtdWx0aXBsZSBxdWVyeUdlb21ldHJ5IHBhcnRzXG4gICAgICAgICAgICAgICAgdGlsZVJlc3VsdC5xdWVyeUdlb21ldHJ5LnB1c2godGlsZVNwYWNlUXVlcnlHZW9tZXRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciB0IGluIHRpbGVSZXN1bHRzKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGlsZVJlc3VsdHNbdF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29udmVydCBhIGNvb3JkaW5hdGUgdG8gYSBwb2ludCBpbiBhIHRpbGUncyBjb29yZGluYXRlIHNwYWNlLlxuICogQHBhcmFtIHtDb29yZGluYXRlfSB0aWxlQ29vcmRcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRcbiAqIEByZXR1cm5zIHtPYmplY3R9IHBvc2l0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb29yZGluYXRlVG9UaWxlUG9pbnQodGlsZUNvb3JkLCBzb3VyY2VNYXhab29tLCBjb29yZCkge1xuICAgIHZhciB6b29tZWRDb29yZCA9IGNvb3JkLnpvb21UbyhNYXRoLm1pbih0aWxlQ29vcmQueiwgc291cmNlTWF4Wm9vbSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6ICh6b29tZWRDb29yZC5jb2x1bW4gLSAodGlsZUNvb3JkLnggKyB0aWxlQ29vcmQudyAqIE1hdGgucG93KDIsIHRpbGVDb29yZC56KSkpICogRVhURU5ULFxuICAgICAgICB5OiAoem9vbWVkQ29vcmQucm93IC0gdGlsZUNvb3JkLnkpICogRVhURU5UXG4gICAgfTtcblxufVxuXG5mdW5jdGlvbiBjb21wYXJlS2V5Wm9vbShhLCBiKSB7XG4gICAgcmV0dXJuIChhICUgMzIpIC0gKGIgJSAzMik7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZCcpO1xudmFyIFNvdXJjZSA9IHJlcXVpcmUoJy4vc291cmNlJyk7XG52YXIgbm9ybWFsaXplVVJMID0gcmVxdWlyZSgnLi4vdXRpbC9tYXBib3gnKS5ub3JtYWxpemVUaWxlVVJMO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGVTb3VyY2U7XG5cbmZ1bmN0aW9uIFZlY3RvclRpbGVTb3VyY2Uob3B0aW9ucykge1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMsIHV0aWwucGljayhvcHRpb25zLCBbJ3VybCcsICd0aWxlU2l6ZSddKSk7XG4gICAgdGhpcy5fb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHsgdHlwZTogJ3ZlY3RvcicgfSwgb3B0aW9ucyk7XG5cbiAgICBpZiAodGhpcy50aWxlU2l6ZSAhPT0gNTEyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmVjdG9yIHRpbGUgc291cmNlcyBtdXN0IGhhdmUgYSB0aWxlU2l6ZSBvZiA1MTInKTtcbiAgICB9XG5cbiAgICBTb3VyY2UuX2xvYWRUaWxlSlNPTi5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5WZWN0b3JUaWxlU291cmNlLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChFdmVudGVkLCB7XG4gICAgbWluem9vbTogMCxcbiAgICBtYXh6b29tOiAyMixcbiAgICB0aWxlU2l6ZTogNTEyLFxuICAgIHJlcGFyc2VPdmVyc2NhbGVkOiB0cnVlLFxuICAgIF9sb2FkZWQ6IGZhbHNlLFxuICAgIGlzVGlsZUNsaXBwZWQ6IHRydWUsXG5cbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgIH0sXG5cbiAgICBsb2FkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHlyYW1pZCAmJiB0aGlzLl9weXJhbWlkLmxvYWRlZCgpO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICBpZiAodGhpcy5fcHlyYW1pZCkge1xuICAgICAgICAgICAgdGhpcy5fcHlyYW1pZC51cGRhdGUodGhpcy51c2VkLCB0cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9weXJhbWlkKSB7XG4gICAgICAgICAgICB0aGlzLl9weXJhbWlkLnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1dGlsLmV4dGVuZCh7fSwgdGhpcy5fb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIGdldFZpc2libGVDb29yZGluYXRlczogU291cmNlLl9nZXRWaXNpYmxlQ29vcmRpbmF0ZXMsXG4gICAgZ2V0VGlsZTogU291cmNlLl9nZXRUaWxlLFxuXG4gICAgcXVlcnlSZW5kZXJlZEZlYXR1cmVzOiBTb3VyY2UuX3F1ZXJ5UmVuZGVyZWRWZWN0b3JGZWF0dXJlcyxcbiAgICBxdWVyeVNvdXJjZUZlYXR1cmVzOiBTb3VyY2UuX3F1ZXJ5U291cmNlRmVhdHVyZXMsXG5cbiAgICBfbG9hZFRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdmFyIG92ZXJzY2FsaW5nID0gdGlsZS5jb29yZC56ID4gdGhpcy5tYXh6b29tID8gTWF0aC5wb3coMiwgdGlsZS5jb29yZC56IC0gdGhpcy5tYXh6b29tKSA6IDE7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICB1cmw6IG5vcm1hbGl6ZVVSTCh0aWxlLmNvb3JkLnVybCh0aGlzLnRpbGVzLCB0aGlzLm1heHpvb20pLCB0aGlzLnVybCksXG4gICAgICAgICAgICB1aWQ6IHRpbGUudWlkLFxuICAgICAgICAgICAgY29vcmQ6IHRpbGUuY29vcmQsXG4gICAgICAgICAgICB6b29tOiB0aWxlLmNvb3JkLnosXG4gICAgICAgICAgICB0aWxlU2l6ZTogdGhpcy50aWxlU2l6ZSAqIG92ZXJzY2FsaW5nLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLmlkLFxuICAgICAgICAgICAgb3ZlcnNjYWxpbmc6IG92ZXJzY2FsaW5nLFxuICAgICAgICAgICAgYW5nbGU6IHRoaXMubWFwLnRyYW5zZm9ybS5hbmdsZSxcbiAgICAgICAgICAgIHBpdGNoOiB0aGlzLm1hcC50cmFuc2Zvcm0ucGl0Y2gsXG4gICAgICAgICAgICBzaG93Q29sbGlzaW9uQm94ZXM6IHRoaXMubWFwLnNob3dDb2xsaXNpb25Cb3hlc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aWxlLndvcmtlcklEKSB7XG4gICAgICAgICAgICBwYXJhbXMucmF3VGlsZURhdGEgPSB0aWxlLnJhd1RpbGVEYXRhO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnNlbmQoJ3JlbG9hZCB0aWxlJywgcGFyYW1zLCB0aGlzLl90aWxlTG9hZGVkLmJpbmQodGhpcywgdGlsZSksIHRpbGUud29ya2VySUQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGlsZS53b3JrZXJJRCA9IHRoaXMuZGlzcGF0Y2hlci5zZW5kKCdsb2FkIHRpbGUnLCBwYXJhbXMsIHRoaXMuX3RpbGVMb2FkZWQuYmluZCh0aGlzLCB0aWxlKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3RpbGVMb2FkZWQ6IGZ1bmN0aW9uKHRpbGUsIGVyciwgZGF0YSkge1xuICAgICAgICBpZiAodGlsZS5hYm9ydGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRpbGUuZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3RpbGUuZXJyb3InLCB7dGlsZTogdGlsZSwgZXJyb3I6IGVycn0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGlsZS5sb2FkVmVjdG9yRGF0YShkYXRhLCB0aGlzLm1hcC5zdHlsZSk7XG5cbiAgICAgICAgaWYgKHRpbGUucmVkb1doZW5Eb25lKSB7XG4gICAgICAgICAgICB0aWxlLnJlZG9XaGVuRG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGlsZS5yZWRvUGxhY2VtZW50KHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maXJlKCd0aWxlLmxvYWQnLCB7dGlsZTogdGlsZX0pO1xuICAgICAgICB0aGlzLmZpcmUoJ3RpbGUuc3RhdHMnLCBkYXRhLmJ1Y2tldFN0YXRzKTtcbiAgICB9LFxuXG4gICAgX2Fib3J0VGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aWxlLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIuc2VuZCgnYWJvcnQgdGlsZScsIHsgdWlkOiB0aWxlLnVpZCwgc291cmNlOiB0aGlzLmlkIH0sIG51bGwsIHRpbGUud29ya2VySUQpO1xuICAgIH0sXG5cbiAgICBfYWRkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3RpbGUuYWRkJywge3RpbGU6IHRpbGV9KTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZVRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGhpcy5maXJlKCd0aWxlLnJlbW92ZScsIHt0aWxlOiB0aWxlfSk7XG4gICAgfSxcblxuICAgIF91bmxvYWRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRpbGUudW5sb2FkVmVjdG9yRGF0YSh0aGlzLm1hcC5wYWludGVyKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnNlbmQoJ3JlbW92ZSB0aWxlJywgeyB1aWQ6IHRpbGUudWlkLCBzb3VyY2U6IHRoaXMuaWQgfSwgbnVsbCwgdGlsZS53b3JrZXJJRCk7XG4gICAgfSxcblxuICAgIHJlZG9QbGFjZW1lbnQ6IFNvdXJjZS5yZWRvUGxhY2VtZW50LFxuXG4gICAgX3JlZG9UaWxlUGxhY2VtZW50OiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRpbGUucmVkb1BsYWNlbWVudCh0aGlzKTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBUaWxlID0gcmVxdWlyZSgnLi90aWxlJyk7XG52YXIgVGlsZUNvb3JkID0gcmVxdWlyZSgnLi90aWxlX2Nvb3JkJyk7XG52YXIgTG5nTGF0ID0gcmVxdWlyZSgnLi4vZ2VvL2xuZ19sYXQnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZCcpO1xudmFyIGFqYXggPSByZXF1aXJlKCcuLi91dGlsL2FqYXgnKTtcbnZhciBFWFRFTlQgPSByZXF1aXJlKCcuLi9kYXRhL2J1Y2tldCcpLkVYVEVOVDtcbnZhciBSYXN0ZXJCb3VuZHNBcnJheSA9IHJlcXVpcmUoJy4uL3JlbmRlci9kcmF3X3Jhc3RlcicpLlJhc3RlckJvdW5kc0FycmF5O1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4uL2RhdGEvYnVmZmVyJyk7XG52YXIgVmVydGV4QXJyYXlPYmplY3QgPSByZXF1aXJlKCcuLi9yZW5kZXIvdmVydGV4X2FycmF5X29iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZGVvU291cmNlO1xuXG4vKipcbiAqIENyZWF0ZSBhIFZpZGVvIGRhdGEgc291cmNlIGluc3RhbmNlIGdpdmVuIGFuIG9wdGlvbnMgb2JqZWN0XG4gKiBAY2xhc3MgVmlkZW9Tb3VyY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gb3B0aW9ucy51cmxzIEFuIGFycmF5IG9mIFVSTHMgdG8gdmlkZW8gZmlsZXNcbiAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbnMuY29vcmRpbmF0ZXMgRm91ciBnZW9ncmFwaGljYWwgW2xuZywgbGF0XSBjb29yZGluYXRlcyBpbiBjbG9ja3dpc2Ugb3JkZXIgZGVmaW5pbmcgdGhlIGNvcm5lcnMgKHN0YXJ0aW5nIHdpdGggdG9wIGxlZnQpIG9mIHRoZSB2aWRlby4gRG9lcyBub3QgaGF2ZSB0byBiZSBhIHJlY3RhbmdsZS5cbiAqIEBleGFtcGxlXG4gKiB2YXIgc291cmNlT2JqID0gbmV3IG1hcGJveGdsLlZpZGVvU291cmNlKHtcbiAqICAgIHVybDogW1xuICogICAgICAgICdodHRwczovL3d3dy5tYXBib3guY29tL3ZpZGVvcy9iYWx0aW1vcmUtc21va2UubXA0JyxcbiAqICAgICAgICAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS92aWRlb3MvYmFsdGltb3JlLXNtb2tlLndlYm0nXG4gKiAgICBdLFxuICogICAgY29vcmRpbmF0ZXM6IFtcbiAqICAgICAgICBbLTc2LjU0MzM1NzM3MjI4Mzk0LCAzOS4xODU3OTkwNzIyOTc0OF0sXG4gKiAgICAgICAgWy03Ni41MjgwMzY1OTQzOTA4NywgMzkuMTgzODM2NDg0NzU4N10sXG4gKiAgICAgICAgWy03Ni41Mjk1Mzg2MzE0MzkyLCAzOS4xNzY4MzM5MjUwNzYwNl0sXG4gKiAgICAgICAgWy03Ni41NDUyMDI3MzIwODYxOCwgMzkuMTc4NzYzNDQxMDY2NDJdXG4gKiAgICBdXG4gKiB9KTtcbiAqIG1hcC5hZGRTb3VyY2UoJ3NvbWUgaWQnLCBzb3VyY2VPYmopOyAvLyBhZGRcbiAqIG1hcC5yZW1vdmVTb3VyY2UoJ3NvbWUgaWQnKTsgIC8vIHJlbW92ZVxuICovXG5mdW5jdGlvbiBWaWRlb1NvdXJjZShvcHRpb25zKSB7XG4gICAgdGhpcy51cmxzID0gb3B0aW9ucy51cmxzO1xuICAgIHRoaXMuY29vcmRpbmF0ZXMgPSBvcHRpb25zLmNvb3JkaW5hdGVzO1xuXG4gICAgYWpheC5nZXRWaWRlbyhvcHRpb25zLnVybHMsIGZ1bmN0aW9uKGVyciwgdmlkZW8pIHtcbiAgICAgICAgLy8gQFRPRE8gaGFuZGxlIGVycm9ycyB2aWEgZXZlbnQuXG4gICAgICAgIGlmIChlcnIpIHJldHVybjtcblxuICAgICAgICB0aGlzLnZpZGVvID0gdmlkZW87XG4gICAgICAgIHRoaXMudmlkZW8ubG9vcCA9IHRydWU7XG5cbiAgICAgICAgdmFyIGxvb3BJRDtcblxuICAgICAgICAvLyBzdGFydCByZXBhaW50aW5nIHdoZW4gdmlkZW8gc3RhcnRzIHBsYXlpbmdcbiAgICAgICAgdGhpcy52aWRlby5hZGRFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsb29wSUQgPSB0aGlzLm1hcC5zdHlsZS5hbmltYXRpb25Mb29wLnNldChJbmZpbml0eSk7XG4gICAgICAgICAgICB0aGlzLm1hcC5fcmVyZW5kZXIoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBzdG9wIHJlcGFpbnRpbmcgd2hlbiB2aWRlbyBzdG9wc1xuICAgICAgICB0aGlzLnZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ3BhdXNlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLm1hcC5zdHlsZS5hbmltYXRpb25Mb29wLmNhbmNlbChsb29wSUQpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMuX2xvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMubWFwKSB7XG4gICAgICAgICAgICB0aGlzLnZpZGVvLnBsYXkoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29vcmRpbmF0ZXMob3B0aW9ucy5jb29yZGluYXRlcyk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xufVxuXG5WaWRlb1NvdXJjZS5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoRXZlbnRlZCwgLyoqIEBsZW5kcyBWaWRlb1NvdXJjZS5wcm90b3R5cGUgKi97XG4gICAgcm91bmRab29tOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBIVE1MIHZpZGVvIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFZpZGVvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlkZW87XG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgICAgIGlmICh0aGlzLnZpZGVvKSB7XG4gICAgICAgICAgICB0aGlzLnZpZGVvLnBsYXkoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29vcmRpbmF0ZXModGhpcy5jb29yZGluYXRlcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHZpZGVvIGNvb3JkaW5hdGVzIGFuZCByZXJlbmRlciBtYXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvb3JkaW5hdGVzIEZvdXIgZ2VvZ3JhcGhpY2FsIFtsbmcsIGxhdF0gY29vcmRpbmF0ZXMgaW4gY2xvY2t3aXNlIG9yZGVyIGRlZmluaW5nIHRoZSBjb3JuZXJzIChzdGFydGluZyB3aXRoIHRvcCBsZWZ0KSBvZiB0aGUgdmlkZW8uIERvZXMgbm90IGhhdmUgdG8gYmUgYSByZWN0YW5nbGUuXG4gICAgICogQHJldHVybnMge1ZpZGVvU291cmNlfSB0aGlzXG4gICAgICovXG4gICAgc2V0Q29vcmRpbmF0ZXM6IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHRoaXMuY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlcztcblxuICAgICAgICAvLyBDYWxjdWxhdGUgd2hpY2ggbWVyY2F0b3IgdGlsZSBpcyBzdWl0YWJsZSBmb3IgcmVuZGVyaW5nIHRoZSB2aWRlbyBpblxuICAgICAgICAvLyBhbmQgY3JlYXRlIGEgYnVmZmVyIHdpdGggdGhlIGNvcm5lciBjb29yZGluYXRlcy4gVGhlc2UgY29vcmRpbmF0ZXNcbiAgICAgICAgLy8gbWF5IGJlIG91dHNpZGUgdGhlIHRpbGUsIGJlY2F1c2UgcmFzdGVyIHRpbGVzIGFyZW4ndCBjbGlwcGVkIHdoZW4gcmVuZGVyaW5nLlxuXG4gICAgICAgIHZhciBtYXAgPSB0aGlzLm1hcDtcbiAgICAgICAgdmFyIGNvcm5lclowQ29vcmRzID0gY29vcmRpbmF0ZXMubWFwKGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwLnRyYW5zZm9ybS5sb2NhdGlvbkNvb3JkaW5hdGUoTG5nTGF0LmNvbnZlcnQoY29vcmQpKS56b29tVG8oMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBjZW50ZXJDb29yZCA9IHRoaXMuY2VudGVyQ29vcmQgPSB1dGlsLmdldENvb3JkaW5hdGVzQ2VudGVyKGNvcm5lclowQ29vcmRzKTtcbiAgICAgICAgY2VudGVyQ29vcmQuY29sdW1uID0gTWF0aC5yb3VuZChjZW50ZXJDb29yZC5jb2x1bW4pO1xuICAgICAgICBjZW50ZXJDb29yZC5yb3cgPSBNYXRoLnJvdW5kKGNlbnRlckNvb3JkLnJvdyk7XG5cblxuICAgICAgICB2YXIgdGlsZUNvb3JkcyA9IGNvcm5lclowQ29vcmRzLm1hcChmdW5jdGlvbihjb29yZCkge1xuICAgICAgICAgICAgdmFyIHpvb21lZENvb3JkID0gY29vcmQuem9vbVRvKGNlbnRlckNvb3JkLnpvb20pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKCh6b29tZWRDb29yZC5jb2x1bW4gLSBjZW50ZXJDb29yZC5jb2x1bW4pICogRVhURU5UKSxcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKCh6b29tZWRDb29yZC5yb3cgLSBjZW50ZXJDb29yZC5yb3cpICogRVhURU5UKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBtYXhJbnQxNiA9IDMyNzY3O1xuICAgICAgICB2YXIgYXJyYXkgPSBuZXcgUmFzdGVyQm91bmRzQXJyYXkoKTtcbiAgICAgICAgYXJyYXkuZW1wbGFjZUJhY2sodGlsZUNvb3Jkc1swXS54LCB0aWxlQ29vcmRzWzBdLnksIDAsIDApO1xuICAgICAgICBhcnJheS5lbXBsYWNlQmFjayh0aWxlQ29vcmRzWzFdLngsIHRpbGVDb29yZHNbMV0ueSwgbWF4SW50MTYsIDApO1xuICAgICAgICBhcnJheS5lbXBsYWNlQmFjayh0aWxlQ29vcmRzWzNdLngsIHRpbGVDb29yZHNbM10ueSwgMCwgbWF4SW50MTYpO1xuICAgICAgICBhcnJheS5lbXBsYWNlQmFjayh0aWxlQ29vcmRzWzJdLngsIHRpbGVDb29yZHNbMl0ueSwgbWF4SW50MTYsIG1heEludDE2KTtcblxuICAgICAgICB0aGlzLnRpbGUgPSBuZXcgVGlsZShuZXcgVGlsZUNvb3JkKGNlbnRlckNvb3JkLnpvb20sIGNlbnRlckNvb3JkLmNvbHVtbiwgY2VudGVyQ29vcmQucm93KSk7XG4gICAgICAgIHRoaXMudGlsZS5idWNrZXRzID0ge307XG5cbiAgICAgICAgdGhpcy50aWxlLmJvdW5kc0J1ZmZlciA9IG5ldyBCdWZmZXIoYXJyYXkuc2VyaWFsaXplKCksIFJhc3RlckJvdW5kc0FycmF5LnNlcmlhbGl6ZSgpLCBCdWZmZXIuQnVmZmVyVHlwZS5WRVJURVgpO1xuICAgICAgICB0aGlzLnRpbGUuYm91bmRzVkFPID0gbmV3IFZlcnRleEFycmF5T2JqZWN0KCk7XG5cbiAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2UnKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlkZW8gJiYgdGhpcy52aWRlby5yZWFkeVN0YXRlID49IDI7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9LFxuXG4gICAgcmVsb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH0sXG5cbiAgICBwcmVwYXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMudmlkZW8ucmVhZHlTdGF0ZSA8IDIpIHJldHVybjsgLy8gbm90IGVub3VnaCBkYXRhIGZvciBjdXJyZW50IHBvc2l0aW9uXG5cbiAgICAgICAgdmFyIGdsID0gdGhpcy5tYXAucGFpbnRlci5nbDtcbiAgICAgICAgaWYgKCF0aGlzLnRpbGUudGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy50aWxlLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRpbGUudGV4dHVyZSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy52aWRlbyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRpbGUudGV4dHVyZSk7XG4gICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMudmlkZW8pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSB0aGlzLnZpZGVvLmN1cnJlbnRUaW1lO1xuICAgIH0sXG5cbiAgICBnZXRWaXNpYmxlQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy50aWxlKSByZXR1cm4gW3RoaXMudGlsZS5jb29yZF07XG4gICAgICAgIGVsc2UgcmV0dXJuIFtdO1xuICAgIH0sXG5cbiAgICBnZXRUaWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZTtcbiAgICB9LFxuXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICd2aWRlbycsXG4gICAgICAgICAgICB1cmxzOiB0aGlzLnVybHMsXG4gICAgICAgICAgICBjb29yZGluYXRlczogdGhpcy5jb29yZGluYXRlc1xuICAgICAgICB9O1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0b3IgPSByZXF1aXJlKCcuLi91dGlsL2FjdG9yJyk7XG52YXIgV29ya2VyVGlsZSA9IHJlcXVpcmUoJy4vd29ya2VyX3RpbGUnKTtcbnZhciBTdHlsZUxheWVyID0gcmVxdWlyZSgnLi4vc3R5bGUvc3R5bGVfbGF5ZXInKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgYWpheCA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheCcpO1xudmFyIHZ0ID0gcmVxdWlyZSgndmVjdG9yLXRpbGUnKTtcbnZhciBQcm90b2J1ZiA9IHJlcXVpcmUoJ3BiZicpO1xudmFyIHN1cGVyY2x1c3RlciA9IHJlcXVpcmUoJ3N1cGVyY2x1c3RlcicpO1xuXG52YXIgZ2VvanNvbnZ0ID0gcmVxdWlyZSgnZ2VvanNvbi12dCcpO1xudmFyIHJld2luZCA9IHJlcXVpcmUoJ2dlb2pzb24tcmV3aW5kJyk7XG52YXIgR2VvSlNPTldyYXBwZXIgPSByZXF1aXJlKCcuL2dlb2pzb25fd3JhcHBlcicpO1xudmFyIHZ0cGJmID0gcmVxdWlyZSgndnQtcGJmJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2VsZikge1xuICAgIHJldHVybiBuZXcgV29ya2VyKHNlbGYpO1xufTtcblxuZnVuY3Rpb24gV29ya2VyKHNlbGYpIHtcbiAgICB0aGlzLnNlbGYgPSBzZWxmO1xuICAgIHRoaXMuYWN0b3IgPSBuZXcgQWN0b3Ioc2VsZiwgdGhpcyk7XG4gICAgdGhpcy5sb2FkaW5nID0ge307XG5cbiAgICB0aGlzLmxvYWRlZCA9IHt9O1xuICAgIHRoaXMuZ2VvSlNPTkluZGV4ZXMgPSB7fTtcbn1cblxudXRpbC5leHRlbmQoV29ya2VyLnByb3RvdHlwZSwge1xuICAgICdzZXQgbGF5ZXJzJzogZnVuY3Rpb24obGF5ZXJzKSB7XG4gICAgICAgIHRoaXMubGF5ZXJzID0ge307XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAvLyBGaWx0ZXIgbGF5ZXJzIGFuZCBjcmVhdGUgYW4gaWQgLT4gbGF5ZXIgbWFwXG4gICAgICAgIHZhciBjaGlsZExheWVySW5kaWNpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcbiAgICAgICAgICAgIGlmIChsYXllci50eXBlID09PSAnZmlsbCcgfHwgbGF5ZXIudHlwZSA9PT0gJ2xpbmUnIHx8IGxheWVyLnR5cGUgPT09ICdjaXJjbGUnIHx8IGxheWVyLnR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLnJlZikge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZExheWVySW5kaWNpZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRMYXllcihsYXllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIFN0eWxlTGF5ZXIgcGVyIGxheWVyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hpbGRMYXllckluZGljaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBzZXRMYXllcihsYXllcnNbY2hpbGRMYXllckluZGljaWVzW2pdXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZXRMYXllcihzZXJpYWxpemVkTGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZUxheWVyID0gU3R5bGVMYXllci5jcmVhdGUoXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZExheWVyLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRMYXllci5yZWYgJiYgdGhhdC5sYXllcnNbc2VyaWFsaXplZExheWVyLnJlZl1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzdHlsZUxheWVyLnVwZGF0ZVBhaW50VHJhbnNpdGlvbnMoe30sIHt0cmFuc2l0aW9uOiBmYWxzZX0pO1xuICAgICAgICAgICAgdGhhdC5sYXllcnNbc3R5bGVMYXllci5pZF0gPSBzdHlsZUxheWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXllckZhbWlsaWVzID0gY3JlYXRlTGF5ZXJGYW1pbGllcyh0aGlzLmxheWVycyk7XG4gICAgfSxcblxuICAgICd1cGRhdGUgbGF5ZXJzJzogZnVuY3Rpb24obGF5ZXJzKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICB2YXIgbGF5ZXI7XG5cbiAgICAgICAgLy8gVXBkYXRlIHJlZiBwYXJlbnRzXG4gICAgICAgIGZvciAoaWQgaW4gbGF5ZXJzKSB7XG4gICAgICAgICAgICBsYXllciA9IGxheWVyc1tpZF07XG4gICAgICAgICAgICBpZiAobGF5ZXIucmVmKSB1cGRhdGVMYXllcihsYXllcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgcmVmIGNoaWxkcmVuXG4gICAgICAgIGZvciAoaWQgaW4gbGF5ZXJzKSB7XG4gICAgICAgICAgICBsYXllciA9IGxheWVyc1tpZF07XG4gICAgICAgICAgICBpZiAoIWxheWVyLnJlZikgdXBkYXRlTGF5ZXIobGF5ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciByZWZMYXllciA9IHRoYXQubGF5ZXJzW2xheWVyLnJlZl07XG4gICAgICAgICAgICBpZiAodGhhdC5sYXllcnNbbGF5ZXIuaWRdKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5sYXllcnNbbGF5ZXIuaWRdLnNldChsYXllciwgcmVmTGF5ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGF0LmxheWVyc1tsYXllci5pZF0gPSBTdHlsZUxheWVyLmNyZWF0ZShsYXllciwgcmVmTGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhhdC5sYXllcnNbbGF5ZXIuaWRdLnVwZGF0ZVBhaW50VHJhbnNpdGlvbnMoe30sIHt0cmFuc2l0aW9uOiBmYWxzZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXllckZhbWlsaWVzID0gY3JlYXRlTGF5ZXJGYW1pbGllcyh0aGlzLmxheWVycyk7XG4gICAgfSxcblxuICAgICdsb2FkIHRpbGUnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBwYXJhbXMuc291cmNlLFxuICAgICAgICAgICAgdWlkID0gcGFyYW1zLnVpZDtcblxuICAgICAgICBpZiAoIXRoaXMubG9hZGluZ1tzb3VyY2VdKVxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nW3NvdXJjZV0gPSB7fTtcblxuXG4gICAgICAgIHZhciB0aWxlID0gdGhpcy5sb2FkaW5nW3NvdXJjZV1bdWlkXSA9IG5ldyBXb3JrZXJUaWxlKHBhcmFtcyk7XG5cbiAgICAgICAgdGlsZS54aHIgPSBhamF4LmdldEFycmF5QnVmZmVyKHBhcmFtcy51cmwsIGRvbmUuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgZnVuY3Rpb24gZG9uZShlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxvYWRpbmdbc291cmNlXVt1aWRdO1xuXG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcblxuICAgICAgICAgICAgdGlsZS5kYXRhID0gbmV3IHZ0LlZlY3RvclRpbGUobmV3IFByb3RvYnVmKG5ldyBVaW50OEFycmF5KGRhdGEpKSk7XG4gICAgICAgICAgICB0aWxlLnBhcnNlKHRpbGUuZGF0YSwgdGhpcy5sYXllckZhbWlsaWVzLCB0aGlzLmFjdG9yLCBkYXRhLCBjYWxsYmFjayk7XG5cbiAgICAgICAgICAgIHRoaXMubG9hZGVkW3NvdXJjZV0gPSB0aGlzLmxvYWRlZFtzb3VyY2VdIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5sb2FkZWRbc291cmNlXVt1aWRdID0gdGlsZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAncmVsb2FkIHRpbGUnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBsb2FkZWQgPSB0aGlzLmxvYWRlZFtwYXJhbXMuc291cmNlXSxcbiAgICAgICAgICAgIHVpZCA9IHBhcmFtcy51aWQ7XG4gICAgICAgIGlmIChsb2FkZWQgJiYgbG9hZGVkW3VpZF0pIHtcbiAgICAgICAgICAgIHZhciB0aWxlID0gbG9hZGVkW3VpZF07XG4gICAgICAgICAgICB0aWxlLnBhcnNlKHRpbGUuZGF0YSwgdGhpcy5sYXllckZhbWlsaWVzLCB0aGlzLmFjdG9yLCBwYXJhbXMucmF3VGlsZURhdGEsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnYWJvcnQgdGlsZSc6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgbG9hZGluZyA9IHRoaXMubG9hZGluZ1twYXJhbXMuc291cmNlXSxcbiAgICAgICAgICAgIHVpZCA9IHBhcmFtcy51aWQ7XG4gICAgICAgIGlmIChsb2FkaW5nICYmIGxvYWRpbmdbdWlkXSkge1xuICAgICAgICAgICAgbG9hZGluZ1t1aWRdLnhoci5hYm9ydCgpO1xuICAgICAgICAgICAgZGVsZXRlIGxvYWRpbmdbdWlkXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAncmVtb3ZlIHRpbGUnOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGxvYWRlZCA9IHRoaXMubG9hZGVkW3BhcmFtcy5zb3VyY2VdLFxuICAgICAgICAgICAgdWlkID0gcGFyYW1zLnVpZDtcbiAgICAgICAgaWYgKGxvYWRlZCAmJiBsb2FkZWRbdWlkXSkge1xuICAgICAgICAgICAgZGVsZXRlIGxvYWRlZFt1aWRdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdyZWRvIHBsYWNlbWVudCc6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGxvYWRlZCA9IHRoaXMubG9hZGVkW3BhcmFtcy5zb3VyY2VdLFxuICAgICAgICAgICAgbG9hZGluZyA9IHRoaXMubG9hZGluZ1twYXJhbXMuc291cmNlXSxcbiAgICAgICAgICAgIHVpZCA9IHBhcmFtcy51aWQ7XG5cbiAgICAgICAgaWYgKGxvYWRlZCAmJiBsb2FkZWRbdWlkXSkge1xuICAgICAgICAgICAgdmFyIHRpbGUgPSBsb2FkZWRbdWlkXTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aWxlLnJlZG9QbGFjZW1lbnQocGFyYW1zLmFuZ2xlLCBwYXJhbXMucGl0Y2gsIHBhcmFtcy5zaG93Q29sbGlzaW9uQm94ZXMpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdC5yZXN1bHQsIHJlc3VsdC50cmFuc2ZlcmFibGVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGxvYWRpbmcgJiYgbG9hZGluZ1t1aWRdKSB7XG4gICAgICAgICAgICBsb2FkaW5nW3VpZF0uYW5nbGUgPSBwYXJhbXMuYW5nbGU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ3BhcnNlIGdlb2pzb24nOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpbmRleERhdGEgPSBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgIHJld2luZChkYXRhLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcIklucHV0IGRhdGEgaXMgbm90IGEgdmFsaWQgR2VvSlNPTiBvYmplY3QuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZW9KU09OSW5kZXhlc1twYXJhbXMuc291cmNlXSA9IHBhcmFtcy5jbHVzdGVyID9cbiAgICAgICAgICAgICAgICAgICAgc3VwZXJjbHVzdGVyKHBhcmFtcy5zdXBlcmNsdXN0ZXJPcHRpb25zKS5sb2FkKGRhdGEuZmVhdHVyZXMpIDpcbiAgICAgICAgICAgICAgICAgICAgZ2VvanNvbnZ0KGRhdGEsIHBhcmFtcy5nZW9qc29uVnRPcHRpb25zKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBOb3QsIGJlY2F1c2Ugb2Ygc2FtZSBvcmlnaW4gaXNzdWVzLCB1cmxzIG11c3QgZWl0aGVyIGluY2x1ZGUgYW5cbiAgICAgICAgLy8gZXhwbGljaXQgb3JpZ2luIG9yIGFic29sdXRlIHBhdGguXG4gICAgICAgIC8vIGllOiAvZm9vL2Jhci5qc29uIG9yIGh0dHA6Ly9leGFtcGxlLmNvbS9iYXIuanNvblxuICAgICAgICAvLyBidXQgbm90IC4uL2Zvby9iYXIuanNvblxuICAgICAgICBpZiAocGFyYW1zLnVybCkge1xuICAgICAgICAgICAgYWpheC5nZXRKU09OKHBhcmFtcy51cmwsIGluZGV4RGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcy5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaW5kZXhEYXRhKG51bGwsIEpTT04ucGFyc2UocGFyYW1zLmRhdGEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJJbnB1dCBkYXRhIGlzIG5vdCBhIHZhbGlkIEdlb0pTT04gb2JqZWN0LlwiKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2xvYWQgZ2VvanNvbiB0aWxlJzogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc291cmNlID0gcGFyYW1zLnNvdXJjZSxcbiAgICAgICAgICAgIGNvb3JkID0gcGFyYW1zLmNvb3JkO1xuXG4gICAgICAgIGlmICghdGhpcy5nZW9KU09OSW5kZXhlc1tzb3VyY2VdKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbCk7IC8vIHdlIGNvdWxkbid0IGxvYWQgdGhlIGZpbGVcblxuICAgICAgICAvLyBjb25zb2xlLnRpbWUoJ3RpbGUgJyArIGNvb3JkLnogKyAnICcgKyBjb29yZC54ICsgJyAnICsgY29vcmQueSk7XG5cbiAgICAgICAgdmFyIGdlb0pTT05UaWxlID0gdGhpcy5nZW9KU09OSW5kZXhlc1tzb3VyY2VdLmdldFRpbGUoTWF0aC5taW4oY29vcmQueiwgcGFyYW1zLm1heFpvb20pLCBjb29yZC54LCBjb29yZC55KTtcblxuICAgICAgICAvLyBjb25zb2xlLnRpbWVFbmQoJ3RpbGUgJyArIGNvb3JkLnogKyAnICcgKyBjb29yZC54ICsgJyAnICsgY29vcmQueSk7XG5cbiAgICAgICAgLy8gaWYgKCFnZW9KU09OVGlsZSkgY29uc29sZS5sb2coJ25vdCBmb3VuZCcsIHRoaXMuZ2VvSlNPTkluZGV4ZXNbc291cmNlXSwgY29vcmQpO1xuXG4gICAgICAgIHZhciB0aWxlID0gZ2VvSlNPTlRpbGUgPyBuZXcgV29ya2VyVGlsZShwYXJhbXMpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIHRoaXMubG9hZGVkW3NvdXJjZV0gPSB0aGlzLmxvYWRlZFtzb3VyY2VdIHx8IHt9O1xuICAgICAgICB0aGlzLmxvYWRlZFtzb3VyY2VdW3BhcmFtcy51aWRdID0gdGlsZTtcblxuICAgICAgICBpZiAoZ2VvSlNPTlRpbGUpIHtcbiAgICAgICAgICAgIHZhciBnZW9qc29uV3JhcHBlciA9IG5ldyBHZW9KU09OV3JhcHBlcihnZW9KU09OVGlsZS5mZWF0dXJlcyk7XG4gICAgICAgICAgICBnZW9qc29uV3JhcHBlci5uYW1lID0gJ19nZW9qc29uVGlsZUxheWVyJztcbiAgICAgICAgICAgIHZhciByYXdUaWxlRGF0YSA9IHZ0cGJmKHsgbGF5ZXJzOiB7ICdfZ2VvanNvblRpbGVMYXllcic6IGdlb2pzb25XcmFwcGVyIH19KS5idWZmZXI7XG4gICAgICAgICAgICB0aWxlLnBhcnNlKGdlb2pzb25XcmFwcGVyLCB0aGlzLmxheWVyRmFtaWxpZXMsIHRoaXMuYWN0b3IsIHJhd1RpbGVEYXRhLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbCk7IC8vIG5vdGhpbmcgaW4gdGhlIGdpdmVuIHRpbGVcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVMYXllckZhbWlsaWVzKGxheWVycykge1xuICAgIHZhciBmYW1pbGllcyA9IHt9O1xuXG4gICAgZm9yICh2YXIgbGF5ZXJJZCBpbiBsYXllcnMpIHtcbiAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2xheWVySWRdO1xuICAgICAgICB2YXIgcGFyZW50TGF5ZXJJZCA9IGxheWVyLnJlZiB8fCBsYXllci5pZDtcbiAgICAgICAgdmFyIHBhcmVudExheWVyID0gbGF5ZXJzW3BhcmVudExheWVySWRdO1xuXG4gICAgICAgIGlmIChwYXJlbnRMYXllci5sYXlvdXQgJiYgcGFyZW50TGF5ZXIubGF5b3V0LnZpc2liaWxpdHkgPT09ICdub25lJykgY29udGludWU7XG5cbiAgICAgICAgZmFtaWxpZXNbcGFyZW50TGF5ZXJJZF0gPSBmYW1pbGllc1twYXJlbnRMYXllcklkXSB8fCBbXTtcbiAgICAgICAgaWYgKGxheWVySWQgPT09IHBhcmVudExheWVySWQpIHtcbiAgICAgICAgICAgIGZhbWlsaWVzW3BhcmVudExheWVySWRdLnVuc2hpZnQobGF5ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmFtaWxpZXNbcGFyZW50TGF5ZXJJZF0ucHVzaChsYXllcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFtaWxpZXM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlSW5kZXggPSByZXF1aXJlKCcuLi9kYXRhL2ZlYXR1cmVfaW5kZXgnKTtcbnZhciBDb2xsaXNpb25UaWxlID0gcmVxdWlyZSgnLi4vc3ltYm9sL2NvbGxpc2lvbl90aWxlJyk7XG52YXIgQnVja2V0ID0gcmVxdWlyZSgnLi4vZGF0YS9idWNrZXQnKTtcbnZhciBDb2xsaXNpb25Cb3hBcnJheSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9jb2xsaXNpb25fYm94Jyk7XG52YXIgRGljdGlvbmFyeUNvZGVyID0gcmVxdWlyZSgnLi4vdXRpbC9kaWN0aW9uYXJ5X2NvZGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV29ya2VyVGlsZTtcblxuZnVuY3Rpb24gV29ya2VyVGlsZShwYXJhbXMpIHtcbiAgICB0aGlzLmNvb3JkID0gcGFyYW1zLmNvb3JkO1xuICAgIHRoaXMudWlkID0gcGFyYW1zLnVpZDtcbiAgICB0aGlzLnpvb20gPSBwYXJhbXMuem9vbTtcbiAgICB0aGlzLnRpbGVTaXplID0gcGFyYW1zLnRpbGVTaXplO1xuICAgIHRoaXMuc291cmNlID0gcGFyYW1zLnNvdXJjZTtcbiAgICB0aGlzLm92ZXJzY2FsaW5nID0gcGFyYW1zLm92ZXJzY2FsaW5nO1xuICAgIHRoaXMuYW5nbGUgPSBwYXJhbXMuYW5nbGU7XG4gICAgdGhpcy5waXRjaCA9IHBhcmFtcy5waXRjaDtcbiAgICB0aGlzLnNob3dDb2xsaXNpb25Cb3hlcyA9IHBhcmFtcy5zaG93Q29sbGlzaW9uQm94ZXM7XG59XG5cbldvcmtlclRpbGUucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oZGF0YSwgbGF5ZXJGYW1pbGllcywgYWN0b3IsIHJhd1RpbGVEYXRhLCBjYWxsYmFjaykge1xuXG4gICAgdGhpcy5zdGF0dXMgPSAncGFyc2luZyc7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcblxuICAgIHRoaXMuY29sbGlzaW9uQm94QXJyYXkgPSBuZXcgQ29sbGlzaW9uQm94QXJyYXkoKTtcbiAgICB2YXIgY29sbGlzaW9uVGlsZSA9IG5ldyBDb2xsaXNpb25UaWxlKHRoaXMuYW5nbGUsIHRoaXMucGl0Y2gsIHRoaXMuY29sbGlzaW9uQm94QXJyYXkpO1xuICAgIHZhciBmZWF0dXJlSW5kZXggPSBuZXcgRmVhdHVyZUluZGV4KHRoaXMuY29vcmQsIHRoaXMub3ZlcnNjYWxpbmcsIGNvbGxpc2lvblRpbGUsIGRhdGEubGF5ZXJzKTtcbiAgICB2YXIgc291cmNlTGF5ZXJDb2RlciA9IG5ldyBEaWN0aW9uYXJ5Q29kZXIoZGF0YS5sYXllcnMgPyBPYmplY3Qua2V5cyhkYXRhLmxheWVycykuc29ydCgpIDogWydfZ2VvanNvblRpbGVMYXllciddKTtcblxuICAgIHZhciBzdGF0cyA9IHsgX3RvdGFsOiAwIH07XG5cbiAgICB2YXIgdGlsZSA9IHRoaXM7XG4gICAgdmFyIGJ1Y2tldHNCeUlkID0ge307XG4gICAgdmFyIGJ1Y2tldHNCeVNvdXJjZUxheWVyID0ge307XG4gICAgdmFyIGk7XG4gICAgdmFyIGxheWVyO1xuICAgIHZhciBzb3VyY2VMYXllcklkO1xuICAgIHZhciBidWNrZXQ7XG5cbiAgICAvLyBNYXAgbm9uLXJlZiBsYXllcnMgdG8gYnVja2V0cy5cbiAgICB2YXIgYnVja2V0SW5kZXggPSAwO1xuICAgIGZvciAodmFyIGxheWVySWQgaW4gbGF5ZXJGYW1pbGllcykge1xuICAgICAgICBsYXllciA9IGxheWVyRmFtaWxpZXNbbGF5ZXJJZF1bMF07XG5cbiAgICAgICAgaWYgKGxheWVyLnNvdXJjZSAhPT0gdGhpcy5zb3VyY2UpIGNvbnRpbnVlO1xuICAgICAgICBpZiAobGF5ZXIucmVmKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGxheWVyLm1pbnpvb20gJiYgdGhpcy56b29tIDwgbGF5ZXIubWluem9vbSkgY29udGludWU7XG4gICAgICAgIGlmIChsYXllci5tYXh6b29tICYmIHRoaXMuem9vbSA+PSBsYXllci5tYXh6b29tKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGxheWVyLmxheW91dCAmJiBsYXllci5sYXlvdXQudmlzaWJpbGl0eSA9PT0gJ25vbmUnKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGRhdGEubGF5ZXJzICYmICFkYXRhLmxheWVyc1tsYXllci5zb3VyY2VMYXllcl0pIGNvbnRpbnVlO1xuXG4gICAgICAgIGJ1Y2tldCA9IEJ1Y2tldC5jcmVhdGUoe1xuICAgICAgICAgICAgbGF5ZXI6IGxheWVyLFxuICAgICAgICAgICAgaW5kZXg6IGJ1Y2tldEluZGV4KyssXG4gICAgICAgICAgICBjaGlsZExheWVyczogbGF5ZXJGYW1pbGllc1tsYXllcklkXSxcbiAgICAgICAgICAgIHpvb206IHRoaXMuem9vbSxcbiAgICAgICAgICAgIG92ZXJzY2FsaW5nOiB0aGlzLm92ZXJzY2FsaW5nLFxuICAgICAgICAgICAgc2hvd0NvbGxpc2lvbkJveGVzOiB0aGlzLnNob3dDb2xsaXNpb25Cb3hlcyxcbiAgICAgICAgICAgIGNvbGxpc2lvbkJveEFycmF5OiB0aGlzLmNvbGxpc2lvbkJveEFycmF5LFxuICAgICAgICAgICAgc291cmNlTGF5ZXJJbmRleDogc291cmNlTGF5ZXJDb2Rlci5lbmNvZGUobGF5ZXIuc291cmNlTGF5ZXIgfHwgJ19nZW9qc29uVGlsZUxheWVyJylcbiAgICAgICAgfSk7XG4gICAgICAgIGJ1Y2tldC5jcmVhdGVGaWx0ZXIoKTtcblxuICAgICAgICBidWNrZXRzQnlJZFtsYXllci5pZF0gPSBidWNrZXQ7XG5cbiAgICAgICAgaWYgKGRhdGEubGF5ZXJzKSB7IC8vIHZlY3RvcnRpbGVcbiAgICAgICAgICAgIHNvdXJjZUxheWVySWQgPSBsYXllci5zb3VyY2VMYXllcjtcbiAgICAgICAgICAgIGJ1Y2tldHNCeVNvdXJjZUxheWVyW3NvdXJjZUxheWVySWRdID0gYnVja2V0c0J5U291cmNlTGF5ZXJbc291cmNlTGF5ZXJJZF0gfHwge307XG4gICAgICAgICAgICBidWNrZXRzQnlTb3VyY2VMYXllcltzb3VyY2VMYXllcklkXVtsYXllci5pZF0gPSBidWNrZXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZWFkIGVhY2ggbGF5ZXIsIGFuZCBzb3J0IGl0cyBmZWF0dXJlcyBpbnRvIGJ1Y2tldHNcbiAgICBpZiAoZGF0YS5sYXllcnMpIHsgLy8gdmVjdG9ydGlsZVxuICAgICAgICBmb3IgKHNvdXJjZUxheWVySWQgaW4gYnVja2V0c0J5U291cmNlTGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyID0gZGF0YS5sYXllcnNbc291cmNlTGF5ZXJJZF07XG4gICAgICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBzb3J0TGF5ZXJJbnRvQnVja2V0cyhsYXllciwgYnVja2V0c0J5U291cmNlTGF5ZXJbc291cmNlTGF5ZXJJZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHsgLy8gZ2VvanNvblxuICAgICAgICBzb3J0TGF5ZXJJbnRvQnVja2V0cyhkYXRhLCBidWNrZXRzQnlJZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc29ydExheWVySW50b0J1Y2tldHMobGF5ZXIsIGJ1Y2tldHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBsYXllci5mZWF0dXJlKGkpO1xuICAgICAgICAgICAgZmVhdHVyZS5pbmRleCA9IGk7XG4gICAgICAgICAgICBmb3IgKHZhciBpZCBpbiBidWNrZXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1Y2tldHNbaWRdLmZpbHRlcihmZWF0dXJlKSlcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0c1tpZF0uZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBidWNrZXRzID0gW10sXG4gICAgICAgIHN5bWJvbEJ1Y2tldHMgPSB0aGlzLnN5bWJvbEJ1Y2tldHMgPSBbXSxcbiAgICAgICAgb3RoZXJCdWNrZXRzID0gW107XG5cbiAgICBmZWF0dXJlSW5kZXguYnVja2V0TGF5ZXJJRHMgPSB7fTtcblxuICAgIGZvciAodmFyIGlkIGluIGJ1Y2tldHNCeUlkKSB7XG4gICAgICAgIGJ1Y2tldCA9IGJ1Y2tldHNCeUlkW2lkXTtcbiAgICAgICAgaWYgKGJ1Y2tldC5mZWF0dXJlcy5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIGZlYXR1cmVJbmRleC5idWNrZXRMYXllcklEc1tidWNrZXQuaW5kZXhdID0gYnVja2V0LmNoaWxkTGF5ZXJzLm1hcChnZXRMYXllcklkKTtcblxuICAgICAgICBidWNrZXRzLnB1c2goYnVja2V0KTtcblxuICAgICAgICBpZiAoYnVja2V0LnR5cGUgPT09ICdzeW1ib2wnKVxuICAgICAgICAgICAgc3ltYm9sQnVja2V0cy5wdXNoKGJ1Y2tldCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG90aGVyQnVja2V0cy5wdXNoKGJ1Y2tldCk7XG4gICAgfVxuXG4gICAgdmFyIGljb25zID0ge307XG4gICAgdmFyIHN0YWNrcyA9IHt9O1xuICAgIHZhciBkZXBzID0gMDtcblxuXG4gICAgaWYgKHN5bWJvbEJ1Y2tldHMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgIC8vIEdldCBkZXBlbmRlbmNpZXMgZm9yIHN5bWJvbCBidWNrZXRzXG4gICAgICAgIGZvciAoaSA9IHN5bWJvbEJ1Y2tldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHN5bWJvbEJ1Y2tldHNbaV0udXBkYXRlSWNvbnMoaWNvbnMpO1xuICAgICAgICAgICAgc3ltYm9sQnVja2V0c1tpXS51cGRhdGVGb250KHN0YWNrcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBmb250TmFtZSBpbiBzdGFja3MpIHtcbiAgICAgICAgICAgIHN0YWNrc1tmb250TmFtZV0gPSBPYmplY3Qua2V5cyhzdGFja3NbZm9udE5hbWVdKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpY29ucyA9IE9iamVjdC5rZXlzKGljb25zKTtcblxuICAgICAgICBhY3Rvci5zZW5kKCdnZXQgZ2x5cGhzJywge3VpZDogdGhpcy51aWQsIHN0YWNrczogc3RhY2tzfSwgZnVuY3Rpb24oZXJyLCBuZXdTdGFja3MpIHtcbiAgICAgICAgICAgIHN0YWNrcyA9IG5ld1N0YWNrcztcbiAgICAgICAgICAgIGdvdERlcGVuZGVuY3koZXJyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGljb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWN0b3Iuc2VuZCgnZ2V0IGljb25zJywge2ljb25zOiBpY29uc30sIGZ1bmN0aW9uKGVyciwgbmV3SWNvbnMpIHtcbiAgICAgICAgICAgICAgICBpY29ucyA9IG5ld0ljb25zO1xuICAgICAgICAgICAgICAgIGdvdERlcGVuZGVuY3koZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ290RGVwZW5kZW5jeSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaW1tZWRpYXRlbHkgcGFyc2Ugbm9uLXN5bWJvbCBidWNrZXRzICh0aGV5IGhhdmUgbm8gZGVwZW5kZW5jaWVzKVxuICAgIGZvciAoaSA9IG90aGVyQnVja2V0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBwYXJzZUJ1Y2tldCh0aGlzLCBvdGhlckJ1Y2tldHNbaV0pO1xuICAgIH1cblxuICAgIGlmIChzeW1ib2xCdWNrZXRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcblxuICAgIGZ1bmN0aW9uIGdvdERlcGVuZGVuY3koZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICBkZXBzKys7XG4gICAgICAgIGlmIChkZXBzID09PSAyKSB7XG4gICAgICAgICAgICAvLyBhbGwgc3ltYm9sIGJ1Y2tldCBkZXBlbmRlbmNpZXMgZmV0Y2hlZDsgcGFyc2UgdGhlbSBpbiBwcm9wZXIgb3JkZXJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzeW1ib2xCdWNrZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VCdWNrZXQodGlsZSwgc3ltYm9sQnVja2V0c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUJ1Y2tldCh0aWxlLCBidWNrZXQpIHtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGJ1Y2tldC5wb3B1bGF0ZUJ1ZmZlcnMoY29sbGlzaW9uVGlsZSwgc3RhY2tzLCBpY29ucyk7XG4gICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKSAtIG5vdztcblxuXG4gICAgICAgIGlmIChidWNrZXQudHlwZSAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVja2V0LmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBidWNrZXQuZmVhdHVyZXNbaV07XG4gICAgICAgICAgICAgICAgZmVhdHVyZUluZGV4Lmluc2VydChmZWF0dXJlLCBmZWF0dXJlLmluZGV4LCBidWNrZXQuc291cmNlTGF5ZXJJbmRleCwgYnVja2V0LmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJ1Y2tldC5mZWF0dXJlcyA9IG51bGw7XG5cbiAgICAgICAgc3RhdHMuX3RvdGFsICs9IHRpbWU7XG4gICAgICAgIHN0YXRzW2J1Y2tldC5pZF0gPSAoc3RhdHNbYnVja2V0LmlkXSB8fCAwKSArIHRpbWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgdGlsZS5zdGF0dXMgPSAnZG9uZSc7XG5cbiAgICAgICAgaWYgKHRpbGUucmVkb1BsYWNlbWVudEFmdGVyRG9uZSkge1xuICAgICAgICAgICAgdGlsZS5yZWRvUGxhY2VtZW50KHRpbGUuYW5nbGUsIHRpbGUucGl0Y2gsIG51bGwpO1xuICAgICAgICAgICAgdGlsZS5yZWRvUGxhY2VtZW50QWZ0ZXJEb25lID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmVhdHVyZUluZGV4XyA9IGZlYXR1cmVJbmRleC5zZXJpYWxpemUoKTtcbiAgICAgICAgdmFyIGNvbGxpc2lvblRpbGVfID0gY29sbGlzaW9uVGlsZS5zZXJpYWxpemUoKTtcbiAgICAgICAgdmFyIGNvbGxpc2lvbkJveEFycmF5ID0gdGlsZS5jb2xsaXNpb25Cb3hBcnJheS5zZXJpYWxpemUoKTtcbiAgICAgICAgdmFyIHRyYW5zZmVyYWJsZXMgPSBbcmF3VGlsZURhdGFdLmNvbmNhdChmZWF0dXJlSW5kZXhfLnRyYW5zZmVyYWJsZXMpLmNvbmNhdChjb2xsaXNpb25UaWxlXy50cmFuc2ZlcmFibGVzKTtcblxuICAgICAgICB2YXIgbm9uRW1wdHlCdWNrZXRzID0gYnVja2V0cy5maWx0ZXIoaXNCdWNrZXRFbXB0eSk7XG5cbiAgICAgICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICAgYnVja2V0czogbm9uRW1wdHlCdWNrZXRzLm1hcChzZXJpYWxpemVCdWNrZXQpLFxuICAgICAgICAgICAgYnVja2V0U3RhdHM6IHN0YXRzLCAvLyBUT0RPIHB1dCB0aGlzIGluIGEgc2VwYXJhdGUgbWVzc2FnZT9cbiAgICAgICAgICAgIGZlYXR1cmVJbmRleDogZmVhdHVyZUluZGV4Xy5kYXRhLFxuICAgICAgICAgICAgY29sbGlzaW9uVGlsZTogY29sbGlzaW9uVGlsZV8uZGF0YSxcbiAgICAgICAgICAgIGNvbGxpc2lvbkJveEFycmF5OiBjb2xsaXNpb25Cb3hBcnJheSxcbiAgICAgICAgICAgIHJhd1RpbGVEYXRhOiByYXdUaWxlRGF0YVxuICAgICAgICB9LCBnZXRUcmFuc2ZlcmFibGVzKG5vbkVtcHR5QnVja2V0cykuY29uY2F0KHRyYW5zZmVyYWJsZXMpKTtcbiAgICB9XG59O1xuXG5Xb3JrZXJUaWxlLnByb3RvdHlwZS5yZWRvUGxhY2VtZW50ID0gZnVuY3Rpb24oYW5nbGUsIHBpdGNoLCBzaG93Q29sbGlzaW9uQm94ZXMpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09ICdkb25lJykge1xuICAgICAgICB0aGlzLnJlZG9QbGFjZW1lbnRBZnRlckRvbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmFuZ2xlID0gYW5nbGU7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICB2YXIgY29sbGlzaW9uVGlsZSA9IG5ldyBDb2xsaXNpb25UaWxlKGFuZ2xlLCBwaXRjaCwgdGhpcy5jb2xsaXNpb25Cb3hBcnJheSk7XG5cbiAgICB2YXIgYnVja2V0cyA9IHRoaXMuc3ltYm9sQnVja2V0cztcblxuICAgIGZvciAodmFyIGkgPSBidWNrZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1Y2tldHNbaV0ucGxhY2VGZWF0dXJlcyhjb2xsaXNpb25UaWxlLCBzaG93Q29sbGlzaW9uQm94ZXMpO1xuICAgIH1cblxuICAgIHZhciBjb2xsaXNpb25UaWxlXyA9IGNvbGxpc2lvblRpbGUuc2VyaWFsaXplKCk7XG5cbiAgICB2YXIgbm9uRW1wdHlCdWNrZXRzID0gYnVja2V0cy5maWx0ZXIoaXNCdWNrZXRFbXB0eSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAgIGJ1Y2tldHM6IG5vbkVtcHR5QnVja2V0cy5tYXAoc2VyaWFsaXplQnVja2V0KSxcbiAgICAgICAgICAgIGNvbGxpc2lvblRpbGU6IGNvbGxpc2lvblRpbGVfLmRhdGFcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmZXJhYmxlczogZ2V0VHJhbnNmZXJhYmxlcyhub25FbXB0eUJ1Y2tldHMpLmNvbmNhdChjb2xsaXNpb25UaWxlXy50cmFuc2ZlcmFibGVzKVxuICAgIH07XG59O1xuXG5mdW5jdGlvbiBpc0J1Y2tldEVtcHR5KGJ1Y2tldCkge1xuICAgIGZvciAodmFyIHByb2dyYW1OYW1lIGluIGJ1Y2tldC5hcnJheUdyb3Vwcykge1xuICAgICAgICB2YXIgcHJvZ3JhbUFycmF5R3JvdXBzID0gYnVja2V0LmFycmF5R3JvdXBzW3Byb2dyYW1OYW1lXTtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBwcm9ncmFtQXJyYXlHcm91cHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBwcm9ncmFtQXJyYXlHcm91cCA9IHByb2dyYW1BcnJheUdyb3Vwc1trXTtcbiAgICAgICAgICAgIGZvciAodmFyIGxheW91dE9yUGFpbnQgaW4gcHJvZ3JhbUFycmF5R3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXlzID0gcHJvZ3JhbUFycmF5R3JvdXBbbGF5b3V0T3JQYWludF07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYnVmZmVyTmFtZSBpbiBhcnJheXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycmF5c1tidWZmZXJOYW1lXS5sZW5ndGggPiAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVCdWNrZXQoYnVja2V0KSB7XG4gICAgcmV0dXJuIGJ1Y2tldC5zZXJpYWxpemUoKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNmZXJhYmxlcyhidWNrZXRzKSB7XG4gICAgdmFyIHRyYW5zZmVyYWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpIGluIGJ1Y2tldHMpIHtcbiAgICAgICAgdmFyIGJ1Y2tldCA9IGJ1Y2tldHNbaV07XG4gICAgICAgIGZvciAodmFyIHByb2dyYW1OYW1lIGluIGJ1Y2tldC5hcnJheUdyb3Vwcykge1xuICAgICAgICAgICAgdmFyIHByb2dyYW1BcnJheUdyb3VwcyA9IGJ1Y2tldC5hcnJheUdyb3Vwc1twcm9ncmFtTmFtZV07XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHByb2dyYW1BcnJheUdyb3Vwcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9ncmFtQXJyYXlHcm91cCA9IHByb2dyYW1BcnJheUdyb3Vwc1trXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsYXlvdXRPclBhaW50IGluIHByb2dyYW1BcnJheUdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheXMgPSBwcm9ncmFtQXJyYXlHcm91cFtsYXlvdXRPclBhaW50XTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYnVmZmVyTmFtZSBpbiBhcnJheXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChhcnJheXNbYnVmZmVyTmFtZV0uYXJyYXlCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2ZlcmFibGVzO1xufVxuXG5mdW5jdGlvbiBnZXRMYXllcklkKGxheWVyKSB7XG4gICAgcmV0dXJuIGxheWVyLmlkO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFuaW1hdGlvbkxvb3A7XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbkxvb3AoKSB7XG4gICAgdGhpcy5uID0gMDtcbiAgICB0aGlzLnRpbWVzID0gW107XG59XG5cbi8vIEFyZSBhbGwgYW5pbWF0aW9ucyBkb25lP1xuQW5pbWF0aW9uTG9vcC5wcm90b3R5cGUuc3RvcHBlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGltZXMgPSB0aGlzLnRpbWVzLmZpbHRlcihmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0LnRpbWUgPj0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gIXRoaXMudGltZXMubGVuZ3RoO1xufTtcblxuLy8gQWRkIGEgbmV3IGFuaW1hdGlvbiB0aGF0IHdpbGwgcnVuIHQgbWlsbGlzZWNvbmRzXG4vLyBSZXR1cm5zIGFuIGlkIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIGl0IGxheWVyXG5BbmltYXRpb25Mb29wLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy50aW1lcy5wdXNoKHsgaWQ6IHRoaXMubiwgdGltZTogdCArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgfSk7XG4gICAgcmV0dXJuIHRoaXMubisrO1xufTtcblxuLy8gQ2FuY2VsIGFuIGFuaW1hdGlvblxuQW5pbWF0aW9uTG9vcC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24obikge1xuICAgIHRoaXMudGltZXMgPSB0aGlzLnRpbWVzLmZpbHRlcihmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0LmlkICE9PSBuO1xuICAgIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQnKTtcbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4Jyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIG5vcm1hbGl6ZVVSTCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwYm94Jykubm9ybWFsaXplU3ByaXRlVVJMO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlU3ByaXRlO1xuXG5mdW5jdGlvbiBJbWFnZVNwcml0ZShiYXNlKSB7XG4gICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICB0aGlzLnJldGluYSA9IGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyA+IDE7XG5cbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5yZXRpbmEgPyAnQDJ4JyA6ICcnO1xuXG4gICAgYWpheC5nZXRKU09OKG5vcm1hbGl6ZVVSTChiYXNlLCBmb3JtYXQsICcuanNvbicpLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIHtlcnJvcjogZXJyfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICBpZiAodGhpcy5pbWcpIHRoaXMuZmlyZSgnbG9hZCcpO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICBhamF4LmdldEltYWdlKG5vcm1hbGl6ZVVSTChiYXNlLCBmb3JtYXQsICcucG5nJyksIGZ1bmN0aW9uKGVyciwgaW1nKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZXJyb3InLCB7ZXJyb3I6IGVycn0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJlbXVsdGlwbHkgdGhlIHNwcml0ZVxuICAgICAgICB2YXIgZGF0YSA9IGltZy5nZXREYXRhKCk7XG4gICAgICAgIHZhciBuZXdkYXRhID0gaW1nLmRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gZGF0YVtpICsgM10gLyAyNTU7XG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAwXSA9IGRhdGFbaSArIDBdICogYWxwaGE7XG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAxXSA9IGRhdGFbaSArIDFdICogYWxwaGE7XG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAyXSA9IGRhdGFbaSArIDJdICogYWxwaGE7XG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAzXSA9IGRhdGFbaSArIDNdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbWcgPSBpbWc7XG4gICAgICAgIGlmICh0aGlzLmRhdGEpIHRoaXMuZmlyZSgnbG9hZCcpO1xuICAgIH0uYmluZCh0aGlzKSk7XG59XG5cbkltYWdlU3ByaXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRlZCk7XG5cbkltYWdlU3ByaXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlO1xufTtcblxuSW1hZ2VTcHJpdGUucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiYgdGhpcy5pbWcpO1xufTtcblxuSW1hZ2VTcHJpdGUucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKC8qZ2wqLykge1xuICAgIGlmIChicm93c2VyLmRldmljZVBpeGVsUmF0aW8gPiAxICE9PSB0aGlzLnJldGluYSkge1xuICAgICAgICB2YXIgbmV3U3ByaXRlID0gbmV3IEltYWdlU3ByaXRlKHRoaXMuYmFzZSk7XG4gICAgICAgIG5ld1Nwcml0ZS5vbignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5pbWcgPSBuZXdTcHJpdGUuaW1nO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3U3ByaXRlLmRhdGE7XG4gICAgICAgICAgICB0aGlzLnJldGluYSA9IG5ld1Nwcml0ZS5yZXRpbmE7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gU3ByaXRlUG9zaXRpb24oKSB7fVxuU3ByaXRlUG9zaXRpb24ucHJvdG90eXBlID0geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwLCBwaXhlbFJhdGlvOiAxLCBzZGY6IGZhbHNlIH07XG5cbkltYWdlU3ByaXRlLnByb3RvdHlwZS5nZXRTcHJpdGVQb3NpdGlvbiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMubG9hZGVkKCkpIHJldHVybiBuZXcgU3ByaXRlUG9zaXRpb24oKTtcblxuICAgIHZhciBwb3MgPSB0aGlzLmRhdGEgJiYgdGhpcy5kYXRhW25hbWVdO1xuICAgIGlmIChwb3MgJiYgdGhpcy5pbWcpIHJldHVybiBwb3M7XG5cbiAgICByZXR1cm4gbmV3IFNwcml0ZVBvc2l0aW9uKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2VDU1NDb2xvciA9IHJlcXVpcmUoJ2Nzc2NvbG9ycGFyc2VyJykucGFyc2VDU1NDb2xvcjtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG5cbnZhciBjb2xvckNhY2hlID0ge307XG5cbmZ1bmN0aW9uIHBhcnNlQ29sb3IoaW5wdXQpIHtcblxuICAgIGlmIChjb2xvckNhY2hlW2lucHV0XSkge1xuICAgICAgICByZXR1cm4gY29sb3JDYWNoZVtpbnB1dF07XG5cbiAgICAvLyBSR0JBIGFycmF5XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG5cbiAgICAvLyBHTCBmdW5jdGlvblxuICAgIH0gZWxzZSBpZiAoaW5wdXQgJiYgaW5wdXQuc3RvcHMpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuZXh0ZW5kKHt9LCBpbnB1dCwge1xuICAgICAgICAgICAgc3RvcHM6IGlucHV0LnN0b3BzLm1hcChwYXJzZUZ1bmN0aW9uU3RvcENvbG9yKVxuICAgICAgICB9KTtcblxuICAgIC8vIENvbG9yIHN0cmluZ1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgcGFyc2VkQ29sb3IgPSBwYXJzZUNTU0NvbG9yKGlucHV0KTtcbiAgICAgICAgaWYgKCFwYXJzZWRDb2xvcikgeyB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29sb3IgJyArIGlucHV0KTsgfVxuXG4gICAgICAgIHZhciBvdXRwdXQgPSBjb2xvckRvd25ncmFkZShwYXJzZWRDb2xvcik7XG4gICAgICAgIGNvbG9yQ2FjaGVbaW5wdXRdID0gb3V0cHV0O1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbG9yICcgKyBpbnB1dCk7XG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIHBhcnNlRnVuY3Rpb25TdG9wQ29sb3Ioc3RvcCkge1xuICAgIHJldHVybiBbc3RvcFswXSwgcGFyc2VDb2xvcihzdG9wWzFdKV07XG59XG5cbmZ1bmN0aW9uIGNvbG9yRG93bmdyYWRlKGNvbG9yKSB7XG4gICAgcmV0dXJuIFtjb2xvclswXSAvIDI1NSwgY29sb3JbMV0gLyAyNTUsIGNvbG9yWzJdIC8gMjU1LCBjb2xvclszXSAvIDFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlQ29sb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgU3R5bGVMYXllciA9IHJlcXVpcmUoJy4vc3R5bGVfbGF5ZXInKTtcbnZhciBJbWFnZVNwcml0ZSA9IHJlcXVpcmUoJy4vaW1hZ2Vfc3ByaXRlJyk7XG52YXIgR2x5cGhTb3VyY2UgPSByZXF1aXJlKCcuLi9zeW1ib2wvZ2x5cGhfc291cmNlJyk7XG52YXIgU3ByaXRlQXRsYXMgPSByZXF1aXJlKCcuLi9zeW1ib2wvc3ByaXRlX2F0bGFzJyk7XG52YXIgTGluZUF0bGFzID0gcmVxdWlyZSgnLi4vcmVuZGVyL2xpbmVfYXRsYXMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgYWpheCA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheCcpO1xudmFyIG5vcm1hbGl6ZVVSTCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwYm94Jykubm9ybWFsaXplU3R5bGVVUkw7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi91dGlsL2Rpc3BhdGNoZXInKTtcbnZhciBBbmltYXRpb25Mb29wID0gcmVxdWlyZSgnLi9hbmltYXRpb25fbG9vcCcpO1xudmFyIHZhbGlkYXRlU3R5bGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRlX3N0eWxlJyk7XG52YXIgU291cmNlID0gcmVxdWlyZSgnLi4vc291cmNlL3NvdXJjZScpO1xudmFyIHN0eWxlU3BlYyA9IHJlcXVpcmUoJy4vc3R5bGVfc3BlYycpO1xudmFyIFN0eWxlRnVuY3Rpb24gPSByZXF1aXJlKCcuL3N0eWxlX2Z1bmN0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3R5bGU7XG5cbmZ1bmN0aW9uIFN0eWxlKHN0eWxlc2hlZXQsIGFuaW1hdGlvbkxvb3ApIHtcbiAgICB0aGlzLmFuaW1hdGlvbkxvb3AgPSBhbmltYXRpb25Mb29wIHx8IG5ldyBBbmltYXRpb25Mb29wKCk7XG4gICAgdGhpcy5kaXNwYXRjaGVyID0gbmV3IERpc3BhdGNoZXIoTWF0aC5tYXgoYnJvd3Nlci5oYXJkd2FyZUNvbmN1cnJlbmN5IC0gMSwgMSksIHRoaXMpO1xuICAgIHRoaXMuc3ByaXRlQXRsYXMgPSBuZXcgU3ByaXRlQXRsYXMoNTEyLCA1MTIpO1xuICAgIHRoaXMubGluZUF0bGFzID0gbmV3IExpbmVBdGxhcygyNTYsIDUxMik7XG5cbiAgICB0aGlzLl9sYXllcnMgPSB7fTtcbiAgICB0aGlzLl9vcmRlciAgPSBbXTtcbiAgICB0aGlzLl9ncm91cHMgPSBbXTtcbiAgICB0aGlzLnNvdXJjZXMgPSB7fTtcbiAgICB0aGlzLnpvb21IaXN0b3J5ID0ge307XG5cbiAgICB1dGlsLmJpbmRBbGwoW1xuICAgICAgICAnX2ZvcndhcmRTb3VyY2VFdmVudCcsXG4gICAgICAgICdfZm9yd2FyZFRpbGVFdmVudCcsXG4gICAgICAgICdfZm9yd2FyZExheWVyRXZlbnQnLFxuICAgICAgICAnX3JlZG9QbGFjZW1lbnQnXG4gICAgXSwgdGhpcyk7XG5cbiAgICB0aGlzLl9yZXNldFVwZGF0ZXMoKTtcblxuICAgIHZhciBsb2FkZWQgPSBmdW5jdGlvbihlcnIsIHN0eWxlc2hlZXQpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIHtlcnJvcjogZXJyfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsaWRhdGVTdHlsZS5lbWl0RXJyb3JzKHRoaXMsIHZhbGlkYXRlU3R5bGUoc3R5bGVzaGVldCkpKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5fbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdHlsZXNoZWV0ID0gc3R5bGVzaGVldDtcblxuICAgICAgICB0aGlzLnVwZGF0ZUNsYXNzZXMoKTtcblxuICAgICAgICB2YXIgc291cmNlcyA9IHN0eWxlc2hlZXQuc291cmNlcztcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gc291cmNlcykge1xuICAgICAgICAgICAgdGhpcy5hZGRTb3VyY2UoaWQsIHNvdXJjZXNbaWRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHlsZXNoZWV0LnNwcml0ZSkge1xuICAgICAgICAgICAgdGhpcy5zcHJpdGUgPSBuZXcgSW1hZ2VTcHJpdGUoc3R5bGVzaGVldC5zcHJpdGUpO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGUub24oJ2xvYWQnLCB0aGlzLmZpcmUuYmluZCh0aGlzLCAnY2hhbmdlJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nbHlwaFNvdXJjZSA9IG5ldyBHbHlwaFNvdXJjZShzdHlsZXNoZWV0LmdseXBocyk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUoKTtcbiAgICAgICAgdGhpcy5maXJlKCdsb2FkJyk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgaWYgKHR5cGVvZiBzdHlsZXNoZWV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBhamF4LmdldEpTT04obm9ybWFsaXplVVJMKHN0eWxlc2hlZXQpLCBsb2FkZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJyb3dzZXIuZnJhbWUobG9hZGVkLmJpbmQodGhpcywgbnVsbCwgc3R5bGVzaGVldCkpO1xuICAgIH1cblxuICAgIHRoaXMub24oJ3NvdXJjZS5sb2FkJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGV2ZW50LnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiBzb3VyY2UudmVjdG9yTGF5ZXJJZHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGxheWVySWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2xheWVySWRdO1xuICAgICAgICAgICAgICAgIGlmIChsYXllci5zb3VyY2UgPT09IHNvdXJjZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0ZUxheWVyKGxheWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuU3R5bGUucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEV2ZW50ZWQsIHtcbiAgICBfbG9hZGVkOiBmYWxzZSxcblxuICAgIF92YWxpZGF0ZUxheWVyOiBmdW5jdGlvbihsYXllcikge1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2VzW2xheWVyLnNvdXJjZV07XG5cbiAgICAgICAgaWYgKCFsYXllci5zb3VyY2VMYXllcikgcmV0dXJuO1xuICAgICAgICBpZiAoIXNvdXJjZSkgcmV0dXJuO1xuICAgICAgICBpZiAoIXNvdXJjZS52ZWN0b3JMYXllcklkcykgcmV0dXJuO1xuXG4gICAgICAgIGlmIChzb3VyY2UudmVjdG9yTGF5ZXJJZHMuaW5kZXhPZihsYXllci5zb3VyY2VMYXllcikgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdTb3VyY2UgbGF5ZXIgXCInICsgbGF5ZXIuc291cmNlTGF5ZXIgKyAnXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICdkb2VzIG5vdCBleGlzdCBvbiBzb3VyY2UgXCInICsgc291cmNlLmlkICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAnYXMgc3BlY2lmaWVkIGJ5IHN0eWxlIGxheWVyIFwiJyArIGxheWVyLmlkICsgJ1wiJ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGxvYWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9hZGVkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuc291cmNlcylcbiAgICAgICAgICAgIGlmICghdGhpcy5zb3VyY2VzW2lkXS5sb2FkZWQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuc3ByaXRlICYmICF0aGlzLnNwcml0ZS5sb2FkZWQoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgX3Jlc29sdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGF5ZXIsIGxheWVySlNPTjtcblxuICAgICAgICB0aGlzLl9sYXllcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fb3JkZXIgID0gdGhpcy5zdHlsZXNoZWV0LmxheWVycy5tYXAoZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXllci5pZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmVzb2x2ZSBhbGwgbGF5ZXJzIFdJVEhPVVQgYSByZWZcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0eWxlc2hlZXQubGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsYXllckpTT04gPSB0aGlzLnN0eWxlc2hlZXQubGF5ZXJzW2ldO1xuICAgICAgICAgICAgaWYgKGxheWVySlNPTi5yZWYpIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGF5ZXIgPSBTdHlsZUxheWVyLmNyZWF0ZShsYXllckpTT04pO1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW2xheWVyLmlkXSA9IGxheWVyO1xuICAgICAgICAgICAgbGF5ZXIub24oJ2Vycm9yJywgdGhpcy5fZm9yd2FyZExheWVyRXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzb2x2ZSBhbGwgbGF5ZXJzIFdJVEggYSByZWZcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnN0eWxlc2hlZXQubGF5ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsYXllckpTT04gPSB0aGlzLnN0eWxlc2hlZXQubGF5ZXJzW2pdO1xuICAgICAgICAgICAgaWYgKCFsYXllckpTT04ucmVmKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciByZWZMYXllciA9IHRoaXMuZ2V0TGF5ZXIobGF5ZXJKU09OLnJlZik7XG4gICAgICAgICAgICBsYXllciA9IFN0eWxlTGF5ZXIuY3JlYXRlKGxheWVySlNPTiwgcmVmTGF5ZXIpO1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW2xheWVyLmlkXSA9IGxheWVyO1xuICAgICAgICAgICAgbGF5ZXIub24oJ2Vycm9yJywgdGhpcy5fZm9yd2FyZExheWVyRXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZ3JvdXBMYXllcnMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlV29ya2VyTGF5ZXJzKCk7XG4gICAgfSxcblxuICAgIF9ncm91cExheWVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBncm91cDtcblxuICAgICAgICB0aGlzLl9ncm91cHMgPSBbXTtcblxuICAgICAgICAvLyBTcGxpdCBpbnRvIGdyb3VwcyBvZiBjb25zZWN1dGl2ZSB0b3AtbGV2ZWwgbGF5ZXJzIHdpdGggdGhlIHNhbWUgc291cmNlLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX29yZGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbdGhpcy5fb3JkZXJbaV1dO1xuXG4gICAgICAgICAgICBpZiAoIWdyb3VwIHx8IGxheWVyLnNvdXJjZSAhPT0gZ3JvdXAuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAgPSBbXTtcbiAgICAgICAgICAgICAgICBncm91cC5zb3VyY2UgPSBsYXllci5zb3VyY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ3JvdXBzLnB1c2goZ3JvdXApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBncm91cC5wdXNoKGxheWVyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdXBkYXRlV29ya2VyTGF5ZXJzOiBmdW5jdGlvbihpZHMpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLmJyb2FkY2FzdChpZHMgPyAndXBkYXRlIGxheWVycycgOiAnc2V0IGxheWVycycsIHRoaXMuX3NlcmlhbGl6ZUxheWVycyhpZHMpKTtcbiAgICB9LFxuXG4gICAgX3NlcmlhbGl6ZUxheWVyczogZnVuY3Rpb24oaWRzKSB7XG4gICAgICAgIGlkcyA9IGlkcyB8fCB0aGlzLl9vcmRlcjtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBbXTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7aW5jbHVkZVJlZlByb3BlcnRpZXM6IHRydWV9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKHRoaXMuX2xheWVyc1tpZHNbaV1dLnNlcmlhbGl6ZShvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfSxcblxuICAgIF9hcHBseUNsYXNzZXM6IGZ1bmN0aW9uKGNsYXNzZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpIHJldHVybjtcblxuICAgICAgICBjbGFzc2VzID0gY2xhc3NlcyB8fCBbXTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge3RyYW5zaXRpb246IHRydWV9O1xuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXMuc3R5bGVzaGVldC50cmFuc2l0aW9uIHx8IHt9O1xuXG4gICAgICAgIHZhciBsYXllcnMgPSB0aGlzLl91cGRhdGVzLmFsbFBhaW50UHJvcHMgPyB0aGlzLl9sYXllcnMgOiB0aGlzLl91cGRhdGVzLnBhaW50UHJvcHM7XG5cbiAgICAgICAgZm9yICh2YXIgaWQgaW4gbGF5ZXJzKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuICAgICAgICAgICAgdmFyIHByb3BzID0gdGhpcy5fdXBkYXRlcy5wYWludFByb3BzW2lkXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3VwZGF0ZXMuYWxsUGFpbnRQcm9wcyB8fCBwcm9wcy5hbGwpIHtcbiAgICAgICAgICAgICAgICBsYXllci51cGRhdGVQYWludFRyYW5zaXRpb25zKGNsYXNzZXMsIG9wdGlvbnMsIHRyYW5zaXRpb24sIHRoaXMuYW5pbWF0aW9uTG9vcCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHBhaW50TmFtZSBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXllcnNbaWRdLnVwZGF0ZVBhaW50VHJhbnNpdGlvbihwYWludE5hbWUsIGNsYXNzZXMsIG9wdGlvbnMsIHRyYW5zaXRpb24sIHRoaXMuYW5pbWF0aW9uTG9vcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9yZWNhbGN1bGF0ZTogZnVuY3Rpb24oeikge1xuICAgICAgICBmb3IgKHZhciBzb3VyY2VJZCBpbiB0aGlzLnNvdXJjZXMpXG4gICAgICAgICAgICB0aGlzLnNvdXJjZXNbc291cmNlSWRdLnVzZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl91cGRhdGVab29tSGlzdG9yeSh6KTtcblxuICAgICAgICB0aGlzLnJhc3RlckZhZGVEdXJhdGlvbiA9IDMwMDtcbiAgICAgICAgZm9yICh2YXIgbGF5ZXJJZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1tsYXllcklkXTtcblxuICAgICAgICAgICAgbGF5ZXIucmVjYWxjdWxhdGUoeiwgdGhpcy56b29tSGlzdG9yeSk7XG4gICAgICAgICAgICBpZiAoIWxheWVyLmlzSGlkZGVuKHopICYmIGxheWVyLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlc1tsYXllci5zb3VyY2VdLnVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1heFpvb21UcmFuc2l0aW9uRHVyYXRpb24gPSAzMDA7XG4gICAgICAgIGlmIChNYXRoLmZsb29yKHRoaXMueikgIT09IE1hdGguZmxvb3IoeikpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uTG9vcC5zZXQobWF4Wm9vbVRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICB0aGlzLmZpcmUoJ3pvb20nKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZVpvb21IaXN0b3J5OiBmdW5jdGlvbih6KSB7XG5cbiAgICAgICAgdmFyIHpoID0gdGhpcy56b29tSGlzdG9yeTtcblxuICAgICAgICBpZiAoemgubGFzdEludGVnZXJab29tID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHRpbWVcbiAgICAgICAgICAgIHpoLmxhc3RJbnRlZ2VyWm9vbSA9IE1hdGguZmxvb3Ioeik7XG4gICAgICAgICAgICB6aC5sYXN0SW50ZWdlclpvb21UaW1lID0gMDtcbiAgICAgICAgICAgIHpoLmxhc3Rab29tID0gejtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgYW4gaW50ZWdlciB6b29tIGxldmVsIGFzIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCBmcmFtZVxuICAgICAgICAvLyBhbmQgaWYgeWVzLCByZWNvcmQgaXQgd2l0aCB0aGUgdGltZS4gVXNlZCBmb3IgdHJhbnNpdGlvbmluZyBwYXR0ZXJucy5cbiAgICAgICAgaWYgKE1hdGguZmxvb3IoemgubGFzdFpvb20pIDwgTWF0aC5mbG9vcih6KSkge1xuICAgICAgICAgICAgemgubGFzdEludGVnZXJab29tID0gTWF0aC5mbG9vcih6KTtcbiAgICAgICAgICAgIHpoLmxhc3RJbnRlZ2VyWm9vbVRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoTWF0aC5mbG9vcih6aC5sYXN0Wm9vbSkgPiBNYXRoLmZsb29yKHopKSB7XG4gICAgICAgICAgICB6aC5sYXN0SW50ZWdlclpvb20gPSBNYXRoLmZsb29yKHogKyAxKTtcbiAgICAgICAgICAgIHpoLmxhc3RJbnRlZ2VyWm9vbVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgemgubGFzdFpvb20gPSB6O1xuICAgIH0sXG5cbiAgICBfY2hlY2tMb2FkZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3R5bGUgaXMgbm90IGRvbmUgbG9hZGluZycpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHF1ZXVlZCBzdHlsZSB1cGRhdGVzIGluIGEgYmF0Y2hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24oY2xhc3Nlcywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuX3VwZGF0ZXMuY2hhbmdlZCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuX3VwZGF0ZXMuYWxsTGF5ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9ncm91cExheWVycygpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlV29ya2VyTGF5ZXJzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlZElkcyA9IE9iamVjdC5rZXlzKHRoaXMuX3VwZGF0ZXMubGF5ZXJzKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVkSWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVdvcmtlckxheWVycyh1cGRhdGVkSWRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1cGRhdGVkU291cmNlSWRzID0gT2JqZWN0LmtleXModGhpcy5fdXBkYXRlcy5zb3VyY2VzKTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB1cGRhdGVkU291cmNlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWxvYWRTb3VyY2UodXBkYXRlZFNvdXJjZUlkc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fdXBkYXRlcy5ldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5fdXBkYXRlcy5ldmVudHNbaV07XG4gICAgICAgICAgICB0aGlzLmZpcmUoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hcHBseUNsYXNzZXMoY2xhc3Nlcywgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3VwZGF0ZXMuY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Jlc2V0VXBkYXRlcygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcmVzZXRVcGRhdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlcyA9IHtcbiAgICAgICAgICAgIGV2ZW50czogW10sXG4gICAgICAgICAgICBsYXllcnM6IHt9LFxuICAgICAgICAgICAgc291cmNlczoge30sXG4gICAgICAgICAgICBwYWludFByb3BzOiB7fVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhZGRTb3VyY2U6IGZ1bmN0aW9uKGlkLCBzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlc1tpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBpcyBhbHJlYWR5IGEgc291cmNlIHdpdGggdGhpcyBJRCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghU291cmNlLmlzKHNvdXJjZSkgJiYgdGhpcy5faGFuZGxlRXJyb3JzKHZhbGlkYXRlU3R5bGUuc291cmNlLCAnc291cmNlcy4nICsgaWQsIHNvdXJjZSkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIHNvdXJjZSA9IFNvdXJjZS5jcmVhdGUoc291cmNlKTtcbiAgICAgICAgdGhpcy5zb3VyY2VzW2lkXSA9IHNvdXJjZTtcbiAgICAgICAgc291cmNlLmlkID0gaWQ7XG4gICAgICAgIHNvdXJjZS5zdHlsZSA9IHRoaXM7XG4gICAgICAgIHNvdXJjZS5kaXNwYXRjaGVyID0gdGhpcy5kaXNwYXRjaGVyO1xuICAgICAgICBzb3VyY2VcbiAgICAgICAgICAgIC5vbignbG9hZCcsIHRoaXMuX2ZvcndhcmRTb3VyY2VFdmVudClcbiAgICAgICAgICAgIC5vbignZXJyb3InLCB0aGlzLl9mb3J3YXJkU291cmNlRXZlbnQpXG4gICAgICAgICAgICAub24oJ2NoYW5nZScsIHRoaXMuX2ZvcndhcmRTb3VyY2VFdmVudClcbiAgICAgICAgICAgIC5vbigndGlsZS5hZGQnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9uKCd0aWxlLmxvYWQnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9uKCd0aWxlLmVycm9yJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgIC5vbigndGlsZS5yZW1vdmUnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9uKCd0aWxlLnN0YXRzJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudCk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlcy5ldmVudHMucHVzaChbJ3NvdXJjZS5hZGQnLCB7c291cmNlOiBzb3VyY2V9XSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZXMuY2hhbmdlZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHNvdXJjZSBmcm9tIHRoaXMgc3R5bGVzaGVldCwgZ2l2ZW4gaXRzIGlkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBpZCBvZiB0aGUgc291cmNlIHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm5zIHtTdHlsZX0gdGhpcyBzdHlsZVxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBzb3VyY2UgaXMgZm91bmQgd2l0aCB0aGUgZ2l2ZW4gSURcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJlbW92ZVNvdXJjZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcblxuICAgICAgICBpZiAodGhpcy5zb3VyY2VzW2lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIHNvdXJjZSB3aXRoIHRoaXMgSUQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2VzW2lkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc291cmNlc1tpZF07XG4gICAgICAgIHNvdXJjZVxuICAgICAgICAgICAgLm9mZignbG9hZCcsIHRoaXMuX2ZvcndhcmRTb3VyY2VFdmVudClcbiAgICAgICAgICAgIC5vZmYoJ2Vycm9yJywgdGhpcy5fZm9yd2FyZFNvdXJjZUV2ZW50KVxuICAgICAgICAgICAgLm9mZignY2hhbmdlJywgdGhpcy5fZm9yd2FyZFNvdXJjZUV2ZW50KVxuICAgICAgICAgICAgLm9mZigndGlsZS5hZGQnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9mZigndGlsZS5sb2FkJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgIC5vZmYoJ3RpbGUuZXJyb3InLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9mZigndGlsZS5yZW1vdmUnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9mZigndGlsZS5zdGF0cycsIHRoaXMuX2ZvcndhcmRUaWxlRXZlbnQpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZXMuZXZlbnRzLnB1c2goWydzb3VyY2UucmVtb3ZlJywge3NvdXJjZTogc291cmNlfV0pO1xuICAgICAgICB0aGlzLl91cGRhdGVzLmNoYW5nZWQgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzb3VyY2UgYnkgaWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIGlkIG9mIHRoZSBkZXNpcmVkIHNvdXJjZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHNvdXJjZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0U291cmNlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzW2lkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGF5ZXIgdG8gdGhlIG1hcCBzdHlsZS4gVGhlIGxheWVyIHdpbGwgYmUgaW5zZXJ0ZWQgYmVmb3JlIHRoZSBsYXllciB3aXRoXG4gICAgICogSUQgYGJlZm9yZWAsIG9yIGFwcGVuZGVkIGlmIGBiZWZvcmVgIGlzIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIHtTdHlsZUxheWVyfE9iamVjdH0gbGF5ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGJlZm9yZSAgSUQgb2YgYW4gZXhpc3RpbmcgbGF5ZXIgdG8gaW5zZXJ0IGJlZm9yZVxuICAgICAqIEBmaXJlcyBsYXllci5hZGRcbiAgICAgKiBAcmV0dXJucyB7U3R5bGV9IGB0aGlzYFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWRkTGF5ZXI6IGZ1bmN0aW9uKGxheWVyLCBiZWZvcmUpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcblxuICAgICAgICBpZiAoIShsYXllciBpbnN0YW5jZW9mIFN0eWxlTGF5ZXIpKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGxheWVyIGlzIG5vdCBpbiB0aGUgc3R5bGUubGF5ZXJzIGFycmF5LCBzbyB3ZSBwYXNzIGFuIGltcG9zc2libGUgYXJyYXkgaW5kZXhcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVFcnJvcnModmFsaWRhdGVTdHlsZS5sYXllcixcbiAgICAgICAgICAgICAgICAgICAgJ2xheWVycy4nICsgbGF5ZXIuaWQsIGxheWVyLCBmYWxzZSwge2FycmF5SW5kZXg6IC0xfSkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgcmVmTGF5ZXIgPSBsYXllci5yZWYgJiYgdGhpcy5nZXRMYXllcihsYXllci5yZWYpO1xuICAgICAgICAgICAgbGF5ZXIgPSBTdHlsZUxheWVyLmNyZWF0ZShsYXllciwgcmVmTGF5ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlTGF5ZXIobGF5ZXIpO1xuXG4gICAgICAgIGxheWVyLm9uKCdlcnJvcicsIHRoaXMuX2ZvcndhcmRMYXllckV2ZW50KTtcblxuICAgICAgICB0aGlzLl9sYXllcnNbbGF5ZXIuaWRdID0gbGF5ZXI7XG4gICAgICAgIHRoaXMuX29yZGVyLnNwbGljZShiZWZvcmUgPyB0aGlzLl9vcmRlci5pbmRleE9mKGJlZm9yZSkgOiBJbmZpbml0eSwgMCwgbGF5ZXIuaWQpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZXMuYWxsTGF5ZXJzID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxheWVyLnNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlcy5zb3VyY2VzW2xheWVyLnNvdXJjZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZXMuZXZlbnRzLnB1c2goWydsYXllci5hZGQnLCB7bGF5ZXI6IGxheWVyfV0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUNsYXNzZXMobGF5ZXIuaWQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBsYXllciBmcm9tIHRoaXMgc3R5bGVzaGVldCwgZ2l2ZW4gaXRzIGlkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBpZCBvZiB0aGUgbGF5ZXIgdG8gcmVtb3ZlXG4gICAgICogQHJldHVybnMge1N0eWxlfSB0aGlzIHN0eWxlXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGxheWVyIGlzIGZvdW5kIHdpdGggdGhlIGdpdmVuIElEXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZW1vdmVMYXllcjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcblxuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuICAgICAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBpcyBubyBsYXllciB3aXRoIHRoaXMgSUQnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xheWVyc1tpXS5yZWYgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMYXllcihpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxheWVyLm9mZignZXJyb3InLCB0aGlzLl9mb3J3YXJkTGF5ZXJFdmVudCk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG4gICAgICAgIHRoaXMuX29yZGVyLnNwbGljZSh0aGlzLl9vcmRlci5pbmRleE9mKGlkKSwgMSk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlcy5hbGxMYXllcnMgPSB0cnVlO1xuICAgICAgICB0aGlzLl91cGRhdGVzLmV2ZW50cy5wdXNoKFsnbGF5ZXIucmVtb3ZlJywge2xheWVyOiBsYXllcn1dKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlcy5jaGFuZ2VkID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBzdHlsZSBsYXllciBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYGlkYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIGlkIG9mIHRoZSBkZXNpcmVkIGxheWVyXG4gICAgICogQHJldHVybnMgez9PYmplY3R9IGEgbGF5ZXIsIGlmIG9uZSB3aXRoIHRoZSBnaXZlbiBgaWRgIGV4aXN0c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0TGF5ZXI6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllcnNbaWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiBhIGxheWVyIGhhcyBhIGByZWZgIHByb3BlcnR5IHRoYXQgbWFrZXMgaXQgZGVyaXZlIHNvbWUgdmFsdWVzXG4gICAgICogZnJvbSBhbm90aGVyIGxheWVyLCByZXR1cm4gdGhhdCByZWZlcmVudCBsYXllci4gT3RoZXJ3aXNlLFxuICAgICAqIHJldHVybnMgdGhlIGxheWVyIGl0c2VsZi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgdGhlIGxheWVyJ3MgaWRcbiAgICAgKiBAcmV0dXJucyB7TGF5ZXJ9IHRoZSByZWZlcmVudCBsYXllciBvciB0aGUgbGF5ZXIgaXRzZWxmXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRSZWZlcmVudExheWVyOiBmdW5jdGlvbihpZCkge1xuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKGlkKTtcbiAgICAgICAgaWYgKGxheWVyLnJlZikge1xuICAgICAgICAgICAgbGF5ZXIgPSB0aGlzLmdldExheWVyKGxheWVyLnJlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgIH0sXG5cbiAgICBzZXRMYXllclpvb21SYW5nZTogZnVuY3Rpb24obGF5ZXJJZCwgbWluem9vbSwgbWF4em9vbSkge1xuICAgICAgICB0aGlzLl9jaGVja0xvYWRlZCgpO1xuXG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0UmVmZXJlbnRMYXllcihsYXllcklkKTtcblxuICAgICAgICBpZiAobGF5ZXIubWluem9vbSA9PT0gbWluem9vbSAmJiBsYXllci5tYXh6b29tID09PSBtYXh6b29tKSByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAobWluem9vbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsYXllci5taW56b29tID0gbWluem9vbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4em9vbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsYXllci5tYXh6b29tID0gbWF4em9vbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlTGF5ZXIobGF5ZXIpO1xuICAgIH0sXG5cbiAgICBzZXRGaWx0ZXI6IGZ1bmN0aW9uKGxheWVySWQsIGZpbHRlcikge1xuICAgICAgICB0aGlzLl9jaGVja0xvYWRlZCgpO1xuXG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0UmVmZXJlbnRMYXllcihsYXllcklkKTtcblxuICAgICAgICBpZiAodGhpcy5faGFuZGxlRXJyb3JzKHZhbGlkYXRlU3R5bGUuZmlsdGVyLCAnbGF5ZXJzLicgKyBsYXllci5pZCArICcuZmlsdGVyJywgZmlsdGVyKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHV0aWwuZGVlcEVxdWFsKGxheWVyLmZpbHRlciwgZmlsdGVyKSkgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxheWVyLmZpbHRlciA9IHV0aWwuY2xvbmUoZmlsdGVyKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlTGF5ZXIobGF5ZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBsYXllcidzIGZpbHRlciBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgdGhlIGxheWVyIHRvIGluc3BlY3RcbiAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIGxheWVyJ3MgZmlsdGVyLCBpZiBhbnlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldEZpbHRlcjogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVmZXJlbnRMYXllcihsYXllcikuZmlsdGVyO1xuICAgIH0sXG5cbiAgICBzZXRMYXlvdXRQcm9wZXJ0eTogZnVuY3Rpb24obGF5ZXJJZCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcblxuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldFJlZmVyZW50TGF5ZXIobGF5ZXJJZCk7XG5cbiAgICAgICAgaWYgKHV0aWwuZGVlcEVxdWFsKGxheWVyLmdldExheW91dFByb3BlcnR5KG5hbWUpLCB2YWx1ZSkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGxheWVyLnNldExheW91dFByb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUxheWVyKGxheWVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgbGF5b3V0IHByb3BlcnR5J3MgdmFsdWUgZnJvbSBhIGdpdmVuIGxheWVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyIHRoZSBsYXllciB0byBpbnNwZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGxheW91dCBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldExheW91dFByb3BlcnR5OiBmdW5jdGlvbihsYXllciwgbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZWZlcmVudExheWVyKGxheWVyKS5nZXRMYXlvdXRQcm9wZXJ0eShuYW1lKTtcbiAgICB9LFxuXG4gICAgc2V0UGFpbnRQcm9wZXJ0eTogZnVuY3Rpb24obGF5ZXJJZCwgbmFtZSwgdmFsdWUsIGtsYXNzKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrTG9hZGVkKCk7XG5cbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcihsYXllcklkKTtcblxuICAgICAgICBpZiAodXRpbC5kZWVwRXF1YWwobGF5ZXIuZ2V0UGFpbnRQcm9wZXJ0eShuYW1lLCBrbGFzcyksIHZhbHVlKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdmFyIHdhc0ZlYXR1cmVDb25zdGFudCA9IGxheWVyLmlzUGFpbnRWYWx1ZUZlYXR1cmVDb25zdGFudChuYW1lKTtcbiAgICAgICAgbGF5ZXIuc2V0UGFpbnRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwga2xhc3MpO1xuXG4gICAgICAgIHZhciBpc0ZlYXR1cmVDb25zdGFudCA9ICEoU3R5bGVGdW5jdGlvbi5pc0Z1bmN0aW9uRGVmaW5pdGlvbih2YWx1ZSkgJiYgdmFsdWUucHJvcGVydHkgIT09ICckem9vbScgJiYgdmFsdWUucHJvcGVydHkgIT09IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgaWYgKCFpc0ZlYXR1cmVDb25zdGFudCB8fCAhd2FzRmVhdHVyZUNvbnN0YW50KSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVzLmxheWVyc1tsYXllcklkXSA9IHRydWU7XG4gICAgICAgICAgICBpZiAobGF5ZXIuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlcy5zb3VyY2VzW2xheWVyLnNvdXJjZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ2xhc3NlcyhsYXllcklkLCBuYW1lKTtcbiAgICB9LFxuXG4gICAgZ2V0UGFpbnRQcm9wZXJ0eTogZnVuY3Rpb24obGF5ZXIsIG5hbWUsIGtsYXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExheWVyKGxheWVyKS5nZXRQYWludFByb3BlcnR5KG5hbWUsIGtsYXNzKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlQ2xhc3NlczogZnVuY3Rpb24gKGxheWVySWQsIHBhaW50TmFtZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIWxheWVySWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZXMuYWxsUGFpbnRQcm9wcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLl91cGRhdGVzLnBhaW50UHJvcHM7XG4gICAgICAgICAgICBpZiAoIXByb3BzW2xheWVySWRdKSBwcm9wc1tsYXllcklkXSA9IHt9O1xuICAgICAgICAgICAgcHJvcHNbbGF5ZXJJZF1bcGFpbnROYW1lIHx8ICdhbGwnXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1dGlsLmZpbHRlck9iamVjdCh7XG4gICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLnN0eWxlc2hlZXQudmVyc2lvbixcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuc3R5bGVzaGVldC5uYW1lLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHRoaXMuc3R5bGVzaGVldC5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNlbnRlcjogdGhpcy5zdHlsZXNoZWV0LmNlbnRlcixcbiAgICAgICAgICAgIHpvb206IHRoaXMuc3R5bGVzaGVldC56b29tLFxuICAgICAgICAgICAgYmVhcmluZzogdGhpcy5zdHlsZXNoZWV0LmJlYXJpbmcsXG4gICAgICAgICAgICBwaXRjaDogdGhpcy5zdHlsZXNoZWV0LnBpdGNoLFxuICAgICAgICAgICAgc3ByaXRlOiB0aGlzLnN0eWxlc2hlZXQuc3ByaXRlLFxuICAgICAgICAgICAgZ2x5cGhzOiB0aGlzLnN0eWxlc2hlZXQuZ2x5cGhzLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogdGhpcy5zdHlsZXNoZWV0LnRyYW5zaXRpb24sXG4gICAgICAgICAgICBzb3VyY2VzOiB1dGlsLm1hcE9iamVjdCh0aGlzLnNvdXJjZXMsIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2Uuc2VyaWFsaXplKCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGxheWVyczogdGhpcy5fb3JkZXIubWFwKGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1tpZF0uc2VyaWFsaXplKCk7XG4gICAgICAgICAgICB9LCB0aGlzKVxuICAgICAgICB9LCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZDsgfSk7XG4gICAgfSxcblxuICAgIF91cGRhdGVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZXMubGF5ZXJzW2xheWVyLmlkXSA9IHRydWU7XG4gICAgICAgIGlmIChsYXllci5zb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZXMuc291cmNlc1tsYXllci5zb3VyY2VdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGVzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2ZsYXR0ZW5SZW5kZXJlZEZlYXR1cmVzOiBmdW5jdGlvbihzb3VyY2VSZXN1bHRzKSB7XG4gICAgICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBsID0gdGhpcy5fb3JkZXIubGVuZ3RoIC0gMTsgbCA+PSAwOyBsLS0pIHtcbiAgICAgICAgICAgIHZhciBsYXllcklEID0gdGhpcy5fb3JkZXJbbF07XG4gICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHNvdXJjZVJlc3VsdHMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXJGZWF0dXJlcyA9IHNvdXJjZVJlc3VsdHNbc11bbGF5ZXJJRF07XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyRmVhdHVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZiA9IDA7IGYgPCBsYXllckZlYXR1cmVzLmxlbmd0aDsgZisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGxheWVyRmVhdHVyZXNbZl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmZWF0dXJlcztcbiAgICB9LFxuXG4gICAgcXVlcnlSZW5kZXJlZEZlYXR1cmVzOiBmdW5jdGlvbihxdWVyeUdlb21ldHJ5LCBwYXJhbXMsIHpvb20sIGJlYXJpbmcpIHtcbiAgICAgICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuZmlsdGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVFcnJvcnModmFsaWRhdGVTdHlsZS5maWx0ZXIsICdxdWVyeVJlbmRlcmVkRmVhdHVyZXMuZmlsdGVyJywgcGFyYW1zLmZpbHRlciwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc291cmNlUmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLnNvdXJjZXMpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZXNbaWRdO1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5xdWVyeVJlbmRlcmVkRmVhdHVyZXMpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VSZXN1bHRzLnB1c2goc291cmNlLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhxdWVyeUdlb21ldHJ5LCBwYXJhbXMsIHpvb20sIGJlYXJpbmcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZmxhdHRlblJlbmRlcmVkRmVhdHVyZXMoc291cmNlUmVzdWx0cyk7XG4gICAgfSxcblxuICAgIHF1ZXJ5U291cmNlRmVhdHVyZXM6IGZ1bmN0aW9uKHNvdXJjZUlELCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuZmlsdGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVFcnJvcnModmFsaWRhdGVTdHlsZS5maWx0ZXIsICdxdWVyeVNvdXJjZUZlYXR1cmVzLmZpbHRlcicsIHBhcmFtcy5maWx0ZXIsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZShzb3VyY2VJRCk7XG4gICAgICAgIHJldHVybiBzb3VyY2UgJiYgc291cmNlLnF1ZXJ5U291cmNlRmVhdHVyZXMgPyBzb3VyY2UucXVlcnlTb3VyY2VGZWF0dXJlcyhwYXJhbXMpIDogW107XG4gICAgfSxcblxuICAgIF9oYW5kbGVFcnJvcnM6IGZ1bmN0aW9uKHZhbGlkYXRlLCBrZXksIHZhbHVlLCB0aHJvd3MsIHByb3BzKSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSB0aHJvd3MgPyB2YWxpZGF0ZVN0eWxlLnRocm93RXJyb3JzIDogdmFsaWRhdGVTdHlsZS5lbWl0RXJyb3JzO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdmFsaWRhdGUuY2FsbCh2YWxpZGF0ZVN0eWxlLCB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIHN0eWxlOiB0aGlzLnNlcmlhbGl6ZSgpLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgICAgfSwgcHJvcHMpKTtcbiAgICAgICAgcmV0dXJuIGFjdGlvbi5jYWxsKHZhbGlkYXRlU3R5bGUsIHRoaXMsIHJlc3VsdCk7XG4gICAgfSxcblxuICAgIF9yZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIucmVtb3ZlKCk7XG4gICAgfSxcblxuICAgIF9yZWxvYWRTb3VyY2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHRoaXMuc291cmNlc1tpZF0ucmVsb2FkKCk7XG4gICAgfSxcblxuICAgIF91cGRhdGVTb3VyY2VzOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5zb3VyY2VzKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZXNbaWRdLnVwZGF0ZSh0cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9yZWRvUGxhY2VtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5zb3VyY2VzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VzW2lkXS5yZWRvUGxhY2VtZW50KSB0aGlzLnNvdXJjZXNbaWRdLnJlZG9QbGFjZW1lbnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZm9yd2FyZFNvdXJjZUV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnc291cmNlLicgKyBlLnR5cGUsIHV0aWwuZXh0ZW5kKHtzb3VyY2U6IGUudGFyZ2V0fSwgZSkpO1xuICAgIH0sXG5cbiAgICBfZm9yd2FyZFRpbGVFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmZpcmUoZS50eXBlLCB1dGlsLmV4dGVuZCh7c291cmNlOiBlLnRhcmdldH0sIGUpKTtcbiAgICB9LFxuXG4gICAgX2ZvcndhcmRMYXllckV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnbGF5ZXIuJyArIGUudHlwZSwgdXRpbC5leHRlbmQoe2xheWVyOiB7aWQ6IGUudGFyZ2V0LmlkfX0sIGUpKTtcbiAgICB9LFxuXG4gICAgLy8gQ2FsbGJhY2tzIGZyb20gd2ViIHdvcmtlcnNcblxuICAgICdnZXQgc3ByaXRlIGpzb24nOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzcHJpdGUgPSB0aGlzLnNwcml0ZTtcbiAgICAgICAgaWYgKHNwcml0ZS5sb2FkZWQoKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeyBzcHJpdGU6IHNwcml0ZS5kYXRhLCByZXRpbmE6IHNwcml0ZS5yZXRpbmEgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcHJpdGUub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7IHNwcml0ZTogc3ByaXRlLmRhdGEsIHJldGluYTogc3ByaXRlLnJldGluYSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdnZXQgaWNvbnMnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzcHJpdGUgPSB0aGlzLnNwcml0ZTtcbiAgICAgICAgdmFyIHNwcml0ZUF0bGFzID0gdGhpcy5zcHJpdGVBdGxhcztcbiAgICAgICAgaWYgKHNwcml0ZS5sb2FkZWQoKSkge1xuICAgICAgICAgICAgc3ByaXRlQXRsYXMuc2V0U3ByaXRlKHNwcml0ZSk7XG4gICAgICAgICAgICBzcHJpdGVBdGxhcy5hZGRJY29ucyhwYXJhbXMuaWNvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNwcml0ZS5vbignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNwcml0ZUF0bGFzLnNldFNwcml0ZShzcHJpdGUpO1xuICAgICAgICAgICAgICAgIHNwcml0ZUF0bGFzLmFkZEljb25zKHBhcmFtcy5pY29ucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2dldCBnbHlwaHMnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzdGFja3MgPSBwYXJhbXMuc3RhY2tzLFxuICAgICAgICAgICAgcmVtYWluaW5nID0gT2JqZWN0LmtleXMoc3RhY2tzKS5sZW5ndGgsXG4gICAgICAgICAgICBhbGxHbHlwaHMgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBmb250TmFtZSBpbiBzdGFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuZ2x5cGhTb3VyY2UuZ2V0U2ltcGxlR2x5cGhzKGZvbnROYW1lLCBzdGFja3NbZm9udE5hbWVdLCBwYXJhbXMudWlkLCBkb25lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyLCBnbHlwaHMsIGZvbnROYW1lKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSBjb25zb2xlLmVycm9yKGVycik7XG5cbiAgICAgICAgICAgIGFsbEdseXBoc1tmb250TmFtZV0gPSBnbHlwaHM7XG4gICAgICAgICAgICByZW1haW5pbmctLTtcblxuICAgICAgICAgICAgaWYgKHJlbWFpbmluZyA9PT0gMClcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBhbGxHbHlwaHMpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBNYXBib3hHTEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9zdHlsZV9mdW5jdGlvbicpO1xudmFyIHBhcnNlQ29sb3IgPSByZXF1aXJlKCcuL3BhcnNlX2NvbG9yJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0eWxlRGVjbGFyYXRpb247XG5cbmZ1bmN0aW9uIFN0eWxlRGVjbGFyYXRpb24ocmVmZXJlbmNlLCB2YWx1ZSkge1xuICAgIHRoaXMudHlwZSA9IHJlZmVyZW5jZS50eXBlO1xuICAgIHRoaXMudHJhbnNpdGlvbmFibGUgPSByZWZlcmVuY2UudHJhbnNpdGlvbjtcbiAgICB0aGlzLnZhbHVlID0gdXRpbC5jbG9uZSh2YWx1ZSk7XG4gICAgdGhpcy5pc0Z1bmN0aW9uID0gISF2YWx1ZS5zdG9wcztcblxuICAgIC8vIGltbXV0YWJsZSByZXByZXNlbnRhdGlvbiBvZiB2YWx1ZS4gdXNlZCBmb3IgY29tcGFyaXNvblxuICAgIHRoaXMuanNvbiA9IEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUpO1xuXG4gICAgdmFyIHBhcnNlZFZhbHVlID0gdGhpcy50eXBlID09PSAnY29sb3InID8gcGFyc2VDb2xvcih0aGlzLnZhbHVlKSA6IHZhbHVlO1xuICAgIHRoaXMuY2FsY3VsYXRlID0gTWFwYm94R0xGdW5jdGlvbltyZWZlcmVuY2UuZnVuY3Rpb24gfHwgJ3BpZWNld2lzZS1jb25zdGFudCddKHBhcnNlZFZhbHVlKTtcbiAgICB0aGlzLmlzRmVhdHVyZUNvbnN0YW50ID0gdGhpcy5jYWxjdWxhdGUuaXNGZWF0dXJlQ29uc3RhbnQ7XG4gICAgdGhpcy5pc1pvb21Db25zdGFudCA9IHRoaXMuY2FsY3VsYXRlLmlzWm9vbUNvbnN0YW50O1xuXG4gICAgaWYgKHJlZmVyZW5jZS5mdW5jdGlvbiA9PT0gJ3BpZWNld2lzZS1jb25zdGFudCcgJiYgcmVmZXJlbmNlLnRyYW5zaXRpb24pIHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGUgPSB0cmFuc2l0aW9uZWQodGhpcy5jYWxjdWxhdGUpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc0ZlYXR1cmVDb25zdGFudCAmJiAhdGhpcy5pc1pvb21Db25zdGFudCkge1xuICAgICAgICB0aGlzLnN0b3Bab29tTGV2ZWxzID0gW107XG4gICAgICAgIHZhciBpbnRlcnBvbGF0aW9uQW1vdW50U3RvcHMgPSBbXTtcbiAgICAgICAgdmFyIHN0b3BzID0gdGhpcy52YWx1ZS5zdG9wcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZhbHVlLnN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgem9vbSA9IHN0b3BzW2ldWzBdLnpvb207XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wWm9vbUxldmVscy5pbmRleE9mKHpvb20pIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcFpvb21MZXZlbHMucHVzaCh6b29tKTtcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uQW1vdW50U3RvcHMucHVzaChbem9vbSwgaW50ZXJwb2xhdGlvbkFtb3VudFN0b3BzLmxlbmd0aF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxjdWxhdGVJbnRlcnBvbGF0aW9uVCA9IE1hcGJveEdMRnVuY3Rpb24uaW50ZXJwb2xhdGVkKHtcbiAgICAgICAgICAgIHN0b3BzOiBpbnRlcnBvbGF0aW9uQW1vdW50U3RvcHMsXG4gICAgICAgICAgICBiYXNlOiB2YWx1ZS5iYXNlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbmVkKGNhbGN1bGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcykge1xuICAgICAgICB2YXIgeiA9IGdsb2JhbFByb3BlcnRpZXMuem9vbTtcbiAgICAgICAgdmFyIHpoID0gZ2xvYmFsUHJvcGVydGllcy56b29tSGlzdG9yeTtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gZ2xvYmFsUHJvcGVydGllcy5kdXJhdGlvbjtcblxuICAgICAgICB2YXIgZnJhY3Rpb24gPSB6ICUgMTtcbiAgICAgICAgdmFyIHQgPSBNYXRoLm1pbigoRGF0ZS5ub3coKSAtIHpoLmxhc3RJbnRlZ2VyWm9vbVRpbWUpIC8gZHVyYXRpb24sIDEpO1xuICAgICAgICB2YXIgZnJvbVNjYWxlID0gMTtcbiAgICAgICAgdmFyIHRvU2NhbGUgPSAxO1xuICAgICAgICB2YXIgbWl4LCBmcm9tLCB0bztcblxuICAgICAgICBpZiAoeiA+IHpoLmxhc3RJbnRlZ2VyWm9vbSkge1xuICAgICAgICAgICAgbWl4ID0gZnJhY3Rpb24gKyAoMSAtIGZyYWN0aW9uKSAqIHQ7XG4gICAgICAgICAgICBmcm9tU2NhbGUgKj0gMjtcbiAgICAgICAgICAgIGZyb20gPSBjYWxjdWxhdGUoe3pvb206IHogLSAxfSwgZmVhdHVyZVByb3BlcnRpZXMpO1xuICAgICAgICAgICAgdG8gPSBjYWxjdWxhdGUoe3pvb206IHp9LCBmZWF0dXJlUHJvcGVydGllcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtaXggPSAxIC0gKDEgLSB0KSAqIGZyYWN0aW9uO1xuICAgICAgICAgICAgdG8gPSBjYWxjdWxhdGUoe3pvb206IHp9LCBmZWF0dXJlUHJvcGVydGllcyk7XG4gICAgICAgICAgICBmcm9tID0gY2FsY3VsYXRlKHt6b29tOiB6ICsgMX0sIGZlYXR1cmVQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIGZyb21TY2FsZSAvPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICBmcm9tU2NhbGU6IGZyb21TY2FsZSxcbiAgICAgICAgICAgIHRvOiB0byxcbiAgICAgICAgICAgIHRvU2NhbGU6IHRvU2NhbGUsXG4gICAgICAgICAgICB0OiBtaXhcbiAgICAgICAgfTtcbiAgICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTWFwYm94R0xGdW5jdGlvbiA9IHJlcXVpcmUoJ21hcGJveC1nbC1mdW5jdGlvbicpO1xuXG5leHBvcnRzLmludGVycG9sYXRlZCA9IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcbiAgICB2YXIgaW5uZXIgPSBNYXBib3hHTEZ1bmN0aW9uLmludGVycG9sYXRlZChwYXJhbWV0ZXJzKTtcbiAgICB2YXIgb3V0ZXIgPSBmdW5jdGlvbihnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcykge1xuICAgICAgICByZXR1cm4gaW5uZXIoZ2xvYmFsUHJvcGVydGllcyAmJiBnbG9iYWxQcm9wZXJ0aWVzLnpvb20sIGZlYXR1cmVQcm9wZXJ0aWVzIHx8IHt9KTtcbiAgICB9O1xuICAgIG91dGVyLmlzRmVhdHVyZUNvbnN0YW50ID0gaW5uZXIuaXNGZWF0dXJlQ29uc3RhbnQ7XG4gICAgb3V0ZXIuaXNab29tQ29uc3RhbnQgPSBpbm5lci5pc1pvb21Db25zdGFudDtcbiAgICByZXR1cm4gb3V0ZXI7XG59O1xuXG5leHBvcnRzWydwaWVjZXdpc2UtY29uc3RhbnQnXSA9IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcbiAgICB2YXIgaW5uZXIgPSBNYXBib3hHTEZ1bmN0aW9uWydwaWVjZXdpc2UtY29uc3RhbnQnXShwYXJhbWV0ZXJzKTtcbiAgICB2YXIgb3V0ZXIgPSBmdW5jdGlvbihnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcykge1xuICAgICAgICByZXR1cm4gaW5uZXIoZ2xvYmFsUHJvcGVydGllcyAmJiBnbG9iYWxQcm9wZXJ0aWVzLnpvb20sIGZlYXR1cmVQcm9wZXJ0aWVzIHx8IHt9KTtcbiAgICB9O1xuICAgIG91dGVyLmlzRmVhdHVyZUNvbnN0YW50ID0gaW5uZXIuaXNGZWF0dXJlQ29uc3RhbnQ7XG4gICAgb3V0ZXIuaXNab29tQ29uc3RhbnQgPSBpbm5lci5pc1pvb21Db25zdGFudDtcbiAgICByZXR1cm4gb3V0ZXI7XG59O1xuXG5leHBvcnRzLmlzRnVuY3Rpb25EZWZpbml0aW9uID0gTWFwYm94R0xGdW5jdGlvbi5pc0Z1bmN0aW9uRGVmaW5pdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBTdHlsZVRyYW5zaXRpb24gPSByZXF1aXJlKCcuL3N0eWxlX3RyYW5zaXRpb24nKTtcbnZhciBTdHlsZURlY2xhcmF0aW9uID0gcmVxdWlyZSgnLi9zdHlsZV9kZWNsYXJhdGlvbicpO1xudmFyIHN0eWxlU3BlYyA9IHJlcXVpcmUoJy4vc3R5bGVfc3BlYycpO1xudmFyIHZhbGlkYXRlU3R5bGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRlX3N0eWxlJyk7XG52YXIgcGFyc2VDb2xvciA9IHJlcXVpcmUoJy4vcGFyc2VfY29sb3InKTtcbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3R5bGVMYXllcjtcblxudmFyIFRSQU5TSVRJT05fU1VGRklYID0gJy10cmFuc2l0aW9uJztcblxuU3R5bGVMYXllci5jcmVhdGUgPSBmdW5jdGlvbihsYXllciwgcmVmTGF5ZXIpIHtcbiAgICB2YXIgQ2xhc3NlcyA9IHtcbiAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi9zdHlsZV9sYXllci9iYWNrZ3JvdW5kX3N0eWxlX2xheWVyJyksXG4gICAgICAgIGNpcmNsZTogcmVxdWlyZSgnLi9zdHlsZV9sYXllci9jaXJjbGVfc3R5bGVfbGF5ZXInKSxcbiAgICAgICAgZmlsbDogcmVxdWlyZSgnLi9zdHlsZV9sYXllci9maWxsX3N0eWxlX2xheWVyJyksXG4gICAgICAgIGxpbmU6IHJlcXVpcmUoJy4vc3R5bGVfbGF5ZXIvbGluZV9zdHlsZV9sYXllcicpLFxuICAgICAgICByYXN0ZXI6IHJlcXVpcmUoJy4vc3R5bGVfbGF5ZXIvcmFzdGVyX3N0eWxlX2xheWVyJyksXG4gICAgICAgIHN5bWJvbDogcmVxdWlyZSgnLi9zdHlsZV9sYXllci9zeW1ib2xfc3R5bGVfbGF5ZXInKVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBDbGFzc2VzWyhyZWZMYXllciB8fCBsYXllcikudHlwZV0obGF5ZXIsIHJlZkxheWVyKTtcbn07XG5cbmZ1bmN0aW9uIFN0eWxlTGF5ZXIobGF5ZXIsIHJlZkxheWVyKSB7XG4gICAgdGhpcy5zZXQobGF5ZXIsIHJlZkxheWVyKTtcbn1cblxuU3R5bGVMYXllci5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoRXZlbnRlZCwge1xuXG4gICAgc2V0OiBmdW5jdGlvbihsYXllciwgcmVmTGF5ZXIpIHtcbiAgICAgICAgdGhpcy5pZCA9IGxheWVyLmlkO1xuICAgICAgICB0aGlzLnJlZiA9IGxheWVyLnJlZjtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IGxheWVyLm1ldGFkYXRhO1xuICAgICAgICB0aGlzLnR5cGUgPSAocmVmTGF5ZXIgfHwgbGF5ZXIpLnR5cGU7XG4gICAgICAgIHRoaXMuc291cmNlID0gKHJlZkxheWVyIHx8IGxheWVyKS5zb3VyY2U7XG4gICAgICAgIHRoaXMuc291cmNlTGF5ZXIgPSAocmVmTGF5ZXIgfHwgbGF5ZXIpWydzb3VyY2UtbGF5ZXInXTtcbiAgICAgICAgdGhpcy5taW56b29tID0gKHJlZkxheWVyIHx8IGxheWVyKS5taW56b29tO1xuICAgICAgICB0aGlzLm1heHpvb20gPSAocmVmTGF5ZXIgfHwgbGF5ZXIpLm1heHpvb207XG4gICAgICAgIHRoaXMuZmlsdGVyID0gKHJlZkxheWVyIHx8IGxheWVyKS5maWx0ZXI7XG5cbiAgICAgICAgdGhpcy5wYWludCA9IHt9O1xuICAgICAgICB0aGlzLmxheW91dCA9IHt9O1xuXG4gICAgICAgIHRoaXMuX3BhaW50U3BlY2lmaWNhdGlvbnMgPSBzdHlsZVNwZWNbJ3BhaW50XycgKyB0aGlzLnR5cGVdO1xuICAgICAgICB0aGlzLl9sYXlvdXRTcGVjaWZpY2F0aW9ucyA9IHN0eWxlU3BlY1snbGF5b3V0XycgKyB0aGlzLnR5cGVdO1xuXG4gICAgICAgIHRoaXMuX3BhaW50VHJhbnNpdGlvbnMgPSB7fTsgLy8ge1twcm9wZXJ0eU5hbWVdOiBTdHlsZVRyYW5zaXRpb259XG4gICAgICAgIHRoaXMuX3BhaW50VHJhbnNpdGlvbk9wdGlvbnMgPSB7fTsgLy8ge1tjbGFzc05hbWVdOiB7W3Byb3BlcnR5TmFtZV06IHsgZHVyYXRpb246TnVtYmVyLCBkZWxheTpOdW1iZXIgfX19XG4gICAgICAgIHRoaXMuX3BhaW50RGVjbGFyYXRpb25zID0ge307IC8vIHtbY2xhc3NOYW1lXToge1twcm9wZXJ0eU5hbWVdOiBTdHlsZURlY2xhcmF0aW9ufX1cbiAgICAgICAgdGhpcy5fbGF5b3V0RGVjbGFyYXRpb25zID0ge307IC8vIHtbcHJvcGVydHlOYW1lXTogU3R5bGVEZWNsYXJhdGlvbn1cbiAgICAgICAgdGhpcy5fbGF5b3V0RnVuY3Rpb25zID0ge307IC8vIHtbcHJvcGVydHlOYW1lXTogQm9vbGVhbn1cblxuICAgICAgICB2YXIgcGFpbnROYW1lLCBsYXlvdXROYW1lO1xuXG4gICAgICAgIC8vIFJlc29sdmUgcGFpbnQgZGVjbGFyYXRpb25zXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBsYXllcikge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0ga2V5Lm1hdGNoKC9ecGFpbnQoPzpcXC4oLiopKT8kLyk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YXIga2xhc3MgPSBtYXRjaFsxXSB8fCAnJztcbiAgICAgICAgICAgICAgICBmb3IgKHBhaW50TmFtZSBpbiBsYXllcltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UGFpbnRQcm9wZXJ0eShwYWludE5hbWUsIGxheWVyW2tleV1bcGFpbnROYW1lXSwga2xhc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc29sdmUgbGF5b3V0IGRlY2xhcmF0aW9uc1xuICAgICAgICBpZiAodGhpcy5yZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dERlY2xhcmF0aW9ucyA9IHJlZkxheWVyLl9sYXlvdXREZWNsYXJhdGlvbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxheW91dE5hbWUgaW4gbGF5ZXIubGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRMYXlvdXRQcm9wZXJ0eShsYXlvdXROYW1lLCBsYXllci5sYXlvdXRbbGF5b3V0TmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IGluaXRpYWwgbGF5b3V0L3BhaW50IHZhbHVlc1xuICAgICAgICBmb3IgKHBhaW50TmFtZSBpbiB0aGlzLl9wYWludFNwZWNpZmljYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50W3BhaW50TmFtZV0gPSB0aGlzLmdldFBhaW50VmFsdWUocGFpbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxheW91dE5hbWUgaW4gdGhpcy5fbGF5b3V0U3BlY2lmaWNhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxheW91dFZhbHVlKGxheW91dE5hbWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldExheW91dFByb3BlcnR5OiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbGF5b3V0RGVjbGFyYXRpb25zW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGtleSA9ICdsYXllcnMuJyArIHRoaXMuaWQgKyAnLmxheW91dC4nICsgbmFtZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVFcnJvcnModmFsaWRhdGVTdHlsZS5sYXlvdXRQcm9wZXJ0eSwga2V5LCBuYW1lLCB2YWx1ZSkpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dERlY2xhcmF0aW9uc1tuYW1lXSA9IG5ldyBTdHlsZURlY2xhcmF0aW9uKHRoaXMuX2xheW91dFNwZWNpZmljYXRpb25zW25hbWVdLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlTGF5b3V0VmFsdWUobmFtZSk7XG4gICAgfSxcblxuICAgIGdldExheW91dFByb3BlcnR5OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9sYXlvdXREZWNsYXJhdGlvbnNbbmFtZV0gJiZcbiAgICAgICAgICAgIHRoaXMuX2xheW91dERlY2xhcmF0aW9uc1tuYW1lXS52YWx1ZVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBnZXRMYXlvdXRWYWx1ZTogZnVuY3Rpb24obmFtZSwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcbiAgICAgICAgdmFyIHNwZWNpZmljYXRpb24gPSB0aGlzLl9sYXlvdXRTcGVjaWZpY2F0aW9uc1tuYW1lXTtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5fbGF5b3V0RGVjbGFyYXRpb25zW25hbWVdO1xuXG4gICAgICAgIGlmIChkZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uLmNhbGN1bGF0ZShnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlY2lmaWNhdGlvbi5kZWZhdWx0O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldFBhaW50UHJvcGVydHk6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBrbGFzcykge1xuICAgICAgICB2YXIgdmFsaWRhdGVTdHlsZUtleSA9ICdsYXllcnMuJyArIHRoaXMuaWQgKyAoa2xhc3MgPyAnW1wicGFpbnQuJyArIGtsYXNzICsgJ1wiXS4nIDogJy5wYWludC4nKSArIG5hbWU7XG5cbiAgICAgICAgaWYgKHV0aWwuZW5kc1dpdGgobmFtZSwgVFJBTlNJVElPTl9TVUZGSVgpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3BhaW50VHJhbnNpdGlvbk9wdGlvbnNba2xhc3MgfHwgJyddKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFpbnRUcmFuc2l0aW9uT3B0aW9uc1trbGFzcyB8fCAnJ10gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BhaW50VHJhbnNpdGlvbk9wdGlvbnNba2xhc3MgfHwgJyddW25hbWVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlRXJyb3JzKHZhbGlkYXRlU3R5bGUucGFpbnRQcm9wZXJ0eSwgdmFsaWRhdGVTdHlsZUtleSwgbmFtZSwgdmFsdWUpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFpbnRUcmFuc2l0aW9uT3B0aW9uc1trbGFzcyB8fCAnJ11bbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcGFpbnREZWNsYXJhdGlvbnNba2xhc3MgfHwgJyddKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFpbnREZWNsYXJhdGlvbnNba2xhc3MgfHwgJyddID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wYWludERlY2xhcmF0aW9uc1trbGFzcyB8fCAnJ11bbmFtZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVFcnJvcnModmFsaWRhdGVTdHlsZS5wYWludFByb3BlcnR5LCB2YWxpZGF0ZVN0eWxlS2V5LCBuYW1lLCB2YWx1ZSkpIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYWludERlY2xhcmF0aW9uc1trbGFzcyB8fCAnJ11bbmFtZV0gPSBuZXcgU3R5bGVEZWNsYXJhdGlvbih0aGlzLl9wYWludFNwZWNpZmljYXRpb25zW25hbWVdLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0UGFpbnRQcm9wZXJ0eTogZnVuY3Rpb24obmFtZSwga2xhc3MpIHtcbiAgICAgICAga2xhc3MgPSBrbGFzcyB8fCAnJztcbiAgICAgICAgaWYgKHV0aWwuZW5kc1dpdGgobmFtZSwgVFJBTlNJVElPTl9TVUZGSVgpKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHRoaXMuX3BhaW50VHJhbnNpdGlvbk9wdGlvbnNba2xhc3NdICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFpbnRUcmFuc2l0aW9uT3B0aW9uc1trbGFzc11bbmFtZV1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHRoaXMuX3BhaW50RGVjbGFyYXRpb25zW2tsYXNzXSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3BhaW50RGVjbGFyYXRpb25zW2tsYXNzXVtuYW1lXSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3BhaW50RGVjbGFyYXRpb25zW2tsYXNzXVtuYW1lXS52YWx1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRQYWludFZhbHVlOiBmdW5jdGlvbihuYW1lLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcykge1xuICAgICAgICB2YXIgc3BlY2lmaWNhdGlvbiA9IHRoaXMuX3BhaW50U3BlY2lmaWNhdGlvbnNbbmFtZV07XG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcy5fcGFpbnRUcmFuc2l0aW9uc1tuYW1lXTtcblxuICAgICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zaXRpb24uY2FsY3VsYXRlKGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChzcGVjaWZpY2F0aW9uLnR5cGUgPT09ICdjb2xvcicgJiYgc3BlY2lmaWNhdGlvbi5kZWZhdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VDb2xvcihzcGVjaWZpY2F0aW9uLmRlZmF1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNwZWNpZmljYXRpb24uZGVmYXVsdDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRQYWludFZhbHVlU3RvcFpvb21MZXZlbHM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLl9wYWludFRyYW5zaXRpb25zW25hbWVdO1xuICAgICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zaXRpb24uZGVjbGFyYXRpb24uc3RvcFpvb21MZXZlbHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0UGFpbnRJbnRlcnBvbGF0aW9uVDogZnVuY3Rpb24obmFtZSwgem9vbSkge1xuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXMuX3BhaW50VHJhbnNpdGlvbnNbbmFtZV07XG4gICAgICAgIHJldHVybiB0cmFuc2l0aW9uLmRlY2xhcmF0aW9uLmNhbGN1bGF0ZUludGVycG9sYXRpb25UKHsgem9vbTogem9vbSB9KTtcbiAgICB9LFxuXG4gICAgaXNQYWludFZhbHVlRmVhdHVyZUNvbnN0YW50OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcy5fcGFpbnRUcmFuc2l0aW9uc1tuYW1lXTtcblxuICAgICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zaXRpb24uZGVjbGFyYXRpb24uaXNGZWF0dXJlQ29uc3RhbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpc1BhaW50VmFsdWVab29tQ29uc3RhbnQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLl9wYWludFRyYW5zaXRpb25zW25hbWVdO1xuXG4gICAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNpdGlvbi5kZWNsYXJhdGlvbi5pc1pvb21Db25zdGFudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuXG4gICAgaXNIaWRkZW46IGZ1bmN0aW9uKHpvb20pIHtcbiAgICAgICAgaWYgKHRoaXMubWluem9vbSAmJiB6b29tIDwgdGhpcy5taW56b29tKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMubWF4em9vbSAmJiB6b29tID49IHRoaXMubWF4em9vbSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLmxheW91dFsndmlzaWJpbGl0eSddID09PSAnbm9uZScpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5wYWludFt0aGlzLnR5cGUgKyAnLW9wYWNpdHknXSA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgdXBkYXRlUGFpbnRUcmFuc2l0aW9uczogZnVuY3Rpb24oY2xhc3Nlcywgb3B0aW9ucywgZ2xvYmFsT3B0aW9ucywgYW5pbWF0aW9uTG9vcCkge1xuICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuX3BhaW50RGVjbGFyYXRpb25zWycnXSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdXRpbC5leHRlbmQoZGVjbGFyYXRpb25zLCB0aGlzLl9wYWludERlY2xhcmF0aW9uc1tjbGFzc2VzW2ldXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgZm9yIChuYW1lIGluIGRlY2xhcmF0aW9ucykgeyAvLyBhcHBseSBuZXcgZGVjbGFyYXRpb25zXG4gICAgICAgICAgICB0aGlzLl9hcHBseVBhaW50RGVjbGFyYXRpb24obmFtZSwgZGVjbGFyYXRpb25zW25hbWVdLCBvcHRpb25zLCBnbG9iYWxPcHRpb25zLCBhbmltYXRpb25Mb29wKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKG5hbWUgaW4gdGhpcy5fcGFpbnRUcmFuc2l0aW9ucykge1xuICAgICAgICAgICAgaWYgKCEobmFtZSBpbiBkZWNsYXJhdGlvbnMpKSAvLyBhcHBseSByZW1vdmVkIGRlY2xhcmF0aW9uc1xuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5UGFpbnREZWNsYXJhdGlvbihuYW1lLCBudWxsLCBvcHRpb25zLCBnbG9iYWxPcHRpb25zLCBhbmltYXRpb25Mb29wKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGVQYWludFRyYW5zaXRpb246IGZ1bmN0aW9uKG5hbWUsIGNsYXNzZXMsIG9wdGlvbnMsIGdsb2JhbE9wdGlvbnMsIGFuaW1hdGlvbkxvb3ApIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5fcGFpbnREZWNsYXJhdGlvbnNbJyddW25hbWVdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjbGFzc1BhaW50RGVjbGFyYXRpb25zID0gdGhpcy5fcGFpbnREZWNsYXJhdGlvbnNbY2xhc3Nlc1tpXV07XG4gICAgICAgICAgICBpZiAoY2xhc3NQYWludERlY2xhcmF0aW9ucyAmJiBjbGFzc1BhaW50RGVjbGFyYXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb24gPSBjbGFzc1BhaW50RGVjbGFyYXRpb25zW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FwcGx5UGFpbnREZWNsYXJhdGlvbihuYW1lLCBkZWNsYXJhdGlvbiwgb3B0aW9ucywgZ2xvYmFsT3B0aW9ucywgYW5pbWF0aW9uTG9vcCk7XG4gICAgfSxcblxuICAgIC8vIHVwZGF0ZSBhbGwgem9vbS1kZXBlbmRlbnQgbGF5b3V0L3BhaW50IHZhbHVlc1xuICAgIHJlY2FsY3VsYXRlOiBmdW5jdGlvbih6b29tLCB6b29tSGlzdG9yeSkge1xuICAgICAgICBmb3IgKHZhciBwYWludE5hbWUgaW4gdGhpcy5fcGFpbnRUcmFuc2l0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5wYWludFtwYWludE5hbWVdID0gdGhpcy5nZXRQYWludFZhbHVlKHBhaW50TmFtZSwge3pvb206IHpvb20sIHpvb21IaXN0b3J5OiB6b29tSGlzdG9yeX0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGxheW91dE5hbWUgaW4gdGhpcy5fbGF5b3V0RnVuY3Rpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dFtsYXlvdXROYW1lXSA9IHRoaXMuZ2V0TGF5b3V0VmFsdWUobGF5b3V0TmFtZSwge3pvb206IHpvb20sIHpvb21IaXN0b3J5OiB6b29tSGlzdG9yeX0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgb3V0cHV0ID0ge1xuICAgICAgICAgICAgJ2lkJzogdGhpcy5pZCxcbiAgICAgICAgICAgICdyZWYnOiB0aGlzLnJlZixcbiAgICAgICAgICAgICdtZXRhZGF0YSc6IHRoaXMubWV0YWRhdGEsXG4gICAgICAgICAgICAnbWluem9vbSc6IHRoaXMubWluem9vbSxcbiAgICAgICAgICAgICdtYXh6b29tJzogdGhpcy5tYXh6b29tXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIga2xhc3MgaW4gdGhpcy5fcGFpbnREZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrbGFzcyA9PT0gJycgPyAncGFpbnQnIDogJ3BhaW50LicgKyBrbGFzcztcbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gdXRpbC5tYXBPYmplY3QodGhpcy5fcGFpbnREZWNsYXJhdGlvbnNba2xhc3NdLCBnZXREZWNsYXJhdGlvblZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5yZWYgfHwgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbmNsdWRlUmVmUHJvcGVydGllcykpIHtcbiAgICAgICAgICAgIHV0aWwuZXh0ZW5kKG91dHB1dCwge1xuICAgICAgICAgICAgICAgICd0eXBlJzogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgICdzb3VyY2UnOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAnc291cmNlLWxheWVyJzogdGhpcy5zb3VyY2VMYXllcixcbiAgICAgICAgICAgICAgICAnZmlsdGVyJzogdGhpcy5maWx0ZXIsXG4gICAgICAgICAgICAgICAgJ2xheW91dCc6IHV0aWwubWFwT2JqZWN0KHRoaXMuX2xheW91dERlY2xhcmF0aW9ucywgZ2V0RGVjbGFyYXRpb25WYWx1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHV0aWwuZmlsdGVyT2JqZWN0KG91dHB1dCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIShrZXkgPT09ICdsYXlvdXQnICYmICFPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIHNldCBwYWludCB0cmFuc2l0aW9uIGJhc2VkIG9uIGEgZ2l2ZW4gcGFpbnQgZGVjbGFyYXRpb25cbiAgICBfYXBwbHlQYWludERlY2xhcmF0aW9uOiBmdW5jdGlvbiAobmFtZSwgZGVjbGFyYXRpb24sIG9wdGlvbnMsIGdsb2JhbE9wdGlvbnMsIGFuaW1hdGlvbkxvb3ApIHtcbiAgICAgICAgdmFyIG9sZFRyYW5zaXRpb24gPSBvcHRpb25zLnRyYW5zaXRpb24gPyB0aGlzLl9wYWludFRyYW5zaXRpb25zW25hbWVdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChkZWNsYXJhdGlvbiA9PT0gbnVsbCB8fCBkZWNsYXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgc3BlYyA9IHRoaXMuX3BhaW50U3BlY2lmaWNhdGlvbnNbbmFtZV07XG4gICAgICAgICAgICBkZWNsYXJhdGlvbiA9IG5ldyBTdHlsZURlY2xhcmF0aW9uKHNwZWMsIHNwZWMuZGVmYXVsdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2xkVHJhbnNpdGlvbiAmJiBvbGRUcmFuc2l0aW9uLmRlY2xhcmF0aW9uLmpzb24gPT09IGRlY2xhcmF0aW9uLmpzb24pIHJldHVybjtcblxuICAgICAgICB2YXIgdHJhbnNpdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBkdXJhdGlvbjogMzAwLFxuICAgICAgICAgICAgZGVsYXk6IDBcbiAgICAgICAgfSwgZ2xvYmFsT3B0aW9ucywgdGhpcy5nZXRQYWludFByb3BlcnR5KG5hbWUgKyBUUkFOU0lUSU9OX1NVRkZJWCkpO1xuXG4gICAgICAgIHZhciBuZXdUcmFuc2l0aW9uID0gdGhpcy5fcGFpbnRUcmFuc2l0aW9uc1tuYW1lXSA9XG4gICAgICAgICAgICAgICAgbmV3IFN0eWxlVHJhbnNpdGlvbihkZWNsYXJhdGlvbiwgb2xkVHJhbnNpdGlvbiwgdHJhbnNpdGlvbk9wdGlvbnMpO1xuXG4gICAgICAgIGlmICghbmV3VHJhbnNpdGlvbi5pbnN0YW50KCkpIHtcbiAgICAgICAgICAgIG5ld1RyYW5zaXRpb24ubG9vcElEID0gYW5pbWF0aW9uTG9vcC5zZXQobmV3VHJhbnNpdGlvbi5lbmRUaW1lIC0gRGF0ZS5ub3coKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZFRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbkxvb3AuY2FuY2VsKG9sZFRyYW5zaXRpb24ubG9vcElEKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyB1cGRhdGUgbGF5b3V0IHZhbHVlIGlmIGl0J3MgY29uc3RhbnQsIG9yIG1hcmsgaXQgYXMgem9vbS1kZXBlbmRlbnRcbiAgICBfdXBkYXRlTGF5b3V0VmFsdWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5fbGF5b3V0RGVjbGFyYXRpb25zW25hbWVdO1xuXG4gICAgICAgIGlmIChkZWNsYXJhdGlvbiAmJiBkZWNsYXJhdGlvbi5pc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXRGdW5jdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xheW91dEZ1bmN0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0W25hbWVdID0gdGhpcy5nZXRMYXlvdXRWYWx1ZShuYW1lKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfaGFuZGxlRXJyb3JzOiBmdW5jdGlvbih2YWxpZGF0ZSwga2V5LCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVTdHlsZS5lbWl0RXJyb3JzKHRoaXMsIHZhbGlkYXRlLmNhbGwodmFsaWRhdGVTdHlsZSwge1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICBsYXllclR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIG9iamVjdEtleTogbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjLFxuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanMvaXNzdWVzLzI0MDdcbiAgICAgICAgICAgIHN0eWxlOiB7Z2x5cGhzOiB0cnVlLCBzcHJpdGU6IHRydWV9XG4gICAgICAgIH0pKTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25WYWx1ZShkZWNsYXJhdGlvbikge1xuICAgIHJldHVybiBkZWNsYXJhdGlvbi52YWx1ZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcbnZhciBTdHlsZUxheWVyID0gcmVxdWlyZSgnLi4vc3R5bGVfbGF5ZXInKTtcblxuZnVuY3Rpb24gQmFja2dyb3VuZFN0eWxlTGF5ZXIoKSB7XG4gICAgU3R5bGVMYXllci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tncm91bmRTdHlsZUxheWVyO1xuXG5CYWNrZ3JvdW5kU3R5bGVMYXllci5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoU3R5bGVMYXllciwge30pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xudmFyIFN0eWxlTGF5ZXIgPSByZXF1aXJlKCcuLi9zdHlsZV9sYXllcicpO1xuXG5mdW5jdGlvbiBDaXJjbGVTdHlsZUxheWVyKCkge1xuICAgIFN0eWxlTGF5ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDaXJjbGVTdHlsZUxheWVyO1xuXG5DaXJjbGVTdHlsZUxheWVyLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChTdHlsZUxheWVyLCB7fSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgU3R5bGVMYXllciA9IHJlcXVpcmUoJy4uL3N0eWxlX2xheWVyJyk7XG5cbmZ1bmN0aW9uIEZpbGxTdHlsZUxheWVyKCkge1xuICAgIFN0eWxlTGF5ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGaWxsU3R5bGVMYXllcjtcblxuRmlsbFN0eWxlTGF5ZXIucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KFN0eWxlTGF5ZXIsIHt9KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcbnZhciBTdHlsZUxheWVyID0gcmVxdWlyZSgnLi4vc3R5bGVfbGF5ZXInKTtcblxuZnVuY3Rpb24gTGluZVN0eWxlTGF5ZXIoKSB7XG4gICAgU3R5bGVMYXllci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVTdHlsZUxheWVyO1xuXG5MaW5lU3R5bGVMYXllci5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoU3R5bGVMYXllciwge1xuXG4gICAgZ2V0UGFpbnRWYWx1ZTogZnVuY3Rpb24obmFtZSwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gU3R5bGVMYXllci5wcm90b3R5cGUuZ2V0UGFpbnRWYWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIC8vIElmIHRoZSBsaW5lIGlzIGRhc2hlZCwgc2NhbGUgdGhlIGRhc2ggbGVuZ3RocyBieSB0aGUgbGluZVxuICAgICAgICAvLyB3aWR0aCBhdCB0aGUgcHJldmlvdXMgcm91bmQgem9vbSBsZXZlbC5cbiAgICAgICAgaWYgKHZhbHVlICYmIG5hbWUgPT09ICdsaW5lLWRhc2hhcnJheScpIHtcbiAgICAgICAgICAgIHZhciBmbG9vcmVkWm9vbSA9IE1hdGguZmxvb3IoZ2xvYmFsUHJvcGVydGllcy56b29tKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9mbG9vcmVkWm9vbSAhPT0gZmxvb3JlZFpvb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mbG9vcmVkWm9vbSA9IGZsb29yZWRab29tO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Zsb29yZWRMaW5lV2lkdGggPSB0aGlzLmdldFBhaW50VmFsdWUoJ2xpbmUtd2lkdGgnLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlLmZyb21TY2FsZSAqPSB0aGlzLl9mbG9vcmVkTGluZVdpZHRoO1xuICAgICAgICAgICAgdmFsdWUudG9TY2FsZSAqPSB0aGlzLl9mbG9vcmVkTGluZVdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xudmFyIFN0eWxlTGF5ZXIgPSByZXF1aXJlKCcuLi9zdHlsZV9sYXllcicpO1xuXG5mdW5jdGlvbiBSYXN0ZXJTdHlsZUxheWVyKCkge1xuICAgIFN0eWxlTGF5ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSYXN0ZXJTdHlsZUxheWVyO1xuXG5SYXN0ZXJTdHlsZUxheWVyLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChTdHlsZUxheWVyLCB7fSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgU3R5bGVMYXllciA9IHJlcXVpcmUoJy4uL3N0eWxlX2xheWVyJyk7XG5cbmZ1bmN0aW9uIFN5bWJvbFN0eWxlTGF5ZXIoKSB7XG4gICAgU3R5bGVMYXllci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbFN0eWxlTGF5ZXI7XG5cblN5bWJvbFN0eWxlTGF5ZXIucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KFN0eWxlTGF5ZXIsIHtcblxuICAgIGlzSGlkZGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKFN0eWxlTGF5ZXIucHJvdG90eXBlLmlzSGlkZGVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybiB0cnVlO1xuXG4gICAgICAgIHZhciBpc1RleHRIaWRkZW4gPSB0aGlzLnBhaW50Wyd0ZXh0LW9wYWNpdHknXSA9PT0gMCB8fCAhdGhpcy5sYXlvdXRbJ3RleHQtZmllbGQnXTtcbiAgICAgICAgdmFyIGlzSWNvbkhpZGRlbiA9IHRoaXMucGFpbnRbJ2ljb24tb3BhY2l0eSddID09PSAwIHx8ICF0aGlzLmxheW91dFsnaWNvbi1pbWFnZSddO1xuICAgICAgICBpZiAoaXNUZXh0SGlkZGVuICYmIGlzSWNvbkhpZGRlbikgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBnZXRMYXlvdXRWYWx1ZTogZnVuY3Rpb24obmFtZSwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICd0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmdldExheW91dFZhbHVlKCdzeW1ib2wtcGxhY2VtZW50JywgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpID09PSAnbGluZScgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5nZXRMYXlvdXRQcm9wZXJ0eSgndGV4dC1yb3RhdGlvbi1hbGlnbm1lbnQnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdtYXAnO1xuICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdpY29uLXJvdGF0aW9uLWFsaWdubWVudCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmdldExheW91dFZhbHVlKCdzeW1ib2wtcGxhY2VtZW50JywgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpID09PSAnbGluZScgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5nZXRMYXlvdXRQcm9wZXJ0eSgnaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnQnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdtYXAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFN0eWxlTGF5ZXIucHJvdG90eXBlLmdldExheW91dFZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ21hcGJveC1nbC1zdHlsZS1zcGVjL3JlZmVyZW5jZS9sYXRlc3QnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBpbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4uL3V0aWwvaW50ZXJwb2xhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHlsZVRyYW5zaXRpb247XG5cbi8qXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNpdGlvbiBiZXR3ZWVuIHR3byBkZWNsYXJhdGlvbnNcbiAqL1xuZnVuY3Rpb24gU3R5bGVUcmFuc2l0aW9uKGRlY2xhcmF0aW9uLCBvbGRUcmFuc2l0aW9uLCB2YWx1ZSkge1xuXG4gICAgdGhpcy5kZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gdGhpcy5lbmRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgIHZhciB0eXBlID0gZGVjbGFyYXRpb24udHlwZTtcbiAgICBpZiAoKHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdhcnJheScpICYmIGRlY2xhcmF0aW9uLnRyYW5zaXRpb25hYmxlKSB7XG4gICAgICAgIHRoaXMuaW50ZXJwID0gaW50ZXJwWm9vbVRyYW5zaXRpb25lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmludGVycCA9IGludGVycG9sYXRlW3R5cGVdO1xuICAgIH1cblxuICAgIHRoaXMub2xkVHJhbnNpdGlvbiA9IG9sZFRyYW5zaXRpb247XG4gICAgdGhpcy5kdXJhdGlvbiA9IHZhbHVlLmR1cmF0aW9uIHx8IDA7XG4gICAgdGhpcy5kZWxheSA9IHZhbHVlLmRlbGF5IHx8IDA7XG5cbiAgICBpZiAoIXRoaXMuaW5zdGFudCgpKSB7XG4gICAgICAgIHRoaXMuZW5kVGltZSA9IHRoaXMuc3RhcnRUaW1lICsgdGhpcy5kdXJhdGlvbiArIHRoaXMuZGVsYXk7XG4gICAgICAgIHRoaXMuZWFzZSA9IHV0aWwuZWFzZUN1YmljSW5PdXQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZFRyYW5zaXRpb24gJiYgb2xkVHJhbnNpdGlvbi5lbmRUaW1lIDw9IHRoaXMuc3RhcnRUaW1lKSB7XG4gICAgICAgIC8vIE9sZCB0cmFuc2l0aW9uIGlzIGRvbmUgcnVubmluZywgc28gd2UgY2FuXG4gICAgICAgIC8vIGRlbGV0ZSBpdHMgcmVmZXJlbmNlIHRvIGl0cyBvbGQgdHJhbnNpdGlvbi5cblxuICAgICAgICBkZWxldGUgb2xkVHJhbnNpdGlvbi5vbGRUcmFuc2l0aW9uO1xuICAgIH1cbn1cblxuU3R5bGVUcmFuc2l0aW9uLnByb3RvdHlwZS5pbnN0YW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLm9sZFRyYW5zaXRpb24gfHwgIXRoaXMuaW50ZXJwIHx8ICh0aGlzLmR1cmF0aW9uID09PSAwICYmIHRoaXMuZGVsYXkgPT09IDApO1xufTtcblxuLypcbiAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHRyYW5zaXRpb25pbmcgcHJvcGVydHkgYXQgem9vbSBsZXZlbCBgemAgYW5kIG9wdGlvbmFsIHRpbWUgYHRgXG4gKi9cblN0eWxlVHJhbnNpdGlvbi5wcm90b3R5cGUuY2FsY3VsYXRlID0gZnVuY3Rpb24oZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmRlY2xhcmF0aW9uLmNhbGN1bGF0ZShcbiAgICAgICAgdXRpbC5leHRlbmQoe30sIGdsb2JhbFByb3BlcnRpZXMsIHtkdXJhdGlvbjogdGhpcy5kdXJhdGlvbn0pLFxuICAgICAgICBmZWF0dXJlUHJvcGVydGllc1xuICAgICk7XG5cbiAgICBpZiAodGhpcy5pbnN0YW50KCkpIHJldHVybiB2YWx1ZTtcblxuICAgIHZhciB0ID0gZ2xvYmFsUHJvcGVydGllcy50aW1lIHx8IERhdGUubm93KCk7XG5cbiAgICBpZiAodCA8IHRoaXMuZW5kVGltZSkge1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm9sZFRyYW5zaXRpb24uY2FsY3VsYXRlKFxuICAgICAgICAgICAgdXRpbC5leHRlbmQoe30sIGdsb2JhbFByb3BlcnRpZXMsIHt0aW1lOiB0aGlzLnN0YXJ0VGltZX0pLFxuICAgICAgICAgICAgZmVhdHVyZVByb3BlcnRpZXNcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIGVhc2VkID0gdGhpcy5lYXNlKCh0IC0gdGhpcy5zdGFydFRpbWUgLSB0aGlzLmRlbGF5KSAvIHRoaXMuZHVyYXRpb24pO1xuICAgICAgICB2YWx1ZSA9IHRoaXMuaW50ZXJwKG9sZFZhbHVlLCB2YWx1ZSwgZWFzZWQpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcblxufTtcblxuZnVuY3Rpb24gaW50ZXJwWm9vbVRyYW5zaXRpb25lZChmcm9tLCB0bywgdCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb206IGZyb20udG8sXG4gICAgICAgIGZyb21TY2FsZTogZnJvbS50b1NjYWxlLFxuICAgICAgICB0bzogdG8udG8sXG4gICAgICAgIHRvU2NhbGU6IHRvLnRvU2NhbGUsXG4gICAgICAgIHQ6IHRcbiAgICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZV9zdHlsZS5taW4nKTtcblxubW9kdWxlLmV4cG9ydHMuZW1pdEVycm9ycyA9IGZ1bmN0aW9uIHRocm93RXJyb3JzKGVtaXR0ZXIsIGVycm9ycykge1xuICAgIGlmIChlcnJvcnMgJiYgZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZW1pdHRlci5maXJlKCdlcnJvcicsIHsgZXJyb3I6IG5ldyBFcnJvcihlcnJvcnNbaV0ubWVzc2FnZSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLnRocm93RXJyb3JzID0gZnVuY3Rpb24gdGhyb3dFcnJvcnMoZW1pdHRlciwgZXJyb3JzKSB7XG4gICAgaWYgKGVycm9ycykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yc1tpXS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQW5jaG9yO1xuXG5mdW5jdGlvbiBBbmNob3IoeCwgeSwgYW5nbGUsIHNlZ21lbnQpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy5hbmdsZSA9IGFuZ2xlO1xuXG4gICAgaWYgKHNlZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNlZ21lbnQgPSBzZWdtZW50O1xuICAgIH1cbn1cblxuQW5jaG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUG9pbnQucHJvdG90eXBlKTtcblxuQW5jaG9yLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgQW5jaG9yKHRoaXMueCwgdGhpcy55LCB0aGlzLmFuZ2xlLCB0aGlzLnNlZ21lbnQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja01heEFuZ2xlO1xuXG4vKipcbiAqIExhYmVscyBwbGFjZWQgYXJvdW5kIHJlYWxseSBzaGFycCBhbmdsZXMgYXJlbid0IHJlYWRhYmxlLiBDaGVjayBpZiBhbnlcbiAqIHBhcnQgb2YgdGhlIHBvdGVudGlhbCBsYWJlbCBoYXMgYSBjb21iaW5lZCBhbmdsZSB0aGF0IGlzIHRvbyBiaWcuXG4gKlxuICogQHBhcmFtIHtBcnJheTxQb2ludD59IGxpbmVcbiAqIEBwYXJhbSB7QW5jaG9yfSBhbmNob3IgVGhlIHBvaW50IG9uIHRoZSBsaW5lIGFyb3VuZCB3aGljaCB0aGUgbGFiZWwgaXMgYW5jaG9yZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbGFiZWxMZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgbGFiZWwgaW4gZ2VvbWV0cnkgdW5pdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gd2luZG93U2l6ZSBUaGUgY2hlY2sgZmFpbHMgaWYgdGhlIGNvbWJpbmVkIGFuZ2xlcyB3aXRoaW4gYSBwYXJ0IG9mIHRoZSBsaW5lIHRoYXQgaXMgYHdpbmRvd1NpemVgIGxvbmcgaXMgdG9vIGJpZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhBbmdsZSBUaGUgbWF4aW11bSBjb21iaW5lZCBhbmdsZSB0aGF0IGFueSB3aW5kb3cgYWxvbmcgdGhlIGxhYmVsIGlzIGFsbG93ZWQgdG8gaGF2ZS5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgbGFiZWwgc2hvdWxkIGJlIHBsYWNlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tNYXhBbmdsZShsaW5lLCBhbmNob3IsIGxhYmVsTGVuZ3RoLCB3aW5kb3dTaXplLCBtYXhBbmdsZSkge1xuXG4gICAgLy8gaG9yaXpvbnRhbCBsYWJlbHMgYWx3YXlzIHBhc3NcbiAgICBpZiAoYW5jaG9yLnNlZ21lbnQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7XG5cbiAgICB2YXIgcCA9IGFuY2hvcjtcbiAgICB2YXIgaW5kZXggPSBhbmNob3Iuc2VnbWVudCArIDE7XG4gICAgdmFyIGFuY2hvckRpc3RhbmNlID0gMDtcblxuICAgIC8vIG1vdmUgYmFja3dhcmRzIGFsb25nIHRoZSBsaW5lIHRvIHRoZSBmaXJzdCBzZWdtZW50IHRoZSBsYWJlbCBhcHBlYXJzIG9uXG4gICAgd2hpbGUgKGFuY2hvckRpc3RhbmNlID4gLWxhYmVsTGVuZ3RoIC8gMikge1xuICAgICAgICBpbmRleC0tO1xuXG4gICAgICAgIC8vIHRoZXJlIGlzbid0IGVub3VnaCByb29tIGZvciB0aGUgbGFiZWwgYWZ0ZXIgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZVxuICAgICAgICBpZiAoaW5kZXggPCAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgYW5jaG9yRGlzdGFuY2UgLT0gbGluZVtpbmRleF0uZGlzdChwKTtcbiAgICAgICAgcCA9IGxpbmVbaW5kZXhdO1xuICAgIH1cblxuICAgIGFuY2hvckRpc3RhbmNlICs9IGxpbmVbaW5kZXhdLmRpc3QobGluZVtpbmRleCArIDFdKTtcbiAgICBpbmRleCsrO1xuXG4gICAgLy8gc3RvcmUgcmVjZW50IGNvcm5lcnMgYW5kIHRoZWlyIHRvdGFsIGFuZ2xlIGRpZmZlcmVuY2VcbiAgICB2YXIgcmVjZW50Q29ybmVycyA9IFtdO1xuICAgIHZhciByZWNlbnRBbmdsZURlbHRhID0gMDtcblxuICAgIC8vIG1vdmUgZm9yd2FyZHMgYnkgdGhlIGxlbmd0aCBvZiB0aGUgbGFiZWwgYW5kIGNoZWNrIGFuZ2xlcyBhbG9uZyB0aGUgd2F5XG4gICAgd2hpbGUgKGFuY2hvckRpc3RhbmNlIDwgbGFiZWxMZW5ndGggLyAyKSB7XG4gICAgICAgIHZhciBwcmV2ID0gbGluZVtpbmRleCAtIDFdO1xuICAgICAgICB2YXIgY3VycmVudCA9IGxpbmVbaW5kZXhdO1xuICAgICAgICB2YXIgbmV4dCA9IGxpbmVbaW5kZXggKyAxXTtcblxuICAgICAgICAvLyB0aGVyZSBpc24ndCBlbm91Z2ggcm9vbSBmb3IgdGhlIGxhYmVsIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSBsaW5lXG4gICAgICAgIGlmICghbmV4dCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciBhbmdsZURlbHRhID0gcHJldi5hbmdsZVRvKGN1cnJlbnQpIC0gY3VycmVudC5hbmdsZVRvKG5leHQpO1xuICAgICAgICAvLyByZXN0cmljdCBhbmdsZSB0byAtcGkuLnBpIHJhbmdlXG4gICAgICAgIGFuZ2xlRGVsdGEgPSBNYXRoLmFicygoKGFuZ2xlRGVsdGEgKyAzICogTWF0aC5QSSkgJSAoTWF0aC5QSSAqIDIpKSAtIE1hdGguUEkpO1xuXG4gICAgICAgIHJlY2VudENvcm5lcnMucHVzaCh7XG4gICAgICAgICAgICBkaXN0YW5jZTogYW5jaG9yRGlzdGFuY2UsXG4gICAgICAgICAgICBhbmdsZURlbHRhOiBhbmdsZURlbHRhXG4gICAgICAgIH0pO1xuICAgICAgICByZWNlbnRBbmdsZURlbHRhICs9IGFuZ2xlRGVsdGE7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGNvcm5lcnMgdGhhdCBhcmUgZmFyIGVub3VnaCBhd2F5IGZyb20gdGhlIGxpc3Qgb2YgcmVjZW50IGFuY2hvcnNcbiAgICAgICAgd2hpbGUgKGFuY2hvckRpc3RhbmNlIC0gcmVjZW50Q29ybmVyc1swXS5kaXN0YW5jZSA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHJlY2VudEFuZ2xlRGVsdGEgLT0gcmVjZW50Q29ybmVycy5zaGlmdCgpLmFuZ2xlRGVsdGE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgc3VtIG9mIGFuZ2xlcyB3aXRoaW4gdGhlIHdpbmRvdyBhcmVhIGV4Y2VlZHMgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZS4gY2hlY2sgZmFpbHMuXG4gICAgICAgIGlmIChyZWNlbnRBbmdsZURlbHRhID4gbWF4QW5nbGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpbmRleCsrO1xuICAgICAgICBhbmNob3JEaXN0YW5jZSArPSBjdXJyZW50LmRpc3QobmV4dCk7XG4gICAgfVxuXG4gICAgLy8gbm8gcGFydCBvZiB0aGUgbGluZSBoYWQgYW4gYW5nbGUgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQuIGNoZWNrIHBhc3Nlcy5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGlwTGluZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJ0IG9mIGEgbXVsdGlsaW5lIHRoYXQgaW50ZXJzZWN0cyB3aXRoIHRoZSBwcm92aWRlZCByZWN0YW5ndWxhciBib3guXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxQb2ludD4+fSBsaW5lc1xuICogQHBhcmFtIHtudW1iZXJ9IHgxIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGJveFxuICogQHBhcmFtIHtudW1iZXJ9IHkxIHRoZSB0b3AgZWRnZSBvZiB0aGUgYm94XG4gKiBAcGFyYW0ge251bWJlcn0geDIgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGJveFxuICogQHBhcmFtIHtudW1iZXJ9IHkyIHRoZSBib3R0b20gZWRnZSBvZiB0aGUgYm94XG4gKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8UG9pbnQ+Pn0gbGluZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsaXBMaW5lKGxpbmVzLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIHZhciBjbGlwcGVkTGluZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGluZXMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tsXTtcbiAgICAgICAgdmFyIGNsaXBwZWRMaW5lO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwMCA9IGxpbmVbaV07XG4gICAgICAgICAgICB2YXIgcDEgPSBsaW5lW2kgKyAxXTtcblxuXG4gICAgICAgICAgICBpZiAocDAueCA8IHgxICYmIHAxLnggPCB4MSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwMC54IDwgeDEpIHtcbiAgICAgICAgICAgICAgICBwMCA9IG5ldyBQb2ludCh4MSwgcDAueSArIChwMS55IC0gcDAueSkgKiAoKHgxIC0gcDAueCkgLyAocDEueCAtIHAwLngpKSkuX3JvdW5kKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAxLnggPCB4MSkge1xuICAgICAgICAgICAgICAgIHAxID0gbmV3IFBvaW50KHgxLCBwMC55ICsgKHAxLnkgLSBwMC55KSAqICgoeDEgLSBwMC54KSAvIChwMS54IC0gcDAueCkpKS5fcm91bmQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHAwLnkgPCB5MSAmJiBwMS55IDwgeTEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocDAueSA8IHkxKSB7XG4gICAgICAgICAgICAgICAgcDAgPSBuZXcgUG9pbnQocDAueCArIChwMS54IC0gcDAueCkgKiAoKHkxIC0gcDAueSkgLyAocDEueSAtIHAwLnkpKSwgeTEpLl9yb3VuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwMS55IDwgeTEpIHtcbiAgICAgICAgICAgICAgICBwMSA9IG5ldyBQb2ludChwMC54ICsgKHAxLnggLSBwMC54KSAqICgoeTEgLSBwMC55KSAvIChwMS55IC0gcDAueSkpLCB5MSkuX3JvdW5kKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwMC54ID49IHgyICYmIHAxLnggPj0geDIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocDAueCA+PSB4Mikge1xuICAgICAgICAgICAgICAgIHAwID0gbmV3IFBvaW50KHgyLCBwMC55ICsgKHAxLnkgLSBwMC55KSAqICgoeDIgLSBwMC54KSAvIChwMS54IC0gcDAueCkpKS5fcm91bmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocDEueCA+PSB4Mikge1xuICAgICAgICAgICAgICAgIHAxID0gbmV3IFBvaW50KHgyLCBwMC55ICsgKHAxLnkgLSBwMC55KSAqICgoeDIgLSBwMC54KSAvIChwMS54IC0gcDAueCkpKS5fcm91bmQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHAwLnkgPj0geTIgJiYgcDEueSA+PSB5Mikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwMC55ID49IHkyKSB7XG4gICAgICAgICAgICAgICAgcDAgPSBuZXcgUG9pbnQocDAueCArIChwMS54IC0gcDAueCkgKiAoKHkyIC0gcDAueSkgLyAocDEueSAtIHAwLnkpKSwgeTIpLl9yb3VuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwMS55ID49IHkyKSB7XG4gICAgICAgICAgICAgICAgcDEgPSBuZXcgUG9pbnQocDAueCArIChwMS54IC0gcDAueCkgKiAoKHkyIC0gcDAueSkgLyAocDEueSAtIHAwLnkpKSwgeTIpLl9yb3VuZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNsaXBwZWRMaW5lIHx8ICFwMC5lcXVhbHMoY2xpcHBlZExpbmVbY2xpcHBlZExpbmUubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgY2xpcHBlZExpbmUgPSBbcDBdO1xuICAgICAgICAgICAgICAgIGNsaXBwZWRMaW5lcy5wdXNoKGNsaXBwZWRMaW5lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xpcHBlZExpbmUucHVzaChwMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xpcHBlZExpbmVzO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RydWN0QXJyYXlUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9zdHJ1Y3RfYXJyYXknKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG4vKipcbiAqIEEgY29sbGlzaW9uIGJveCByZXByZXNlbnRzIGFuIGFyZWEgb2YgdGhlIG1hcCB0aGF0IHRoYXQgaXMgY292ZXJlZCBieSBhXG4gKiBsYWJlbC4gQ29sbGlzaW9uRmVhdHVyZSB1c2VzIG9uZSBvciBtb3JlIG9mIHRoZXNlIGNvbGxpc2lvbiBib3hlcyB0b1xuICogcmVwcmVzZW50IGFsbCB0aGUgYXJlYSBjb3ZlcmVkIGJ5IGEgc2luZ2xlIGxhYmVsLiBUaGV5IGFyZSB1c2VkIHRvXG4gKiBwcmV2ZW50IGNvbGxpc2lvbnMgYmV0d2VlbiBsYWJlbHMuXG4gKlxuICogQSBjb2xsaXNpb24gYm94IGFjdHVhbGx5IHJlcHJlc2VudHMgYSAzZCB2b2x1bWUuIFRoZSBmaXJzdCB0d28gZGltZW5zaW9ucyxcbiAqIHggYW5kIHksIGFyZSBzcGVjaWZpZWQgd2l0aCBgYW5jaG9yYCBhbG9uZyB3aXRoIGB4MWAsIGB5MWAsIGB4MmAsIGB5MmAuXG4gKiBUaGUgdGhpcmQgZGltZW5zaW9uLCB6b29tLCBpcyBsaW1pdGVkIGJ5IGBtYXhTY2FsZWAgd2hpY2ggZGV0ZXJtaW5lc1xuICogaG93IGZhciBpbiB0aGUgeiBkaW1lbnNpb25zIHRoZSBib3ggZXh0ZW5kcy5cbiAqXG4gKiBBcyB5b3Ugem9vbSBpbiBvbiBhIG1hcCwgYWxsIHBvaW50cyBvbiB0aGUgbWFwIGdldCBmdXJ0aGVyIGFuZCBmdXJ0aGVyIGFwYXJ0XG4gKiBidXQgbGFiZWxzIHN0YXkgcm91Z2hseSB0aGUgc2FtZSBzaXplLiBMYWJlbHMgY292ZXIgbGVzcyByZWFsIHdvcmxkIGFyZWEgb25cbiAqIHRoZSBtYXAgYXQgaGlnaGVyIHpvb20gbGV2ZWxzIHRoYW4gdGhleSBkbyBhdCBsb3dlciB6b29tIGxldmVscy4gVGhpcyBpcyB3aHlcbiAqIGFyZWFzIGFyZSBhcmUgcmVwcmVzZW50ZWQgd2l0aCBhbiBhbmNob3IgcG9pbnQgYW5kIG9mZnNldHMgZnJvbSB0aGF0IHBvaW50XG4gKiBpbnN0ZWFkIG9mIGp1c3QgdXNpbmcgZm91ciBhYnNvbHV0ZSBwb2ludHMuXG4gKlxuICogTGluZSBsYWJlbHMgYXJlIHJlcHJlc2VudGVkIGJ5IGEgc2V0IG9mIHRoZXNlIGJveGVzIHNwYWNlZCBvdXQgYWxvbmcgYSBsaW5lLlxuICogV2hlbiB5b3Ugem9vbSBpbiwgbGluZSBsYWJlbHMgY292ZXIgbGVzcyByZWFsIHdvcmxkIGRpc3RhbmNlIGFsb25nIHRoZSBsaW5lXG4gKiB0aGFuIHRoZXkgdXNlZCB0by4gQ29sbGlzaW9uIGJveGVzIG5lYXIgdGhlIGVkZ2VzIHRoYXQgdXNlZCB0byBjb3ZlciBsYWJlbFxuICogbm8gbG9uZ2VyIGRvLiBJZiBhIGJveCBkb2Vzbid0IGNvdmVyIHRoZSBsYWJlbCBhbnltb3JlIGl0IHNob3VsZCBiZSBpZ25vcmVkXG4gKiB3aGVuIGRvaW5nIGNvbGxpc2lvbiBjaGVja3MuIGBtYXhTY2FsZWAgaXMgaG93IG11Y2ggeW91IGNhbiBzY2FsZSB0aGUgbWFwXG4gKiBiZWZvcmUgdGhlIGxhYmVsIGlzbid0IHdpdGhpbiB0aGUgYm94IGFueW1vcmUuXG4gKiBGb3IgZXhhbXBsZVxuICogbG93ZXIgem9vbTpcbiAqIGh0dHBzOi8vY2xvdWQuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fzc2V0cy8xNDIxNjUyLzgwNjAwOTQvNGQ5NzVmNzYtMGU5MS0xMWU1LTg0YjEtNGVkZWIzMGE1ODc1LnBuZ1xuICogc2xpZ2h0bHkgaGlnaGVyIHpvb206XG4gKiBodHRwczovL2Nsb3VkLmdpdGh1YnVzZXJjb250ZW50LmNvbS9hc3NldHMvMTQyMTY1Mi84MDYwMDYxLzI2YWUxYzM4LTBlOTEtMTFlNS04YzVhLTlmMzgwYmYyOWYwYS5wbmdcbiAqIEluIHRoZSB6b29tZWQgaW4gaW1hZ2UgdGhlIHR3byBncmV5IGJveGVzIG9uIGVpdGhlciBzaWRlIGRvbid0IGNvdmVyIHRoZVxuICogbGFiZWwgYW55bW9yZS4gVGhlaXIgbWF4U2NhbGUgaXMgc21hbGxlciB0aGFuIHRoZSBjdXJyZW50IHNjYWxlLlxuICpcbiAqXG4gKiBAY2xhc3MgQ29sbGlzaW9uQm94QXJyYXlcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIENvbGxpc2lvbkJveEFycmF5ID0gbW9kdWxlLmV4cG9ydHMgPSBuZXcgU3RydWN0QXJyYXlUeXBlKHtcbiAgICBtZW1iZXJzOiBbXG4gICAgICAgIC8vIHRoZSBib3ggaXMgY2VudGVyZWQgYXJvdW5kIHRoZSBhbmNob3IgcG9pbnRcbiAgICAgICAgeyB0eXBlOiAnSW50MTYnLCBuYW1lOiAnYW5jaG9yUG9pbnRYJyB9LFxuICAgICAgICB7IHR5cGU6ICdJbnQxNicsIG5hbWU6ICdhbmNob3JQb2ludFknIH0sXG5cbiAgICAgICAgLy8gZGlzdGFuY2VzIHRvIHRoZSBlZGdlcyBmcm9tIHRoZSBhbmNob3JcbiAgICAgICAgeyB0eXBlOiAnSW50MTYnLCBuYW1lOiAneDEnIH0sXG4gICAgICAgIHsgdHlwZTogJ0ludDE2JywgbmFtZTogJ3kxJyB9LFxuICAgICAgICB7IHR5cGU6ICdJbnQxNicsIG5hbWU6ICd4MicgfSxcbiAgICAgICAgeyB0eXBlOiAnSW50MTYnLCBuYW1lOiAneTInIH0sXG5cbiAgICAgICAgLy8gdGhlIGJveCBpcyBvbmx5IHZhbGlkIGZvciBzY2FsZXMgPCBtYXhTY2FsZS5cbiAgICAgICAgLy8gVGhlIGJveCBkb2VzIG5vdCBibG9jayBvdGhlciBib3hlcyBhdCBzY2FsZXMgPj0gbWF4U2NhbGU7XG4gICAgICAgIHsgdHlwZTogJ0Zsb2F0MzInLCBuYW1lOiAnbWF4U2NhbGUnIH0sXG5cbiAgICAgICAgLy8gdGhlIGluZGV4IG9mIHRoZSBmZWF0dXJlIGluIHRoZSBvcmlnaW5hbCB2ZWN0b3J0aWxlXG4gICAgICAgIHsgdHlwZTogJ1VpbnQzMicsIG5hbWU6ICdmZWF0dXJlSW5kZXgnIH0sXG4gICAgICAgIC8vIHRoZSBzb3VyY2UgbGF5ZXIgdGhlIGZlYXR1cmUgYXBwZWFycyBpblxuICAgICAgICB7IHR5cGU6ICdVaW50MTYnLCBuYW1lOiAnc291cmNlTGF5ZXJJbmRleCcgfSxcbiAgICAgICAgLy8gdGhlIGJ1Y2tldCB0aGUgZmVhdHVyZSBhcHBlYXJzIGluXG4gICAgICAgIHsgdHlwZTogJ1VpbnQxNicsIG5hbWU6ICdidWNrZXRJbmRleCcgfSxcblxuICAgICAgICAvLyByb3RhdGVkIGFuZCBzY2FsZWQgYmJveCB1c2VkIGZvciBpbmRleGluZ1xuICAgICAgICB7IHR5cGU6ICdJbnQxNicsIG5hbWU6ICdiYm94MCcgfSxcbiAgICAgICAgeyB0eXBlOiAnSW50MTYnLCBuYW1lOiAnYmJveDEnIH0sXG4gICAgICAgIHsgdHlwZTogJ0ludDE2JywgbmFtZTogJ2Jib3gyJyB9LFxuICAgICAgICB7IHR5cGU6ICdJbnQxNicsIG5hbWU6ICdiYm94MycgfSxcblxuICAgICAgICB7IHR5cGU6ICdGbG9hdDMyJywgbmFtZTogJ3BsYWNlbWVudFNjYWxlJyB9XG4gICAgXX0pO1xuXG51dGlsLmV4dGVuZEFsbChDb2xsaXNpb25Cb3hBcnJheS5wcm90b3R5cGUuU3RydWN0VHlwZS5wcm90b3R5cGUsIHtcbiAgICBnZXQgYW5jaG9yUG9pbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5hbmNob3JQb2ludFgsIHRoaXMuYW5jaG9yUG9pbnRZKTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsaXNpb25GZWF0dXJlO1xuXG4vKipcbiAqIEEgQ29sbGlzaW9uRmVhdHVyZSByZXByZXNlbnRzIHRoZSBhcmVhIG9mIHRoZSB0aWxlIGNvdmVyZWQgYnkgYSBzaW5nbGUgbGFiZWwuXG4gKiBJdCBpcyB1c2VkIHdpdGggQ29sbGlzaW9uVGlsZSB0byBjaGVjayBpZiB0aGUgbGFiZWwgb3ZlcmxhcHMgd2l0aCBhbnlcbiAqIHByZXZpb3VzIGxhYmVscy4gQSBDb2xsaXNpb25GZWF0dXJlIGlzIG1vc3RseSBqdXN0IGEgc2V0IG9mIENvbGxpc2lvbkJveFxuICogb2JqZWN0cy5cbiAqXG4gKiBAY2xhc3MgQ29sbGlzaW9uRmVhdHVyZVxuICogQHBhcmFtIHtBcnJheTxQb2ludD59IGxpbmUgVGhlIGdlb21ldHJ5IHRoZSBsYWJlbCBpcyBwbGFjZWQgb24uXG4gKiBAcGFyYW0ge0FuY2hvcn0gYW5jaG9yIFRoZSBwb2ludCBhbG9uZyB0aGUgbGluZSBhcm91bmQgd2hpY2ggdGhlIGxhYmVsIGlzIGFuY2hvcmVkLlxuICogQHBhcmFtIHtWZWN0b3JUaWxlRmVhdHVyZX0gZmVhdHVyZSBUaGUgVmVjdG9yVGlsZUZlYXR1cmUgdGhhdCB0aGlzIENvbGxpc2lvbkZlYXR1cmUgd2FzIGNyZWF0ZWQgZm9yLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBsYXllcklEcyBUaGUgSURzIG9mIHRoZSBsYXllcnMgdGhhdCB0aGlzIENvbGxpc2lvbkZlYXR1cmUgaXMgYSBwYXJ0IG9mLlxuICogQHBhcmFtIHtPYmplY3R9IHNoYXBlZCBUaGUgdGV4dCBvciBpY29uIHNoYXBpbmcgcmVzdWx0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3hTY2FsZSBBIG1hZ2ljIG51bWJlciB1c2VkIHRvIGNvbnZlcnQgZnJvbSBnbHlwaCBtZXRyaWNzIHVuaXRzIHRvIGdlb21ldHJ5IHVuaXRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmcgVGhlIGFtb3VudCBvZiBwYWRkaW5nIHRvIGFkZCBhcm91bmQgdGhlIGxhYmVsIGVkZ2VzLlxuICogQHBhcmFtIHtib29sZWFufSBhbGlnbkxpbmUgV2hldGhlciB0aGUgbGFiZWwgaXMgYWxpZ25lZCB3aXRoIHRoZSBsaW5lIG9yIHRoZSB2aWV3cG9ydC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBDb2xsaXNpb25GZWF0dXJlKGNvbGxpc2lvbkJveEFycmF5LCBsaW5lLCBhbmNob3IsIGZlYXR1cmVJbmRleCwgc291cmNlTGF5ZXJJbmRleCwgYnVja2V0SW5kZXgsIHNoYXBlZCwgYm94U2NhbGUsIHBhZGRpbmcsIGFsaWduTGluZSwgc3RyYWlnaHQpIHtcblxuICAgIHZhciB5MSA9IHNoYXBlZC50b3AgKiBib3hTY2FsZSAtIHBhZGRpbmc7XG4gICAgdmFyIHkyID0gc2hhcGVkLmJvdHRvbSAqIGJveFNjYWxlICsgcGFkZGluZztcbiAgICB2YXIgeDEgPSBzaGFwZWQubGVmdCAqIGJveFNjYWxlIC0gcGFkZGluZztcbiAgICB2YXIgeDIgPSBzaGFwZWQucmlnaHQgKiBib3hTY2FsZSArIHBhZGRpbmc7XG5cbiAgICB0aGlzLmJveFN0YXJ0SW5kZXggPSBjb2xsaXNpb25Cb3hBcnJheS5sZW5ndGg7XG5cbiAgICBpZiAoYWxpZ25MaW5lKSB7XG5cbiAgICAgICAgdmFyIGhlaWdodCA9IHkyIC0geTE7XG4gICAgICAgIHZhciBsZW5ndGggPSB4MiAtIHgxO1xuXG4gICAgICAgIGlmIChoZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAvLyBzZXQgbWluaW11bSBib3ggaGVpZ2h0IHRvIGF2b2lkIHZlcnkgbWFueSBzbWFsbCBsYWJlbHNcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGgubWF4KDEwICogYm94U2NhbGUsIGhlaWdodCk7XG5cbiAgICAgICAgICAgIGlmIChzdHJhaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIHVzZWQgZm9yIGljb24gbGFiZWxzIHRoYXQgYXJlIGFsaWduZWQgd2l0aCB0aGUgbGluZSwgYnV0IGRvbid0IGN1cnZlIGFsb25nIGl0XG4gICAgICAgICAgICAgICAgdmFyIHZlY3RvciA9IGxpbmVbYW5jaG9yLnNlZ21lbnQgKyAxXS5zdWIobGluZVthbmNob3Iuc2VnbWVudF0pLl91bml0KCkuX211bHQobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyYWlnaHRMaW5lID0gW2FuY2hvci5zdWIodmVjdG9yKSwgYW5jaG9yLmFkZCh2ZWN0b3IpXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRMaW5lQ29sbGlzaW9uQm94ZXMoY29sbGlzaW9uQm94QXJyYXksIHN0cmFpZ2h0TGluZSwgYW5jaG9yLCAwLCBsZW5ndGgsIGhlaWdodCwgZmVhdHVyZUluZGV4LCBzb3VyY2VMYXllckluZGV4LCBidWNrZXRJbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVzZWQgZm9yIHRleHQgbGFiZWxzIHRoYXQgY3VydmUgYWxvbmcgYSBsaW5lXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTGluZUNvbGxpc2lvbkJveGVzKGNvbGxpc2lvbkJveEFycmF5LCBsaW5lLCBhbmNob3IsIGFuY2hvci5zZWdtZW50LCBsZW5ndGgsIGhlaWdodCwgZmVhdHVyZUluZGV4LCBzb3VyY2VMYXllckluZGV4LCBidWNrZXRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbGxpc2lvbkJveEFycmF5LmVtcGxhY2VCYWNrKGFuY2hvci54LCBhbmNob3IueSwgeDEsIHkxLCB4MiwgeTIsIEluZmluaXR5LCBmZWF0dXJlSW5kZXgsIHNvdXJjZUxheWVySW5kZXgsIGJ1Y2tldEluZGV4LFxuICAgICAgICAgICAgICAgIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cblxuICAgIHRoaXMuYm94RW5kSW5kZXggPSBjb2xsaXNpb25Cb3hBcnJheS5sZW5ndGg7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc2V0IG9mIENvbGxpc2lvbkJveCBvYmplY3RzIGZvciBhIGxpbmUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxQb2ludD59IGxpbmVcbiAqIEBwYXJhbSB7QW5jaG9yfSBhbmNob3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbExlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBsYWJlbCBpbiBnZW9tZXRyeSB1bml0cy5cbiAqIEBwYXJhbSB7QW5jaG9yfSBhbmNob3IgVGhlIHBvaW50IGFsb25nIHRoZSBsaW5lIGFyb3VuZCB3aGljaCB0aGUgbGFiZWwgaXMgYW5jaG9yZWQuXG4gKiBAcGFyYW0ge1ZlY3RvclRpbGVGZWF0dXJlfSBmZWF0dXJlIFRoZSBWZWN0b3JUaWxlRmVhdHVyZSB0aGF0IHRoaXMgQ29sbGlzaW9uRmVhdHVyZSB3YXMgY3JlYXRlZCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gYm94U2l6ZSBUaGUgc2l6ZSBvZiB0aGUgY29sbGlzaW9uIGJveGVzIHRoYXQgd2lsbCBiZSBjcmVhdGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkNvbGxpc2lvbkZlYXR1cmUucHJvdG90eXBlLl9hZGRMaW5lQ29sbGlzaW9uQm94ZXMgPSBmdW5jdGlvbihjb2xsaXNpb25Cb3hBcnJheSwgbGluZSwgYW5jaG9yLCBzZWdtZW50LCBsYWJlbExlbmd0aCwgYm94U2l6ZSwgZmVhdHVyZUluZGV4LCBzb3VyY2VMYXllckluZGV4LCBidWNrZXRJbmRleCkge1xuICAgIHZhciBzdGVwID0gYm94U2l6ZSAvIDI7XG4gICAgdmFyIG5Cb3hlcyA9IE1hdGguZmxvb3IobGFiZWxMZW5ndGggLyBzdGVwKTtcblxuICAgIC8vIG9mZnNldCB0aGUgY2VudGVyIG9mIHRoZSBmaXJzdCBib3ggYnkgaGFsZiBhIGJveCBzbyB0aGF0IHRoZSBlZGdlIG9mIHRoZVxuICAgIC8vIGJveCBpcyBhdCB0aGUgZWRnZSBvZiB0aGUgbGFiZWwuXG4gICAgdmFyIGZpcnN0Qm94T2Zmc2V0ID0gLWJveFNpemUgLyAyO1xuXG4gICAgdmFyIGJib3hlcyA9IHRoaXMuYm94ZXM7XG5cbiAgICB2YXIgcCA9IGFuY2hvcjtcbiAgICB2YXIgaW5kZXggPSBzZWdtZW50ICsgMTtcbiAgICB2YXIgYW5jaG9yRGlzdGFuY2UgPSBmaXJzdEJveE9mZnNldDtcblxuICAgIC8vIG1vdmUgYmFja3dhcmRzIGFsb25nIHRoZSBsaW5lIHRvIHRoZSBmaXJzdCBzZWdtZW50IHRoZSBsYWJlbCBhcHBlYXJzIG9uXG4gICAgZG8ge1xuICAgICAgICBpbmRleC0tO1xuXG4gICAgICAgIC8vIHRoZXJlIGlzbid0IGVub3VnaCByb29tIGZvciB0aGUgbGFiZWwgYWZ0ZXIgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZVxuICAgICAgICAvLyBjaGVja01heEFuZ2xlIHNob3VsZCBoYXZlIGFscmVhZHkgY2F1Z2h0IHRoaXNcbiAgICAgICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuIGJib3hlcztcblxuICAgICAgICBhbmNob3JEaXN0YW5jZSAtPSBsaW5lW2luZGV4XS5kaXN0KHApO1xuICAgICAgICBwID0gbGluZVtpbmRleF07XG4gICAgfSB3aGlsZSAoYW5jaG9yRGlzdGFuY2UgPiAtbGFiZWxMZW5ndGggLyAyKTtcblxuICAgIHZhciBzZWdtZW50TGVuZ3RoID0gbGluZVtpbmRleF0uZGlzdChsaW5lW2luZGV4ICsgMV0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuQm94ZXM7IGkrKykge1xuICAgICAgICAvLyB0aGUgZGlzdGFuY2UgdGhlIGJveCB3aWxsIGJlIGZyb20gdGhlIGFuY2hvclxuICAgICAgICB2YXIgYm94RGlzdGFuY2VUb0FuY2hvciA9IC1sYWJlbExlbmd0aCAvIDIgKyBpICogc3RlcDtcblxuICAgICAgICAvLyB0aGUgYm94IGlzIG5vdCBvbiB0aGUgY3VycmVudCBzZWdtZW50LiBNb3ZlIHRvIHRoZSBuZXh0IHNlZ21lbnQuXG4gICAgICAgIHdoaWxlIChhbmNob3JEaXN0YW5jZSArIHNlZ21lbnRMZW5ndGggPCBib3hEaXN0YW5jZVRvQW5jaG9yKSB7XG4gICAgICAgICAgICBhbmNob3JEaXN0YW5jZSArPSBzZWdtZW50TGVuZ3RoO1xuICAgICAgICAgICAgaW5kZXgrKztcblxuICAgICAgICAgICAgLy8gVGhlcmUgaXNuJ3QgZW5vdWdoIHJvb20gYmVmb3JlIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgICAgICAgICBpZiAoaW5kZXggKyAxID49IGxpbmUubGVuZ3RoKSByZXR1cm4gYmJveGVzO1xuXG4gICAgICAgICAgICBzZWdtZW50TGVuZ3RoID0gbGluZVtpbmRleF0uZGlzdChsaW5lW2luZGV4ICsgMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIGRpc3RhbmNlIHRoZSBib3ggd2lsbCBiZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlZ21lbnRcbiAgICAgICAgdmFyIHNlZ21lbnRCb3hEaXN0YW5jZSA9IGJveERpc3RhbmNlVG9BbmNob3IgLSBhbmNob3JEaXN0YW5jZTtcblxuICAgICAgICB2YXIgcDAgPSBsaW5lW2luZGV4XTtcbiAgICAgICAgdmFyIHAxID0gbGluZVtpbmRleCArIDFdO1xuICAgICAgICB2YXIgYm94QW5jaG9yUG9pbnQgPSBwMS5zdWIocDApLl91bml0KCkuX211bHQoc2VnbWVudEJveERpc3RhbmNlKS5fYWRkKHAwKS5fcm91bmQoKTtcblxuICAgICAgICB2YXIgZGlzdGFuY2VUb0lubmVyRWRnZSA9IE1hdGgubWF4KE1hdGguYWJzKGJveERpc3RhbmNlVG9BbmNob3IgLSBmaXJzdEJveE9mZnNldCkgLSBzdGVwIC8gMiwgMCk7XG4gICAgICAgIHZhciBtYXhTY2FsZSA9IGxhYmVsTGVuZ3RoIC8gMiAvIGRpc3RhbmNlVG9Jbm5lckVkZ2U7XG5cbiAgICAgICAgY29sbGlzaW9uQm94QXJyYXkuZW1wbGFjZUJhY2soYm94QW5jaG9yUG9pbnQueCwgYm94QW5jaG9yUG9pbnQueSxcbiAgICAgICAgICAgICAgICAtYm94U2l6ZSAvIDIsIC1ib3hTaXplIC8gMiwgYm94U2l6ZSAvIDIsIGJveFNpemUgLyAyLCBtYXhTY2FsZSxcbiAgICAgICAgICAgICAgICBmZWF0dXJlSW5kZXgsIHNvdXJjZUxheWVySW5kZXgsIGJ1Y2tldEluZGV4LFxuICAgICAgICAgICAgICAgIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cblxuICAgIHJldHVybiBiYm94ZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xudmFyIEVYVEVOVCA9IHJlcXVpcmUoJy4uL2RhdGEvYnVja2V0JykuRVhURU5UO1xudmFyIEdyaWQgPSByZXF1aXJlKCdncmlkLWluZGV4Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGlzaW9uVGlsZTtcblxuLyoqXG4gKiBBIGNvbGxpc2lvbiB0aWxlIHVzZWQgdG8gcHJldmVudCBzeW1ib2xzIGZyb20gb3ZlcmxhcHBpbmcuIEl0IGtlZXAgdHJhY2tzIG9mXG4gKiB3aGVyZSBwcmV2aW91cyBzeW1ib2xzIGhhdmUgYmVlbiBwbGFjZWQgYW5kIGlzIHVzZWQgdG8gY2hlY2sgaWYgYSBuZXdcbiAqIHN5bWJvbCBvdmVybGFwcyB3aXRoIGFueSBwcmV2aW91c2x5IGFkZGVkIHN5bWJvbHMuXG4gKlxuICogQGNsYXNzIENvbGxpc2lvblRpbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICogQHBhcmFtIHtudW1iZXJ9IHBpdGNoXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBDb2xsaXNpb25UaWxlKGFuZ2xlLCBwaXRjaCwgY29sbGlzaW9uQm94QXJyYXkpIHtcbiAgICBpZiAodHlwZW9mIGFuZ2xlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgc2VyaWFsaXplZCA9IGFuZ2xlO1xuICAgICAgICBjb2xsaXNpb25Cb3hBcnJheSA9IHBpdGNoO1xuICAgICAgICBhbmdsZSA9IHNlcmlhbGl6ZWQuYW5nbGU7XG4gICAgICAgIHBpdGNoID0gc2VyaWFsaXplZC5waXRjaDtcbiAgICAgICAgdGhpcy5ncmlkID0gbmV3IEdyaWQoc2VyaWFsaXplZC5ncmlkKTtcbiAgICAgICAgdGhpcy5pZ25vcmVkR3JpZCA9IG5ldyBHcmlkKHNlcmlhbGl6ZWQuaWdub3JlZEdyaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ3JpZCA9IG5ldyBHcmlkKEVYVEVOVCwgMTIsIDYpO1xuICAgICAgICB0aGlzLmlnbm9yZWRHcmlkID0gbmV3IEdyaWQoRVhURU5ULCAxMiwgMCk7XG4gICAgfVxuXG4gICAgdGhpcy5hbmdsZSA9IGFuZ2xlO1xuICAgIHRoaXMucGl0Y2ggPSBwaXRjaDtcblxuICAgIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICB0aGlzLnJvdGF0aW9uTWF0cml4ID0gW2NvcywgLXNpbiwgc2luLCBjb3NdO1xuICAgIHRoaXMucmV2ZXJzZVJvdGF0aW9uTWF0cml4ID0gW2Nvcywgc2luLCAtc2luLCBjb3NdO1xuXG4gICAgLy8gU3RyZXRjaCBib3hlcyBpbiB5IGRpcmVjdGlvbiB0byBhY2NvdW50IGZvciB0aGUgbWFwIHRpbHQuXG4gICAgdGhpcy55U3RyZXRjaCA9IDEgLyBNYXRoLmNvcyhwaXRjaCAvIDE4MCAqIE1hdGguUEkpO1xuXG4gICAgLy8gVGhlIGFtb3VudCB0aGUgbWFwIGlzIHNxdWlzaGVkIGRlcGVuZHMgb24gdGhlIHkgcG9zaXRpb24uXG4gICAgLy8gU29ydCBvZiBhY2NvdW50IGZvciB0aGlzIGJ5IG1ha2luZyBhbGwgYm94ZXMgYSBiaXQgYmlnZ2VyLlxuICAgIHRoaXMueVN0cmV0Y2ggPSBNYXRoLnBvdyh0aGlzLnlTdHJldGNoLCAxLjMpO1xuXG4gICAgdGhpcy5jb2xsaXNpb25Cb3hBcnJheSA9IGNvbGxpc2lvbkJveEFycmF5O1xuICAgIGlmIChjb2xsaXNpb25Cb3hBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gdGhlIGZpcnN0IGNvbGxpc2lvbkJveEFycmF5IGlzIHBhc3NlZCB0byBhIENvbGxpc2lvblRpbGVcblxuICAgICAgICAvLyB0ZW1wQ29sbGlzaW9uQm94XG4gICAgICAgIGNvbGxpc2lvbkJveEFycmF5LmVtcGxhY2VCYWNrKCk7XG5cbiAgICAgICAgdmFyIG1heEludDE2ID0gMzI3Njc7XG4gICAgICAgIC8vbGVmdFxuICAgICAgICBjb2xsaXNpb25Cb3hBcnJheS5lbXBsYWNlQmFjaygwLCAwLCAwLCAtbWF4SW50MTYsIDAsIG1heEludDE2LCBtYXhJbnQxNixcbiAgICAgICAgICAgICAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgIDApO1xuICAgICAgICAvLyByaWdodFxuICAgICAgICBjb2xsaXNpb25Cb3hBcnJheS5lbXBsYWNlQmFjayhFWFRFTlQsIDAsIDAsIC1tYXhJbnQxNiwgMCwgbWF4SW50MTYsIG1heEludDE2LFxuICAgICAgICAgICAgICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAgMCk7XG4gICAgICAgIC8vIHRvcFxuICAgICAgICBjb2xsaXNpb25Cb3hBcnJheS5lbXBsYWNlQmFjaygwLCAwLCAtbWF4SW50MTYsIDAsIG1heEludDE2LCAwLCBtYXhJbnQxNixcbiAgICAgICAgICAgICAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgIDApO1xuICAgICAgICAvLyBib3R0b21cbiAgICAgICAgY29sbGlzaW9uQm94QXJyYXkuZW1wbGFjZUJhY2soMCwgRVhURU5ULCAtbWF4SW50MTYsIDAsIG1heEludDE2LCAwLCBtYXhJbnQxNixcbiAgICAgICAgICAgICAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgIDApO1xuICAgIH1cblxuICAgIHRoaXMudGVtcENvbGxpc2lvbkJveCA9IGNvbGxpc2lvbkJveEFycmF5LmdldCgwKTtcbiAgICB0aGlzLmVkZ2VzID0gW1xuICAgICAgICBjb2xsaXNpb25Cb3hBcnJheS5nZXQoMSksXG4gICAgICAgIGNvbGxpc2lvbkJveEFycmF5LmdldCgyKSxcbiAgICAgICAgY29sbGlzaW9uQm94QXJyYXkuZ2V0KDMpLFxuICAgICAgICBjb2xsaXNpb25Cb3hBcnJheS5nZXQoNClcbiAgICBdO1xufVxuXG5Db2xsaXNpb25UaWxlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgYW5nbGU6IHRoaXMuYW5nbGUsXG4gICAgICAgIHBpdGNoOiB0aGlzLnBpdGNoLFxuICAgICAgICBncmlkOiB0aGlzLmdyaWQudG9BcnJheUJ1ZmZlcigpLFxuICAgICAgICBpZ25vcmVkR3JpZDogdGhpcy5pZ25vcmVkR3JpZC50b0FycmF5QnVmZmVyKClcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHRyYW5zZmVyYWJsZXM6IFtkYXRhLmdyaWQsIGRhdGEuaWdub3JlZEdyaWRdXG4gICAgfTtcbn07XG5cbkNvbGxpc2lvblRpbGUucHJvdG90eXBlLm1pblNjYWxlID0gMC4yNTtcbkNvbGxpc2lvblRpbGUucHJvdG90eXBlLm1heFNjYWxlID0gMjtcblxuXG4vKipcbiAqIEZpbmQgdGhlIHNjYWxlIGF0IHdoaWNoIHRoZSBjb2xsaXNpb25GZWF0dXJlIGNhbiBiZSBzaG93biB3aXRob3V0XG4gKiBvdmVybGFwcGluZyB3aXRoIG90aGVyIGZlYXR1cmVzLlxuICpcbiAqIEBwYXJhbSB7Q29sbGlzaW9uRmVhdHVyZX0gY29sbGlzaW9uRmVhdHVyZVxuICogQHJldHVybnMge251bWJlcn0gcGxhY2VtZW50U2NhbGVcbiAqIEBwcml2YXRlXG4gKi9cbkNvbGxpc2lvblRpbGUucHJvdG90eXBlLnBsYWNlQ29sbGlzaW9uRmVhdHVyZSA9IGZ1bmN0aW9uKGNvbGxpc2lvbkZlYXR1cmUsIGFsbG93T3ZlcmxhcCwgYXZvaWRFZGdlcykge1xuXG4gICAgdmFyIGNvbGxpc2lvbkJveEFycmF5ID0gdGhpcy5jb2xsaXNpb25Cb3hBcnJheTtcbiAgICB2YXIgbWluUGxhY2VtZW50U2NhbGUgPSB0aGlzLm1pblNjYWxlO1xuICAgIHZhciByb3RhdGlvbk1hdHJpeCA9IHRoaXMucm90YXRpb25NYXRyaXg7XG4gICAgdmFyIHlTdHJldGNoID0gdGhpcy55U3RyZXRjaDtcblxuICAgIGZvciAodmFyIGIgPSBjb2xsaXNpb25GZWF0dXJlLmJveFN0YXJ0SW5kZXg7IGIgPCBjb2xsaXNpb25GZWF0dXJlLmJveEVuZEluZGV4OyBiKyspIHtcblxuICAgICAgICB2YXIgYm94ID0gY29sbGlzaW9uQm94QXJyYXkuZ2V0KGIpO1xuXG4gICAgICAgIHZhciBhbmNob3JQb2ludCA9IGJveC5hbmNob3JQb2ludC5fbWF0TXVsdChyb3RhdGlvbk1hdHJpeCk7XG4gICAgICAgIHZhciB4ID0gYW5jaG9yUG9pbnQueDtcbiAgICAgICAgdmFyIHkgPSBhbmNob3JQb2ludC55O1xuXG4gICAgICAgIHZhciB4MSA9IHggKyBib3gueDE7XG4gICAgICAgIHZhciB5MSA9IHkgKyBib3gueTEgKiB5U3RyZXRjaDtcbiAgICAgICAgdmFyIHgyID0geCArIGJveC54MjtcbiAgICAgICAgdmFyIHkyID0geSArIGJveC55MiAqIHlTdHJldGNoO1xuXG4gICAgICAgIGJveC5iYm94MCA9IHgxO1xuICAgICAgICBib3guYmJveDEgPSB5MTtcbiAgICAgICAgYm94LmJib3gyID0geDI7XG4gICAgICAgIGJveC5iYm94MyA9IHkyO1xuXG4gICAgICAgIGlmICghYWxsb3dPdmVybGFwKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2tpbmdCb3hlcyA9IHRoaXMuZ3JpZC5xdWVyeSh4MSwgeTEsIHgyLCB5Mik7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tpbmdCb3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBibG9ja2luZyA9IGNvbGxpc2lvbkJveEFycmF5LmdldChibG9ja2luZ0JveGVzW2ldKTtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tpbmdBbmNob3JQb2ludCA9IGJsb2NraW5nLmFuY2hvclBvaW50Ll9tYXRNdWx0KHJvdGF0aW9uTWF0cml4KTtcblxuICAgICAgICAgICAgICAgIG1pblBsYWNlbWVudFNjYWxlID0gdGhpcy5nZXRQbGFjZW1lbnRTY2FsZShtaW5QbGFjZW1lbnRTY2FsZSwgYW5jaG9yUG9pbnQsIGJveCwgYmxvY2tpbmdBbmNob3JQb2ludCwgYmxvY2tpbmcpO1xuICAgICAgICAgICAgICAgIGlmIChtaW5QbGFjZW1lbnRTY2FsZSA+PSB0aGlzLm1heFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtaW5QbGFjZW1lbnRTY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXZvaWRFZGdlcykge1xuICAgICAgICAgICAgdmFyIHJvdGF0ZWRDb2xsaXNpb25Cb3g7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldmVyc2VSb3RhdGlvbk1hdHJpeCA9IHRoaXMucmV2ZXJzZVJvdGF0aW9uTWF0cml4O1xuICAgICAgICAgICAgICAgIHZhciB0bCA9IG5ldyBQb2ludChib3gueDEsIGJveC55MSkubWF0TXVsdChyZXZlcnNlUm90YXRpb25NYXRyaXgpO1xuICAgICAgICAgICAgICAgIHZhciB0ciA9IG5ldyBQb2ludChib3gueDIsIGJveC55MSkubWF0TXVsdChyZXZlcnNlUm90YXRpb25NYXRyaXgpO1xuICAgICAgICAgICAgICAgIHZhciBibCA9IG5ldyBQb2ludChib3gueDEsIGJveC55MikubWF0TXVsdChyZXZlcnNlUm90YXRpb25NYXRyaXgpO1xuICAgICAgICAgICAgICAgIHZhciBiciA9IG5ldyBQb2ludChib3gueDIsIGJveC55MikubWF0TXVsdChyZXZlcnNlUm90YXRpb25NYXRyaXgpO1xuXG4gICAgICAgICAgICAgICAgcm90YXRlZENvbGxpc2lvbkJveCA9IHRoaXMudGVtcENvbGxpc2lvbkJveDtcbiAgICAgICAgICAgICAgICByb3RhdGVkQ29sbGlzaW9uQm94LmFuY2hvclBvaW50WCA9IGJveC5hbmNob3JQb2ludC54O1xuICAgICAgICAgICAgICAgIHJvdGF0ZWRDb2xsaXNpb25Cb3guYW5jaG9yUG9pbnRZID0gYm94LmFuY2hvclBvaW50Lnk7XG4gICAgICAgICAgICAgICAgcm90YXRlZENvbGxpc2lvbkJveC54MSA9IE1hdGgubWluKHRsLngsIHRyLngsIGJsLngsIGJyLngpO1xuICAgICAgICAgICAgICAgIHJvdGF0ZWRDb2xsaXNpb25Cb3gueTEgPSBNYXRoLm1pbih0bC55LCB0ci54LCBibC54LCBici54KTtcbiAgICAgICAgICAgICAgICByb3RhdGVkQ29sbGlzaW9uQm94LngyID0gTWF0aC5tYXgodGwueCwgdHIueCwgYmwueCwgYnIueCk7XG4gICAgICAgICAgICAgICAgcm90YXRlZENvbGxpc2lvbkJveC55MiA9IE1hdGgubWF4KHRsLnksIHRyLngsIGJsLngsIGJyLngpO1xuICAgICAgICAgICAgICAgIHJvdGF0ZWRDb2xsaXNpb25Cb3gubWF4U2NhbGUgPSBib3gubWF4U2NhbGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdGF0ZWRDb2xsaXNpb25Cb3ggPSBib3g7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5lZGdlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBlZGdlQm94ID0gdGhpcy5lZGdlc1trXTtcbiAgICAgICAgICAgICAgICBtaW5QbGFjZW1lbnRTY2FsZSA9IHRoaXMuZ2V0UGxhY2VtZW50U2NhbGUobWluUGxhY2VtZW50U2NhbGUsIGJveC5hbmNob3JQb2ludCwgcm90YXRlZENvbGxpc2lvbkJveCwgZWRnZUJveC5hbmNob3JQb2ludCwgZWRnZUJveCk7XG4gICAgICAgICAgICAgICAgaWYgKG1pblBsYWNlbWVudFNjYWxlID49IHRoaXMubWF4U2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1pblBsYWNlbWVudFNjYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtaW5QbGFjZW1lbnRTY2FsZTtcbn07XG5cbkNvbGxpc2lvblRpbGUucHJvdG90eXBlLnF1ZXJ5UmVuZGVyZWRTeW1ib2xzID0gZnVuY3Rpb24obWluWCwgbWluWSwgbWF4WCwgbWF4WSwgc2NhbGUpIHtcbiAgICB2YXIgc291cmNlTGF5ZXJGZWF0dXJlcyA9IHt9O1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIHZhciBjb2xsaXNpb25Cb3hBcnJheSA9IHRoaXMuY29sbGlzaW9uQm94QXJyYXk7XG4gICAgdmFyIHJvdGF0aW9uTWF0cml4ID0gdGhpcy5yb3RhdGlvbk1hdHJpeDtcbiAgICB2YXIgYW5jaG9yUG9pbnQgPSBuZXcgUG9pbnQobWluWCwgbWluWSkuX21hdE11bHQocm90YXRpb25NYXRyaXgpO1xuXG4gICAgdmFyIHF1ZXJ5Qm94ID0gdGhpcy50ZW1wQ29sbGlzaW9uQm94O1xuICAgIHF1ZXJ5Qm94LmFuY2hvclggPSBhbmNob3JQb2ludC54O1xuICAgIHF1ZXJ5Qm94LmFuY2hvclkgPSBhbmNob3JQb2ludC55O1xuICAgIHF1ZXJ5Qm94LngxID0gMDtcbiAgICBxdWVyeUJveC55MSA9IDA7XG4gICAgcXVlcnlCb3gueDIgPSBtYXhYIC0gbWluWDtcbiAgICBxdWVyeUJveC55MiA9IG1heFkgLSBtaW5ZO1xuICAgIHF1ZXJ5Qm94Lm1heFNjYWxlID0gc2NhbGU7XG5cbiAgICAvLyBtYXhTY2FsZSBpcyBzdG9yZWQgdXNpbmcgYSBGbG9hdDMyLiBDb252ZXJ0IGBzY2FsZWAgdG8gdGhlIHN0b3JlZCBGbG9hdDMyIHZhbHVlLlxuICAgIHNjYWxlID0gcXVlcnlCb3gubWF4U2NhbGU7XG5cbiAgICB2YXIgc2VhcmNoQm94ID0gW1xuICAgICAgICBhbmNob3JQb2ludC54ICsgcXVlcnlCb3gueDEgLyBzY2FsZSxcbiAgICAgICAgYW5jaG9yUG9pbnQueSArIHF1ZXJ5Qm94LnkxIC8gc2NhbGUgKiB0aGlzLnlTdHJldGNoLFxuICAgICAgICBhbmNob3JQb2ludC54ICsgcXVlcnlCb3gueDIgLyBzY2FsZSxcbiAgICAgICAgYW5jaG9yUG9pbnQueSArIHF1ZXJ5Qm94LnkyIC8gc2NhbGUgKiB0aGlzLnlTdHJldGNoXG4gICAgXTtcblxuICAgIHZhciBibG9ja2luZ0JveEtleXMgPSB0aGlzLmdyaWQucXVlcnkoc2VhcmNoQm94WzBdLCBzZWFyY2hCb3hbMV0sIHNlYXJjaEJveFsyXSwgc2VhcmNoQm94WzNdKTtcbiAgICB2YXIgYmxvY2tpbmdCb3hLZXlzMiA9IHRoaXMuaWdub3JlZEdyaWQucXVlcnkoc2VhcmNoQm94WzBdLCBzZWFyY2hCb3hbMV0sIHNlYXJjaEJveFsyXSwgc2VhcmNoQm94WzNdKTtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGJsb2NraW5nQm94S2V5czIubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgYmxvY2tpbmdCb3hLZXlzLnB1c2goYmxvY2tpbmdCb3hLZXlzMltrXSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja2luZ0JveEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGJsb2NraW5nID0gY29sbGlzaW9uQm94QXJyYXkuZ2V0KGJsb2NraW5nQm94S2V5c1tpXSk7XG5cbiAgICAgICAgdmFyIHNvdXJjZUxheWVyID0gYmxvY2tpbmcuc291cmNlTGF5ZXJJbmRleDtcbiAgICAgICAgdmFyIGZlYXR1cmVJbmRleCA9IGJsb2NraW5nLmZlYXR1cmVJbmRleDtcbiAgICAgICAgaWYgKHNvdXJjZUxheWVyRmVhdHVyZXNbc291cmNlTGF5ZXJdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNvdXJjZUxheWVyRmVhdHVyZXNbc291cmNlTGF5ZXJdID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNvdXJjZUxheWVyRmVhdHVyZXNbc291cmNlTGF5ZXJdW2ZlYXR1cmVJbmRleF0pIHtcbiAgICAgICAgICAgIHZhciBibG9ja2luZ0FuY2hvclBvaW50ID0gYmxvY2tpbmcuYW5jaG9yUG9pbnQubWF0TXVsdChyb3RhdGlvbk1hdHJpeCk7XG4gICAgICAgICAgICB2YXIgbWluUGxhY2VtZW50U2NhbGUgPSB0aGlzLmdldFBsYWNlbWVudFNjYWxlKHRoaXMubWluU2NhbGUsIGFuY2hvclBvaW50LCBxdWVyeUJveCwgYmxvY2tpbmdBbmNob3JQb2ludCwgYmxvY2tpbmcpO1xuICAgICAgICAgICAgaWYgKG1pblBsYWNlbWVudFNjYWxlID49IHNjYWxlKSB7XG4gICAgICAgICAgICAgICAgc291cmNlTGF5ZXJGZWF0dXJlc1tzb3VyY2VMYXllcl1bZmVhdHVyZUluZGV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmxvY2tpbmdCb3hLZXlzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5Db2xsaXNpb25UaWxlLnByb3RvdHlwZS5nZXRQbGFjZW1lbnRTY2FsZSA9IGZ1bmN0aW9uKG1pblBsYWNlbWVudFNjYWxlLCBhbmNob3JQb2ludCwgYm94LCBibG9ja2luZ0FuY2hvclBvaW50LCBibG9ja2luZykge1xuXG4gICAgLy8gRmluZCB0aGUgbG93ZXN0IHNjYWxlIGF0IHdoaWNoIHRoZSB0d28gYm94ZXMgY2FuIGZpdCBzaWRlIGJ5IHNpZGUgd2l0aG91dCBvdmVybGFwcGluZy5cbiAgICAvLyBPcmlnaW5hbCBhbGdvcml0aG06XG4gICAgdmFyIGFuY2hvckRpZmZYID0gYW5jaG9yUG9pbnQueCAtIGJsb2NraW5nQW5jaG9yUG9pbnQueDtcbiAgICB2YXIgYW5jaG9yRGlmZlkgPSBhbmNob3JQb2ludC55IC0gYmxvY2tpbmdBbmNob3JQb2ludC55O1xuICAgIHZhciBzMSA9IChibG9ja2luZy54MSAtIGJveC54MikgLyBhbmNob3JEaWZmWDsgLy8gc2NhbGUgYXQgd2hpY2ggbmV3IGJveCBpcyB0byB0aGUgbGVmdCBvZiBvbGQgYm94XG4gICAgdmFyIHMyID0gKGJsb2NraW5nLngyIC0gYm94LngxKSAvIGFuY2hvckRpZmZYOyAvLyBzY2FsZSBhdCB3aGljaCBuZXcgYm94IGlzIHRvIHRoZSByaWdodCBvZiBvbGQgYm94XG4gICAgdmFyIHMzID0gKGJsb2NraW5nLnkxIC0gYm94LnkyKSAqIHRoaXMueVN0cmV0Y2ggLyBhbmNob3JEaWZmWTsgLy8gc2NhbGUgYXQgd2hpY2ggbmV3IGJveCBpcyB0byB0aGUgdG9wIG9mIG9sZCBib3hcbiAgICB2YXIgczQgPSAoYmxvY2tpbmcueTIgLSBib3gueTEpICogdGhpcy55U3RyZXRjaCAvIGFuY2hvckRpZmZZOyAvLyBzY2FsZSBhdCB3aGljaCBuZXcgYm94IGlzIHRvIHRoZSBib3R0b20gb2Ygb2xkIGJveFxuXG4gICAgaWYgKGlzTmFOKHMxKSB8fCBpc05hTihzMikpIHMxID0gczIgPSAxO1xuICAgIGlmIChpc05hTihzMykgfHwgaXNOYU4oczQpKSBzMyA9IHM0ID0gMTtcblxuICAgIHZhciBjb2xsaXNpb25GcmVlU2NhbGUgPSBNYXRoLm1pbihNYXRoLm1heChzMSwgczIpLCBNYXRoLm1heChzMywgczQpKTtcbiAgICB2YXIgYmxvY2tpbmdNYXhTY2FsZSA9IGJsb2NraW5nLm1heFNjYWxlO1xuICAgIHZhciBib3hNYXhTY2FsZSA9IGJveC5tYXhTY2FsZTtcblxuICAgIGlmIChjb2xsaXNpb25GcmVlU2NhbGUgPiBibG9ja2luZ01heFNjYWxlKSB7XG4gICAgICAgIC8vIEFmdGVyIGEgYm94J3MgbWF4U2NhbGUgdGhlIGxhYmVsIGhhcyBzaHJ1bmsgZW5vdWdoIHRoYXQgdGhlIGJveCBpcyBubyBsb25nZXIgbmVlZGVkIHRvIGNvdmVyIGl0LFxuICAgICAgICAvLyBzbyB1bmJsb2NrIHRoZSBuZXcgYm94IGF0IHRoZSBzY2FsZSB0aGF0IHRoZSBvbGQgYm94IGRpc2FwcGVhcnMuXG4gICAgICAgIGNvbGxpc2lvbkZyZWVTY2FsZSA9IGJsb2NraW5nTWF4U2NhbGU7XG4gICAgfVxuXG4gICAgaWYgKGNvbGxpc2lvbkZyZWVTY2FsZSA+IGJveE1heFNjYWxlKSB7XG4gICAgICAgIC8vIElmIHRoZSBib3ggY2FuIG9ubHkgYmUgc2hvd24gYWZ0ZXIgaXQgaXMgdmlzaWJsZSwgdGhlbiB0aGUgYm94IGNhbiBuZXZlciBiZSBzaG93bi5cbiAgICAgICAgLy8gQnV0IHRoZSBsYWJlbCBjYW4gYmUgc2hvd24gYWZ0ZXIgdGhpcyBib3ggaXMgbm90IHZpc2libGUuXG4gICAgICAgIGNvbGxpc2lvbkZyZWVTY2FsZSA9IGJveE1heFNjYWxlO1xuICAgIH1cblxuICAgIGlmIChjb2xsaXNpb25GcmVlU2NhbGUgPiBtaW5QbGFjZW1lbnRTY2FsZSAmJlxuICAgICAgICAgICAgY29sbGlzaW9uRnJlZVNjYWxlID49IGJsb2NraW5nLnBsYWNlbWVudFNjYWxlKSB7XG4gICAgICAgIC8vIElmIHRoaXMgY29sbGlzaW9uIG9jY3VycyBhdCBhIGxvd2VyIHNjYWxlIHRoYW4gcHJldmlvdXNseSBmb3VuZCBjb2xsaXNpb25zXG4gICAgICAgIC8vIGFuZCB0aGUgY29sbGlzaW9uIG9jY3VycyB3aGlsZSB0aGUgb3RoZXIgbGFiZWwgaXMgdmlzaWJsZVxuXG4gICAgICAgIC8vIHRoaXMgdGhpcyBpcyB0aGUgbG93ZXN0IHNjYWxlIGF0IHdoaWNoIHRoZSBsYWJlbCB3b24ndCBjb2xsaWRlIHdpdGggYW55dGhpbmdcbiAgICAgICAgbWluUGxhY2VtZW50U2NhbGUgPSBjb2xsaXNpb25GcmVlU2NhbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pblBsYWNlbWVudFNjYWxlO1xufTtcblxuXG4vKipcbiAqIFJlbWVtYmVyIHRoaXMgY29sbGlzaW9uRmVhdHVyZSBhbmQgd2hhdCBzY2FsZSBpdCB3YXMgcGxhY2VkIGF0IHRvIGJsb2NrXG4gKiBsYXRlciBmZWF0dXJlcyBmcm9tIG92ZXJsYXBwaW5nIHdpdGggaXQuXG4gKlxuICogQHBhcmFtIHtDb2xsaXNpb25GZWF0dXJlfSBjb2xsaXNpb25GZWF0dXJlXG4gKiBAcGFyYW0ge251bWJlcn0gbWluUGxhY2VtZW50U2NhbGVcbiAqIEBwcml2YXRlXG4gKi9cbkNvbGxpc2lvblRpbGUucHJvdG90eXBlLmluc2VydENvbGxpc2lvbkZlYXR1cmUgPSBmdW5jdGlvbihjb2xsaXNpb25GZWF0dXJlLCBtaW5QbGFjZW1lbnRTY2FsZSwgaWdub3JlUGxhY2VtZW50KSB7XG5cbiAgICB2YXIgZ3JpZCA9IGlnbm9yZVBsYWNlbWVudCA/IHRoaXMuaWdub3JlZEdyaWQgOiB0aGlzLmdyaWQ7XG4gICAgdmFyIGNvbGxpc2lvbkJveEFycmF5ID0gdGhpcy5jb2xsaXNpb25Cb3hBcnJheTtcblxuICAgIGZvciAodmFyIGsgPSBjb2xsaXNpb25GZWF0dXJlLmJveFN0YXJ0SW5kZXg7IGsgPCBjb2xsaXNpb25GZWF0dXJlLmJveEVuZEluZGV4OyBrKyspIHtcbiAgICAgICAgdmFyIGJveCA9IGNvbGxpc2lvbkJveEFycmF5LmdldChrKTtcbiAgICAgICAgYm94LnBsYWNlbWVudFNjYWxlID0gbWluUGxhY2VtZW50U2NhbGU7XG4gICAgICAgIGlmIChtaW5QbGFjZW1lbnRTY2FsZSA8IHRoaXMubWF4U2NhbGUpIHtcbiAgICAgICAgICAgIGdyaWQuaW5zZXJ0KGssIGJveC5iYm94MCwgYm94LmJib3gxLCBib3guYmJveDIsIGJveC5iYm94Myk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW50ZXJwb2xhdGUgPSByZXF1aXJlKCcuLi91dGlsL2ludGVycG9sYXRlJyk7XG52YXIgQW5jaG9yID0gcmVxdWlyZSgnLi4vc3ltYm9sL2FuY2hvcicpO1xudmFyIGNoZWNrTWF4QW5nbGUgPSByZXF1aXJlKCcuL2NoZWNrX21heF9hbmdsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFuY2hvcnM7XG5cbmZ1bmN0aW9uIGdldEFuY2hvcnMobGluZSwgc3BhY2luZywgbWF4QW5nbGUsIHNoYXBlZFRleHQsIHNoYXBlZEljb24sIGdseXBoU2l6ZSwgYm94U2NhbGUsIG92ZXJzY2FsaW5nLCB0aWxlRXh0ZW50KSB7XG5cbiAgICAvLyBSZXNhbXBsZSBhIGxpbmUgdG8gZ2V0IGFuY2hvciBwb2ludHMgZm9yIGxhYmVscyBhbmQgY2hlY2sgdGhhdCBlYWNoXG4gICAgLy8gcG90ZW50aWFsIGxhYmVsIHBhc3NlcyB0ZXh0LW1heC1hbmdsZSBjaGVjayBhbmQgaGFzIGVub3VnaCBmcm9vbSB0byBmaXRcbiAgICAvLyBvbiB0aGUgbGluZS5cblxuICAgIHZhciBhbmdsZVdpbmRvd1NpemUgPSBzaGFwZWRUZXh0ID9cbiAgICAgICAgMyAvIDUgKiBnbHlwaFNpemUgKiBib3hTY2FsZSA6XG4gICAgICAgIDA7XG5cbiAgICB2YXIgbGFiZWxMZW5ndGggPSBNYXRoLm1heChcbiAgICAgICAgc2hhcGVkVGV4dCA/IHNoYXBlZFRleHQucmlnaHQgLSBzaGFwZWRUZXh0LmxlZnQgOiAwLFxuICAgICAgICBzaGFwZWRJY29uID8gc2hhcGVkSWNvbi5yaWdodCAtIHNoYXBlZEljb24ubGVmdCA6IDApO1xuXG4gICAgLy8gSXMgdGhlIGxpbmUgY29udGludWVkIGZyb20gb3V0c2lkZSB0aGUgdGlsZSBib3VuZGFyeT9cbiAgICB2YXIgaXNMaW5lQ29udGludWVkID0gbGluZVswXS54ID09PSAwIHx8IGxpbmVbMF0ueCA9PT0gdGlsZUV4dGVudCB8fCBsaW5lWzBdLnkgPT09IDAgfHwgbGluZVswXS55ID09PSB0aWxlRXh0ZW50O1xuXG4gICAgLy8gSXMgdGhlIGxhYmVsIGxvbmcsIHJlbGF0aXZlIHRvIHRoZSBzcGFjaW5nP1xuICAgIC8vIElmIHNvLCBhZGp1c3QgdGhlIHNwYWNpbmcgc28gdGhlcmUgaXMgYWx3YXlzIGEgbWluaW11bSBzcGFjZSBvZiBgc3BhY2luZyAvIDRgIGJldHdlZW4gbGFiZWwgZWRnZXMuXG4gICAgaWYgKHNwYWNpbmcgLSBsYWJlbExlbmd0aCAqIGJveFNjYWxlICA8IHNwYWNpbmcgLyA0KSB7XG4gICAgICAgIHNwYWNpbmcgPSBsYWJlbExlbmd0aCAqIGJveFNjYWxlICsgc3BhY2luZyAvIDQ7XG4gICAgfVxuXG4gICAgLy8gT2Zmc2V0IHRoZSBmaXJzdCBhbmNob3IgYnk6XG4gICAgLy8gRWl0aGVyIGhhbGYgdGhlIGxhYmVsIGxlbmd0aCBwbHVzIGEgZml4ZWQgZXh0cmEgb2Zmc2V0IGlmIHRoZSBsaW5lIGlzIG5vdCBjb250aW51ZWRcbiAgICAvLyBPciBoYWxmIHRoZSBzcGFjaW5nIGlmIHRoZSBsaW5lIGlzIGNvbnRpbnVlZC5cblxuICAgIC8vIEZvciBub24tY29udGludWVkIGxpbmVzLCBhZGQgYSBiaXQgb2YgZml4ZWQgZXh0cmEgb2Zmc2V0IHRvIGF2b2lkIGNvbGxpc2lvbnMgYXQgVCBpbnRlcnNlY3Rpb25zLlxuICAgIHZhciBmaXhlZEV4dHJhT2Zmc2V0ID0gZ2x5cGhTaXplICogMjtcblxuICAgIHZhciBvZmZzZXQgPSAhaXNMaW5lQ29udGludWVkID9cbiAgICAgICAgKChsYWJlbExlbmd0aCAvIDIgKyBmaXhlZEV4dHJhT2Zmc2V0KSAqIGJveFNjYWxlICogb3ZlcnNjYWxpbmcpICUgc3BhY2luZyA6XG4gICAgICAgIChzcGFjaW5nIC8gMiAqIG92ZXJzY2FsaW5nKSAlIHNwYWNpbmc7XG5cbiAgICByZXR1cm4gcmVzYW1wbGUobGluZSwgb2Zmc2V0LCBzcGFjaW5nLCBhbmdsZVdpbmRvd1NpemUsIG1heEFuZ2xlLCBsYWJlbExlbmd0aCAqIGJveFNjYWxlLCBpc0xpbmVDb250aW51ZWQsIGZhbHNlLCB0aWxlRXh0ZW50KTtcbn1cblxuXG5mdW5jdGlvbiByZXNhbXBsZShsaW5lLCBvZmZzZXQsIHNwYWNpbmcsIGFuZ2xlV2luZG93U2l6ZSwgbWF4QW5nbGUsIGxhYmVsTGVuZ3RoLCBpc0xpbmVDb250aW51ZWQsIHBsYWNlQXRNaWRkbGUsIHRpbGVFeHRlbnQpIHtcblxuICAgIHZhciBoYWxmTGFiZWxMZW5ndGggPSBsYWJlbExlbmd0aCAvIDI7XG4gICAgdmFyIGxpbmVMZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGluZS5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgICAgbGluZUxlbmd0aCArPSBsaW5lW2tdLmRpc3QobGluZVtrICsgMV0pO1xuICAgIH1cblxuICAgIHZhciBkaXN0YW5jZSA9IDAsXG4gICAgICAgIG1hcmtlZERpc3RhbmNlID0gb2Zmc2V0IC0gc3BhY2luZztcblxuICAgIHZhciBhbmNob3JzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubGVuZ3RoIC0gMTsgaSsrKSB7XG5cbiAgICAgICAgdmFyIGEgPSBsaW5lW2ldLFxuICAgICAgICAgICAgYiA9IGxpbmVbaSArIDFdO1xuXG4gICAgICAgIHZhciBzZWdtZW50RGlzdCA9IGEuZGlzdChiKSxcbiAgICAgICAgICAgIGFuZ2xlID0gYi5hbmdsZVRvKGEpO1xuXG4gICAgICAgIHdoaWxlIChtYXJrZWREaXN0YW5jZSArIHNwYWNpbmcgPCBkaXN0YW5jZSArIHNlZ21lbnREaXN0KSB7XG4gICAgICAgICAgICBtYXJrZWREaXN0YW5jZSArPSBzcGFjaW5nO1xuXG4gICAgICAgICAgICB2YXIgdCA9IChtYXJrZWREaXN0YW5jZSAtIGRpc3RhbmNlKSAvIHNlZ21lbnREaXN0LFxuICAgICAgICAgICAgICAgIHggPSBpbnRlcnBvbGF0ZShhLngsIGIueCwgdCksXG4gICAgICAgICAgICAgICAgeSA9IGludGVycG9sYXRlKGEueSwgYi55LCB0KTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSB0aWxlIGJvdW5kYXJpZXMgYW5kIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZSBsYWJlbCB3b3VsZCBmaXQgYmVmb3JlIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgbGluZVxuICAgICAgICAgICAgLy8gaWYgcGxhY2VkIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgICAgICBpZiAoeCA+PSAwICYmIHggPCB0aWxlRXh0ZW50ICYmIHkgPj0gMCAmJiB5IDwgdGlsZUV4dGVudCAmJlxuICAgICAgICAgICAgICAgICAgICBtYXJrZWREaXN0YW5jZSAtIGhhbGZMYWJlbExlbmd0aCA+PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlZERpc3RhbmNlICsgaGFsZkxhYmVsTGVuZ3RoIDw9IGxpbmVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5jaG9yID0gbmV3IEFuY2hvcih4LCB5LCBhbmdsZSwgaSkuX3JvdW5kKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWFuZ2xlV2luZG93U2l6ZSB8fCBjaGVja01heEFuZ2xlKGxpbmUsIGFuY2hvciwgbGFiZWxMZW5ndGgsIGFuZ2xlV2luZG93U2l6ZSwgbWF4QW5nbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuY2hvcnMucHVzaChhbmNob3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3RhbmNlICs9IHNlZ21lbnREaXN0O1xuICAgIH1cblxuICAgIGlmICghcGxhY2VBdE1pZGRsZSAmJiAhYW5jaG9ycy5sZW5ndGggJiYgIWlzTGluZUNvbnRpbnVlZCkge1xuICAgICAgICAvLyBUaGUgZmlyc3QgYXR0ZW1wdCBhdCBmaW5kaW5nIGFuY2hvcnMgYXQgd2hpY2ggbGFiZWxzIGNhbiBiZSBwbGFjZWQgZmFpbGVkLlxuICAgICAgICAvLyBUcnkgYWdhaW4sIGJ1dCB0aGlzIHRpbWUganVzdCB0cnkgcGxhY2luZyBvbmUgYW5jaG9yIGF0IHRoZSBtaWRkbGUgb2YgdGhlIGxpbmUuXG4gICAgICAgIC8vIFRoaXMgaGFzIHRoZSBtb3N0IGVmZmVjdCBmb3Igc2hvcnQgbGluZXMgaW4gb3ZlcnNjYWxlZCB0aWxlcywgc2luY2UgdGhlXG4gICAgICAgIC8vIGluaXRpYWwgb2Zmc2V0IHVzZWQgaW4gb3ZlcnNjYWxlZCB0aWxlcyBpcyBjYWxjdWxhdGVkIHRvIGFsaWduIGxhYmVscyB3aXRoIHBvc2l0aW9ucyBpblxuICAgICAgICAvLyBwYXJlbnQgdGlsZXMgaW5zdGVhZCBvZiBwbGFjaW5nIHRoZSBsYWJlbCBhcyBjbG9zZSB0byB0aGUgYmVnaW5uaW5nIGFzIHBvc3NpYmxlLlxuICAgICAgICBhbmNob3JzID0gcmVzYW1wbGUobGluZSwgZGlzdGFuY2UgLyAyLCBzcGFjaW5nLCBhbmdsZVdpbmRvd1NpemUsIG1heEFuZ2xlLCBsYWJlbExlbmd0aCwgaXNMaW5lQ29udGludWVkLCB0cnVlLCB0aWxlRXh0ZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jaG9ycztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNoZWxmUGFjayA9IHJlcXVpcmUoJ3NoZWxmLXBhY2snKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaEF0bGFzO1xuZnVuY3Rpb24gR2x5cGhBdGxhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy5iaW4gPSBuZXcgU2hlbGZQYWNrKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuaW5kZXggPSB7fTtcbiAgICB0aGlzLmlkcyA9IHt9O1xuICAgIHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0KTtcbn1cblxuR2x5cGhBdGxhcy5wcm90b3R5cGUuZ2V0R2x5cGhzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdseXBocyA9IHt9LFxuICAgICAgICBzcGxpdCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgaWQ7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5pZHMpIHtcbiAgICAgICAgc3BsaXQgPSBrZXkuc3BsaXQoJyMnKTtcbiAgICAgICAgbmFtZSA9IHNwbGl0WzBdO1xuICAgICAgICBpZCA9IHNwbGl0WzFdO1xuXG4gICAgICAgIGlmICghZ2x5cGhzW25hbWVdKSBnbHlwaHNbbmFtZV0gPSBbXTtcbiAgICAgICAgZ2x5cGhzW25hbWVdLnB1c2goaWQpO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaHM7XG59O1xuXG5HbHlwaEF0bGFzLnByb3RvdHlwZS5nZXRSZWN0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZWN0cyA9IHt9LFxuICAgICAgICBzcGxpdCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgaWQ7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5pZHMpIHtcbiAgICAgICAgc3BsaXQgPSBrZXkuc3BsaXQoJyMnKTtcbiAgICAgICAgbmFtZSA9IHNwbGl0WzBdO1xuICAgICAgICBpZCA9IHNwbGl0WzFdO1xuXG4gICAgICAgIGlmICghcmVjdHNbbmFtZV0pIHJlY3RzW25hbWVdID0ge307XG4gICAgICAgIHJlY3RzW25hbWVdW2lkXSA9IHRoaXMuaW5kZXhba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjdHM7XG59O1xuXG5cbkdseXBoQXRsYXMucHJvdG90eXBlLmFkZEdseXBoID0gZnVuY3Rpb24oaWQsIG5hbWUsIGdseXBoLCBidWZmZXIpIHtcbiAgICBpZiAoIWdseXBoKSB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignbWlzc2luZyBnbHlwaCcsIGNvZGUsIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGtleSA9IG5hbWUgKyBcIiNcIiArIGdseXBoLmlkO1xuXG4gICAgLy8gVGhlIGdseXBoIGlzIGFscmVhZHkgaW4gdGhpcyB0ZXh0dXJlLlxuICAgIGlmICh0aGlzLmluZGV4W2tleV0pIHtcbiAgICAgICAgaWYgKHRoaXMuaWRzW2tleV0uaW5kZXhPZihpZCkgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLmlkc1trZXldLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4W2tleV07XG4gICAgfVxuXG4gICAgLy8gVGhlIGdseXBoIGJpdG1hcCBoYXMgemVybyB3aWR0aC5cbiAgICBpZiAoIWdseXBoLmJpdG1hcCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYnVmZmVyZWRXaWR0aCA9IGdseXBoLndpZHRoICsgYnVmZmVyICogMjtcbiAgICB2YXIgYnVmZmVyZWRIZWlnaHQgPSBnbHlwaC5oZWlnaHQgKyBidWZmZXIgKiAyO1xuXG4gICAgLy8gQWRkIGEgMXB4IGJvcmRlciBhcm91bmQgZXZlcnkgaW1hZ2UuXG4gICAgdmFyIHBhZGRpbmcgPSAxO1xuICAgIHZhciBwYWNrV2lkdGggPSBidWZmZXJlZFdpZHRoICsgMiAqIHBhZGRpbmc7XG4gICAgdmFyIHBhY2tIZWlnaHQgPSBidWZmZXJlZEhlaWdodCArIDIgKiBwYWRkaW5nO1xuXG4gICAgLy8gSW5jcmVhc2UgdG8gbmV4dCBudW1iZXIgZGl2aXNpYmxlIGJ5IDQsIGJ1dCBhdCBsZWFzdCAxLlxuICAgIC8vIFRoaXMgaXMgc28gd2UgY2FuIHNjYWxlIGRvd24gdGhlIHRleHR1cmUgY29vcmRpbmF0ZXMgYW5kIHBhY2sgdGhlbVxuICAgIC8vIGludG8gMiBieXRlcyByYXRoZXIgdGhhbiA0IGJ5dGVzLlxuICAgIHBhY2tXaWR0aCArPSAoNCAtIHBhY2tXaWR0aCAlIDQpO1xuICAgIHBhY2tIZWlnaHQgKz0gKDQgLSBwYWNrSGVpZ2h0ICUgNCk7XG5cbiAgICB2YXIgcmVjdCA9IHRoaXMuYmluLnBhY2tPbmUocGFja1dpZHRoLCBwYWNrSGVpZ2h0KTtcbiAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgcmVjdCA9IHRoaXMuYmluLnBhY2tPbmUocGFja1dpZHRoLCBwYWNrSGVpZ2h0KTtcbiAgICB9XG4gICAgaWYgKCFyZWN0KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignZ2x5cGggYml0bWFwIG92ZXJmbG93Jyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuaW5kZXhba2V5XSA9IHJlY3Q7XG4gICAgdGhpcy5pZHNba2V5XSA9IFtpZF07XG5cbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5kYXRhO1xuICAgIHZhciBzb3VyY2UgPSBnbHlwaC5iaXRtYXA7XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBidWZmZXJlZEhlaWdodDsgeSsrKSB7XG4gICAgICAgIHZhciB5MSA9IHRoaXMud2lkdGggKiAocmVjdC55ICsgeSArIHBhZGRpbmcpICsgcmVjdC54ICsgcGFkZGluZztcbiAgICAgICAgdmFyIHkyID0gYnVmZmVyZWRXaWR0aCAqIHk7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgYnVmZmVyZWRXaWR0aDsgeCsrKSB7XG4gICAgICAgICAgICB0YXJnZXRbeTEgKyB4XSA9IHNvdXJjZVt5MiArIHhdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICByZXR1cm4gcmVjdDtcbn07XG5cbkdseXBoQXRsYXMucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcmlndyA9IHRoaXMud2lkdGgsXG4gICAgICAgIG9yaWdoID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAvLyBGb3Igbm93LCBkb24ndCBncm93IHRoZSBhdGxhcyBiZXlvbmQgMTAyNHgxMDI0IGJlY2F1c2Ugb2YgaG93XG4gICAgLy8gdGV4dHVyZSBjb29yZHMgcGFjayBpbnRvIHVuc2lnbmVkIGJ5dGUgaW4gc3ltYm9sIGJ1Y2tldC5cbiAgICBpZiAob3JpZ3cgPiA1MTIgfHwgb3JpZ2ggPiA1MTIpIHJldHVybjtcblxuICAgIGlmICh0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2wpIHtcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLnRleHR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy53aWR0aCAqPSAyO1xuICAgIHRoaXMuaGVpZ2h0ICo9IDI7XG4gICAgdGhpcy5iaW4ucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0KSxcbiAgICAgICAgc3JjLCBkc3Q7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmlnaDsgaSsrKSB7XG4gICAgICAgIHNyYyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIG9yaWdoICogaSwgb3JpZ3cpO1xuICAgICAgICBkc3QgPSBuZXcgVWludDhBcnJheShidWYsIG9yaWdoICogaSAqIDIsIG9yaWd3KTtcbiAgICAgICAgZHN0LnNldChzcmMpO1xuICAgIH1cbiAgICB0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheShidWYpO1xufTtcblxuR2x5cGhBdGxhcy5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGdsKSB7XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIGlmICghdGhpcy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuQUxQSEEsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAwLCBnbC5BTFBIQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIH1cbn07XG5cbkdseXBoQXRsYXMucHJvdG90eXBlLnVwZGF0ZVRleHR1cmUgPSBmdW5jdGlvbihnbCkge1xuICAgIHRoaXMuYmluZChnbCk7XG4gICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgZ2wuQUxQSEEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuZGF0YSk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9ybWFsaXplVVJMID0gcmVxdWlyZSgnLi4vdXRpbC9tYXBib3gnKS5ub3JtYWxpemVHbHlwaHNVUkw7XG52YXIgZ2V0QXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuLi91dGlsL2FqYXgnKS5nZXRBcnJheUJ1ZmZlcjtcbnZhciBHbHlwaHMgPSByZXF1aXJlKCcuLi91dGlsL2dseXBocycpO1xudmFyIEdseXBoQXRsYXMgPSByZXF1aXJlKCcuLi9zeW1ib2wvZ2x5cGhfYXRsYXMnKTtcbnZhciBQcm90b2J1ZiA9IHJlcXVpcmUoJ3BiZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdseXBoU291cmNlO1xuXG4vKipcbiAqIEEgZ2x5cGggc291cmNlIGhhcyBhIFVSTCBmcm9tIHdoaWNoIHRvIGxvYWQgbmV3IGdseXBocyBhbmQgbWFuYWdlc1xuICogR2x5cGhBdGxhc2VzIGluIHdoaWNoIHRvIHN0b3JlIGdseXBocyB1c2VkIGJ5IHRoZSByZXF1ZXN0ZWQgZm9udHN0YWNrc1xuICogYW5kIHJhbmdlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIGdseXBoIHRlbXBsYXRlIHVybFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gR2x5cGhTb3VyY2UodXJsKSB7XG4gICAgdGhpcy51cmwgPSB1cmwgJiYgbm9ybWFsaXplVVJMKHVybCk7XG4gICAgdGhpcy5hdGxhc2VzID0ge307XG4gICAgdGhpcy5zdGFja3MgPSB7fTtcbiAgICB0aGlzLmxvYWRpbmcgPSB7fTtcbn1cblxuR2x5cGhTb3VyY2UucHJvdG90eXBlLmdldFNpbXBsZUdseXBocyA9IGZ1bmN0aW9uKGZvbnRzdGFjaywgZ2x5cGhJRHMsIHVpZCwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5zdGFja3NbZm9udHN0YWNrXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc3RhY2tzW2ZvbnRzdGFja10gPSB7fTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXRsYXNlc1tmb250c3RhY2tdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5hdGxhc2VzW2ZvbnRzdGFja10gPSBuZXcgR2x5cGhBdGxhcygxMjgsIDEyOCk7XG4gICAgfVxuXG4gICAgdmFyIGdseXBocyA9IHt9O1xuICAgIHZhciBzdGFjayA9IHRoaXMuc3RhY2tzW2ZvbnRzdGFja107XG4gICAgdmFyIGF0bGFzID0gdGhpcy5hdGxhc2VzW2ZvbnRzdGFja107XG5cbiAgICAvLyB0aGUgbnVtYmVyIG9mIHBpeGVscyB0aGUgc2RmIGJpdG1hcHMgYXJlIHBhZGRlZCBieVxuICAgIHZhciBidWZmZXIgPSAzO1xuXG4gICAgdmFyIG1pc3NpbmcgPSB7fTtcbiAgICB2YXIgcmVtYWluaW5nID0gMDtcbiAgICB2YXIgcmFuZ2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBoSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBnbHlwaElEID0gZ2x5cGhJRHNbaV07XG4gICAgICAgIHJhbmdlID0gTWF0aC5mbG9vcihnbHlwaElEIC8gMjU2KTtcblxuICAgICAgICBpZiAoc3RhY2tbcmFuZ2VdKSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGggPSBzdGFja1tyYW5nZV0uZ2x5cGhzW2dseXBoSURdO1xuICAgICAgICAgICAgdmFyIHJlY3QgID0gYXRsYXMuYWRkR2x5cGgodWlkLCBmb250c3RhY2ssIGdseXBoLCBidWZmZXIpO1xuICAgICAgICAgICAgaWYgKGdseXBoKSBnbHlwaHNbZ2x5cGhJRF0gPSBuZXcgU2ltcGxlR2x5cGgoZ2x5cGgsIHJlY3QsIGJ1ZmZlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobWlzc2luZ1tyYW5nZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1pc3NpbmdbcmFuZ2VdID0gW107XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtaXNzaW5nW3JhbmdlXS5wdXNoKGdseXBoSUQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyZW1haW5pbmcpIGNhbGxiYWNrKHVuZGVmaW5lZCwgZ2x5cGhzLCBmb250c3RhY2spO1xuXG4gICAgdmFyIG9uUmFuZ2VMb2FkZWQgPSBmdW5jdGlvbihlcnIsIHJhbmdlLCBkYXRhKSB7XG4gICAgICAgIC8vIFRPRE8gbm90IGJlIHNpbGVudCBhYm91dCBlcnJvcnNcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMuc3RhY2tzW2ZvbnRzdGFja11bcmFuZ2VdID0gZGF0YS5zdGFja3NbMF07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pc3NpbmdbcmFuZ2VdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdseXBoSUQgPSBtaXNzaW5nW3JhbmdlXVtpXTtcbiAgICAgICAgICAgICAgICB2YXIgZ2x5cGggPSBzdGFjay5nbHlwaHNbZ2x5cGhJRF07XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgID0gYXRsYXMuYWRkR2x5cGgodWlkLCBmb250c3RhY2ssIGdseXBoLCBidWZmZXIpO1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaCkgZ2x5cGhzW2dseXBoSURdID0gbmV3IFNpbXBsZUdseXBoKGdseXBoLCByZWN0LCBidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbWFpbmluZy0tO1xuICAgICAgICBpZiAoIXJlbWFpbmluZykgY2FsbGJhY2sodW5kZWZpbmVkLCBnbHlwaHMsIGZvbnRzdGFjayk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgciBpbiBtaXNzaW5nKSB7XG4gICAgICAgIHRoaXMubG9hZFJhbmdlKGZvbnRzdGFjaywgciwgb25SYW5nZUxvYWRlZCk7XG4gICAgfVxufTtcblxuLy8gQSBzaW1wbGlmaWVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnbHlwaCBjb250YWluaW5nIG9ubHkgdGhlIHByb3BlcnRpZXMgbmVlZGVkIGZvciBzaGFwaW5nLlxuZnVuY3Rpb24gU2ltcGxlR2x5cGgoZ2x5cGgsIHJlY3QsIGJ1ZmZlcikge1xuICAgIHZhciBwYWRkaW5nID0gMTtcbiAgICB0aGlzLmFkdmFuY2UgPSBnbHlwaC5hZHZhbmNlO1xuICAgIHRoaXMubGVmdCA9IGdseXBoLmxlZnQgLSBidWZmZXIgLSBwYWRkaW5nO1xuICAgIHRoaXMudG9wID0gZ2x5cGgudG9wICsgYnVmZmVyICsgcGFkZGluZztcbiAgICB0aGlzLnJlY3QgPSByZWN0O1xufVxuXG5HbHlwaFNvdXJjZS5wcm90b3R5cGUubG9hZFJhbmdlID0gZnVuY3Rpb24oZm9udHN0YWNrLCByYW5nZSwgY2FsbGJhY2spIHtcbiAgICBpZiAocmFuZ2UgKiAyNTYgPiA2NTUzNSkgcmV0dXJuIGNhbGxiYWNrKCdnbHlwaHMgPiA2NTUzNSBub3Qgc3VwcG9ydGVkJyk7XG5cbiAgICBpZiAodGhpcy5sb2FkaW5nW2ZvbnRzdGFja10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxvYWRpbmdbZm9udHN0YWNrXSA9IHt9O1xuICAgIH1cbiAgICB2YXIgbG9hZGluZyA9IHRoaXMubG9hZGluZ1tmb250c3RhY2tdO1xuXG4gICAgaWYgKGxvYWRpbmdbcmFuZ2VdKSB7XG4gICAgICAgIGxvYWRpbmdbcmFuZ2VdLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWRpbmdbcmFuZ2VdID0gW2NhbGxiYWNrXTtcblxuICAgICAgICB2YXIgcmFuZ2VOYW1lID0gKHJhbmdlICogMjU2KSArICctJyArIChyYW5nZSAqIDI1NiArIDI1NSk7XG4gICAgICAgIHZhciB1cmwgPSBnbHlwaFVybChmb250c3RhY2ssIHJhbmdlTmFtZSwgdGhpcy51cmwpO1xuXG4gICAgICAgIGdldEFycmF5QnVmZmVyKHVybCwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGhzID0gIWVyciAmJiBuZXcgR2x5cGhzKG5ldyBQcm90b2J1ZihuZXcgVWludDhBcnJheShkYXRhKSkpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2FkaW5nW3JhbmdlXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxvYWRpbmdbcmFuZ2VdW2ldKGVyciwgcmFuZ2UsIGdseXBocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgbG9hZGluZ1tyYW5nZV07XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbkdseXBoU291cmNlLnByb3RvdHlwZS5nZXRHbHlwaEF0bGFzID0gZnVuY3Rpb24oZm9udHN0YWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuYXRsYXNlc1tmb250c3RhY2tdO1xufTtcblxuLyoqXG4gKiBVc2UgQ05BTUUgc2hhcmRpbmcgdG8gbG9hZCBhIHNwZWNpZmljIGdseXBoIHJhbmdlIG92ZXIgYSByYW5kb21pemVkXG4gKiBidXQgY29uc2lzdGVudCBzdWJkb21haW4uXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udHN0YWNrIGNvbW1hLWpvaW5lZCBmb250c1xuICogQHBhcmFtIHtzdHJpbmd9IHJhbmdlIGNvbW1hLWpvaW5lZCByYW5nZVxuICogQHBhcmFtIHt1cmx9IHVybCB0ZW1wbGF0ZWQgdXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N1YmRvbWFpbnM9YWJjXSBzdWJkb21haW5zIGFzIGEgc3RyaW5nIHdoZXJlIGVhY2ggbGV0dGVyIGlzIG9uZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IGEgdXJsIHRvIGxvYWQgdGhhdCBzZWN0aW9uIG9mIGdseXBoc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2x5cGhVcmwoZm9udHN0YWNrLCByYW5nZSwgdXJsLCBzdWJkb21haW5zKSB7XG4gICAgc3ViZG9tYWlucyA9IHN1YmRvbWFpbnMgfHwgJ2FiYyc7XG5cbiAgICByZXR1cm4gdXJsXG4gICAgICAgIC5yZXBsYWNlKCd7c30nLCBzdWJkb21haW5zW2ZvbnRzdGFjay5sZW5ndGggJSBzdWJkb21haW5zLmxlbmd0aF0pXG4gICAgICAgIC5yZXBsYWNlKCd7Zm9udHN0YWNrfScsIGZvbnRzdGFjaylcbiAgICAgICAgLnJlcGxhY2UoJ3tyYW5nZX0nLCByYW5nZSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZlYXR1cmVzLCB0ZXh0RmVhdHVyZXMsIGdlb21ldHJpZXMpIHtcblxuICAgIHZhciBsZWZ0SW5kZXggPSB7fSxcbiAgICAgICAgcmlnaHRJbmRleCA9IHt9LFxuICAgICAgICBtZXJnZWRGZWF0dXJlcyA9IFtdLFxuICAgICAgICBtZXJnZWRHZW9tID0gW10sXG4gICAgICAgIG1lcmdlZFRleHRzID0gW10sXG4gICAgICAgIG1lcmdlZEluZGV4ID0gMCxcbiAgICAgICAgaztcblxuICAgIGZ1bmN0aW9uIGFkZChrKSB7XG4gICAgICAgIG1lcmdlZEZlYXR1cmVzLnB1c2goZmVhdHVyZXNba10pO1xuICAgICAgICBtZXJnZWRHZW9tLnB1c2goZ2VvbWV0cmllc1trXSk7XG4gICAgICAgIG1lcmdlZFRleHRzLnB1c2godGV4dEZlYXR1cmVzW2tdKTtcbiAgICAgICAgbWVyZ2VkSW5kZXgrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUZyb21SaWdodChsZWZ0S2V5LCByaWdodEtleSwgZ2VvbSkge1xuICAgICAgICB2YXIgaSA9IHJpZ2h0SW5kZXhbbGVmdEtleV07XG4gICAgICAgIGRlbGV0ZSByaWdodEluZGV4W2xlZnRLZXldO1xuICAgICAgICByaWdodEluZGV4W3JpZ2h0S2V5XSA9IGk7XG5cbiAgICAgICAgbWVyZ2VkR2VvbVtpXVswXS5wb3AoKTtcbiAgICAgICAgbWVyZ2VkR2VvbVtpXVswXSA9IG1lcmdlZEdlb21baV1bMF0uY29uY2F0KGdlb21bMF0pO1xuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUZyb21MZWZ0KGxlZnRLZXksIHJpZ2h0S2V5LCBnZW9tKSB7XG4gICAgICAgIHZhciBpID0gbGVmdEluZGV4W3JpZ2h0S2V5XTtcbiAgICAgICAgZGVsZXRlIGxlZnRJbmRleFtyaWdodEtleV07XG4gICAgICAgIGxlZnRJbmRleFtsZWZ0S2V5XSA9IGk7XG5cbiAgICAgICAgbWVyZ2VkR2VvbVtpXVswXS5zaGlmdCgpO1xuICAgICAgICBtZXJnZWRHZW9tW2ldWzBdID0gZ2VvbVswXS5jb25jYXQobWVyZ2VkR2VvbVtpXVswXSk7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEtleSh0ZXh0LCBnZW9tLCBvblJpZ2h0KSB7XG4gICAgICAgIHZhciBwb2ludCA9IG9uUmlnaHQgPyBnZW9tWzBdW2dlb21bMF0ubGVuZ3RoIC0gMV0gOiBnZW9tWzBdWzBdO1xuICAgICAgICByZXR1cm4gdGV4dCArICc6JyArIHBvaW50LnggKyAnOicgKyBwb2ludC55O1xuICAgIH1cblxuICAgIGZvciAoayA9IDA7IGsgPCBmZWF0dXJlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgZ2VvbSA9IGdlb21ldHJpZXNba10sXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dEZlYXR1cmVzW2tdO1xuXG4gICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgYWRkKGspO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVmdEtleSA9IGdldEtleSh0ZXh0LCBnZW9tKSxcbiAgICAgICAgICAgIHJpZ2h0S2V5ID0gZ2V0S2V5KHRleHQsIGdlb20sIHRydWUpO1xuXG4gICAgICAgIGlmICgobGVmdEtleSBpbiByaWdodEluZGV4KSAmJiAocmlnaHRLZXkgaW4gbGVmdEluZGV4KSAmJiAocmlnaHRJbmRleFtsZWZ0S2V5XSAhPT0gbGVmdEluZGV4W3JpZ2h0S2V5XSkpIHtcbiAgICAgICAgICAgIC8vIGZvdW5kIGxpbmVzIHdpdGggdGhlIHNhbWUgdGV4dCBhZGphY2VudCB0byBib3RoIGVuZHMgb2YgdGhlIGN1cnJlbnQgbGluZSwgbWVyZ2UgYWxsIHRocmVlXG4gICAgICAgICAgICB2YXIgaiA9IG1lcmdlRnJvbUxlZnQobGVmdEtleSwgcmlnaHRLZXksIGdlb20pO1xuICAgICAgICAgICAgdmFyIGkgPSBtZXJnZUZyb21SaWdodChsZWZ0S2V5LCByaWdodEtleSwgbWVyZ2VkR2VvbVtqXSk7XG5cbiAgICAgICAgICAgIGRlbGV0ZSBsZWZ0SW5kZXhbbGVmdEtleV07XG4gICAgICAgICAgICBkZWxldGUgcmlnaHRJbmRleFtyaWdodEtleV07XG5cbiAgICAgICAgICAgIHJpZ2h0SW5kZXhbZ2V0S2V5KHRleHQsIG1lcmdlZEdlb21baV0sIHRydWUpXSA9IGk7XG4gICAgICAgICAgICBtZXJnZWRHZW9tW2pdID0gbnVsbDtcblxuICAgICAgICB9IGVsc2UgaWYgKGxlZnRLZXkgaW4gcmlnaHRJbmRleCkge1xuICAgICAgICAgICAgLy8gZm91bmQgbWVyZ2VhYmxlIGxpbmUgYWRqYWNlbnQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjdXJyZW50IGxpbmUsIG1lcmdlXG4gICAgICAgICAgICBtZXJnZUZyb21SaWdodChsZWZ0S2V5LCByaWdodEtleSwgZ2VvbSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChyaWdodEtleSBpbiBsZWZ0SW5kZXgpIHtcbiAgICAgICAgICAgIC8vIGZvdW5kIG1lcmdlYWJsZSBsaW5lIGFkamFjZW50IHRvIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgbGluZSwgbWVyZ2VcbiAgICAgICAgICAgIG1lcmdlRnJvbUxlZnQobGVmdEtleSwgcmlnaHRLZXksIGdlb20pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBhZGphY2VudCBsaW5lcywgYWRkIGFzIGEgbmV3IGl0ZW1cbiAgICAgICAgICAgIGFkZChrKTtcbiAgICAgICAgICAgIGxlZnRJbmRleFtsZWZ0S2V5XSA9IG1lcmdlZEluZGV4IC0gMTtcbiAgICAgICAgICAgIHJpZ2h0SW5kZXhbcmlnaHRLZXldID0gbWVyZ2VkSW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmVhdHVyZXM6IG1lcmdlZEZlYXR1cmVzLFxuICAgICAgICB0ZXh0RmVhdHVyZXM6IG1lcmdlZFRleHRzLFxuICAgICAgICBnZW9tZXRyaWVzOiBtZXJnZWRHZW9tXG4gICAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldEljb25RdWFkczogZ2V0SWNvblF1YWRzLFxuICAgIGdldEdseXBoUXVhZHM6IGdldEdseXBoUXVhZHNcbn07XG5cbnZhciBtaW5TY2FsZSA9IDAuNTsgLy8gdW5kZXJzY2FsZSBieSAxIHpvb20gbGV2ZWxcblxuLyoqXG4gKiBBIHRleHR1cmVkIHF1YWQgZm9yIHJlbmRlcmluZyBhIHNpbmdsZSBpY29uIG9yIGdseXBoLlxuICpcbiAqIFRoZSB6b29tIHJhbmdlIHRoZSBnbHlwaCBjYW4gYmUgc2hvd24gaXMgZGVmaW5lZCBieSBtaW5TY2FsZSBhbmQgbWF4U2NhbGUuXG4gKlxuICogQHBhcmFtIHtQb2ludH0gYW5jaG9yUG9pbnQgdGhlIHBvaW50IHRoZSBzeW1ib2wgaXMgYW5jaG9yZWQgYXJvdW5kXG4gKiBAcGFyYW0ge1BvaW50fSB0bCBUaGUgb2Zmc2V0IG9mIHRoZSB0b3AgbGVmdCBjb3JuZXIgZnJvbSB0aGUgYW5jaG9yLlxuICogQHBhcmFtIHtQb2ludH0gdHIgVGhlIG9mZnNldCBvZiB0aGUgdG9wIHJpZ2h0IGNvcm5lciBmcm9tIHRoZSBhbmNob3IuXG4gKiBAcGFyYW0ge1BvaW50fSBibCBUaGUgb2Zmc2V0IG9mIHRoZSBib3R0b20gbGVmdCBjb3JuZXIgZnJvbSB0aGUgYW5jaG9yLlxuICogQHBhcmFtIHtQb2ludH0gYnIgVGhlIG9mZnNldCBvZiB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lciBmcm9tIHRoZSBhbmNob3IuXG4gKiBAcGFyYW0ge09iamVjdH0gdGV4IFRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIFRoZSBhbmdsZSBvZiB0aGUgbGFiZWwgYXQgaXQncyBjZW50ZXIsIG5vdCB0aGUgYW5nbGUgb2YgdGhpcyBxdWFkLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblNjYWxlIFRoZSBtaW5pbXVtIHNjYWxlLCByZWxhdGl2ZSB0byB0aGUgdGlsZSdzIGludGVuZGVkIHNjYWxlLCB0aGF0IHRoZSBnbHlwaCBjYW4gYmUgc2hvd24gYXQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4U2NhbGUgVGhlIG1heGltdW0gc2NhbGUsIHJlbGF0aXZlIHRvIHRoZSB0aWxlJ3MgaW50ZW5kZWQgc2NhbGUsIHRoYXQgdGhlIGdseXBoIGNhbiBiZSBzaG93biBhdC5cbiAqXG4gKiBAY2xhc3MgU3ltYm9sUXVhZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gU3ltYm9sUXVhZChhbmNob3JQb2ludCwgdGwsIHRyLCBibCwgYnIsIHRleCwgYW5nbGUsIG1pblNjYWxlLCBtYXhTY2FsZSkge1xuICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBhbmNob3JQb2ludDtcbiAgICB0aGlzLnRsID0gdGw7XG4gICAgdGhpcy50ciA9IHRyO1xuICAgIHRoaXMuYmwgPSBibDtcbiAgICB0aGlzLmJyID0gYnI7XG4gICAgdGhpcy50ZXggPSB0ZXg7XG4gICAgdGhpcy5hbmdsZSA9IGFuZ2xlO1xuICAgIHRoaXMubWluU2NhbGUgPSBtaW5TY2FsZTtcbiAgICB0aGlzLm1heFNjYWxlID0gbWF4U2NhbGU7XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBxdWFkcyB1c2VkIGZvciByZW5kZXJpbmcgYW4gaWNvbi5cbiAqXG4gKiBAcGFyYW0ge0FuY2hvcn0gYW5jaG9yXG4gKiBAcGFyYW0ge1Bvc2l0aW9uZWRJY29ufSBzaGFwZWRJY29uXG4gKiBAcGFyYW0ge251bWJlcn0gYm94U2NhbGUgQSBtYWdpYyBudW1iZXIgZm9yIGNvbnZlcnRpbmcgZ2x5cGggbWV0cmljIHVuaXRzIHRvIGdlb21ldHJ5IHVuaXRzLlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxQb2ludD4+fSBsaW5lXG4gKiBAcGFyYW0ge0xheW91dFByb3BlcnRpZXN9IGxheW91dFxuICogQHBhcmFtIHtib29sZWFufSBhbG9uZ0xpbmUgV2hldGhlciB0aGUgaWNvbiBzaG91bGQgYmUgcGxhY2VkIGFsb25nIHRoZSBsaW5lLlxuICogQHJldHVybnMge0FycmF5PFN5bWJvbFF1YWQ+fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0SWNvblF1YWRzKGFuY2hvciwgc2hhcGVkSWNvbiwgYm94U2NhbGUsIGxpbmUsIGxheW91dCwgYWxvbmdMaW5lKSB7XG5cbiAgICB2YXIgcmVjdCA9IHNoYXBlZEljb24uaW1hZ2UucmVjdDtcblxuICAgIHZhciBib3JkZXIgPSAxO1xuICAgIHZhciBsZWZ0ID0gc2hhcGVkSWNvbi5sZWZ0IC0gYm9yZGVyO1xuICAgIHZhciByaWdodCA9IGxlZnQgKyByZWN0LncgLyBzaGFwZWRJY29uLmltYWdlLnBpeGVsUmF0aW87XG4gICAgdmFyIHRvcCA9IHNoYXBlZEljb24udG9wIC0gYm9yZGVyO1xuICAgIHZhciBib3R0b20gPSB0b3AgKyByZWN0LmggLyBzaGFwZWRJY29uLmltYWdlLnBpeGVsUmF0aW87XG4gICAgdmFyIHRsID0gbmV3IFBvaW50KGxlZnQsIHRvcCk7XG4gICAgdmFyIHRyID0gbmV3IFBvaW50KHJpZ2h0LCB0b3ApO1xuICAgIHZhciBiciA9IG5ldyBQb2ludChyaWdodCwgYm90dG9tKTtcbiAgICB2YXIgYmwgPSBuZXcgUG9pbnQobGVmdCwgYm90dG9tKTtcblxuICAgIHZhciBhbmdsZSA9IGxheW91dFsnaWNvbi1yb3RhdGUnXSAqIE1hdGguUEkgLyAxODA7XG4gICAgaWYgKGFsb25nTGluZSkge1xuICAgICAgICB2YXIgcHJldiA9IGxpbmVbYW5jaG9yLnNlZ21lbnRdO1xuICAgICAgICBpZiAoYW5jaG9yLnkgPT09IHByZXYueSAmJiBhbmNob3IueCA9PT0gcHJldi54ICYmIGFuY2hvci5zZWdtZW50ICsgMSA8IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGxpbmVbYW5jaG9yLnNlZ21lbnQgKyAxXTtcbiAgICAgICAgICAgIGFuZ2xlICs9IE1hdGguYXRhbjIoYW5jaG9yLnkgLSBuZXh0LnksIGFuY2hvci54IC0gbmV4dC54KSArIE1hdGguUEk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmdsZSArPSBNYXRoLmF0YW4yKGFuY2hvci55IC0gcHJldi55LCBhbmNob3IueCAtIHByZXYueCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgIG1hdHJpeCA9IFtjb3MsIC1zaW4sIHNpbiwgY29zXTtcblxuICAgICAgICB0bCA9IHRsLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgdHIgPSB0ci5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgIGJsID0gYmwubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICBiciA9IGJyLm1hdE11bHQobWF0cml4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gW25ldyBTeW1ib2xRdWFkKG5ldyBQb2ludChhbmNob3IueCwgYW5jaG9yLnkpLCB0bCwgdHIsIGJsLCBiciwgc2hhcGVkSWNvbi5pbWFnZS5yZWN0LCAwLCBtaW5TY2FsZSwgSW5maW5pdHkpXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgdGhlIHF1YWRzIHVzZWQgZm9yIHJlbmRlcmluZyBhIHRleHQgbGFiZWwuXG4gKlxuICogQHBhcmFtIHtBbmNob3J9IGFuY2hvclxuICogQHBhcmFtIHtTaGFwaW5nfSBzaGFwaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gYm94U2NhbGUgQSBtYWdpYyBudW1iZXIgZm9yIGNvbnZlcnRpbmcgZnJvbSBnbHlwaCBtZXRyaWMgdW5pdHMgdG8gZ2VvbWV0cnkgdW5pdHMuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PFBvaW50Pj59IGxpbmVcbiAqIEBwYXJhbSB7TGF5b3V0UHJvcGVydGllc30gbGF5b3V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsb25nTGluZSBXaGV0aGVyIHRoZSBsYWJlbCBzaG91bGQgYmUgcGxhY2VkIGFsb25nIHRoZSBsaW5lLlxuICogQHJldHVybnMge0FycmF5PFN5bWJvbFF1YWQ+fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0R2x5cGhRdWFkcyhhbmNob3IsIHNoYXBpbmcsIGJveFNjYWxlLCBsaW5lLCBsYXlvdXQsIGFsb25nTGluZSkge1xuXG4gICAgdmFyIHRleHRSb3RhdGUgPSBsYXlvdXRbJ3RleHQtcm90YXRlJ10gKiBNYXRoLlBJIC8gMTgwO1xuICAgIHZhciBrZWVwVXByaWdodCA9IGxheW91dFsndGV4dC1rZWVwLXVwcmlnaHQnXTtcblxuICAgIHZhciBwb3NpdGlvbmVkR2x5cGhzID0gc2hhcGluZy5wb3NpdGlvbmVkR2x5cGhzO1xuICAgIHZhciBxdWFkcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBwb3NpdGlvbmVkR2x5cGhzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbmVkR2x5cGggPSBwb3NpdGlvbmVkR2x5cGhzW2tdO1xuICAgICAgICB2YXIgZ2x5cGggPSBwb3NpdGlvbmVkR2x5cGguZ2x5cGg7XG4gICAgICAgIHZhciByZWN0ID0gZ2x5cGgucmVjdDtcblxuICAgICAgICBpZiAoIXJlY3QpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBjZW50ZXJYID0gKHBvc2l0aW9uZWRHbHlwaC54ICsgZ2x5cGguYWR2YW5jZSAvIDIpICogYm94U2NhbGU7XG5cbiAgICAgICAgdmFyIGdseXBoSW5zdGFuY2VzO1xuICAgICAgICB2YXIgbGFiZWxNaW5TY2FsZSA9IG1pblNjYWxlO1xuICAgICAgICBpZiAoYWxvbmdMaW5lKSB7XG4gICAgICAgICAgICBnbHlwaEluc3RhbmNlcyA9IFtdO1xuICAgICAgICAgICAgbGFiZWxNaW5TY2FsZSA9IGdldFNlZ21lbnRHbHlwaHMoZ2x5cGhJbnN0YW5jZXMsIGFuY2hvciwgY2VudGVyWCwgbGluZSwgYW5jaG9yLnNlZ21lbnQsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGtlZXBVcHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgbGFiZWxNaW5TY2FsZSA9IE1hdGgubWluKGxhYmVsTWluU2NhbGUsIGdldFNlZ21lbnRHbHlwaHMoZ2x5cGhJbnN0YW5jZXMsIGFuY2hvciwgY2VudGVyWCwgbGluZSwgYW5jaG9yLnNlZ21lbnQsIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdseXBoSW5zdGFuY2VzID0gW3tcbiAgICAgICAgICAgICAgICBhbmNob3JQb2ludDogbmV3IFBvaW50KGFuY2hvci54LCBhbmNob3IueSksXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgIGFuZ2xlOiAwLFxuICAgICAgICAgICAgICAgIG1heFNjYWxlOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBtaW5TY2FsZTogbWluU2NhbGVcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHgxID0gcG9zaXRpb25lZEdseXBoLnggKyBnbHlwaC5sZWZ0LFxuICAgICAgICAgICAgeTEgPSBwb3NpdGlvbmVkR2x5cGgueSAtIGdseXBoLnRvcCxcbiAgICAgICAgICAgIHgyID0geDEgKyByZWN0LncsXG4gICAgICAgICAgICB5MiA9IHkxICsgcmVjdC5oLFxuXG4gICAgICAgICAgICBvdGwgPSBuZXcgUG9pbnQoeDEsIHkxKSxcbiAgICAgICAgICAgIG90ciA9IG5ldyBQb2ludCh4MiwgeTEpLFxuICAgICAgICAgICAgb2JsID0gbmV3IFBvaW50KHgxLCB5MiksXG4gICAgICAgICAgICBvYnIgPSBuZXcgUG9pbnQoeDIsIHkyKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBoSW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGdseXBoSW5zdGFuY2VzW2ldLFxuICAgICAgICAgICAgICAgIHRsID0gb3RsLFxuICAgICAgICAgICAgICAgIHRyID0gb3RyLFxuICAgICAgICAgICAgICAgIGJsID0gb2JsLFxuICAgICAgICAgICAgICAgIGJyID0gb2JyLFxuICAgICAgICAgICAgICAgIGFuZ2xlID0gaW5zdGFuY2UuYW5nbGUgKyB0ZXh0Um90YXRlO1xuXG4gICAgICAgICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeCA9IFtjb3MsIC1zaW4sIHNpbiwgY29zXTtcblxuICAgICAgICAgICAgICAgIHRsID0gdGwubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICAgICAgICAgIHRyID0gdHIubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICAgICAgICAgIGJsID0gYmwubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICAgICAgICAgIGJyID0gYnIubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcmV2ZW50IGxhYmVsIGZyb20gZXh0ZW5kaW5nIHBhc3QgdGhlIGVuZCBvZiB0aGUgbGluZVxuICAgICAgICAgICAgdmFyIGdseXBoTWluU2NhbGUgPSBNYXRoLm1heChpbnN0YW5jZS5taW5TY2FsZSwgbGFiZWxNaW5TY2FsZSk7XG5cbiAgICAgICAgICAgIHZhciBnbHlwaEFuZ2xlID0gKGFuY2hvci5hbmdsZSArIHRleHRSb3RhdGUgKyBpbnN0YW5jZS5vZmZzZXQgKyAyICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgcXVhZHMucHVzaChuZXcgU3ltYm9sUXVhZChpbnN0YW5jZS5hbmNob3JQb2ludCwgdGwsIHRyLCBibCwgYnIsIHJlY3QsIGdseXBoQW5nbGUsIGdseXBoTWluU2NhbGUsIGluc3RhbmNlLm1heFNjYWxlKSk7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBxdWFkcztcbn1cblxuLyoqXG4gKiBXZSBjYW4gb25seSByZW5kZXIgZ2x5cGggcXVhZHMgdGhhdCBzbGlkZSBhbG9uZyBhIHN0cmFpZ2h0IGxpbmUuIFRvIGRyYXdcbiAqIGN1cnZlZCBsaW5lcyB3ZSBuZWVkIGFuIGluc3RhbmNlIG9mIGEgZ2x5cGggZm9yIGVhY2ggc2VnbWVudCBpdCBhcHBlYXJzIG9uLlxuICogVGhpcyBjcmVhdGVzIGFsbCB0aGUgaW5zdGFuY2VzIG9mIGEgZ2x5cGggdGhhdCBhcmUgbmVjZXNzYXJ5IHRvIHJlbmRlciBhIGxhYmVsLlxuICpcbiAqIFdlIG5lZWQgYVxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBnbHlwaEluc3RhbmNlcyBBbiBlbXB0eSBhcnJheSB0aGF0IGdseXBoSW5zdGFuY2VzIGFyZSBhZGRlZCB0by5cbiAqIEBwYXJhbSB7QW5jaG9yfSBhbmNob3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIGdseXBoJ3Mgb2Zmc2V0IGZyb20gdGhlIGNlbnRlciBvZiB0aGUgbGFiZWwuXG4gKiBAcGFyYW0ge0FycmF5PFBvaW50Pn0gbGluZVxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQgVGhlIGluZGV4IG9mIHRoZSBzZWdtZW50IG9mIHRoZSBsaW5lIG9uIHdoaWNoIHRoZSBhbmNob3IgZXhpc3RzLlxuICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkIElmIHRydWUgZ2V0IHRoZSBnbHlwaHMgdGhhdCBjb21lIGxhdGVyIG9uIHRoZSBsaW5lLCBvdGhlcndpc2UgZ2V0IHRoZSBnbHlwaHMgdGhhdCBjb21lIGVhcmxpZXIuXG4gKlxuICogQHJldHVybnMge0FycmF5PE9iamVjdD59IGdseXBoSW5zdGFuY2VzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRTZWdtZW50R2x5cGhzKGdseXBocywgYW5jaG9yLCBvZmZzZXQsIGxpbmUsIHNlZ21lbnQsIGZvcndhcmQpIHtcbiAgICB2YXIgdXBzaWRlRG93biA9ICFmb3J3YXJkO1xuXG4gICAgaWYgKG9mZnNldCA8IDApIGZvcndhcmQgPSAhZm9yd2FyZDtcblxuICAgIGlmIChmb3J3YXJkKSBzZWdtZW50Kys7XG5cbiAgICB2YXIgbmV3QW5jaG9yUG9pbnQgPSBuZXcgUG9pbnQoYW5jaG9yLngsIGFuY2hvci55KTtcbiAgICB2YXIgZW5kID0gbGluZVtzZWdtZW50XTtcbiAgICB2YXIgcHJldlNjYWxlID0gSW5maW5pdHk7XG5cbiAgICBvZmZzZXQgPSBNYXRoLmFicyhvZmZzZXQpO1xuXG4gICAgdmFyIHBsYWNlbWVudFNjYWxlID0gbWluU2NhbGU7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBuZXdBbmNob3JQb2ludC5kaXN0KGVuZCk7XG4gICAgICAgIHZhciBzY2FsZSA9IG9mZnNldCAvIGRpc3RhbmNlO1xuXG4gICAgICAgIC8vIEdldCB0aGUgYW5nbGUgb2YgdGhlIGxpbmUgc2VnbWVudFxuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKGVuZC55IC0gbmV3QW5jaG9yUG9pbnQueSwgZW5kLnggLSBuZXdBbmNob3JQb2ludC54KTtcbiAgICAgICAgaWYgKCFmb3J3YXJkKSBhbmdsZSArPSBNYXRoLlBJO1xuICAgICAgICBpZiAodXBzaWRlRG93bikgYW5nbGUgKz0gTWF0aC5QSTtcblxuICAgICAgICBnbHlwaHMucHVzaCh7XG4gICAgICAgICAgICBhbmNob3JQb2ludDogbmV3QW5jaG9yUG9pbnQsXG4gICAgICAgICAgICBvZmZzZXQ6IHVwc2lkZURvd24gPyBNYXRoLlBJIDogMCxcbiAgICAgICAgICAgIG1pblNjYWxlOiBzY2FsZSxcbiAgICAgICAgICAgIG1heFNjYWxlOiBwcmV2U2NhbGUsXG4gICAgICAgICAgICBhbmdsZTogKGFuZ2xlICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2NhbGUgPD0gcGxhY2VtZW50U2NhbGUpIGJyZWFrO1xuXG4gICAgICAgIG5ld0FuY2hvclBvaW50ID0gZW5kO1xuXG4gICAgICAgIC8vIHNraXAgZHVwbGljYXRlIG5vZGVzXG4gICAgICAgIHdoaWxlIChuZXdBbmNob3JQb2ludC5lcXVhbHMoZW5kKSkge1xuICAgICAgICAgICAgc2VnbWVudCArPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgICAgICAgICAgZW5kID0gbGluZVtzZWdtZW50XTtcbiAgICAgICAgICAgIGlmICghZW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVuaXQgPSBlbmQuc3ViKG5ld0FuY2hvclBvaW50KS5fdW5pdCgpO1xuICAgICAgICBuZXdBbmNob3JQb2ludCA9IG5ld0FuY2hvclBvaW50LnN1Yih1bml0Ll9tdWx0KGRpc3RhbmNlKSk7XG5cbiAgICAgICAgcHJldlNjYWxlID0gc2NhbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBsYWNlbWVudFNjYWxlO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVzb2x2ZVRva2VucyA9IHJlcXVpcmUoJy4uL3V0aWwvdG9rZW4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlVGV4dDtcblxuLyoqXG4gKiBGb3IgYW4gYXJyYXkgb2YgZmVhdHVyZXMgZGV0ZXJtaW5lIHdoYXQgZ2x5cGhzIG5lZWQgdG8gYmUgbG9hZGVkXG4gKiBhbmQgYXBwbHkgYW55IHRleHQgcHJlcHJvY2Vzc2luZy4gVGhlIHJlbWFpbmluZyB1c2VycyBvZiB0ZXh0IHNob3VsZFxuICogdXNlIHRoZSBgdGV4dEZlYXR1cmVzYCBrZXkgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiBhY2Nlc3NpbmdcbiAqIGZlYXR1cmUgdGV4dCBkaXJlY3RseS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVUZXh0KGZlYXR1cmVzLCBsYXlvdXRQcm9wZXJ0aWVzLCBjb2RlcG9pbnRzKSB7XG4gICAgdmFyIHRleHRGZWF0dXJlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGZsID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgZmw7IGkrKykge1xuICAgICAgICB2YXIgdGV4dCA9IHJlc29sdmVUb2tlbnMoZmVhdHVyZXNbaV0ucHJvcGVydGllcywgbGF5b3V0UHJvcGVydGllc1sndGV4dC1maWVsZCddKTtcbiAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICB0ZXh0RmVhdHVyZXNbaV0gPSBudWxsO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IHRleHQudG9TdHJpbmcoKTtcblxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gbGF5b3V0UHJvcGVydGllc1sndGV4dC10cmFuc2Zvcm0nXTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSA9PT0gJ3VwcGVyY2FzZScpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRvTG9jYWxlVXBwZXJDYXNlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtID09PSAnbG93ZXJjYXNlJykge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29kZXBvaW50c1t0ZXh0LmNoYXJDb2RlQXQoaildID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYWNrIGluZGV4ZXMgb2YgZmVhdHVyZXMgd2l0aCB0ZXh0LlxuICAgICAgICB0ZXh0RmVhdHVyZXNbaV0gPSB0ZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0RmVhdHVyZXM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHNoYXBlVGV4dDogc2hhcGVUZXh0LFxuICAgIHNoYXBlSWNvbjogc2hhcGVJY29uXG59O1xuXG5cbi8vIFRoZSBwb3NpdGlvbiBvZiBhIGdseXBoIHJlbGF0aXZlIHRvIHRoZSB0ZXh0J3MgYW5jaG9yIHBvaW50LlxuZnVuY3Rpb24gUG9zaXRpb25lZEdseXBoKGNvZGVQb2ludCwgeCwgeSwgZ2x5cGgpIHtcbiAgICB0aGlzLmNvZGVQb2ludCA9IGNvZGVQb2ludDtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy5nbHlwaCA9IGdseXBoO1xufVxuXG4vLyBBIGNvbGxlY3Rpb24gb2YgcG9zaXRpb25lZCBnbHlwaHMgYW5kIHNvbWUgbWV0YWRhdGFcbmZ1bmN0aW9uIFNoYXBpbmcocG9zaXRpb25lZEdseXBocywgdGV4dCwgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0KSB7XG4gICAgdGhpcy5wb3NpdGlvbmVkR2x5cGhzID0gcG9zaXRpb25lZEdseXBocztcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMudG9wID0gdG9wO1xuICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xufVxuXG5mdW5jdGlvbiBzaGFwZVRleHQodGV4dCwgZ2x5cGhzLCBtYXhXaWR0aCwgbGluZUhlaWdodCwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBqdXN0aWZ5LCBzcGFjaW5nLCB0cmFuc2xhdGUpIHtcblxuICAgIHZhciBwb3NpdGlvbmVkR2x5cGhzID0gW107XG4gICAgdmFyIHNoYXBpbmcgPSBuZXcgU2hhcGluZyhwb3NpdGlvbmVkR2x5cGhzLCB0ZXh0LCB0cmFuc2xhdGVbMV0sIHRyYW5zbGF0ZVsxXSwgdHJhbnNsYXRlWzBdLCB0cmFuc2xhdGVbMF0pO1xuXG4gICAgLy8gdGhlIHkgb2Zmc2V0ICpzaG91bGQqIGJlIHBhcnQgb2YgdGhlIGZvbnQgbWV0YWRhdGFcbiAgICB2YXIgeU9mZnNldCA9IC0xNztcblxuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeSA9IHlPZmZzZXQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGVQb2ludCA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2NvZGVQb2ludF07XG5cbiAgICAgICAgaWYgKCFnbHlwaCkgY29udGludWU7XG5cbiAgICAgICAgcG9zaXRpb25lZEdseXBocy5wdXNoKG5ldyBQb3NpdGlvbmVkR2x5cGgoY29kZVBvaW50LCB4LCB5LCBnbHlwaCkpO1xuICAgICAgICB4ICs9IGdseXBoLmFkdmFuY2UgKyBzcGFjaW5nO1xuICAgIH1cblxuICAgIGlmICghcG9zaXRpb25lZEdseXBocy5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGxpbmV3cmFwKHNoYXBpbmcsIGdseXBocywgbGluZUhlaWdodCwgbWF4V2lkdGgsIGhvcml6b250YWxBbGlnbiwgdmVydGljYWxBbGlnbiwganVzdGlmeSwgdHJhbnNsYXRlKTtcblxuICAgIHJldHVybiBzaGFwaW5nO1xufVxuXG52YXIgaW52aXNpYmxlID0ge1xuICAgIDB4MjA6ICAgdHJ1ZSwgLy8gc3BhY2VcbiAgICAweDIwMGI6IHRydWUgIC8vIHplcm8td2lkdGggc3BhY2Vcbn07XG5cbnZhciBicmVha2FibGUgPSB7XG4gICAgMHgyMDogICB0cnVlLCAvLyBzcGFjZVxuICAgIDB4MjY6ICAgdHJ1ZSwgLy8gYW1wZXJzYW5kXG4gICAgMHgyYjogICB0cnVlLCAvLyBwbHVzIHNpZ25cbiAgICAweDJkOiAgIHRydWUsIC8vIGh5cGhlbi1taW51c1xuICAgIDB4MmY6ICAgdHJ1ZSwgLy8gc29saWR1c1xuICAgIDB4YWQ6ICAgdHJ1ZSwgLy8gc29mdCBoeXBoZW5cbiAgICAweGI3OiAgIHRydWUsIC8vIG1pZGRsZSBkb3RcbiAgICAweDIwMGI6IHRydWUsIC8vIHplcm8td2lkdGggc3BhY2VcbiAgICAweDIwMTA6IHRydWUsIC8vIGh5cGhlblxuICAgIDB4MjAxMzogdHJ1ZSAgLy8gZW4gZGFzaFxufTtcblxuZnVuY3Rpb24gbGluZXdyYXAoc2hhcGluZywgZ2x5cGhzLCBsaW5lSGVpZ2h0LCBtYXhXaWR0aCwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBqdXN0aWZ5LCB0cmFuc2xhdGUpIHtcbiAgICB2YXIgbGFzdFNhZmVCcmVhayA9IG51bGw7XG5cbiAgICB2YXIgbGVuZ3RoQmVmb3JlQ3VycmVudExpbmUgPSAwO1xuICAgIHZhciBsaW5lU3RhcnRJbmRleCA9IDA7XG4gICAgdmFyIGxpbmUgPSAwO1xuXG4gICAgdmFyIG1heExpbmVMZW5ndGggPSAwO1xuXG4gICAgdmFyIHBvc2l0aW9uZWRHbHlwaHMgPSBzaGFwaW5nLnBvc2l0aW9uZWRHbHlwaHM7XG5cbiAgICBpZiAobWF4V2lkdGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3NpdGlvbmVkR2x5cGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25lZEdseXBoID0gcG9zaXRpb25lZEdseXBoc1tpXTtcblxuICAgICAgICAgICAgcG9zaXRpb25lZEdseXBoLnggLT0gbGVuZ3RoQmVmb3JlQ3VycmVudExpbmU7XG4gICAgICAgICAgICBwb3NpdGlvbmVkR2x5cGgueSArPSBsaW5lSGVpZ2h0ICogbGluZTtcblxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uZWRHbHlwaC54ID4gbWF4V2lkdGggJiYgbGFzdFNhZmVCcmVhayAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBwb3NpdGlvbmVkR2x5cGhzW2xhc3RTYWZlQnJlYWsgKyAxXS54O1xuICAgICAgICAgICAgICAgIG1heExpbmVMZW5ndGggPSBNYXRoLm1heChsaW5lTGVuZ3RoLCBtYXhMaW5lTGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSBsYXN0U2FmZUJyZWFrICsgMTsgayA8PSBpOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25lZEdseXBoc1trXS55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uZWRHbHlwaHNba10ueCAtPSBsaW5lTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChqdXN0aWZ5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbGxhcHNlIGludmlzaWJsZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZUVuZCA9IGxhc3RTYWZlQnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnZpc2libGVbcG9zaXRpb25lZEdseXBoc1tsYXN0U2FmZUJyZWFrXS5jb2RlUG9pbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lRW5kLS07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5TGluZShwb3NpdGlvbmVkR2x5cGhzLCBnbHlwaHMsIGxpbmVTdGFydEluZGV4LCBsaW5lRW5kLCBqdXN0aWZ5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsaW5lU3RhcnRJbmRleCA9IGxhc3RTYWZlQnJlYWsgKyAxO1xuICAgICAgICAgICAgICAgIGxhc3RTYWZlQnJlYWsgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxlbmd0aEJlZm9yZUN1cnJlbnRMaW5lICs9IGxpbmVMZW5ndGg7XG4gICAgICAgICAgICAgICAgbGluZSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYnJlYWthYmxlW3Bvc2l0aW9uZWRHbHlwaC5jb2RlUG9pbnRdKSB7XG4gICAgICAgICAgICAgICAgbGFzdFNhZmVCcmVhayA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFzdFBvc2l0aW9uZWRHbHlwaCA9IHBvc2l0aW9uZWRHbHlwaHNbcG9zaXRpb25lZEdseXBocy5sZW5ndGggLSAxXTtcbiAgICB2YXIgbGFzdExpbmVMZW5ndGggPSBsYXN0UG9zaXRpb25lZEdseXBoLnggKyBnbHlwaHNbbGFzdFBvc2l0aW9uZWRHbHlwaC5jb2RlUG9pbnRdLmFkdmFuY2U7XG4gICAgbWF4TGluZUxlbmd0aCA9IE1hdGgubWF4KG1heExpbmVMZW5ndGgsIGxhc3RMaW5lTGVuZ3RoKTtcblxuICAgIHZhciBoZWlnaHQgPSAobGluZSArIDEpICogbGluZUhlaWdodDtcblxuICAgIGp1c3RpZnlMaW5lKHBvc2l0aW9uZWRHbHlwaHMsIGdseXBocywgbGluZVN0YXJ0SW5kZXgsIHBvc2l0aW9uZWRHbHlwaHMubGVuZ3RoIC0gMSwganVzdGlmeSk7XG4gICAgYWxpZ24ocG9zaXRpb25lZEdseXBocywganVzdGlmeSwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBtYXhMaW5lTGVuZ3RoLCBsaW5lSGVpZ2h0LCBsaW5lLCB0cmFuc2xhdGUpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBib3VuZGluZyBib3hcbiAgICBzaGFwaW5nLnRvcCArPSAtdmVydGljYWxBbGlnbiAqIGhlaWdodDtcbiAgICBzaGFwaW5nLmJvdHRvbSA9IHNoYXBpbmcudG9wICsgaGVpZ2h0O1xuICAgIHNoYXBpbmcubGVmdCArPSAtaG9yaXpvbnRhbEFsaWduICogbWF4TGluZUxlbmd0aDtcbiAgICBzaGFwaW5nLnJpZ2h0ID0gc2hhcGluZy5sZWZ0ICsgbWF4TGluZUxlbmd0aDtcbn1cblxuZnVuY3Rpb24ganVzdGlmeUxpbmUocG9zaXRpb25lZEdseXBocywgZ2x5cGhzLCBzdGFydCwgZW5kLCBqdXN0aWZ5KSB7XG4gICAgdmFyIGxhc3RBZHZhbmNlID0gZ2x5cGhzW3Bvc2l0aW9uZWRHbHlwaHNbZW5kXS5jb2RlUG9pbnRdLmFkdmFuY2U7XG4gICAgdmFyIGxpbmVJbmRlbnQgPSAocG9zaXRpb25lZEdseXBoc1tlbmRdLnggKyBsYXN0QWR2YW5jZSkgKiBqdXN0aWZ5O1xuXG4gICAgZm9yICh2YXIgaiA9IHN0YXJ0OyBqIDw9IGVuZDsgaisrKSB7XG4gICAgICAgIHBvc2l0aW9uZWRHbHlwaHNbal0ueCAtPSBsaW5lSW5kZW50O1xuICAgIH1cblxufVxuXG5mdW5jdGlvbiBhbGlnbihwb3NpdGlvbmVkR2x5cGhzLCBqdXN0aWZ5LCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIG1heExpbmVMZW5ndGgsIGxpbmVIZWlnaHQsIGxpbmUsIHRyYW5zbGF0ZSkge1xuICAgIHZhciBzaGlmdFggPSAoanVzdGlmeSAtIGhvcml6b250YWxBbGlnbikgKiBtYXhMaW5lTGVuZ3RoICsgdHJhbnNsYXRlWzBdO1xuICAgIHZhciBzaGlmdFkgPSAoLXZlcnRpY2FsQWxpZ24gKiAobGluZSArIDEpICsgMC41KSAqIGxpbmVIZWlnaHQgKyB0cmFuc2xhdGVbMV07XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvc2l0aW9uZWRHbHlwaHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcG9zaXRpb25lZEdseXBoc1tqXS54ICs9IHNoaWZ0WDtcbiAgICAgICAgcG9zaXRpb25lZEdseXBoc1tqXS55ICs9IHNoaWZ0WTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gc2hhcGVJY29uKGltYWdlLCBsYXlvdXQpIHtcbiAgICBpZiAoIWltYWdlIHx8ICFpbWFnZS5yZWN0KSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBkeCA9IGxheW91dFsnaWNvbi1vZmZzZXQnXVswXTtcbiAgICB2YXIgZHkgPSBsYXlvdXRbJ2ljb24tb2Zmc2V0J11bMV07XG4gICAgdmFyIHgxID0gZHggLSBpbWFnZS53aWR0aCAvIDI7XG4gICAgdmFyIHgyID0geDEgKyBpbWFnZS53aWR0aDtcbiAgICB2YXIgeTEgPSBkeSAtIGltYWdlLmhlaWdodCAvIDI7XG4gICAgdmFyIHkyID0geTEgKyBpbWFnZS5oZWlnaHQ7XG5cbiAgICByZXR1cm4gbmV3IFBvc2l0aW9uZWRJY29uKGltYWdlLCB5MSwgeTIsIHgxLCB4Mik7XG59XG5cbmZ1bmN0aW9uIFBvc2l0aW9uZWRJY29uKGltYWdlLCB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQpIHtcbiAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgdGhpcy50b3AgPSB0b3A7XG4gICAgdGhpcy5ib3R0b20gPSBib3R0b207XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBTaGVsZlBhY2sgPSByZXF1aXJlKCdzaGVsZi1wYWNrJyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZUF0bGFzO1xuZnVuY3Rpb24gU3ByaXRlQXRsYXMod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIHRoaXMuYmluID0gbmV3IFNoZWxmUGFjayh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmltYWdlcyA9IHt9O1xuICAgIHRoaXMuZGF0YSA9IGZhbHNlO1xuICAgIHRoaXMudGV4dHVyZSA9IDA7IC8vIFdlYkdMIElEXG4gICAgdGhpcy5maWx0ZXIgPSAwOyAvLyBXZWJHTCBJRFxuICAgIHRoaXMucGl4ZWxSYXRpbyA9IDE7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvcHlCaXRtYXAoc3JjLCBzcmNTdHJpZGUsIHNyY1gsIHNyY1ksIGRzdCwgZHN0U3RyaWRlLCBkc3RYLCBkc3RZLCB3aWR0aCwgaGVpZ2h0LCB3cmFwKSB7XG4gICAgdmFyIHNyY0kgPSBzcmNZICogc3JjU3RyaWRlICsgc3JjWDtcbiAgICB2YXIgZHN0SSA9IGRzdFkgKiBkc3RTdHJpZGUgKyBkc3RYO1xuICAgIHZhciB4LCB5O1xuXG4gICAgaWYgKHdyYXApIHtcbiAgICAgICAgLy8gYWRkIDEgcGl4ZWwgd3JhcHBlZCBwYWRkaW5nIG9uIGVhY2ggc2lkZSBvZiB0aGUgaW1hZ2VcbiAgICAgICAgZHN0SSAtPSBkc3RTdHJpZGU7XG4gICAgICAgIGZvciAoeSA9IC0xOyB5IDw9IGhlaWdodDsgeSsrLCBzcmNJID0gKCh5ICsgaGVpZ2h0KSAlIGhlaWdodCArIHNyY1kpICogc3JjU3RyaWRlICsgc3JjWCwgZHN0SSArPSBkc3RTdHJpZGUpIHtcbiAgICAgICAgICAgIGZvciAoeCA9IC0xOyB4IDw9IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBkc3RbZHN0SSArIHhdID0gc3JjW3NyY0kgKyAoKHggKyB3aWR0aCkgJSB3aWR0aCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyssIHNyY0kgKz0gc3JjU3RyaWRlLCBkc3RJICs9IGRzdFN0cmlkZSkge1xuICAgICAgICAgICAgZm9yICh4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBkc3RbZHN0SSArIHhdID0gc3JjW3NyY0kgKyB4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuU3ByaXRlQXRsYXMucHJvdG90eXBlLmFsbG9jYXRlSW1hZ2UgPSBmdW5jdGlvbihwaXhlbFdpZHRoLCBwaXhlbEhlaWdodCkge1xuXG4gICAgcGl4ZWxXaWR0aCA9IHBpeGVsV2lkdGggLyB0aGlzLnBpeGVsUmF0aW87XG4gICAgcGl4ZWxIZWlnaHQgPSBwaXhlbEhlaWdodCAvIHRoaXMucGl4ZWxSYXRpbztcblxuICAgIC8vIEluY3JlYXNlIHRvIG5leHQgbnVtYmVyIGRpdmlzaWJsZSBieSA0LCBidXQgYXQgbGVhc3QgMS5cbiAgICAvLyBUaGlzIGlzIHNvIHdlIGNhbiBzY2FsZSBkb3duIHRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIGFuZCBwYWNrIHRoZW1cbiAgICAvLyBpbnRvIDIgYnl0ZXMgcmF0aGVyIHRoYW4gNCBieXRlcy5cbiAgICAvLyBQYWQgaWNvbnMgdG8gcHJldmVudCB0aGVtIGZyb20gcG9sbHV0aW5nIG5laWdoYm91cnMgZHVyaW5nIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgdmFyIHBhZGRpbmcgPSAyO1xuICAgIHZhciBwYWNrV2lkdGggPSBwaXhlbFdpZHRoICsgcGFkZGluZyArICg0IC0gKHBpeGVsV2lkdGggKyBwYWRkaW5nKSAlIDQpO1xuICAgIHZhciBwYWNrSGVpZ2h0ID0gcGl4ZWxIZWlnaHQgKyBwYWRkaW5nICsgKDQgLSAocGl4ZWxIZWlnaHQgKyBwYWRkaW5nKSAlIDQpOy8vICsgNDtcblxuICAgIHZhciByZWN0ID0gdGhpcy5iaW4ucGFja09uZShwYWNrV2lkdGgsIHBhY2tIZWlnaHQpO1xuICAgIGlmICghcmVjdCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1Nwcml0ZUF0bGFzIG91dCBvZiBzcGFjZS4nKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3Q7XG59O1xuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbihuYW1lLCB3cmFwKSB7XG4gICAgaWYgKHRoaXMuaW1hZ2VzW25hbWVdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlc1tuYW1lXTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc3ByaXRlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwb3MgPSB0aGlzLnNwcml0ZS5nZXRTcHJpdGVQb3NpdGlvbihuYW1lKTtcbiAgICBpZiAoIXBvcy53aWR0aCB8fCAhcG9zLmhlaWdodCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IHRoaXMuYWxsb2NhdGVJbWFnZShwb3Mud2lkdGgsIHBvcy5oZWlnaHQpO1xuICAgIGlmICghcmVjdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2UgPSBuZXcgQXRsYXNJbWFnZShyZWN0LCBwb3Mud2lkdGggLyBwb3MucGl4ZWxSYXRpbywgcG9zLmhlaWdodCAvIHBvcy5waXhlbFJhdGlvLCBwb3Muc2RmLCBwb3MucGl4ZWxSYXRpbyAvIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgdGhpcy5pbWFnZXNbbmFtZV0gPSBpbWFnZTtcblxuICAgIHRoaXMuY29weShyZWN0LCBwb3MsIHdyYXApO1xuXG4gICAgcmV0dXJuIGltYWdlO1xufTtcblxuXG4vLyBSZXR1cm4gcG9zaXRpb24gb2YgYSByZXBlYXRpbmcgZmlsbCBwYXR0ZXJuLlxuU3ByaXRlQXRsYXMucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24obmFtZSwgcmVwZWF0aW5nKSB7XG4gICAgdmFyIGltYWdlID0gdGhpcy5nZXRJbWFnZShuYW1lLCByZXBlYXRpbmcpO1xuICAgIHZhciByZWN0ID0gaW1hZ2UgJiYgaW1hZ2UucmVjdDtcblxuICAgIGlmICghcmVjdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2lkdGggPSBpbWFnZS53aWR0aCAqIGltYWdlLnBpeGVsUmF0aW87XG4gICAgdmFyIGhlaWdodCA9IGltYWdlLmhlaWdodCAqIGltYWdlLnBpeGVsUmF0aW87XG4gICAgdmFyIHBhZGRpbmcgPSAxO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2l6ZTogW2ltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHRdLFxuICAgICAgICB0bDogWyhyZWN0LnggKyBwYWRkaW5nKSAgICAgICAgIC8gdGhpcy53aWR0aCwgKHJlY3QueSArIHBhZGRpbmcpICAgICAgICAgIC8gdGhpcy5oZWlnaHRdLFxuICAgICAgICBicjogWyhyZWN0LnggKyBwYWRkaW5nICsgd2lkdGgpIC8gdGhpcy53aWR0aCwgKHJlY3QueSArIHBhZGRpbmcgKyBoZWlnaHQpIC8gdGhpcy5oZWlnaHRdXG4gICAgfTtcbn07XG5cblxuU3ByaXRlQXRsYXMucHJvdG90eXBlLmFsbG9jYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEpIHtcbiAgICAgICAgdmFyIHcgPSBNYXRoLmZsb29yKHRoaXMud2lkdGggKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgICAgICB2YXIgaCA9IE1hdGguZmxvb3IodGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgVWludDMyQXJyYXkodyAqIGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5kYXRhW2ldID0gMDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuU3ByaXRlQXRsYXMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihkc3QsIHNyYywgd3JhcCkge1xuICAgIGlmICghdGhpcy5zcHJpdGUuaW1nLmRhdGEpIHJldHVybjtcbiAgICB2YXIgc3JjSW1nID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuc3ByaXRlLmltZy5kYXRhLmJ1ZmZlcik7XG5cbiAgICB0aGlzLmFsbG9jYXRlKCk7XG4gICAgdmFyIGRzdEltZyA9IHRoaXMuZGF0YTtcblxuICAgIHZhciBwYWRkaW5nID0gMTtcblxuICAgIGNvcHlCaXRtYXAoXG4gICAgICAgIC8qIHNvdXJjZSBidWZmZXIgKi8gIHNyY0ltZyxcbiAgICAgICAgLyogc291cmNlIHN0cmlkZSAqLyAgdGhpcy5zcHJpdGUuaW1nLndpZHRoLFxuICAgICAgICAvKiBzb3VyY2UgeCAqLyAgICAgICBzcmMueCxcbiAgICAgICAgLyogc291cmNlIHkgKi8gICAgICAgc3JjLnksXG4gICAgICAgIC8qIGRlc3QgYnVmZmVyICovICAgIGRzdEltZyxcbiAgICAgICAgLyogZGVzdCBzdHJpZGUgKi8gICAgdGhpcy53aWR0aCAqIHRoaXMucGl4ZWxSYXRpbyxcbiAgICAgICAgLyogZGVzdCB4ICovICAgICAgICAgKGRzdC54ICsgcGFkZGluZykgKiB0aGlzLnBpeGVsUmF0aW8sXG4gICAgICAgIC8qIGRlc3QgeSAqLyAgICAgICAgIChkc3QueSArIHBhZGRpbmcpICogdGhpcy5waXhlbFJhdGlvLFxuICAgICAgICAvKiBpY29uIGRpbWVuc2lvbiAqLyBzcmMud2lkdGgsXG4gICAgICAgIC8qIGljb24gZGltZW5zaW9uICovIHNyYy5oZWlnaHQsXG4gICAgICAgIC8qIHdyYXAgKi8gd3JhcFxuICAgICk7XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbn07XG5cblNwcml0ZUF0bGFzLnByb3RvdHlwZS5zZXRTcHJpdGUgPSBmdW5jdGlvbihzcHJpdGUpIHtcbiAgICBpZiAoc3ByaXRlKSB7XG4gICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyA+IDEgPyAyIDogMTtcblxuICAgICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy53aWR0aCAqIHRoaXMucGl4ZWxSYXRpbztcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuc3ByaXRlID0gc3ByaXRlO1xufTtcblxuU3ByaXRlQXRsYXMucHJvdG90eXBlLmFkZEljb25zID0gZnVuY3Rpb24oaWNvbnMsIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpY29ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmdldEltYWdlKGljb25zW2ldKTtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCB0aGlzLmltYWdlcyk7XG59O1xuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGdsLCBsaW5lYXIpIHtcbiAgICB2YXIgZmlyc3QgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMudGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgfVxuXG4gICAgdmFyIGZpbHRlclZhbCA9IGxpbmVhciA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1Q7XG4gICAgaWYgKGZpbHRlclZhbCAhPT0gdGhpcy5maWx0ZXIpIHtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlclZhbCk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXJWYWwpO1xuICAgICAgICB0aGlzLmZpbHRlciA9IGZpbHRlclZhbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICB0aGlzLmFsbG9jYXRlKCk7XG5cbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKFxuICAgICAgICAgICAgICAgIGdsLlRFWFRVUkVfMkQsIC8vIGVudW0gdGFyZ2V0XG4gICAgICAgICAgICAgICAgMCwgLy8gaW5kIGxldmVsXG4gICAgICAgICAgICAgICAgZ2wuUkdCQSwgLy8gaW5kIGludGVybmFsZm9ybWF0XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCAqIHRoaXMucGl4ZWxSYXRpbywgLy8gR0xzaXplaSB3aWR0aFxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvLCAvLyBHTHNpemVpIGhlaWdodFxuICAgICAgICAgICAgICAgIDAsIC8vIGluZCBib3JkZXJcbiAgICAgICAgICAgICAgICBnbC5SR0JBLCAvLyBlbnVtIGZvcm1hdFxuICAgICAgICAgICAgICAgIGdsLlVOU0lHTkVEX0JZVEUsIC8vIGVudW0gdHlwZVxuICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIpIC8vIE9iamVjdCBkYXRhXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChcbiAgICAgICAgICAgICAgICBnbC5URVhUVVJFXzJELCAvLyBlbnVtIHRhcmdldFxuICAgICAgICAgICAgICAgIDAsIC8vIGludCBsZXZlbFxuICAgICAgICAgICAgICAgIDAsIC8vIGludCB4b2Zmc2V0XG4gICAgICAgICAgICAgICAgMCwgLy8gaW50IHlvZmZzZXRcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvLCAvLyBsb25nIHdpZHRoXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8sIC8vIGxvbmcgaGVpZ2h0XG4gICAgICAgICAgICAgICAgZ2wuUkdCQSwgLy8gZW51bSBmb3JtYXRcbiAgICAgICAgICAgICAgICBnbC5VTlNJR05FRF9CWVRFLCAvLyBlbnVtIHR5cGVcbiAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyKSAvLyBPYmplY3QgcGl4ZWxzXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIEF0bGFzSW1hZ2UocmVjdCwgd2lkdGgsIGhlaWdodCwgc2RmLCBwaXhlbFJhdGlvKSB7XG4gICAgdGhpcy5yZWN0ID0gcmVjdDtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5zZGYgPSBzZGY7XG4gICAgdGhpcy5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBpbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4uL3V0aWwvaW50ZXJwb2xhdGUnKTtcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgTG5nTGF0ID0gcmVxdWlyZSgnLi4vZ2VvL2xuZ19sYXQnKTtcbnZhciBMbmdMYXRCb3VuZHMgPSByZXF1aXJlKCcuLi9nZW8vbG5nX2xhdF9ib3VuZHMnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbi8qKlxuICogT3B0aW9ucyBjb21tb24gdG8gTWFwI2p1bXBUbywgTWFwI2Vhc2VUbywgYW5kIE1hcCNmbHlUbywgY29udHJvbGxpbmcgdGhlIGRlc3RpbmF0aW9uXG4gKiBsb2NhdGlvbiwgem9vbSBsZXZlbCwgYmVhcmluZyBhbmQgcGl0Y2guIEFsbCBwcm9wZXJ0aWVzIGFyZSBvcHRpb25zOyB1bnNwZWNpZmllZFxuICogb3B0aW9ucyB3aWxsIGRlZmF1bHQgdG8gdGhlIGN1cnJlbnQgdmFsdWUgZm9yIHRoYXQgcHJvcGVydHkuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2FtZXJhT3B0aW9uc1xuICogQHByb3BlcnR5IHtMbmdMYXR9IGNlbnRlciBNYXAgY2VudGVyXG4gKiBAcHJvcGVydHkge251bWJlcn0gem9vbSBNYXAgem9vbSBsZXZlbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJlYXJpbmcgTWFwIHJvdGF0aW9uIGJlYXJpbmcgaW4gZGVncmVlcyBjb3VudGVyLWNsb2Nrd2lzZSBmcm9tIG5vcnRoXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGl0Y2ggTWFwIGFuZ2xlIGluIGRlZ3JlZXMgYXQgd2hpY2ggdGhlIGNhbWVyYSBpcyBsb29raW5nIGF0IHRoZSBncm91bmRcbiAqIEBwcm9wZXJ0eSB7TG5nTGF0fSBhcm91bmQgSWYgem9vbWluZywgdGhlIHpvb20gY2VudGVyIChkZWZhdWx0cyB0byBtYXAgY2VudGVyKVxuICovXG5cbi8qKlxuICogT3B0aW9ucyBjb21tb24gdG8gbWFwIG1vdmVtZW50IG1ldGhvZHMgdGhhdCBpbnZvbHZlIGFuaW1hdGlvbiwgc3VjaCBhcyBNYXAjcGFuQnkgYW5kXG4gKiBNYXAjZWFzZVRvLCBjb250cm9sbGluZyB0aGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBhbmQgZWFzaW5nIGZ1bmN0aW9uLiBBbGwgcHJvcGVydGllc1xuICogYXJlIG9wdGlvbmFsLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFuaW1hdGlvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvbiBOdW1iZXIgaW4gbWlsbGlzZWNvbmRzXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlYXNpbmdcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IG9mZnNldCBwb2ludCwgb3JpZ2luIG9mIG1vdmVtZW50IHJlbGF0aXZlIHRvIG1hcCBjZW50ZXJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYW5pbWF0ZSBXaGVuIHNldCB0byBmYWxzZSwgbm8gYW5pbWF0aW9uIGhhcHBlbnNcbiAqL1xuXG52YXIgQ2FtZXJhID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHt9O1xuXG51dGlsLmV4dGVuZChDYW1lcmEucHJvdG90eXBlLCAvKiogQGxlbmRzIE1hcC5wcm90b3R5cGUgKi97XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHZpZXcgZ2VvZ3JhcGhpY2FsIHBvaW50LlxuICAgICAqIEByZXR1cm5zIHtMbmdMYXR9XG4gICAgICovXG4gICAgZ2V0Q2VudGVyOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmNlbnRlcjsgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtYXAgbG9jYXRpb24uIEVxdWl2YWxlbnQgdG8gYGp1bXBUbyh7Y2VudGVyOiBjZW50ZXJ9KWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xuZ0xhdH0gY2VudGVyIE1hcCBjZW50ZXIgdG8ganVtcCB0b1xuICAgICAqIEBwYXJhbSB7RXZlbnREYXRhfSBbZXZlbnREYXRhXSBEYXRhIHRvIHByb3BhZ2F0ZSB0byBhbnkgZXZlbnQgcmVjZWl2ZXJzXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBtYXAuc2V0Q2VudGVyKFstNzQsIDM4XSk7XG4gICAgICovXG4gICAgc2V0Q2VudGVyOiBmdW5jdGlvbihjZW50ZXIsIGV2ZW50RGF0YSkge1xuICAgICAgICB0aGlzLmp1bXBUbyh7Y2VudGVyOiBjZW50ZXJ9LCBldmVudERhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFuIGJ5IGEgY2VydGFpbiBudW1iZXIgb2YgcGl4ZWxzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IG9mZnNldCBbeCwgeV1cbiAgICAgKiBAcGFyYW0ge0FuaW1hdGlvbk9wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7RXZlbnREYXRhfSBbZXZlbnREYXRhXSBEYXRhIHRvIHByb3BhZ2F0ZSB0byBhbnkgZXZlbnQgcmVjZWl2ZXJzXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgcGFuQnk6IGZ1bmN0aW9uKG9mZnNldCwgb3B0aW9ucywgZXZlbnREYXRhKSB7XG4gICAgICAgIHRoaXMucGFuVG8odGhpcy50cmFuc2Zvcm0uY2VudGVyLFxuICAgICAgICAgICAgdXRpbC5leHRlbmQoe29mZnNldDogUG9pbnQuY29udmVydChvZmZzZXQpLm11bHQoLTEpfSwgb3B0aW9ucyksIGV2ZW50RGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYW4gdG8gYSBjZXJ0YWluIGxvY2F0aW9uIHdpdGggZWFzaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xuZ0xhdH0gbG5nbGF0IExvY2F0aW9uIHRvIHBhbiB0b1xuICAgICAqIEBwYXJhbSB7QW5pbWF0aW9uT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtFdmVudERhdGF9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCByZWNlaXZlcnNcbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBwYW5UbzogZnVuY3Rpb24obG5nbGF0LCBvcHRpb25zLCBldmVudERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFzZVRvKHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGNlbnRlcjogbG5nbGF0XG4gICAgICAgIH0sIG9wdGlvbnMpLCBldmVudERhdGEpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCB6b29tXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRab29tOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnpvb207IH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbWFwIHpvb20uIEVxdWl2YWxlbnQgdG8gYGp1bXBUbyh7em9vbTogem9vbX0pYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIE1hcCB6b29tIGxldmVsXG4gICAgICogQHBhcmFtIHtFdmVudERhdGF9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCByZWNlaXZlcnNcbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIHpvb21zdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlXG4gICAgICogQGZpcmVzIHpvb21cbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEBmaXJlcyB6b29tZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB6b29tIHRoZSBtYXAgdG8gNVxuICAgICAqIG1hcC5zZXRab29tKDUpO1xuICAgICAqL1xuICAgIHNldFpvb206IGZ1bmN0aW9uKHpvb20sIGV2ZW50RGF0YSkge1xuICAgICAgICB0aGlzLmp1bXBUbyh7em9vbTogem9vbX0sIGV2ZW50RGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBab29tcyB0byBhIGNlcnRhaW4gem9vbSBsZXZlbCB3aXRoIGVhc2luZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tXG4gICAgICogQHBhcmFtIHtBbmltYXRpb25PcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge0V2ZW50RGF0YX0gW2V2ZW50RGF0YV0gRGF0YSB0byBwcm9wYWdhdGUgdG8gYW55IGV2ZW50IHJlY2VpdmVyc1xuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgem9vbXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVcbiAgICAgKiBAZmlyZXMgem9vbVxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQGZpcmVzIHpvb21lbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICB6b29tVG86IGZ1bmN0aW9uKHpvb20sIG9wdGlvbnMsIGV2ZW50RGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lYXNlVG8odXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgem9vbTogem9vbVxuICAgICAgICB9LCBvcHRpb25zKSwgZXZlbnREYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWm9vbSBpbiBieSAxIGxldmVsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FuaW1hdGlvbk9wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7RXZlbnREYXRhfSBbZXZlbnREYXRhXSBEYXRhIHRvIHByb3BhZ2F0ZSB0byBhbnkgZXZlbnQgcmVjZWl2ZXJzXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyB6b29tc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZVxuICAgICAqIEBmaXJlcyB6b29tXG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAZmlyZXMgem9vbWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHpvb21JbjogZnVuY3Rpb24ob3B0aW9ucywgZXZlbnREYXRhKSB7XG4gICAgICAgIHRoaXMuem9vbVRvKHRoaXMuZ2V0Wm9vbSgpICsgMSwgb3B0aW9ucywgZXZlbnREYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFpvb20gb3V0IGJ5IDEgbGV2ZWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QW5pbWF0aW9uT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtFdmVudERhdGF9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCByZWNlaXZlcnNcbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIHpvb21zdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlXG4gICAgICogQGZpcmVzIHpvb21cbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEBmaXJlcyB6b29tZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgem9vbU91dDogZnVuY3Rpb24ob3B0aW9ucywgZXZlbnREYXRhKSB7XG4gICAgICAgIHRoaXMuem9vbVRvKHRoaXMuZ2V0Wm9vbSgpIC0gMSwgb3B0aW9ucywgZXZlbnREYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGJlYXJpbmcgaW4gZGVncmVlc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0QmVhcmluZzogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybS5iZWFyaW5nOyB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1hcCByb3RhdGlvbi4gRXF1aXZhbGVudCB0byBganVtcFRvKHtiZWFyaW5nOiBiZWFyaW5nfSlgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJlYXJpbmcgTWFwIHJvdGF0aW9uIGJlYXJpbmcgaW4gZGVncmVlcyBjb3VudGVyLWNsb2Nrd2lzZSBmcm9tIG5vcnRoXG4gICAgICogQHBhcmFtIHtFdmVudERhdGF9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCByZWNlaXZlcnNcbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHJvdGF0ZSB0aGUgbWFwIHRvIDkwIGRlZ3JlZXNcbiAgICAgKiBtYXAuc2V0QmVhcmluZyg5MCk7XG4gICAgICovXG4gICAgc2V0QmVhcmluZzogZnVuY3Rpb24oYmVhcmluZywgZXZlbnREYXRhKSB7XG4gICAgICAgIHRoaXMuanVtcFRvKHtiZWFyaW5nOiBiZWFyaW5nfSwgZXZlbnREYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZSBiZWFyaW5nIGJ5IGEgY2VydGFpbiBudW1iZXIgb2YgZGVncmVlcyB3aXRoIGVhc2luZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJlYXJpbmdcbiAgICAgKiBAcGFyYW0ge0FuaW1hdGlvbk9wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7RXZlbnREYXRhfSBbZXZlbnREYXRhXSBEYXRhIHRvIHByb3BhZ2F0ZSB0byBhbnkgZXZlbnQgcmVjZWl2ZXJzXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgcm90YXRlVG86IGZ1bmN0aW9uKGJlYXJpbmcsIG9wdGlvbnMsIGV2ZW50RGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lYXNlVG8odXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgYmVhcmluZzogYmVhcmluZ1xuICAgICAgICB9LCBvcHRpb25zKSwgZXZlbnREYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBtYXAgYmVhcmluZyB0byAwIChub3J0aCkgd2l0aCBlYXNpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QW5pbWF0aW9uT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtFdmVudERhdGF9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCByZWNlaXZlcnNcbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZXNldE5vcnRoOiBmdW5jdGlvbihvcHRpb25zLCBldmVudERhdGEpIHtcbiAgICAgICAgdGhpcy5yb3RhdGVUbygwLCB1dGlsLmV4dGVuZCh7ZHVyYXRpb246IDEwMDB9LCBvcHRpb25zKSwgZXZlbnREYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGVzIG1hcCBiZWFyaW5nIHRvIDAgKG5vcnRoKSBpZiBpdCdzIGFscmVhZHkgY2xvc2UgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FuaW1hdGlvbk9wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7RXZlbnREYXRhfSBbZXZlbnREYXRhXSBEYXRhIHRvIHByb3BhZ2F0ZSB0byBhbnkgZXZlbnQgcmVjZWl2ZXJzXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgc25hcFRvTm9ydGg6IGZ1bmN0aW9uKG9wdGlvbnMsIGV2ZW50RGF0YSkge1xuICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5nZXRCZWFyaW5nKCkpIDwgdGhpcy5vcHRpb25zLmJlYXJpbmdTbmFwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNldE5vcnRoKG9wdGlvbnMsIGV2ZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBhbmdsZSBpbiBkZWdyZWVzXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRQaXRjaDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybS5waXRjaDsgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtYXAgYW5nbGUuIEVxdWl2YWxlbnQgdG8gYGp1bXBUbyh7cGl0Y2g6IHBpdGNofSlgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpdGNoIFRoZSBhbmdsZSBhdCB3aGljaCB0aGUgY2FtZXJhIGlzIGxvb2tpbmcgYXQgdGhlIGdyb3VuZFxuICAgICAqIEBwYXJhbSB7RXZlbnREYXRhfSBbZXZlbnREYXRhXSBEYXRhIHRvIHByb3BhZ2F0ZSB0byBhbnkgZXZlbnQgcmVjZWl2ZXJzXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgc2V0UGl0Y2g6IGZ1bmN0aW9uKHBpdGNoLCBldmVudERhdGEpIHtcbiAgICAgICAgdGhpcy5qdW1wVG8oe3BpdGNoOiBwaXRjaH0sIGV2ZW50RGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFpvb20gdG8gY29udGFpbiBjZXJ0YWluIGdlb2dyYXBoaWNhbCBib3VuZHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG5nTGF0Qm91bmRzfEFycmF5PEFycmF5PG51bWJlcj4+fSBib3VuZHMgW1ttaW5MbmcsIG1pbkxhdF0sIFttYXhMbmcsIG1heExhdF1dXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxpbmVhcl0gV2hlbiB0cnVlLCB0aGUgbWFwIHRyYW5zaXRpb25zIHRvIHRoZSBuZXcgY2FtZXJhIHVzaW5nXG4gICAgICogICAgIHtAbGluayAjTWFwLmVhc2VUb30uIFdoZW4gZmFsc2UsIHRoZSBtYXAgdHJhbnNpdGlvbnMgdXNpbmcge0BsaW5rICNNYXAuZmx5VG99LiBTZWVcbiAgICAgKiAgICAge0BsaW5rICNNYXAuZmx5VG99IGZvciBpbmZvcm1hdGlvbiBvbiBvcHRpb25zIHNwZWNpZmljIHRvIHRoYXQgYW5pbWF0aW9uIHRyYW5zaXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5lYXNpbmdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5wYWRkaW5nIGhvdyBtdWNoIHBhZGRpbmcgdGhlcmUgaXMgYXJvdW5kIHRoZSBnaXZlbiBib3VuZHMgb24gZWFjaCBzaWRlIGluIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1heFpvb20gVGhlIHJlc3VsdGluZyB6b29tIGxldmVsIHdpbGwgYmUgYXQgbW9zdFxuICAgICAqICAgICB0aGlzIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RXZlbnREYXRhfSBbZXZlbnREYXRhXSBEYXRhIHRvIHByb3BhZ2F0ZSB0byBhbnkgZXZlbnQgcmVjZWl2ZXJzXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgZml0Qm91bmRzOiBmdW5jdGlvbihib3VuZHMsIG9wdGlvbnMsIGV2ZW50RGF0YSkge1xuXG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgb2Zmc2V0OiBbMCwgMF0sXG4gICAgICAgICAgICBtYXhab29tOiBJbmZpbml0eVxuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICBib3VuZHMgPSBMbmdMYXRCb3VuZHMuY29udmVydChib3VuZHMpO1xuXG4gICAgICAgIHZhciBvZmZzZXQgPSBQb2ludC5jb252ZXJ0KG9wdGlvbnMub2Zmc2V0KSxcbiAgICAgICAgICAgIHRyID0gdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICBudyA9IHRyLnByb2plY3QoYm91bmRzLmdldE5vcnRoV2VzdCgpKSxcbiAgICAgICAgICAgIHNlID0gdHIucHJvamVjdChib3VuZHMuZ2V0U291dGhFYXN0KCkpLFxuICAgICAgICAgICAgc2l6ZSA9IHNlLnN1YihudyksXG4gICAgICAgICAgICBzY2FsZVggPSAodHIud2lkdGggLSBvcHRpb25zLnBhZGRpbmcgKiAyIC0gTWF0aC5hYnMob2Zmc2V0LngpICogMikgLyBzaXplLngsXG4gICAgICAgICAgICBzY2FsZVkgPSAodHIuaGVpZ2h0IC0gb3B0aW9ucy5wYWRkaW5nICogMiAtIE1hdGguYWJzKG9mZnNldC55KSAqIDIpIC8gc2l6ZS55O1xuXG4gICAgICAgIG9wdGlvbnMuY2VudGVyID0gdHIudW5wcm9qZWN0KG53LmFkZChzZSkuZGl2KDIpKTtcbiAgICAgICAgb3B0aW9ucy56b29tID0gTWF0aC5taW4odHIuc2NhbGVab29tKHRyLnNjYWxlICogTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpKSwgb3B0aW9ucy5tYXhab29tKTtcbiAgICAgICAgb3B0aW9ucy5iZWFyaW5nID0gMDtcblxuICAgICAgICByZXR1cm4gb3B0aW9ucy5saW5lYXIgP1xuICAgICAgICAgICAgdGhpcy5lYXNlVG8ob3B0aW9ucywgZXZlbnREYXRhKSA6XG4gICAgICAgICAgICB0aGlzLmZseVRvKG9wdGlvbnMsIGV2ZW50RGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoYW5nZSBhbnkgY29tYmluYXRpb24gb2YgY2VudGVyLCB6b29tLCBiZWFyaW5nLCBhbmQgcGl0Y2gsIHdpdGhvdXRcbiAgICAgKiBhIHRyYW5zaXRpb24uIFRoZSBtYXAgd2lsbCByZXRhaW4gdGhlIGN1cnJlbnQgdmFsdWVzIGZvciBhbnkgb3B0aW9uc1xuICAgICAqIG5vdCBpbmNsdWRlZCBpbiBgb3B0aW9uc2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbWVyYU9wdGlvbnN9IG9wdGlvbnMgbWFwIHZpZXcgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7RXZlbnREYXRhfSBbZXZlbnREYXRhXSBEYXRhIHRvIHByb3BhZ2F0ZSB0byBhbnkgZXZlbnQgcmVjZWl2ZXJzXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyB6b29tc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZVxuICAgICAqIEBmaXJlcyB6b29tXG4gICAgICogQGZpcmVzIHJvdGF0ZVxuICAgICAqIEBmaXJlcyBwaXRjaFxuICAgICAqIEBmaXJlcyB6b29tZW5kXG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBqdW1wVG86IGZ1bmN0aW9uKG9wdGlvbnMsIGV2ZW50RGF0YSkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcblxuICAgICAgICB2YXIgdHIgPSB0aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIHpvb21DaGFuZ2VkID0gZmFsc2UsXG4gICAgICAgICAgICBiZWFyaW5nQ2hhbmdlZCA9IGZhbHNlLFxuICAgICAgICAgICAgcGl0Y2hDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCd6b29tJyBpbiBvcHRpb25zICYmIHRyLnpvb20gIT09ICtvcHRpb25zLnpvb20pIHtcbiAgICAgICAgICAgIHpvb21DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyLnpvb20gPSArb3B0aW9ucy56b29tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdjZW50ZXInIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRyLmNlbnRlciA9IExuZ0xhdC5jb252ZXJ0KG9wdGlvbnMuY2VudGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnYmVhcmluZycgaW4gb3B0aW9ucyAmJiB0ci5iZWFyaW5nICE9PSArb3B0aW9ucy5iZWFyaW5nKSB7XG4gICAgICAgICAgICBiZWFyaW5nQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB0ci5iZWFyaW5nID0gK29wdGlvbnMuYmVhcmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgncGl0Y2gnIGluIG9wdGlvbnMgJiYgdHIucGl0Y2ggIT09ICtvcHRpb25zLnBpdGNoKSB7XG4gICAgICAgICAgICBwaXRjaENoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdHIucGl0Y2ggPSArb3B0aW9ucy5waXRjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlyZSgnbW92ZXN0YXJ0JywgZXZlbnREYXRhKVxuICAgICAgICAgICAgLmZpcmUoJ21vdmUnLCBldmVudERhdGEpO1xuXG4gICAgICAgIGlmICh6b29tQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCd6b29tc3RhcnQnLCBldmVudERhdGEpXG4gICAgICAgICAgICAgICAgLmZpcmUoJ3pvb20nLCBldmVudERhdGEpXG4gICAgICAgICAgICAgICAgLmZpcmUoJ3pvb21lbmQnLCBldmVudERhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJlYXJpbmdDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3JvdGF0ZScsIGV2ZW50RGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGl0Y2hDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3BpdGNoJywgZXZlbnREYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnLCBldmVudERhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgYW55IGNvbWJpbmF0aW9uIG9mIGNlbnRlciwgem9vbSwgYmVhcmluZywgYW5kIHBpdGNoLCB3aXRoIGEgc21vb3RoIGFuaW1hdGlvblxuICAgICAqIGJldHdlZW4gb2xkIGFuZCBuZXcgdmFsdWVzLiBUaGUgbWFwIHdpbGwgcmV0YWluIHRoZSBjdXJyZW50IHZhbHVlcyBmb3IgYW55IG9wdGlvbnNcbiAgICAgKiBub3QgaW5jbHVkZWQgaW4gYG9wdGlvbnNgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW1lcmFPcHRpb25zfEFuaW1hdGlvbk9wdGlvbnN9IG9wdGlvbnMgbWFwIHZpZXcgYW5kIGFuaW1hdGlvbiBvcHRpb25zXG4gICAgICogQHBhcmFtIHtFdmVudERhdGF9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCByZWNlaXZlcnNcbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIHpvb21zdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlXG4gICAgICogQGZpcmVzIHpvb21cbiAgICAgKiBAZmlyZXMgcm90YXRlXG4gICAgICogQGZpcmVzIHBpdGNoXG4gICAgICogQGZpcmVzIHpvb21lbmRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIGVhc2VUbzogZnVuY3Rpb24ob3B0aW9ucywgZXZlbnREYXRhKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXG4gICAgICAgICAgICBlYXNpbmc6IHV0aWwuZWFzZVxuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICB2YXIgdHIgPSB0aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIG9mZnNldCA9IFBvaW50LmNvbnZlcnQob3B0aW9ucy5vZmZzZXQpLFxuICAgICAgICAgICAgc3RhcnRab29tID0gdGhpcy5nZXRab29tKCksXG4gICAgICAgICAgICBzdGFydEJlYXJpbmcgPSB0aGlzLmdldEJlYXJpbmcoKSxcbiAgICAgICAgICAgIHN0YXJ0UGl0Y2ggPSB0aGlzLmdldFBpdGNoKCksXG5cbiAgICAgICAgICAgIHpvb20gPSAnem9vbScgaW4gb3B0aW9ucyA/ICtvcHRpb25zLnpvb20gOiBzdGFydFpvb20sXG4gICAgICAgICAgICBiZWFyaW5nID0gJ2JlYXJpbmcnIGluIG9wdGlvbnMgPyB0aGlzLl9ub3JtYWxpemVCZWFyaW5nKG9wdGlvbnMuYmVhcmluZywgc3RhcnRCZWFyaW5nKSA6IHN0YXJ0QmVhcmluZyxcbiAgICAgICAgICAgIHBpdGNoID0gJ3BpdGNoJyBpbiBvcHRpb25zID8gK29wdGlvbnMucGl0Y2ggOiBzdGFydFBpdGNoLFxuXG4gICAgICAgICAgICB0b0xuZ0xhdCxcbiAgICAgICAgICAgIHRvUG9pbnQ7XG5cbiAgICAgICAgaWYgKCdjZW50ZXInIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRvTG5nTGF0ID0gTG5nTGF0LmNvbnZlcnQob3B0aW9ucy5jZW50ZXIpO1xuICAgICAgICAgICAgdG9Qb2ludCA9IHRyLmNlbnRlclBvaW50LmFkZChvZmZzZXQpO1xuICAgICAgICB9IGVsc2UgaWYgKCdhcm91bmQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRvTG5nTGF0ID0gTG5nTGF0LmNvbnZlcnQob3B0aW9ucy5hcm91bmQpO1xuICAgICAgICAgICAgdG9Qb2ludCA9IHRyLmxvY2F0aW9uUG9pbnQodG9MbmdMYXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9Qb2ludCA9IHRyLmNlbnRlclBvaW50LmFkZChvZmZzZXQpO1xuICAgICAgICAgICAgdG9MbmdMYXQgPSB0ci5wb2ludExvY2F0aW9uKHRvUG9pbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZyb21Qb2ludCA9IHRyLmxvY2F0aW9uUG9pbnQodG9MbmdMYXQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlKSBvcHRpb25zLmR1cmF0aW9uID0gMDtcblxuICAgICAgICB0aGlzLnpvb21pbmcgPSAoem9vbSAhPT0gc3RhcnRab29tKTtcbiAgICAgICAgdGhpcy5yb3RhdGluZyA9IChzdGFydEJlYXJpbmcgIT09IGJlYXJpbmcpO1xuICAgICAgICB0aGlzLnBpdGNoaW5nID0gKHBpdGNoICE9PSBzdGFydFBpdGNoKTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZXN0YXJ0JywgZXZlbnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy56b29taW5nKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3pvb21zdGFydCcsIGV2ZW50RGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fb25FYXNlRW5kKTtcblxuICAgICAgICB0aGlzLl9lYXNlKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy56b29taW5nKSB7XG4gICAgICAgICAgICAgICAgdHIuem9vbSA9IGludGVycG9sYXRlKHN0YXJ0Wm9vbSwgem9vbSwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnJvdGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgdHIuYmVhcmluZyA9IGludGVycG9sYXRlKHN0YXJ0QmVhcmluZywgYmVhcmluZywgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBpdGNoaW5nKSB7XG4gICAgICAgICAgICAgICAgdHIucGl0Y2ggPSBpbnRlcnBvbGF0ZShzdGFydFBpdGNoLCBwaXRjaCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyLnNldExvY2F0aW9uQXRQb2ludCh0b0xuZ0xhdCwgZnJvbVBvaW50LmFkZCh0b1BvaW50LnN1Yihmcm9tUG9pbnQpLl9tdWx0KGspKSk7XG5cbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZScsIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICBpZiAodGhpcy56b29taW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCd6b29tJywgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJvdGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdyb3RhdGUnLCBldmVudERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucGl0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ3BpdGNoJywgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWxheUVuZEV2ZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRWFzZUVuZCA9IHNldFRpbWVvdXQodGhpcy5fZWFzZVRvRW5kLmJpbmQodGhpcywgZXZlbnREYXRhKSwgb3B0aW9ucy5kZWxheUVuZEV2ZW50cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vhc2VUb0VuZChldmVudERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcyksIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfZWFzZVRvRW5kOiBmdW5jdGlvbihldmVudERhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuem9vbWluZykge1xuICAgICAgICAgICAgdGhpcy5maXJlKCd6b29tZW5kJywgZXZlbnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpcmUoJ21vdmVlbmQnLCBldmVudERhdGEpO1xuXG4gICAgICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJvdGF0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGl0Y2hpbmcgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIGFueSBjb21iaW5hdGlvbiBvZiBjZW50ZXIsIHpvb20sIGJlYXJpbmcsIGFuZCBwaXRjaCwgYW5pbWF0ZWQgYWxvbmcgYSBjdXJ2ZSB0aGF0XG4gICAgICogZXZva2VzIGZsaWdodC4gVGhlIHRyYW5zaXRpb24gYW5pbWF0aW9uIHNlYW1sZXNzbHkgaW5jb3Jwb3JhdGVzIHpvb21pbmcgYW5kIHBhbm5pbmcgdG8gaGVscFxuICAgICAqIHRoZSB1c2VyIGZpbmQgaGlzIG9yIGhlciBiZWFyaW5ncyBldmVuIGFmdGVyIHRyYXZlcnNpbmcgYSBncmVhdCBkaXN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FtZXJhT3B0aW9uc3xBbmltYXRpb25PcHRpb25zfSBvcHRpb25zIG1hcCB2aWV3IGFuZCBhbmltYXRpb24gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jdXJ2ZT0xLjQyXSBSZWxhdGl2ZSBhbW91bnQgb2Ygem9vbWluZyB0aGF0IHRha2VzIHBsYWNlIGFsb25nIHRoZVxuICAgICAqICAgICBmbGlnaHQgcGF0aC4gQSBoaWdoIHZhbHVlIG1heGltaXplcyB6b29taW5nIGZvciBhbiBleGFnZ2VyYXRlZCBhbmltYXRpb24sIHdoaWxlIGEgbG93XG4gICAgICogICAgIHZhbHVlIG1pbmltaXplcyB6b29taW5nIGZvciBzb21ldGhpbmcgY2xvc2VyIHRvIHtAbGluayAjTWFwLmVhc2VUb30uIDEuNDIgaXMgdGhlIGF2ZXJhZ2VcbiAgICAgKiAgICAgdmFsdWUgc2VsZWN0ZWQgYnkgcGFydGljaXBhbnRzIGluIHRoZSB1c2VyIHN0dWR5IGluXG4gICAgICogICAgIFt2YW4gV2lqayAoMjAwMyldKGh0dHBzOi8vd3d3Lndpbi50dWUubmwvfnZhbndpamsvem9vbXBhbi5wZGYpLiBBIHZhbHVlIG9mXG4gICAgICogICAgIGBNYXRoLnBvdyg2LCAwLjI1KWAgd291bGQgYmUgZXF1aXZhbGVudCB0byB0aGUgcm9vdCBtZWFuIHNxdWFyZWQgYXZlcmFnZSB2ZWxvY2l0eS4gQVxuICAgICAqICAgICB2YWx1ZSBvZiAxIHdvdWxkIHByb2R1Y2UgYSBjaXJjdWxhciBtb3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1pblpvb21dIFplcm8tYmFzZWQgem9vbSBsZXZlbCBhdCB0aGUgcGVhayBvZiB0aGUgZmxpZ2h0IHBhdGguIElmXG4gICAgICogICAgIGBvcHRpb25zLmN1cnZlYCBpcyBzcGVjaWZpZWQsIHRoaXMgb3B0aW9uIGlzIGlnbm9yZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNwZWVkPTEuMl0gQXZlcmFnZSBzcGVlZCBvZiB0aGUgYW5pbWF0aW9uLiBBIHNwZWVkIG9mIDEuMiBtZWFucyB0aGF0XG4gICAgICogICAgIHRoZSBtYXAgYXBwZWFycyB0byBtb3ZlIGFsb25nIHRoZSBmbGlnaHQgcGF0aCBieSAxLjIgdGltZXMgYG9wdGlvbnMuY3VydmVgIHNjcmVlbmZ1bHMgZXZlcnlcbiAgICAgKiAgICAgc2Vjb25kLiBBIF9zY3JlZW5mdWxfIGlzIHRoZSB2aXNpYmxlIHNwYW4gaW4gcGl4ZWxzLiBJdCBkb2VzIG5vdCBjb3JyZXNwb25kIHRvIGEgZml4ZWRcbiAgICAgKiAgICAgcGh5c2ljYWwgZGlzdGFuY2UgYnV0IHJhdGhlciB2YXJpZXMgYnkgem9vbSBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2NyZWVuU3BlZWRdIEF2ZXJhZ2Ugc3BlZWQgb2YgdGhlIGFuaW1hdGlvbiwgbWVhc3VyZWQgaW4gc2NyZWVuZnVsc1xuICAgICAqICAgICBwZXIgc2Vjb25kLCBhc3N1bWluZyBhIGxpbmVhciB0aW1pbmcgY3VydmUuIElmIGBvcHRpb25zLnNwZWVkYCBpcyBzcGVjaWZpZWQsIHRoaXMgb3B0aW9uXG4gICAgICogICAgIGlzIGlnbm9yZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZWFzaW5nXSBUcmFuc2l0aW9uIHRpbWluZyBjdXJ2ZVxuICAgICAqIEBwYXJhbSB7RXZlbnREYXRhfSBbZXZlbnREYXRhXSBEYXRhIHRvIHByb3BhZ2F0ZSB0byBhbnkgZXZlbnQgcmVjZWl2ZXJzXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyB6b29tc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZVxuICAgICAqIEBmaXJlcyB6b29tXG4gICAgICogQGZpcmVzIHJvdGF0ZVxuICAgICAqIEBmaXJlcyBwaXRjaFxuICAgICAqIEBmaXJlcyB6b29tZW5kXG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGZseSB3aXRoIGRlZmF1bHQgb3B0aW9ucyB0byBudWxsIGlzbGFuZFxuICAgICAqIG1hcC5mbHlUbyh7Y2VudGVyOiBbMCwgMF0sIHpvb206IDl9KTtcbiAgICAgKiAvLyB1c2luZyBmbHlUbyBvcHRpb25zXG4gICAgICogbWFwLmZseVRvKHtcbiAgICAgKiAgIGNlbnRlcjogWzAsIDBdLFxuICAgICAqICAgem9vbTogOSxcbiAgICAgKiAgIHNwZWVkOiAwLjIsXG4gICAgICogICBjdXJ2ZTogMSxcbiAgICAgKiAgIGVhc2luZzogZnVuY3Rpb24odCkge1xuICAgICAqICAgICByZXR1cm4gdDtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBmbHlUbzogZnVuY3Rpb24ob3B0aW9ucywgZXZlbnREYXRhKSB7XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgYW4g4oCcb3B0aW1hbCBwYXRo4oCdIGFuaW1hdGlvbiwgYXMgZGV0YWlsZWQgaW46XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFZhbiBXaWprLCBKYXJrZSBKLjsgTnVpaiwgV2ltIEEuIEEuIOKAnFNtb290aCBhbmQgZWZmaWNpZW50IHpvb21pbmcgYW5kIHBhbm5pbmcu4oCdIElORk9WSVNcbiAgICAgICAgLy8gICDigJkwMy4gcHAuIDE14oCTMjIuIDxodHRwczovL3d3dy53aW4udHVlLm5sL352YW53aWprL3pvb21wYW4ucGRmI3BhZ2U9NT4uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdoZXJlIGFwcGxpY2FibGUsIGxvY2FsIHZhcmlhYmxlIGRvY3VtZW50YXRpb24gYmVnaW5zIHdpdGggdGhlIGFzc29jaWF0ZWQgdmFyaWFibGUgb3JcbiAgICAgICAgLy8gZnVuY3Rpb24gaW4gdmFuIFdpamsgKDIwMDMpLlxuXG4gICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgICAgIHNwZWVkOiAxLjIsXG4gICAgICAgICAgICBjdXJ2ZTogMS40MixcbiAgICAgICAgICAgIGVhc2luZzogdXRpbC5lYXNlXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciB0ciA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgb2Zmc2V0ID0gUG9pbnQuY29udmVydChvcHRpb25zLm9mZnNldCksXG4gICAgICAgICAgICBzdGFydFpvb20gPSB0aGlzLmdldFpvb20oKSxcbiAgICAgICAgICAgIHN0YXJ0QmVhcmluZyA9IHRoaXMuZ2V0QmVhcmluZygpLFxuICAgICAgICAgICAgc3RhcnRQaXRjaCA9IHRoaXMuZ2V0UGl0Y2goKTtcblxuICAgICAgICB2YXIgY2VudGVyID0gJ2NlbnRlcicgaW4gb3B0aW9ucyA/IExuZ0xhdC5jb252ZXJ0KG9wdGlvbnMuY2VudGVyKSA6IHRoaXMuZ2V0Q2VudGVyKCk7XG4gICAgICAgIHZhciB6b29tID0gJ3pvb20nIGluIG9wdGlvbnMgPyAgK29wdGlvbnMuem9vbSA6IHN0YXJ0Wm9vbTtcbiAgICAgICAgdmFyIGJlYXJpbmcgPSAnYmVhcmluZycgaW4gb3B0aW9ucyA/IHRoaXMuX25vcm1hbGl6ZUJlYXJpbmcob3B0aW9ucy5iZWFyaW5nLCBzdGFydEJlYXJpbmcpIDogc3RhcnRCZWFyaW5nO1xuICAgICAgICB2YXIgcGl0Y2ggPSAncGl0Y2gnIGluIG9wdGlvbnMgPyArb3B0aW9ucy5waXRjaCA6IHN0YXJ0UGl0Y2g7XG5cbiAgICAgICAgLy8gSWYgYSBwYXRoIGNyb3NzaW5nIHRoZSBhbnRpbWVyaWRpYW4gd291bGQgYmUgc2hvcnRlciwgZXh0ZW5kIHRoZSBmaW5hbCBjb29yZGluYXRlIHNvIHRoYXRcbiAgICAgICAgLy8gaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHRoZSB0d28gZW5kcG9pbnRzIHdpbGwgY3Jvc3MgaXQuXG4gICAgICAgIGlmIChNYXRoLmFicyh0ci5jZW50ZXIubG5nKSArIE1hdGguYWJzKGNlbnRlci5sbmcpID4gMTgwKSB7XG4gICAgICAgICAgICBpZiAodHIuY2VudGVyLmxuZyA+IDAgJiYgY2VudGVyLmxuZyA8IDApIHtcbiAgICAgICAgICAgICAgICBjZW50ZXIubG5nICs9IDM2MDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHIuY2VudGVyLmxuZyA8IDAgJiYgY2VudGVyLmxuZyA+IDApIHtcbiAgICAgICAgICAgICAgICBjZW50ZXIubG5nIC09IDM2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzY2FsZSA9IHRyLnpvb21TY2FsZSh6b29tIC0gc3RhcnRab29tKSxcbiAgICAgICAgICAgIGZyb20gPSB0ci5wb2ludCxcbiAgICAgICAgICAgIHRvID0gJ2NlbnRlcicgaW4gb3B0aW9ucyA/IHRyLnByb2plY3QoY2VudGVyKS5zdWIob2Zmc2V0LmRpdihzY2FsZSkpIDogZnJvbTtcblxuICAgICAgICB2YXIgc3RhcnRXb3JsZFNpemUgPSB0ci53b3JsZFNpemUsXG4gICAgICAgICAgICByaG8gPSBvcHRpb25zLmN1cnZlLFxuXG4gICAgICAgICAgICAvLyB34oKAOiBJbml0aWFsIHZpc2libGUgc3BhbiwgbWVhc3VyZWQgaW4gcGl4ZWxzIGF0IHRoZSBpbml0aWFsIHNjYWxlLlxuICAgICAgICAgICAgdzAgPSBNYXRoLm1heCh0ci53aWR0aCwgdHIuaGVpZ2h0KSxcbiAgICAgICAgICAgIC8vIHfigoE6IEZpbmFsIHZpc2libGUgc3BhbiwgbWVhc3VyZWQgaW4gcGl4ZWxzIHdpdGggcmVzcGVjdCB0byB0aGUgaW5pdGlhbCBzY2FsZS5cbiAgICAgICAgICAgIHcxID0gdzAgLyBzY2FsZSxcbiAgICAgICAgICAgIC8vIExlbmd0aCBvZiB0aGUgZmxpZ2h0IHBhdGggYXMgcHJvamVjdGVkIG9udG8gdGhlIGdyb3VuZCBwbGFuZSwgbWVhc3VyZWQgaW4gcGl4ZWxzIGZyb21cbiAgICAgICAgICAgIC8vIHRoZSB3b3JsZCBpbWFnZSBvcmlnaW4gYXQgdGhlIGluaXRpYWwgc2NhbGUuXG4gICAgICAgICAgICB1MSA9IHRvLnN1Yihmcm9tKS5tYWcoKTtcblxuICAgICAgICBpZiAoJ21pblpvb20nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBtaW5ab29tID0gdXRpbC5jbGFtcChNYXRoLm1pbihvcHRpb25zLm1pblpvb20sIHN0YXJ0Wm9vbSwgem9vbSksIHRyLm1pblpvb20sIHRyLm1heFpvb20pO1xuICAgICAgICAgICAgLy8gdzxzdWI+bTwvc3ViPjogTWF4aW11bSB2aXNpYmxlIHNwYW4sIG1lYXN1cmVkIGluIHBpeGVscyB3aXRoIHJlc3BlY3QgdG8gdGhlIGluaXRpYWxcbiAgICAgICAgICAgIC8vIHNjYWxlLlxuICAgICAgICAgICAgdmFyIHdNYXggPSB3MCAvIHRyLnpvb21TY2FsZShtaW5ab29tIC0gc3RhcnRab29tKTtcbiAgICAgICAgICAgIHJobyA9IE1hdGguc3FydCh3TWF4IC8gdTEgKiAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIM+BwrJcbiAgICAgICAgdmFyIHJobzIgPSByaG8gKiByaG87XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHLhtaI6IFJldHVybnMgdGhlIHpvb20tb3V0IGZhY3RvciBhdCBvbmUgZW5kIG9mIHRoZSBhbmltYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpIDAgZm9yIHRoZSBhc2NlbnQgb3IgMSBmb3IgdGhlIGRlc2NlbnQuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiByKGkpIHtcbiAgICAgICAgICAgIHZhciBiID0gKHcxICogdzEgLSB3MCAqIHcwICsgKGkgPyAtMSA6IDEpICogcmhvMiAqIHJobzIgKiB1MSAqIHUxKSAvICgyICogKGkgPyB3MSA6IHcwKSAqIHJobzIgKiB1MSk7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5sb2coTWF0aC5zcXJ0KGIgKiBiICsgMSkgLSBiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNpbmgobikgeyByZXR1cm4gKE1hdGguZXhwKG4pIC0gTWF0aC5leHAoLW4pKSAvIDI7IH1cbiAgICAgICAgZnVuY3Rpb24gY29zaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgKyBNYXRoLmV4cCgtbikpIC8gMjsgfVxuICAgICAgICBmdW5jdGlvbiB0YW5oKG4pIHsgcmV0dXJuIHNpbmgobikgLyBjb3NoKG4pOyB9XG5cbiAgICAgICAgLy8gcuKCgDogWm9vbS1vdXQgZmFjdG9yIGR1cmluZyBhc2NlbnQuXG4gICAgICAgIHZhciByMCA9IHIoMCksXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHcocyk6IFJldHVybnMgdGhlIHZpc2libGUgc3BhbiBvbiB0aGUgZ3JvdW5kLCBtZWFzdXJlZCBpbiBwaXhlbHMgd2l0aCByZXNwZWN0IHRvIHRoZVxuICAgICAgICAgICAgICogaW5pdGlhbCBzY2FsZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBBc3N1bWVzIGFuIGFuZ3VsYXIgZmllbGQgb2YgdmlldyBvZiAyIGFyY3RhbiDCvSDiiYggNTPCsC5cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHcgPSBmdW5jdGlvbiAocykgeyByZXR1cm4gKGNvc2gocjApIC8gY29zaChyMCArIHJobyAqIHMpKTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogdShzKTogUmV0dXJucyB0aGUgZGlzdGFuY2UgYWxvbmcgdGhlIGZsaWdodCBwYXRoIGFzIHByb2plY3RlZCBvbnRvIHRoZSBncm91bmQgcGxhbmUsXG4gICAgICAgICAgICAgKiBtZWFzdXJlZCBpbiBwaXhlbHMgZnJvbSB0aGUgd29ybGQgaW1hZ2Ugb3JpZ2luIGF0IHRoZSBpbml0aWFsIHNjYWxlLlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdSA9IGZ1bmN0aW9uIChzKSB7IHJldHVybiB3MCAqICgoY29zaChyMCkgKiB0YW5oKHIwICsgcmhvICogcykgLSBzaW5oKHIwKSkgLyByaG8yKSAvIHUxOyB9LFxuICAgICAgICAgICAgLy8gUzogVG90YWwgbGVuZ3RoIG9mIHRoZSBmbGlnaHQgcGF0aCwgbWVhc3VyZWQgaW4gz4Etc2NyZWVuZnVscy5cbiAgICAgICAgICAgIFMgPSAocigxKSAtIHIwKSAvIHJobztcblxuICAgICAgICAvLyBXaGVuIHXigoAgPSB14oKBLCB0aGUgb3B0aW1hbCBwYXRoIGRvZXNu4oCZdCByZXF1aXJlIGJvdGggYXNjZW50IGFuZCBkZXNjZW50LlxuICAgICAgICBpZiAoTWF0aC5hYnModTEpIDwgMC4wMDAwMDEpIHtcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gYSBtb3JlIG9yIGxlc3MgaW5zdGFudGFuZW91cyB0cmFuc2l0aW9uIGlmIHRoZSBwYXRoIGlzIHRvbyBzaG9ydC5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh3MCAtIHcxKSA8IDAuMDAwMDAxKSByZXR1cm4gdGhpcy5lYXNlVG8ob3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHZhciBrID0gdzEgPCB3MCA/IC0xIDogMTtcbiAgICAgICAgICAgIFMgPSBNYXRoLmFicyhNYXRoLmxvZyh3MSAvIHcwKSkgLyByaG87XG5cbiAgICAgICAgICAgIHUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4gICAgICAgICAgICB3ID0gZnVuY3Rpb24ocykgeyByZXR1cm4gTWF0aC5leHAoayAqIHJobyAqIHMpOyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdkdXJhdGlvbicgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9ICtvcHRpb25zLmR1cmF0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIFYgPSAnc2NyZWVuU3BlZWQnIGluIG9wdGlvbnMgPyArb3B0aW9ucy5zY3JlZW5TcGVlZCAvIHJobyA6ICtvcHRpb25zLnNwZWVkO1xuICAgICAgICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9IDEwMDAgKiBTIC8gVjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuem9vbWluZyA9IHRydWU7XG4gICAgICAgIGlmIChzdGFydEJlYXJpbmcgIT09IGJlYXJpbmcpIHRoaXMucm90YXRpbmcgPSB0cnVlO1xuICAgICAgICBpZiAoc3RhcnRQaXRjaCAhPT0gcGl0Y2gpIHRoaXMucGl0Y2hpbmcgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuZmlyZSgnbW92ZXN0YXJ0JywgZXZlbnREYXRhKTtcbiAgICAgICAgdGhpcy5maXJlKCd6b29tc3RhcnQnLCBldmVudERhdGEpO1xuXG4gICAgICAgIHRoaXMuX2Vhc2UoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIC8vIHM6IFRoZSBkaXN0YW5jZSB0cmF2ZWxlZCBhbG9uZyB0aGUgZmxpZ2h0IHBhdGgsIG1lYXN1cmVkIGluIM+BLXNjcmVlbmZ1bHMuXG4gICAgICAgICAgICB2YXIgcyA9IGsgKiBTLFxuICAgICAgICAgICAgICAgIHVzID0gdShzKTtcblxuICAgICAgICAgICAgdHIuem9vbSA9IHN0YXJ0Wm9vbSArIHRyLnNjYWxlWm9vbSgxIC8gdyhzKSk7XG4gICAgICAgICAgICB0ci5jZW50ZXIgPSB0ci51bnByb2plY3QoZnJvbS5hZGQodG8uc3ViKGZyb20pLm11bHQodXMpKSwgc3RhcnRXb3JsZFNpemUpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5yb3RhdGluZykge1xuICAgICAgICAgICAgICAgIHRyLmJlYXJpbmcgPSBpbnRlcnBvbGF0ZShzdGFydEJlYXJpbmcsIGJlYXJpbmcsIGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucGl0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICB0ci5waXRjaCA9IGludGVycG9sYXRlKHN0YXJ0UGl0Y2gsIHBpdGNoLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlJywgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnem9vbScsIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICBpZiAodGhpcy5yb3RhdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgncm90YXRlJywgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBpdGNoaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdwaXRjaCcsIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCd6b29tZW5kJywgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZWVuZCcsIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB0aGlzLnpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucm90YXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucGl0Y2hpbmcgPSBmYWxzZTtcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGlzRWFzaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fYWJvcnRGbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RvcCBjdXJyZW50IGFuaW1hdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9hYm9ydEZuKSB7XG4gICAgICAgICAgICB0aGlzLl9hYm9ydEZuKCk7XG4gICAgICAgICAgICB0aGlzLl9maW5pc2hFYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9lYXNlOiBmdW5jdGlvbihmcmFtZSwgZmluaXNoLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2ZpbmlzaEZuID0gZmluaXNoO1xuICAgICAgICB0aGlzLl9hYm9ydEZuID0gYnJvd3Nlci50aW1lZChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgZnJhbWUuY2FsbCh0aGlzLCBvcHRpb25zLmVhc2luZyh0KSk7XG4gICAgICAgICAgICBpZiAodCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmlzaEVhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSA/IDAgOiBvcHRpb25zLmR1cmF0aW9uLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX2ZpbmlzaEVhc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fYWJvcnRGbjtcbiAgICAgICAgLy8gVGhlIGZpbmlzaCBmdW5jdGlvbiBtaWdodCBlbWl0IGV2ZW50cyB3aGljaCB0cmlnZ2VyIG5ldyBlYXNlcywgd2hpY2hcbiAgICAgICAgLy8gc2V0IGEgbmV3IF9maW5pc2hGbi4gRW5zdXJlIHdlIGRvbid0IGRlbGV0ZSBpdCB1bmludGVudGlvbmFsbHkuXG4gICAgICAgIHZhciBmaW5pc2ggPSB0aGlzLl9maW5pc2hGbjtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2ZpbmlzaEZuO1xuICAgICAgICBmaW5pc2guY2FsbCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gY29udmVydCBiZWFyaW5nIHNvIHRoYXQgaXQncyBudW1lcmljYWxseSBjbG9zZSB0byB0aGUgY3VycmVudCBvbmUgc28gdGhhdCBpdCBpbnRlcnBvbGF0ZXMgcHJvcGVybHlcbiAgICBfbm9ybWFsaXplQmVhcmluZzogZnVuY3Rpb24oYmVhcmluZywgY3VycmVudEJlYXJpbmcpIHtcbiAgICAgICAgYmVhcmluZyA9IHV0aWwud3JhcChiZWFyaW5nLCAtMTgwLCAxODApO1xuICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKGJlYXJpbmcgLSBjdXJyZW50QmVhcmluZyk7XG4gICAgICAgIGlmIChNYXRoLmFicyhiZWFyaW5nIC0gMzYwIC0gY3VycmVudEJlYXJpbmcpIDwgZGlmZikgYmVhcmluZyAtPSAzNjA7XG4gICAgICAgIGlmIChNYXRoLmFicyhiZWFyaW5nICsgMzYwIC0gY3VycmVudEJlYXJpbmcpIDwgZGlmZikgYmVhcmluZyArPSAzNjA7XG4gICAgICAgIHJldHVybiBiZWFyaW5nO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlRWFzaW5nOiBmdW5jdGlvbihkdXJhdGlvbiwgem9vbSwgYmV6aWVyKSB7XG4gICAgICAgIHZhciBlYXNpbmc7XG5cbiAgICAgICAgaWYgKHRoaXMuZWFzZSkge1xuICAgICAgICAgICAgdmFyIGVhc2UgPSB0aGlzLmVhc2UsXG4gICAgICAgICAgICAgICAgdCA9IChEYXRlLm5vdygpIC0gZWFzZS5zdGFydCkgLyBlYXNlLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHNwZWVkID0gZWFzZS5lYXNpbmcodCArIDAuMDEpIC0gZWFzZS5lYXNpbmcodCksXG5cbiAgICAgICAgICAgICAgICAvLyBRdWljayBoYWNrIHRvIG1ha2UgbmV3IGJlemllciB0aGF0IGlzIGNvbnRpbnVvdXMgd2l0aCBsYXN0XG4gICAgICAgICAgICAgICAgeCA9IDAuMjcgLyBNYXRoLnNxcnQoc3BlZWQgKiBzcGVlZCArIDAuMDAwMSkgKiAwLjAxLFxuICAgICAgICAgICAgICAgIHkgPSBNYXRoLnNxcnQoMC4yNyAqIDAuMjcgLSB4ICogeCk7XG5cbiAgICAgICAgICAgIGVhc2luZyA9IHV0aWwuYmV6aWVyKHgsIHksIDAuMjUsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWFzaW5nID0gYmV6aWVyID8gdXRpbC5iZXppZXIuYXBwbHkodXRpbCwgYmV6aWVyKSA6IHV0aWwuZWFzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0b3JlIGluZm9ybWF0aW9uIG9uIGN1cnJlbnQgZWFzaW5nXG4gICAgICAgIHRoaXMuZWFzZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiAobmV3IERhdGUoKSkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgdG86IE1hdGgucG93KDIsIHpvb20pLFxuICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgICAgZWFzaW5nOiBlYXNpbmdcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZWFzaW5nO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFBpdGNoIGV2ZW50LiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbmV2ZXIgdGhlIG1hcCdzIHBpdGNoIGNoYW5nZXMuXG4gKlxuICogQGV2ZW50IHBpdGNoXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7RXZlbnREYXRhfSBkYXRhIE9yaWdpbmFsIGV2ZW50IGRhdGFcbiAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29udHJvbCA9IHJlcXVpcmUoJy4vY29udHJvbCcpO1xudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF0dHJpYnV0aW9uO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXR0cmlidXRpb24gY29udHJvbFxuICogQGNsYXNzIEF0dHJpYnV0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucG9zaXRpb249J2JvdHRvbS1yaWdodCddIEEgc3RyaW5nIGluZGljYXRpbmcgdGhlIGNvbnRyb2wncyBwb3NpdGlvbiBvbiB0aGUgbWFwLiBPcHRpb25zIGFyZSBgdG9wLXJpZ2h0YCwgYHRvcC1sZWZ0YCwgYGJvdHRvbS1yaWdodGAsIGBib3R0b20tbGVmdGBcbiAqIEBleGFtcGxlXG4gKiB2YXIgbWFwID0gbmV3IG1hcGJveGdsLk1hcCh7YXR0cmlidXRpb25Db250cm9sOiBmYWxzZX0pXG4gKiAgICAgLmFkZENvbnRyb2wobmV3IG1hcGJveGdsLkF0dHJpYnV0aW9uKHtwb3NpdGlvbjogJ3RvcC1sZWZ0J30pKTtcbiAqL1xuZnVuY3Rpb24gQXR0cmlidXRpb24ob3B0aW9ucykge1xuICAgIHV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbn1cblxuQXR0cmlidXRpb24uY3JlYXRlQXR0cmlidXRpb25TdHJpbmcgPSBmdW5jdGlvbihzb3VyY2VzKSB7XG4gICAgdmFyIGF0dHJpYnV0aW9ucyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaWQgaW4gc291cmNlcykge1xuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpZF07XG4gICAgICAgIGlmIChzb3VyY2UuYXR0cmlidXRpb24gJiYgYXR0cmlidXRpb25zLmluZGV4T2Yoc291cmNlLmF0dHJpYnV0aW9uKSA8IDApIHtcbiAgICAgICAgICAgIGF0dHJpYnV0aW9ucy5wdXNoKHNvdXJjZS5hdHRyaWJ1dGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYW55IGVudHJpZXMgdGhhdCBhcmUgc3Vic3RyaW5ncyBvZiBhbm90aGVyIGVudHJ5LlxuICAgIC8vIGZpcnN0IHNvcnQgYnkgbGVuZ3RoIHNvIHRoYXQgc3Vic3RyaW5ncyBjb21lIGZpcnN0XG4gICAgYXR0cmlidXRpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7IH0pO1xuICAgIGF0dHJpYnV0aW9ucyA9IGF0dHJpYnV0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGF0dHJpYiwgaSkge1xuICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBhdHRyaWJ1dGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGlvbnNbal0uaW5kZXhPZihhdHRyaWIpID49IDApIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXR0cmlidXRpb25zLmpvaW4oJyB8ICcpO1xufTtcblxuQXR0cmlidXRpb24ucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KENvbnRyb2wsIHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYm90dG9tLXJpZ2h0J1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAnbWFwYm94Z2wtY3RybC1hdHRyaWInLFxuICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRE9NLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBtYXAuZ2V0Q29udGFpbmVyKCkpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICBtYXAub24oJ3NvdXJjZS5sb2FkJywgdGhpcy5fdXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgICBtYXAub24oJ3NvdXJjZS5jaGFuZ2UnLCB0aGlzLl91cGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIG1hcC5vbignc291cmNlLnJlbW92ZScsIHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgbWFwLm9uKCdtb3ZlZW5kJywgdGhpcy5fdXBkYXRlRWRpdExpbmsuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXAuc3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBBdHRyaWJ1dGlvbi5jcmVhdGVBdHRyaWJ1dGlvblN0cmluZyh0aGlzLl9tYXAuc3R5bGUuc291cmNlcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lZGl0TGluayA9IHRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdtYXBib3gtaW1wcm92ZS1tYXAnKVswXTtcbiAgICAgICAgdGhpcy5fdXBkYXRlRWRpdExpbmsoKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUVkaXRMaW5rOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VkaXRMaW5rKSB7XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xuICAgICAgICAgICAgdGhpcy5fZWRpdExpbmsuaHJlZiA9ICdodHRwczovL3d3dy5tYXBib3guY29tL21hcC1mZWVkYmFjay8jLycgK1xuICAgICAgICAgICAgICAgICAgICBjZW50ZXIubG5nICsgJy8nICsgY2VudGVyLmxhdCArICcvJyArIE1hdGgucm91bmQodGhpcy5fbWFwLmdldFpvb20oKSArIDEpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udHJvbDtcblxuLyoqXG4gKiBBIGJhc2UgY2xhc3MgZm9yIG1hcC1yZWxhdGVkIGludGVyZmFjZSBlbGVtZW50cy5cbiAqXG4gKiBAY2xhc3MgQ29udHJvbFxuICovXG5mdW5jdGlvbiBDb250cm9sKCkge31cblxuQ29udHJvbC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQWRkIHRoaXMgY29udHJvbCB0byB0aGUgbWFwLCByZXR1cm5pbmcgdGhlIGNvbnRyb2wgaXRzZWxmXG4gICAgICogZm9yIGNoYWluaW5nLiBUaGlzIHdpbGwgaW5zZXJ0IHRoZSBjb250cm9sJ3MgRE9NIGVsZW1lbnQgaW50b1xuICAgICAqIHRoZSBtYXAncyBET00gZWxlbWVudCBpZiB0aGUgY29udHJvbCBoYXMgYSBgcG9zaXRpb25gIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TWFwfSBtYXBcbiAgICAgKiBAcmV0dXJucyB7Q29udHJvbH0gYHRoaXNgXG4gICAgICovXG4gICAgYWRkVG86IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSB0aGlzLm9uQWRkKG1hcCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIGNvcm5lciA9IG1hcC5fY29udHJvbENvcm5lcnNbcG9zXTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgKz0gJyBtYXBib3hnbC1jdHJsJztcbiAgICAgICAgICAgIGlmIChwb3MuaW5kZXhPZignYm90dG9tJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29ybmVyLmluc2VydEJlZm9yZShjb250YWluZXIsIGNvcm5lci5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29ybmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoaXMgY29udHJvbCBmcm9tIHRoZSBtYXAgaXQgaGFzIGJlZW4gYWRkZWQgdG8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29udHJvbH0gYHRoaXNgXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgaWYgKHRoaXMub25SZW1vdmUpIHRoaXMub25SZW1vdmUodGhpcy5fbWFwKTtcbiAgICAgICAgdGhpcy5fbWFwID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENvbnRyb2wgPSByZXF1aXJlKCcuL2NvbnRyb2wnKTtcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9icm93c2VyJyk7XG52YXIgRE9NID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9kb20nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gR2VvbG9jYXRlO1xuXG52YXIgZ2VvT3B0aW9ucyA9IHsgZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZSwgdGltZW91dDogNjAwMCAvKiA2c2VjICovIH07XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgZ2VvbG9jYXRpb24gY29udHJvbFxuICogQGNsYXNzIEdlb2xvY2F0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uPSd0b3AtcmlnaHQnXSBBIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBjb250cm9sJ3MgcG9zaXRpb24gb24gdGhlIG1hcC4gT3B0aW9ucyBhcmUgYHRvcC1yaWdodGAsIGB0b3AtbGVmdGAsIGBib3R0b20tcmlnaHRgLCBgYm90dG9tLWxlZnRgXG4gKiBAZXhhbXBsZVxuICogbWFwLmFkZENvbnRyb2wobmV3IG1hcGJveGdsLkdlb2xvY2F0ZSh7cG9zaXRpb246ICd0b3AtbGVmdCd9KSk7IC8vIHBvc2l0aW9uIGlzIG9wdGlvbmFsXG4gKi9cbmZ1bmN0aW9uIEdlb2xvY2F0ZShvcHRpb25zKSB7XG4gICAgdXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5HZW9sb2NhdGUucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KENvbnRyb2wsIHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHBvc2l0aW9uOiAndG9wLXJpZ2h0J1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAnbWFwYm94Z2wtY3RybCc7XG5cbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERPTS5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctZ3JvdXAnLCBtYXAuZ2V0Q29udGFpbmVyKCkpO1xuICAgICAgICBpZiAoIWJyb3dzZXIuc3VwcG9ydHNHZW9sb2NhdGlvbikgcmV0dXJuIGNvbnRhaW5lcjtcblxuICAgICAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLl9vbkNvbnRleHRNZW51LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbiA9IERPTS5jcmVhdGUoJ2J1dHRvbicsIChjbGFzc05hbWUgKyAnLWljb24gJyArIGNsYXNzTmFtZSArICctZ2VvbG9jYXRlJyksIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2tHZW9sb2NhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfSxcblxuICAgIF9vbkNvbnRleHRNZW51OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgX29uQ2xpY2tHZW9sb2NhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKHRoaXMuX3N1Y2Nlc3MuYmluZCh0aGlzKSwgdGhpcy5fZXJyb3IuYmluZCh0aGlzKSwgZ2VvT3B0aW9ucyk7XG5cbiAgICAgICAgLy8gVGhpcyB0aW1lb3V0IGVuc3VyZXMgdGhhdCB3ZSBzdGlsbCBjYWxsIGZpbmlzaCgpIGV2ZW4gaWZcbiAgICAgICAgLy8gdGhlIHVzZXIgZGVjbGluZXMgdG8gc2hhcmUgdGhlaXIgbG9jYXRpb24gaW4gRmlyZWZveFxuICAgICAgICB0aGlzLl90aW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX2ZpbmlzaC5iaW5kKHRoaXMpLCAxMDAwMCAvKiAxMHNlYyAqLyk7XG4gICAgfSxcblxuICAgIF9zdWNjZXNzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB0aGlzLl9tYXAuanVtcFRvKHtcbiAgICAgICAgICAgIGNlbnRlcjogW3Bvc2l0aW9uLmNvb3Jkcy5sb25naXR1ZGUsIHBvc2l0aW9uLmNvb3Jkcy5sYXRpdHVkZV0sXG4gICAgICAgICAgICB6b29tOiAxNyxcbiAgICAgICAgICAgIGJlYXJpbmc6IDAsXG4gICAgICAgICAgICBwaXRjaDogMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZmluaXNoKCk7XG4gICAgfSxcblxuICAgIF9lcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2ZpbmlzaCgpO1xuICAgIH0sXG5cbiAgICBfZmluaXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVvdXRJZCkgeyBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dElkKTsgfVxuICAgICAgICB0aGlzLl90aW1lb3V0SWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG59KTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29udHJvbCA9IHJlcXVpcmUoJy4vY29udHJvbCcpO1xudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5hdmlnYXRpb247XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5hdmlnYXRpb24gY29udHJvbCB3aXRoIHpvb20gYnV0dG9ucyBhbmQgYSBjb21wYXNzXG4gKiBAY2xhc3MgTmF2aWdhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uPSd0b3AtcmlnaHQnXSBBIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBjb250cm9sJ3MgcG9zaXRpb24gb24gdGhlIG1hcC4gT3B0aW9ucyBhcmUgYHRvcC1yaWdodGAsIGB0b3AtbGVmdGAsIGBib3R0b20tcmlnaHRgLCBgYm90dG9tLWxlZnRgXG4gKiBAZXhhbXBsZVxuICogbWFwLmFkZENvbnRyb2wobmV3IG1hcGJveGdsLk5hdmlnYXRpb24oe3Bvc2l0aW9uOiAndG9wLWxlZnQnfSkpOyAvLyBwb3NpdGlvbiBpcyBvcHRpb25hbFxuICovXG5mdW5jdGlvbiBOYXZpZ2F0aW9uKG9wdGlvbnMpIHtcbiAgICB1dGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG59XG5cbk5hdmlnYXRpb24ucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KENvbnRyb2wsIHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHBvc2l0aW9uOiAndG9wLXJpZ2h0J1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAnbWFwYm94Z2wtY3RybCc7XG5cbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERPTS5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctZ3JvdXAnLCBtYXAuZ2V0Q29udGFpbmVyKCkpO1xuICAgICAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLl9vbkNvbnRleHRNZW51LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMuX3pvb21JbkJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihjbGFzc05hbWUgKyAnLWljb24gJyArIGNsYXNzTmFtZSArICctem9vbS1pbicsIG1hcC56b29tSW4uYmluZChtYXApKTtcbiAgICAgICAgdGhpcy5fem9vbU91dEJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihjbGFzc05hbWUgKyAnLWljb24gJyArIGNsYXNzTmFtZSArICctem9vbS1vdXQnLCBtYXAuem9vbU91dC5iaW5kKG1hcCkpO1xuICAgICAgICB0aGlzLl9jb21wYXNzID0gdGhpcy5fY3JlYXRlQnV0dG9uKGNsYXNzTmFtZSArICctaWNvbiAnICsgY2xhc3NOYW1lICsgJy1jb21wYXNzJywgbWFwLnJlc2V0Tm9ydGguYmluZChtYXApKTtcblxuICAgICAgICB0aGlzLl9jb21wYXNzQXJyb3cgPSBET00uY3JlYXRlKCdkaXYnLCAnYXJyb3cnLCB0aGlzLl9jb21wYXNzKTtcblxuICAgICAgICB0aGlzLl9jb21wYXNzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uQ29tcGFzc0Rvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX29uQ29tcGFzc01vdmUgPSB0aGlzLl9vbkNvbXBhc3NNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX29uQ29tcGFzc1VwID0gdGhpcy5fb25Db21wYXNzVXAuYmluZCh0aGlzKTtcblxuICAgICAgICBtYXAub24oJ3JvdGF0ZScsIHRoaXMuX3JvdGF0ZUNvbXBhc3NBcnJvdy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fcm90YXRlQ29tcGFzc0Fycm93KCk7XG5cbiAgICAgICAgdGhpcy5fZWwgPSBtYXAuZ2V0Q2FudmFzQ29udGFpbmVyKCk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgX29uQ29udGV4dE1lbnU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBfb25Db21wYXNzRG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5idXR0b24gIT09IDApIHJldHVybjtcblxuICAgICAgICBET00uZGlzYWJsZURyYWcoKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Db21wYXNzTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbkNvbXBhc3NVcCk7XG5cbiAgICAgICAgdGhpcy5fZWwuZGlzcGF0Y2hFdmVudChjb3B5TW91c2VFdmVudChlKSk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcblxuICAgIF9vbkNvbXBhc3NNb3ZlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLmJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuX2VsLmRpc3BhdGNoRXZlbnQoY29weU1vdXNlRXZlbnQoZSkpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG5cbiAgICBfb25Db21wYXNzVXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUuYnV0dG9uICE9PSAwKSByZXR1cm47XG5cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Db21wYXNzTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbkNvbXBhc3NVcCk7XG4gICAgICAgIERPTS5lbmFibGVEcmFnKCk7XG5cbiAgICAgICAgdGhpcy5fZWwuZGlzcGF0Y2hFdmVudChjb3B5TW91c2VFdmVudChlKSk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcblxuICAgIF9jcmVhdGVCdXR0b246IGZ1bmN0aW9uKGNsYXNzTmFtZSwgZm4pIHtcbiAgICAgICAgdmFyIGEgPSBET00uY3JlYXRlKCdidXR0b24nLCBjbGFzc05hbWUsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIGEuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHsgZm4oKTsgfSk7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH0sXG5cbiAgICBfcm90YXRlQ29tcGFzc0Fycm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJvdGF0ZSA9ICdyb3RhdGUoJyArICh0aGlzLl9tYXAudHJhbnNmb3JtLmFuZ2xlICogKDE4MCAvIE1hdGguUEkpKSArICdkZWcpJztcbiAgICAgICAgdGhpcy5fY29tcGFzc0Fycm93LnN0eWxlLnRyYW5zZm9ybSA9IHJvdGF0ZTtcbiAgICB9XG59KTtcblxuXG5mdW5jdGlvbiBjb3B5TW91c2VFdmVudChlKSB7XG4gICAgcmV0dXJuIG5ldyBNb3VzZUV2ZW50KGUudHlwZSwge1xuICAgICAgICBidXR0b246IDIsICAgIC8vIHJpZ2h0IGNsaWNrXG4gICAgICAgIGJ1dHRvbnM6IDIsICAgLy8gcmlnaHQgY2xpY2tcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgZGV0YWlsOiBlLmRldGFpbCxcbiAgICAgICAgdmlldzogZS52aWV3LFxuICAgICAgICBzY3JlZW5YOiBlLnNjcmVlblgsXG4gICAgICAgIHNjcmVlblk6IGUuc2NyZWVuWSxcbiAgICAgICAgY2xpZW50WDogZS5jbGllbnRYLFxuICAgICAgICBjbGllbnRZOiBlLmNsaWVudFksXG4gICAgICAgIG1vdmVtZW50WDogZS5tb3ZlbWVudFgsXG4gICAgICAgIG1vdmVtZW50WTogZS5tb3ZlbWVudFksXG4gICAgICAgIGN0cmxLZXk6IGUuY3RybEtleSxcbiAgICAgICAgc2hpZnRLZXk6IGUuc2hpZnRLZXksXG4gICAgICAgIGFsdEtleTogZS5hbHRLZXksXG4gICAgICAgIG1ldGFLZXk6IGUubWV0YUtleVxuICAgIH0pO1xufVxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBET00gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvbScpLFxuICAgIExuZ0xhdEJvdW5kcyA9IHJlcXVpcmUoJy4uLy4uL2dlby9sbmdfbGF0X2JvdW5kcycpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb3hab29tSGFuZGxlcjtcblxuLyoqXG4gKiBUaGUgYEJveFpvb21IYW5kbGVyYCBhbGxvd3MgYSB1c2VyIHRvIHpvb20gdGhlIG1hcCB0byBmaXQgYSBib3VuZGluZyBib3guXG4gKiBUaGUgYm91bmRpbmcgYm94IGlzIGRlZmluZWQgYnkgaG9sZGluZyBgc2hpZnRgIHdoaWxlIGRyYWdnaW5nIHRoZSBjdXJzb3IuXG4gKiBAY2xhc3MgQm94Wm9vbUhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gQm94Wm9vbUhhbmRsZXIobWFwKSB7XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuX2VsID0gbWFwLmdldENhbnZhc0NvbnRhaW5lcigpO1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IG1hcC5nZXRDb250YWluZXIoKTtcblxuICAgIHV0aWwuYmluZEhhbmRsZXJzKHRoaXMpO1xufVxuXG5Cb3hab29tSGFuZGxlci5wcm90b3R5cGUgPSB7XG5cbiAgICBfZW5hYmxlZDogZmFsc2UsXG4gICAgX2FjdGl2ZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGVuYWJsZWQvZGlzYWJsZWQgc3RhdGUgb2YgdGhlIFwiYm94IHpvb21cIiBpbnRlcmFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZW5hYmxlZCBzdGF0ZVxuICAgICAqL1xuICAgIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBcImJveCB6b29tXCIgaW50ZXJhY3Rpb24gaXMgY3VycmVudGx5IGFjdGl2ZSwgaS5lLiBjdXJyZW50bHkgYmVpbmcgdXNlZC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYWN0aXZlIHN0YXRlXG4gICAgICovXG4gICAgaXNBY3RpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRoZSBcImJveCB6b29tXCIgaW50ZXJhY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgIG1hcC5ib3hab29tLmVuYWJsZSgpO1xuICAgICAqL1xuICAgIGVuYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQoKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZSB0aGUgXCJib3ggem9vbVwiIGludGVyYWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICBtYXAuYm94Wm9vbS5kaXNhYmxlKCk7XG4gICAgICovXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5fZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24pO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCEoZS5zaGlmdEtleSAmJiBlLmJ1dHRvbiA9PT0gMCkpIHJldHVybjtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXAsIGZhbHNlKTtcblxuICAgICAgICBET00uZGlzYWJsZURyYWcoKTtcbiAgICAgICAgdGhpcy5fc3RhcnRQb3MgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUpO1xuICAgICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBwMCA9IHRoaXMuX3N0YXJ0UG9zLFxuICAgICAgICAgICAgcDEgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUpO1xuXG4gICAgICAgIGlmICghdGhpcy5fYm94KSB7XG4gICAgICAgICAgICB0aGlzLl9ib3ggPSBET00uY3JlYXRlKCdkaXYnLCAnbWFwYm94Z2wtYm94em9vbScsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtY3Jvc3NoYWlyJyk7XG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ2JveHpvb21zdGFydCcsIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pblggPSBNYXRoLm1pbihwMC54LCBwMS54KSxcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChwMC54LCBwMS54KSxcbiAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihwMC55LCBwMS55KSxcbiAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChwMC55LCBwMS55KTtcblxuICAgICAgICBET00uc2V0VHJhbnNmb3JtKHRoaXMuX2JveCwgJ3RyYW5zbGF0ZSgnICsgbWluWCArICdweCwnICsgbWluWSArICdweCknKTtcblxuICAgICAgICB0aGlzLl9ib3guc3R5bGUud2lkdGggPSAobWF4WCAtIG1pblgpICsgJ3B4JztcbiAgICAgICAgdGhpcy5fYm94LnN0eWxlLmhlaWdodCA9IChtYXhZIC0gbWluWSkgKyAncHgnO1xuICAgIH0sXG5cbiAgICBfb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5idXR0b24gIT09IDApIHJldHVybjtcblxuICAgICAgICB2YXIgcDAgPSB0aGlzLl9zdGFydFBvcyxcbiAgICAgICAgICAgIHAxID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlKSxcbiAgICAgICAgICAgIGJvdW5kcyA9IG5ldyBMbmdMYXRCb3VuZHModGhpcy5fbWFwLnVucHJvamVjdChwMCksIHRoaXMuX21hcC51bnByb2plY3QocDEpKTtcblxuICAgICAgICB0aGlzLl9maW5pc2goKTtcblxuICAgICAgICBpZiAocDAueCA9PT0gcDEueCAmJiBwMC55ID09PSBwMS55KSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ2JveHpvb21jYW5jZWwnLCBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21hcFxuICAgICAgICAgICAgICAgIC5maXRCb3VuZHMoYm91bmRzLCB7bGluZWFyOiB0cnVlfSlcbiAgICAgICAgICAgICAgICAuZmlyZSgnYm94em9vbWVuZCcsIHsgb3JpZ2luYWxFdmVudDogZSwgYm94Wm9vbUJvdW5kczogYm91bmRzIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgICAgICB0aGlzLl9maW5pc2goKTtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnYm94em9vbWNhbmNlbCcsIGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9maW5pc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ21hcGJveGdsLWNyb3NzaGFpcicpO1xuXG4gICAgICAgIGlmICh0aGlzLl9ib3gpIHtcbiAgICAgICAgICAgIHRoaXMuX2JveC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2JveCk7XG4gICAgICAgICAgICB0aGlzLl9ib3ggPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgRE9NLmVuYWJsZURyYWcoKTtcbiAgICB9LFxuXG4gICAgX2ZpcmVFdmVudDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5maXJlKHR5cGUsIHsgb3JpZ2luYWxFdmVudDogZSB9KTtcbiAgICB9XG59O1xuXG5cbi8qKlxuICogQm94em9vbSBzdGFydCBldmVudC4gVGhpcyBldmVudCBpcyBlbWl0dGVkIGF0IHRoZSBzdGFydCBvZiBhIGJveCB6b29tIGludGVyYWN0aW9uLlxuICpcbiAqIEBldmVudCBib3h6b29tc3RhcnRcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtFdmVudERhdGF9IGRhdGEgT3JpZ2luYWwgZXZlbnQgZGF0YVxuICovXG5cbi8qKlxuICogQm94em9vbSBlbmQgZXZlbnQuIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCBhdCB0aGUgZW5kIG9mIGEgYm94IHpvb20gaW50ZXJhY3Rpb25cbiAqXG4gKiBAZXZlbnQgYm94em9vbWVuZFxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtFdmVudH0gb3JpZ2luYWxFdmVudCB0aGUgb3JpZ2luYWwgRE9NIGV2ZW50XG4gKiBAcHJvcGVydHkge0xuZ0xhdEJvdW5kc30gYm94Wm9vbUJvdW5kcyB0aGUgYm91bmRzIG9mIHRoZSBib3ggem9vbSB0YXJnZXRcbiAqL1xuXG4vKipcbiAqIEJveHpvb20gY2FuY2VsIGV2ZW50LiAgVGhpcyBldmVudCBpcyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2FuY2VscyBhIGJveCB6b29tIGludGVyYWN0aW9uLFxuICogICBvciB3aGVuIHRoZSBib3ggem9vbSBkb2VzIG5vdCBtZWV0IHRoZSBtaW5pbXVtIHNpemUgdGhyZXNob2xkLlxuICpcbiAqIEBldmVudCBib3h6b29tY2FuY2VsXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7RXZlbnREYXRhfSBkYXRhIE9yaWdpbmFsIGV2ZW50IGRhdGFcbiAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERvdWJsZUNsaWNrWm9vbUhhbmRsZXI7XG5cbi8qKlxuICogVGhlIGBEb3VibGVDbGlja1pvb21IYW5kbGVyYCBhbGxvd3MgYSB1c2VyIHRvIHpvb20gdGhlIG1hcCBhcm91bmQgcG9pbnQgYnlcbiAqIGRvdWJsZSBjbGlja2luZy5cbiAqIEBjbGFzcyBEb3VibGVDbGlja1pvb21IYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIERvdWJsZUNsaWNrWm9vbUhhbmRsZXIobWFwKSB7XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuX29uRGJsQ2xpY2sgPSB0aGlzLl9vbkRibENsaWNrLmJpbmQodGhpcyk7XG59XG5cbkRvdWJsZUNsaWNrWm9vbUhhbmRsZXIucHJvdG90eXBlID0ge1xuXG4gICAgX2VuYWJsZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBlbmFibGVkL2Rpc2FibGVkIHN0YXRlIG9mIHRoZSBcImRvdWJsZSBjbGljayB0byB6b29tXCIgaW50ZXJhY3Rpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGVuYWJsZWQgc3RhdGVcbiAgICAgKi9cbiAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSB0aGUgXCJkb3VibGUgY2xpY2sgdG8gem9vbVwiIGludGVyYWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbWFwLmRvdWJsZUNsaWNrWm9vbS5lbmFibGUoKTtcbiAgICAgKi9cbiAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX29uRGJsQ2xpY2spO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZSB0aGUgXCJkb3VibGUgY2xpY2sgdG8gem9vbVwiIGludGVyYWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbWFwLmRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKCk7XG4gICAgICovXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9vbkRibENsaWNrKTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBfb25EYmxDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fbWFwLnpvb21Ubyh0aGlzLl9tYXAuZ2V0Wm9vbSgpICtcbiAgICAgICAgICAgIChlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgPyAtMSA6IDEpLCB7YXJvdW5kOiBlLmxuZ0xhdH0pO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBET00gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvbScpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcmFnUGFuSGFuZGxlcjtcblxudmFyIGluZXJ0aWFMaW5lYXJpdHkgPSAwLjMsXG4gICAgaW5lcnRpYUVhc2luZyA9IHV0aWwuYmV6aWVyKDAsIDAsIGluZXJ0aWFMaW5lYXJpdHksIDEpLFxuICAgIGluZXJ0aWFNYXhTcGVlZCA9IDE0MDAsIC8vIHB4L3NcbiAgICBpbmVydGlhRGVjZWxlcmF0aW9uID0gMjUwMDsgLy8gcHgvc14yXG5cblxuLyoqXG4gKiBUaGUgYERyYWdQYW5IYW5kbGVyYCBhbGxvd3MgYSB1c2VyIHRvIHBhbiB0aGUgbWFwIGJ5IGNsaWNraW5nIGFuZCBkcmFnZ2luZ1xuICogdGhlIGN1cnNvci5cbiAqIEBjbGFzcyBEcmFnUGFuSGFuZGxlclxuICovXG5mdW5jdGlvbiBEcmFnUGFuSGFuZGxlcihtYXApIHtcbiAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgdGhpcy5fZWwgPSBtYXAuZ2V0Q2FudmFzQ29udGFpbmVyKCk7XG5cbiAgICB1dGlsLmJpbmRIYW5kbGVycyh0aGlzKTtcbn1cblxuRHJhZ1BhbkhhbmRsZXIucHJvdG90eXBlID0ge1xuXG4gICAgX2VuYWJsZWQ6IGZhbHNlLFxuICAgIF9hY3RpdmU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBlbmFibGVkL2Rpc2FibGVkIHN0YXRlIG9mIHRoZSBcImRyYWcgdG8gcGFuXCIgaW50ZXJhY3Rpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGVuYWJsZWQgc3RhdGVcbiAgICAgKi9cbiAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgXCJkcmFnIHRvIHBhblwiIGludGVyYWN0aW9uIGlzIGN1cnJlbnRseSBhY3RpdmUsIGkuZS4gY3VycmVudGx5IGJlaW5nIHVzZWQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGFjdGl2ZSBzdGF0ZVxuICAgICAqL1xuICAgIGlzQWN0aXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSB0aGUgXCJkcmFnIHRvIHBhblwiIGludGVyYWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbWFwLmRyYWdQYW4uZW5hYmxlKCk7XG4gICAgICovXG4gICAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCgpKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2VsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uRG93bik7XG4gICAgICAgIHRoaXMuX2VsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24pO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZSB0aGUgXCJkcmFnIHRvIHBhblwiIGludGVyYWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbWFwLmRyYWdQYW4uZGlzYWJsZSgpO1xuICAgICAqL1xuICAgIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCgpKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uRG93bik7XG4gICAgICAgIHRoaXMuX2VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24pO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pZ25vcmVFdmVudChlKSkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKGUudG91Y2hlcykge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdmUpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9wb3MgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUpO1xuICAgICAgICB0aGlzLl9pbmVydGlhID0gW1tEYXRlLm5vdygpLCB0aGlzLl9wb3NdXTtcbiAgICB9LFxuXG4gICAgX29uTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lnbm9yZUV2ZW50KGUpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ2RyYWdzdGFydCcsIGUpO1xuICAgICAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdtb3Zlc3RhcnQnLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3MgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUpLFxuICAgICAgICAgICAgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgIG1hcC5zdG9wKCk7XG4gICAgICAgIHRoaXMuX2RyYWluSW5lcnRpYUJ1ZmZlcigpO1xuICAgICAgICB0aGlzLl9pbmVydGlhLnB1c2goW0RhdGUubm93KCksIHBvc10pO1xuXG4gICAgICAgIG1hcC50cmFuc2Zvcm0uc2V0TG9jYXRpb25BdFBvaW50KG1hcC50cmFuc2Zvcm0ucG9pbnRMb2NhdGlvbih0aGlzLl9wb3MpLCBwb3MpO1xuXG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnZHJhZycsIGUpO1xuICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ21vdmUnLCBlKTtcblxuICAgICAgICB0aGlzLl9wb3MgPSBwb3M7XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBfb25VcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlKCkpIHJldHVybjtcblxuICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdkcmFnZW5kJywgZSk7XG4gICAgICAgIHRoaXMuX2RyYWluSW5lcnRpYUJ1ZmZlcigpO1xuXG4gICAgICAgIHZhciBmaW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnbW92ZWVuZCcsIGUpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdmFyIGluZXJ0aWEgPSB0aGlzLl9pbmVydGlhO1xuICAgICAgICBpZiAoaW5lcnRpYS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0ID0gaW5lcnRpYVtpbmVydGlhLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgZmlyc3QgPSBpbmVydGlhWzBdLFxuICAgICAgICAgICAgZmxpbmdPZmZzZXQgPSBsYXN0WzFdLnN1YihmaXJzdFsxXSksXG4gICAgICAgICAgICBmbGluZ0R1cmF0aW9uID0gKGxhc3RbMF0gLSBmaXJzdFswXSkgLyAxMDAwO1xuXG4gICAgICAgIGlmIChmbGluZ0R1cmF0aW9uID09PSAwIHx8IGxhc3RbMV0uZXF1YWxzKGZpcnN0WzFdKSkge1xuICAgICAgICAgICAgZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxjdWxhdGUgcHgvcyB2ZWxvY2l0eSAmIGFkanVzdCBmb3IgaW5jcmVhc2VkIGluaXRpYWwgYW5pbWF0aW9uIHNwZWVkIHdoZW4gZWFzaW5nIG91dFxuICAgICAgICB2YXIgdmVsb2NpdHkgPSBmbGluZ09mZnNldC5tdWx0KGluZXJ0aWFMaW5lYXJpdHkgLyBmbGluZ0R1cmF0aW9uKSxcbiAgICAgICAgICAgIHNwZWVkID0gdmVsb2NpdHkubWFnKCk7IC8vIHB4L3NcblxuICAgICAgICBpZiAoc3BlZWQgPiBpbmVydGlhTWF4U3BlZWQpIHtcbiAgICAgICAgICAgIHNwZWVkID0gaW5lcnRpYU1heFNwZWVkO1xuICAgICAgICAgICAgdmVsb2NpdHkuX3VuaXQoKS5fbXVsdChzcGVlZCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHVyYXRpb24gPSBzcGVlZCAvIChpbmVydGlhRGVjZWxlcmF0aW9uICogaW5lcnRpYUxpbmVhcml0eSksXG4gICAgICAgICAgICBvZmZzZXQgPSB2ZWxvY2l0eS5tdWx0KC1kdXJhdGlvbiAvIDIpO1xuXG4gICAgICAgIHRoaXMuX21hcC5wYW5CeShvZmZzZXQsIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiAqIDEwMDAsXG4gICAgICAgICAgICBlYXNpbmc6IGluZXJ0aWFFYXNpbmcsXG4gICAgICAgICAgICBub01vdmVTdGFydDogdHJ1ZVxuICAgICAgICB9LCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSk7XG4gICAgfSxcblxuICAgIF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pZ25vcmVFdmVudChlKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9vblVwKGUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICB9LFxuXG4gICAgX29uVG91Y2hFbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pZ25vcmVFdmVudChlKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9vblVwKGUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQpO1xuICAgIH0sXG5cbiAgICBfZmlyZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmZpcmUodHlwZSwgeyBvcmlnaW5hbEV2ZW50OiBlIH0pO1xuICAgIH0sXG5cbiAgICBfaWdub3JlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgaWYgKG1hcC5ib3hab29tICYmIG1hcC5ib3hab29tLmlzQWN0aXZlKCkpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAobWFwLmRyYWdSb3RhdGUgJiYgbWFwLmRyYWdSb3RhdGUuaXNBY3RpdmUoKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChlLnRvdWNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGUuY3RybEtleSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB2YXIgYnV0dG9ucyA9IDEsICAvLyBsZWZ0IGJ1dHRvblxuICAgICAgICAgICAgICAgIGJ1dHRvbiA9IDA7ICAgLy8gbGVmdCBidXR0b25cbiAgICAgICAgICAgIHJldHVybiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJyA/IGUuYnV0dG9ucyAmIGJ1dHRvbnMgPT09IDAgOiBlLmJ1dHRvbiAhPT0gYnV0dG9uKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZHJhaW5JbmVydGlhQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmVydGlhID0gdGhpcy5faW5lcnRpYSxcbiAgICAgICAgICAgIG5vdyA9IERhdGUubm93KCksXG4gICAgICAgICAgICBjdXRvZmYgPSAxNjA7ICAgLy8gbXNlY1xuXG4gICAgICAgIHdoaWxlIChpbmVydGlhLmxlbmd0aCA+IDAgJiYgbm93IC0gaW5lcnRpYVswXVswXSA+IGN1dG9mZikgaW5lcnRpYS5zaGlmdCgpO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBEcmFnIHN0YXJ0IGV2ZW50LiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgYXQgdGhlIHN0YXJ0IG9mIGEgdXNlci1pbml0aWF0ZWQgcGFuIGludGVyYWN0aW9uLlxuICpcbiAqIEBldmVudCBkcmFnc3RhcnRcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtFdmVudERhdGF9IGRhdGEgT3JpZ2luYWwgZXZlbnQgZGF0YVxuICovXG5cbi8qKlxuICogRHJhZyBldmVudC4gVGhpcyBldmVudCBpcyBlbWl0dGVkIHJlcGVhdGVkbHkgZHVyaW5nIGEgdXNlci1pbml0aWF0ZWQgcGFuIGludGVyYWN0aW9uLlxuICpcbiAqIEBldmVudCBkcmFnXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7RXZlbnREYXRhfSBkYXRhIE9yaWdpbmFsIGV2ZW50IGRhdGFcbiAqL1xuXG4vKipcbiAqIERyYWcgZW5kIGV2ZW50LiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgYXQgdGhlIGVuZCBvZiBhIHVzZXItaW5pdGlhdGVkIHBhbiBpbnRlcmFjdGlvbi5cbiAqXG4gKiBAZXZlbnQgZHJhZ2VuZFxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge0V2ZW50RGF0YX0gZGF0YSBPcmlnaW5hbCBldmVudCBkYXRhXG4gKi9cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyksXG4gICAgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcmFnUm90YXRlSGFuZGxlcjtcblxudmFyIGluZXJ0aWFMaW5lYXJpdHkgPSAwLjI1LFxuICAgIGluZXJ0aWFFYXNpbmcgPSB1dGlsLmJlemllcigwLCAwLCBpbmVydGlhTGluZWFyaXR5LCAxKSxcbiAgICBpbmVydGlhTWF4U3BlZWQgPSAxODAsIC8vIGRlZy9zXG4gICAgaW5lcnRpYURlY2VsZXJhdGlvbiA9IDcyMDsgLy8gZGVnL3NeMlxuXG5cbi8qKlxuICogVGhlIGBEcmFnUm90YXRlSGFuZGxlcmAgYWxsb3dzIGEgdXNlciB0byByb3RhdGUgdGhlIG1hcCBieSBjbGlja2luZyBhbmRcbiAqIGRyYWdnaW5nIHRoZSBjdXJzb3Igd2hpbGUgaG9sZGluZyB0aGUgcmlnaHQgbW91c2UgYnV0dG9uIG9yIHRoZSBgY3RybGAga2V5LlxuICogQGNsYXNzIERyYWdSb3RhdGVIYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIERyYWdSb3RhdGVIYW5kbGVyKG1hcCkge1xuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB0aGlzLl9lbCA9IG1hcC5nZXRDYW52YXNDb250YWluZXIoKTtcblxuICAgIHV0aWwuYmluZEhhbmRsZXJzKHRoaXMpO1xufVxuXG5EcmFnUm90YXRlSGFuZGxlci5wcm90b3R5cGUgPSB7XG5cbiAgICBfZW5hYmxlZDogZmFsc2UsXG4gICAgX2FjdGl2ZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGVuYWJsZWQvZGlzYWJsZWQgc3RhdGUgb2YgdGhlIFwiZHJhZyB0byByb3RhdGVcIiBpbnRlcmFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZW5hYmxlZCBzdGF0ZVxuICAgICAqL1xuICAgIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBcImRyYWcgdG8gcm90YXRlXCIgaW50ZXJhY3Rpb24gaXMgY3VycmVudGx5IGFjdGl2ZSwgaS5lLiBjdXJyZW50bHkgYmVpbmcgdXNlZC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYWN0aXZlIHN0YXRlXG4gICAgICovXG4gICAgaXNBY3RpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRoZSBcImRyYWcgdG8gcm90YXRlXCIgaW50ZXJhY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBtYXAuZHJhZ1JvdGF0ZS5lbmFibGUoKTtcbiAgICAgKi9cbiAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5fZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Eb3duKTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc2FibGUgdGhlIFwiZHJhZyB0byByb3RhdGVcIiBpbnRlcmFjdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG1hcC5kcmFnUm90YXRlLmRpc2FibGUoKTtcbiAgICAgKi9cbiAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0VuYWJsZWQoKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbkRvd24pO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pZ25vcmVFdmVudChlKSkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSByZXR1cm47XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uVXApO1xuXG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbmVydGlhID0gW1tEYXRlLm5vdygpLCB0aGlzLl9tYXAuZ2V0QmVhcmluZygpXV07XG4gICAgICAgIHRoaXMuX3N0YXJ0UG9zID0gdGhpcy5fcG9zID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlKTtcbiAgICAgICAgdGhpcy5fY2VudGVyID0gdGhpcy5fbWFwLnRyYW5zZm9ybS5jZW50ZXJQb2ludDsgIC8vIENlbnRlciBvZiByb3RhdGlvblxuXG4gICAgICAgIC8vIElmIHRoZSBmaXJzdCBjbGljayB3YXMgdG9vIGNsb3NlIHRvIHRoZSBjZW50ZXIsIG1vdmUgdGhlIGNlbnRlciBvZiByb3RhdGlvbiBieSAyMDAgcGl4ZWxzXG4gICAgICAgIC8vIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGNsaWNrLlxuICAgICAgICB2YXIgc3RhcnRUb0NlbnRlciA9IHRoaXMuX3N0YXJ0UG9zLnN1Yih0aGlzLl9jZW50ZXIpLFxuICAgICAgICAgICAgc3RhcnRUb0NlbnRlckRpc3QgPSBzdGFydFRvQ2VudGVyLm1hZygpO1xuXG4gICAgICAgIGlmIChzdGFydFRvQ2VudGVyRGlzdCA8IDIwMCkge1xuICAgICAgICAgICAgdGhpcy5fY2VudGVyID0gdGhpcy5fc3RhcnRQb3MuYWRkKG5ldyBQb2ludCgtMjAwLCAwKS5fcm90YXRlKHN0YXJ0VG9DZW50ZXIuYW5nbGUoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5faWdub3JlRXZlbnQoZSkpIHJldHVybjtcblxuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVFdmVudCgncm90YXRlc3RhcnQnLCBlKTtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnbW92ZXN0YXJ0JywgZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuICAgICAgICBtYXAuc3RvcCgpO1xuXG4gICAgICAgIHZhciBwMSA9IHRoaXMuX3BvcyxcbiAgICAgICAgICAgIHAyID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlKSxcbiAgICAgICAgICAgIGNlbnRlciA9IHRoaXMuX2NlbnRlcixcbiAgICAgICAgICAgIGJlYXJpbmdEaWZmID0gcDEuc3ViKGNlbnRlcikuYW5nbGVXaXRoKHAyLnN1YihjZW50ZXIpKSAvIE1hdGguUEkgKiAxODAsXG4gICAgICAgICAgICBiZWFyaW5nID0gbWFwLmdldEJlYXJpbmcoKSAtIGJlYXJpbmdEaWZmLFxuICAgICAgICAgICAgaW5lcnRpYSA9IHRoaXMuX2luZXJ0aWEsXG4gICAgICAgICAgICBsYXN0ID0gaW5lcnRpYVtpbmVydGlhLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIHRoaXMuX2RyYWluSW5lcnRpYUJ1ZmZlcigpO1xuICAgICAgICBpbmVydGlhLnB1c2goW0RhdGUubm93KCksIG1hcC5fbm9ybWFsaXplQmVhcmluZyhiZWFyaW5nLCBsYXN0WzFdKV0pO1xuXG4gICAgICAgIG1hcC50cmFuc2Zvcm0uYmVhcmluZyA9IGJlYXJpbmc7XG5cbiAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdyb3RhdGUnLCBlKTtcbiAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdtb3ZlJywgZSk7XG5cbiAgICAgICAgdGhpcy5fcG9zID0gcDI7XG4gICAgfSxcblxuICAgIF9vblVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5faWdub3JlRXZlbnQoZSkpIHJldHVybjtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uVXApO1xuXG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSgpKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudCgncm90YXRlZW5kJywgZSk7XG4gICAgICAgIHRoaXMuX2RyYWluSW5lcnRpYUJ1ZmZlcigpO1xuXG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gICAgICAgICAgICBtYXBCZWFyaW5nID0gbWFwLmdldEJlYXJpbmcoKSxcbiAgICAgICAgICAgIGluZXJ0aWEgPSB0aGlzLl9pbmVydGlhO1xuXG4gICAgICAgIHZhciBmaW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhtYXBCZWFyaW5nKSA8IG1hcC5vcHRpb25zLmJlYXJpbmdTbmFwKSB7XG4gICAgICAgICAgICAgICAgbWFwLnJlc2V0Tm9ydGgoe25vTW92ZVN0YXJ0OiB0cnVlfSwgeyBvcmlnaW5hbEV2ZW50OiBlIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ21vdmVlbmQnLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIGlmIChpbmVydGlhLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIGZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpcnN0ID0gaW5lcnRpYVswXSxcbiAgICAgICAgICAgIGxhc3QgPSBpbmVydGlhW2luZXJ0aWEubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwcmV2aW91cyA9IGluZXJ0aWFbaW5lcnRpYS5sZW5ndGggLSAyXSxcbiAgICAgICAgICAgIGJlYXJpbmcgPSBtYXAuX25vcm1hbGl6ZUJlYXJpbmcobWFwQmVhcmluZywgcHJldmlvdXNbMV0pLFxuICAgICAgICAgICAgZmxpbmdEaWZmID0gbGFzdFsxXSAtIGZpcnN0WzFdLFxuICAgICAgICAgICAgc2lnbiA9IGZsaW5nRGlmZiA8IDAgPyAtMSA6IDEsXG4gICAgICAgICAgICBmbGluZ0R1cmF0aW9uID0gKGxhc3RbMF0gLSBmaXJzdFswXSkgLyAxMDAwO1xuXG4gICAgICAgIGlmIChmbGluZ0RpZmYgPT09IDAgfHwgZmxpbmdEdXJhdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3BlZWQgPSBNYXRoLmFicyhmbGluZ0RpZmYgKiAoaW5lcnRpYUxpbmVhcml0eSAvIGZsaW5nRHVyYXRpb24pKTsgIC8vIGRlZy9zXG4gICAgICAgIGlmIChzcGVlZCA+IGluZXJ0aWFNYXhTcGVlZCkge1xuICAgICAgICAgICAgc3BlZWQgPSBpbmVydGlhTWF4U3BlZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHVyYXRpb24gPSBzcGVlZCAvIChpbmVydGlhRGVjZWxlcmF0aW9uICogaW5lcnRpYUxpbmVhcml0eSksXG4gICAgICAgICAgICBvZmZzZXQgPSBzaWduICogc3BlZWQgKiAoZHVyYXRpb24gLyAyKTtcblxuICAgICAgICBiZWFyaW5nICs9IG9mZnNldDtcblxuICAgICAgICBpZiAoTWF0aC5hYnMobWFwLl9ub3JtYWxpemVCZWFyaW5nKGJlYXJpbmcsIDApKSA8IG1hcC5vcHRpb25zLmJlYXJpbmdTbmFwKSB7XG4gICAgICAgICAgICBiZWFyaW5nID0gbWFwLl9ub3JtYWxpemVCZWFyaW5nKDAsIGJlYXJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFwLnJvdGF0ZVRvKGJlYXJpbmcsIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiAqIDEwMDAsXG4gICAgICAgICAgICBlYXNpbmc6IGluZXJ0aWFFYXNpbmcsXG4gICAgICAgICAgICBub01vdmVTdGFydDogdHJ1ZVxuICAgICAgICB9LCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSk7XG4gICAgfSxcblxuICAgIF9maXJlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuZmlyZSh0eXBlLCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSk7XG4gICAgfSxcblxuICAgIF9pZ25vcmVFdmVudDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICAgICAgICBpZiAobWFwLmJveFpvb20gJiYgbWFwLmJveFpvb20uaXNBY3RpdmUoKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChtYXAuZHJhZ1BhbiAmJiBtYXAuZHJhZ1Bhbi5pc0FjdGl2ZSgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGUudG91Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIChlLnRvdWNoZXMubGVuZ3RoID4gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYnV0dG9ucyA9IChlLmN0cmxLZXkgPyAxIDogMiksICAvLyA/IGN0cmwrbGVmdCBidXR0b24gOiByaWdodCBidXR0b25cbiAgICAgICAgICAgICAgICBidXR0b24gPSAoZS5jdHJsS2V5ID8gMCA6IDIpOyAgIC8vID8gY3RybCtsZWZ0IGJ1dHRvbiA6IHJpZ2h0IGJ1dHRvblxuICAgICAgICAgICAgcmV0dXJuIChlLnR5cGUgPT09ICdtb3VzZW1vdmUnID8gZS5idXR0b25zICYgYnV0dG9ucyA9PT0gMCA6IGUuYnV0dG9uICE9PSBidXR0b24pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9kcmFpbkluZXJ0aWFCdWZmZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluZXJ0aWEgPSB0aGlzLl9pbmVydGlhLFxuICAgICAgICAgICAgbm93ID0gRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGN1dG9mZiA9IDE2MDsgICAvL21zZWNcblxuICAgICAgICB3aGlsZSAoaW5lcnRpYS5sZW5ndGggPiAwICYmIG5vdyAtIGluZXJ0aWFbMF1bMF0gPiBjdXRvZmYpXG4gICAgICAgICAgICBpbmVydGlhLnNoaWZ0KCk7XG4gICAgfVxuXG59O1xuXG5cbi8qKlxuICogUm90YXRlIHN0YXJ0IGV2ZW50LiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgYXQgdGhlIHN0YXJ0IG9mIGEgdXNlci1pbml0aWF0ZWQgcm90YXRlIGludGVyYWN0aW9uLlxuICpcbiAqIEBldmVudCByb3RhdGVzdGFydFxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge0V2ZW50RGF0YX0gZGF0YSBPcmlnaW5hbCBldmVudCBkYXRhXG4gKi9cblxuLyoqXG4gKiBSb3RhdGUgZXZlbnQuIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCByZXBlYXRlZGx5IGR1cmluZyBhIHVzZXItaW5pdGlhdGVkIHJvdGF0ZSBpbnRlcmFjdGlvbi5cbiAqXG4gKiBAZXZlbnQgcm90YXRlXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7RXZlbnREYXRhfSBkYXRhIE9yaWdpbmFsIGV2ZW50IGRhdGFcbiAqL1xuXG4vKipcbiAqIFJvdGF0ZSBlbmQgZXZlbnQuIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCBhdCB0aGUgZW5kIG9mIGEgdXNlci1pbml0aWF0ZWQgcm90YXRlIGludGVyYWN0aW9uLlxuICpcbiAqIEBldmVudCByb3RhdGVlbmRcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtFdmVudERhdGF9IGRhdGEgT3JpZ2luYWwgZXZlbnQgZGF0YVxuICovXG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5Ym9hcmRIYW5kbGVyO1xuXG5cbnZhciBwYW5EZWx0YSA9IDgwLFxuICAgIHJvdGF0ZURlbHRhID0gMixcbiAgICBwaXRjaERlbHRhID0gNTtcblxuLyoqXG4gKiBUaGUgYEtleWJvYXJkSGFuZGxlcmAgYWxsb3dzIGEgdXNlciB0byB6b29tLCByb3RhdGUsIGFuZCBwYW4gdGhlIG1hcCB1c2luZ1xuICogZm9sbG93aW5nIGtleWJvYXJkIHNob3J0Y3V0czpcbiAqICAqIGA9YCAvIGArYDogaW5jcmVhc2Ugem9vbSBsZXZlbCBieSAxXG4gKiAgKiBgU2hpZnQtPWAgLyBgU2hpZnQtK2A6IGluY3JlYXNlIHpvb20gbGV2ZWwgYnkgMlxuICogICogYC1gOiBkZWNyZWFzZSB6b29tIGxldmVsIGJ5IDFcbiAqICAqIGBTaGlmdC0tYDogZGVjcmVhc2Ugem9vbSBsZXZlbCBieSAyXG4gKiAgKiBBcnJvdyBrZXlzOiBwYW4gYnkgODAgcGl4ZWxzXG4gKiAgKiBgU2hpZnQr4oeiYDogaW5jcmVhc2Ugcm90YXRpb24gYnkgMiBkZWdyZWVzXG4gKiAgKiBgU2hpZnQr4oegYDogZGVjcmVhc2Ugcm90YXRpb24gYnkgMiBkZWdyZWVzXG4gKiAgKiBgU2hpZnQr4oehYDogaW5jcmVhc2UgcGl0Y2ggYnkgNSBkZWdyZWVzXG4gKiAgKiBgU2hpZnQr4oejYDogZGVjcmVhc2UgcGl0Y2ggYnkgNSBkZWdyZWVzXG4gKiBAY2xhc3MgS2V5Ym9hcmRIYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIEtleWJvYXJkSGFuZGxlcihtYXApIHtcbiAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgdGhpcy5fZWwgPSBtYXAuZ2V0Q2FudmFzQ29udGFpbmVyKCk7XG5cbiAgICB0aGlzLl9vbktleURvd24gPSB0aGlzLl9vbktleURvd24uYmluZCh0aGlzKTtcbn1cblxuS2V5Ym9hcmRIYW5kbGVyLnByb3RvdHlwZSA9IHtcblxuICAgIF9lbmFibGVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgZW5hYmxlZC9kaXNhYmxlZCBzdGF0ZSBvZiBrZXlib2FyZCBpbnRlcmFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZW5hYmxlZCBzdGF0ZVxuICAgICAqL1xuICAgIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRoZSBhYmlsaXR5IHRvIGludGVyYWN0IHdpdGggdGhlIG1hcCB1c2luZyBrZXlib2FyZCBpbnB1dC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG1hcC5rZXlib2FyZC5lbmFibGUoKTtcbiAgICAgKi9cbiAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5fZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZSB0aGUgYWJpbGl0eSB0byBpbnRlcmFjdCB3aXRoIHRoZSBtYXAgdXNpbmcga2V5Ym9hcmQgaW5wdXQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBtYXAua2V5Ym9hcmQuZGlzYWJsZSgpO1xuICAgICAqL1xuICAgIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCgpKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24pO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSByZXR1cm47XG5cbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgICAgICAgICAgIGV2ZW50RGF0YSA9IHsgb3JpZ2luYWxFdmVudDogZSB9O1xuXG4gICAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgNjE6XG4gICAgICAgIGNhc2UgMTA3OlxuICAgICAgICBjYXNlIDE3MTpcbiAgICAgICAgY2FzZSAxODc6XG4gICAgICAgICAgICBtYXAuem9vbVRvKE1hdGgucm91bmQobWFwLmdldFpvb20oKSkgKyAoZS5zaGlmdEtleSA/IDIgOiAxKSwgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTg5OlxuICAgICAgICBjYXNlIDEwOTpcbiAgICAgICAgY2FzZSAxNzM6XG4gICAgICAgICAgICBtYXAuem9vbVRvKE1hdGgucm91bmQobWFwLmdldFpvb20oKSkgLSAoZS5zaGlmdEtleSA/IDIgOiAxKSwgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIG1hcC5lYXNlVG8oeyBiZWFyaW5nOiBtYXAuZ2V0QmVhcmluZygpIC0gcm90YXRlRGVsdGEgfSwgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIG1hcC5wYW5CeShbLXBhbkRlbHRhLCAwXSwgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIG1hcC5lYXNlVG8oeyBiZWFyaW5nOiBtYXAuZ2V0QmVhcmluZygpICsgcm90YXRlRGVsdGEgfSwgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIG1hcC5wYW5CeShbcGFuRGVsdGEsIDBdLCBldmVudERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgbWFwLmVhc2VUbyh7IHBpdGNoOiBtYXAuZ2V0UGl0Y2goKSArIHBpdGNoRGVsdGEgfSwgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIG1hcC5wYW5CeShbMCwgLXBhbkRlbHRhXSwgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIG1hcC5lYXNlVG8oeyBwaXRjaDogTWF0aC5tYXgobWFwLmdldFBpdGNoKCkgLSBwaXRjaERlbHRhLCAwKSB9LCBldmVudERhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgbWFwLnBhbkJ5KFswLCBwYW5EZWx0YV0sIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBET00gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvbScpLFxuICAgIGJyb3dzZXIgPSByZXF1aXJlKCcuLi8uLi91dGlsL2Jyb3dzZXInKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2Nyb2xsWm9vbUhhbmRsZXI7XG5cblxudmFyIHVhID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkgOiAnJyxcbiAgICBmaXJlZm94ID0gdWEuaW5kZXhPZignZmlyZWZveCcpICE9PSAtMSxcbiAgICBzYWZhcmkgPSB1YS5pbmRleE9mKCdzYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignY2hyb20nKSA9PT0gLTE7XG5cblxuLyoqXG4gKiBUaGUgYFNjcm9sbFpvb21IYW5kbGVyYCBhbGxvd3MgYSB1c2VyIHRvIHpvb20gdGhlIG1hcCBieSBzY3JvbGxpbmcuXG4gKiBAY2xhc3MgU2Nyb2xsWm9vbUhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gU2Nyb2xsWm9vbUhhbmRsZXIobWFwKSB7XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuX2VsID0gbWFwLmdldENhbnZhc0NvbnRhaW5lcigpO1xuXG4gICAgdXRpbC5iaW5kSGFuZGxlcnModGhpcyk7XG59XG5cblNjcm9sbFpvb21IYW5kbGVyLnByb3RvdHlwZSA9IHtcblxuICAgIF9lbmFibGVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgZW5hYmxlZC9kaXNhYmxlZCBzdGF0ZSBvZiB0aGUgXCJzY3JvbGwgdG8gem9vbVwiIGludGVyYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBlbmFibGVkIHN0YXRlXG4gICAgICovXG4gICAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdGhlIFwic2Nyb2xsIHRvIHpvb21cIiBpbnRlcmFjdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgbWFwLnNjcm9sbFpvb20uZW5hYmxlKCk7XG4gICAgICovXG4gICAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCgpKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2VsLmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5fb25XaGVlbCwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbCwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZSB0aGUgXCJzY3JvbGwgdG8gem9vbVwiIGludGVyYWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICBtYXAuc2Nyb2xsWm9vbS5kaXNhYmxlKCk7XG4gICAgICovXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5fZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLl9vbldoZWVsKTtcbiAgICAgICAgdGhpcy5fZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWwpO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIF9vbldoZWVsOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ3doZWVsJykge1xuICAgICAgICAgICAgdmFsdWUgPSBlLmRlbHRhWTtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggZG91YmxlcyB0aGUgdmFsdWVzIG9uIHJldGluYSBzY3JlZW5zLi4uXG4gICAgICAgICAgICBpZiAoZmlyZWZveCAmJiBlLmRlbHRhTW9kZSA9PT0gd2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX1BJWEVMKSB2YWx1ZSAvPSBicm93c2VyLmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgICAgICBpZiAoZS5kZWx0YU1vZGUgPT09IHdpbmRvdy5XaGVlbEV2ZW50LkRPTV9ERUxUQV9MSU5FKSB2YWx1ZSAqPSA0MDtcblxuICAgICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IC1lLndoZWVsRGVsdGFZO1xuICAgICAgICAgICAgaWYgKHNhZmFyaSkgdmFsdWUgPSB2YWx1ZSAvIDM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm93ID0gYnJvd3Nlci5ub3coKSxcbiAgICAgICAgICAgIHRpbWVEZWx0YSA9IG5vdyAtICh0aGlzLl90aW1lIHx8IDApO1xuXG4gICAgICAgIHRoaXMuX3BvcyA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZSk7XG4gICAgICAgIHRoaXMuX3RpbWUgPSBub3c7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSAwICYmICh2YWx1ZSAlIDQuMDAwMjQ0MTQwNjI1KSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gVGhpcyBvbmUgaXMgZGVmaW5pdGVseSBhIG1vdXNlIHdoZWVsIGV2ZW50LlxuICAgICAgICAgICAgdGhpcy5fdHlwZSA9ICd3aGVlbCc7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdGhpcyB2YWx1ZSB0byBtYXRjaCB0cmFja3BhZC5cbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvIDQpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IDAgJiYgTWF0aC5hYnModmFsdWUpIDwgNCkge1xuICAgICAgICAgICAgLy8gVGhpcyBvbmUgaXMgZGVmaW5pdGVseSBhIHRyYWNrcGFkIGV2ZW50IGJlY2F1c2UgaXQgaXMgc28gc21hbGwuXG4gICAgICAgICAgICB0aGlzLl90eXBlID0gJ3RyYWNrcGFkJztcblxuICAgICAgICB9IGVsc2UgaWYgKHRpbWVEZWx0YSA+IDQwMCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBsaWtlbHkgYSBuZXcgc2Nyb2xsIGFjdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbGFzdFZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IGEgdGltZW91dCBpbiBjYXNlIHRoaXMgd2FzIGEgc2luZ3VsYXIgZXZlbnQsIGFuZCBkZWx5IGl0IGJ5IHVwIHRvIDQwbXMuXG4gICAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl9vblRpbWVvdXQsIDQwKTtcblxuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl90eXBlKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgcmVwZWF0aW5nIGV2ZW50LCBidXQgd2UgZG9uJ3Qga25vdyB0aGUgdHlwZSBvZiBldmVudCBqdXN0IHlldC5cbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWx0YSBwZXIgdGltZSBpcyBzbWFsbCwgd2UgYXNzdW1lIGl0J3MgYSBmYXN0IHRyYWNrcGFkOyBvdGhlcndpc2Ugd2Ugc3dpdGNoIGludG8gd2hlZWwgbW9kZS5cbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSAoTWF0aC5hYnModGltZURlbHRhICogdmFsdWUpIDwgMjAwKSA/ICd0cmFja3BhZCcgOiAnd2hlZWwnO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgb3VyIGRlbGF5ZWQgZXZlbnQgaXNuJ3QgZmlyZWQgYWdhaW4sIGJlY2F1c2Ugd2UgYWNjdW11bGF0ZVxuICAgICAgICAgICAgLy8gdGhlIHByZXZpb3VzIGV2ZW50ICh3aGljaCB3YXMgbGVzcyB0aGFuIDQwbXMgYWdvKSBpbnRvIHRoaXMgZXZlbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5fdGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSB0aGlzLl9sYXN0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTbG93IGRvd24gem9vbSBpZiBzaGlmdCBrZXkgaXMgaGVsZCBmb3IgbW9yZSBwcmVjaXNlIHpvb21pbmdcbiAgICAgICAgaWYgKGUuc2hpZnRLZXkgJiYgdmFsdWUpIHZhbHVlID0gdmFsdWUgLyA0O1xuXG4gICAgICAgIC8vIE9ubHkgZmlyZSB0aGUgY2FsbGJhY2sgaWYgd2UgYWN0dWFsbHkga25vdyB3aGF0IHR5cGUgb2Ygc2Nyb2xsaW5nIGRldmljZSB0aGUgdXNlciB1c2VzLlxuICAgICAgICBpZiAodGhpcy5fdHlwZSkgdGhpcy5fem9vbSgtdmFsdWUsIGUpO1xuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgX29uVGltZW91dDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90eXBlID0gJ3doZWVsJztcbiAgICAgICAgdGhpcy5fem9vbSgtdGhpcy5fbGFzdFZhbHVlKTtcbiAgICB9LFxuXG4gICAgX3pvb206IGZ1bmN0aW9uIChkZWx0YSwgZSkge1xuICAgICAgICBpZiAoZGVsdGEgPT09IDApIHJldHVybjtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICAgICAgICAvLyBTY2FsZSBieSBzaWdtb2lkIG9mIHNjcm9sbCB3aGVlbCBkZWx0YS5cbiAgICAgICAgdmFyIHNjYWxlID0gMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGRlbHRhIC8gMTAwKSkpO1xuICAgICAgICBpZiAoZGVsdGEgPCAwICYmIHNjYWxlICE9PSAwKSBzY2FsZSA9IDEgLyBzY2FsZTtcblxuICAgICAgICB2YXIgZnJvbVNjYWxlID0gbWFwLmVhc2UgPyBtYXAuZWFzZS50byA6IG1hcC50cmFuc2Zvcm0uc2NhbGUsXG4gICAgICAgICAgICB0YXJnZXRab29tID0gbWFwLnRyYW5zZm9ybS5zY2FsZVpvb20oZnJvbVNjYWxlICogc2NhbGUpO1xuXG4gICAgICAgIG1hcC56b29tVG8odGFyZ2V0Wm9vbSwge1xuICAgICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgICBhcm91bmQ6IG1hcC51bnByb2plY3QodGhpcy5fcG9zKSxcbiAgICAgICAgICAgIGRlbGF5RW5kRXZlbnRzOiAyMDBcbiAgICAgICAgfSwgeyBvcmlnaW5hbEV2ZW50OiBlIH0pO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBab29tIHN0YXJ0IGV2ZW50LiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQganVzdCBiZWZvcmUgdGhlIG1hcCBiZWdpbnMgYSB0cmFuc2l0aW9uIGZyb20gb25lXG4gKiB6b29tIGxldmVsIHRvIGFub3RoZXIsIGVpdGhlciBhcyBhIHJlc3VsdCBvZiB1c2VyIGludGVyYWN0aW9uIG9yIHRoZSB1c2Ugb2YgbWV0aG9kcyBzdWNoIGFzIGBNYXAjanVtcFRvYC5cbiAqXG4gKiBAZXZlbnQgem9vbXN0YXJ0XG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7RXZlbnREYXRhfSBkYXRhIE9yaWdpbmFsIGV2ZW50IGRhdGEsIGlmIGZpcmVkIGludGVyYWN0aXZlbHlcbiAqL1xuXG4vKipcbiAqIFpvb20gZXZlbnQuIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCByZXBlYXRlZGx5IGR1cmluZyBhbmltYXRlZCB0cmFuc2l0aW9ucyBmcm9tIG9uZSB6b29tIGxldmVsIHRvXG4gKiBhbm90aGVyLCBlaXRoZXIgYXMgYSByZXN1bHQgb2YgdXNlciBpbnRlcmFjdGlvbiBvciB0aGUgdXNlIG9mIG1ldGhvZHMgc3VjaCBhcyBgTWFwI2p1bXBUb2AuXG4gKlxuICogQGV2ZW50IHpvb21cbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtFdmVudERhdGF9IGRhdGEgT3JpZ2luYWwgZXZlbnQgZGF0YSwgaWYgZmlyZWQgaW50ZXJhY3RpdmVseVxuICovXG5cbi8qKlxuICogWm9vbSBlbmQgZXZlbnQuIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCBqdXN0IGFmdGVyIHRoZSBtYXAgY29tcGxldGVzIGEgdHJhbnNpdGlvbiBmcm9tIG9uZVxuICogem9vbSBsZXZlbCB0byBhbm90aGVyLCBlaXRoZXIgYXMgYSByZXN1bHQgb2YgdXNlciBpbnRlcmFjdGlvbiBvciB0aGUgdXNlIG9mIG1ldGhvZHMgc3VjaCBhcyBgTWFwI2p1bXBUb2AuXG4gKlxuICogQGV2ZW50IHpvb21lbmRcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtFdmVudERhdGF9IGRhdGEgT3JpZ2luYWwgZXZlbnQgZGF0YSwgaWYgZmlyZWQgaW50ZXJhY3RpdmVseVxuICovXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBET00gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvbScpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUb3VjaFpvb21Sb3RhdGVIYW5kbGVyO1xuXG52YXIgaW5lcnRpYUxpbmVhcml0eSA9IDAuMTUsXG4gICAgaW5lcnRpYUVhc2luZyA9IHV0aWwuYmV6aWVyKDAsIDAsIGluZXJ0aWFMaW5lYXJpdHksIDEpLFxuICAgIGluZXJ0aWFEZWNlbGVyYXRpb24gPSAxMiwgLy8gc2NhbGUgLyBzXjJcbiAgICBpbmVydGlhTWF4U3BlZWQgPSAyLjUsIC8vIHNjYWxlIC8gc1xuICAgIHNpZ25pZmljYW50U2NhbGVUaHJlc2hvbGQgPSAwLjE1LFxuICAgIHNpZ25pZmljYW50Um90YXRlVGhyZXNob2xkID0gNDtcblxuXG4vKipcbiAqIFRoZSBgVG91Y2hab29tUm90YXRlSGFuZGxlcmAgYWxsb3dzIGEgdXNlciB0byB6b29tIGFuZCByb3RhdGUgdGhlIG1hcCBieVxuICogcGluY2hpbmcgb24gYSB0b3VjaHNjcmVlbi5cbiAqIEBjbGFzcyBUb3VjaFpvb21Sb3RhdGVIYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIFRvdWNoWm9vbVJvdGF0ZUhhbmRsZXIobWFwKSB7XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuX2VsID0gbWFwLmdldENhbnZhc0NvbnRhaW5lcigpO1xuXG4gICAgdXRpbC5iaW5kSGFuZGxlcnModGhpcyk7XG59XG5cblRvdWNoWm9vbVJvdGF0ZUhhbmRsZXIucHJvdG90eXBlID0ge1xuXG4gICAgX2VuYWJsZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBlbmFibGVkL2Rpc2FibGVkIHN0YXRlIG9mIHRoZSBcInBpbmNoIHRvIHJvdGF0ZSBhbmQgem9vbVwiIGludGVyYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBlbmFibGVkIHN0YXRlXG4gICAgICovXG4gICAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdGhlIFwicGluY2ggdG8gcm90YXRlIGFuZCB6b29tXCIgaW50ZXJhY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgIG1hcC50b3VjaFpvb21Sb3RhdGUuZW5hYmxlKCk7XG4gICAgICovXG4gICAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCgpKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2VsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblN0YXJ0LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIHRoZSBcInBpbmNoIHRvIHJvdGF0ZSBhbmQgem9vbVwiIGludGVyYWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICBtYXAudG91Y2hab29tUm90YXRlLmRpc2FibGUoKTtcbiAgICAgKi9cbiAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0VuYWJsZWQoKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9lbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25TdGFydCk7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZSB0aGUgXCJwaW5jaCB0byByb3RhdGVcIiBpbnRlcmFjdGlvbiwgbGVhdmluZyB0aGUgXCJwaW5jaCB0byB6b29tXCJcbiAgICAgKiBpbnRlcmFjdGlvbiBlbmFibGVkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICBtYXAudG91Y2hab29tUm90YXRlLmRpc2FibGVSb3RhdGlvbigpO1xuICAgICAqL1xuICAgIGRpc2FibGVSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3JvdGF0aW9uRGlzYWJsZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdGhlIFwicGluY2ggdG8gcm90YXRlXCIgaW50ZXJhY3Rpb24sIHVuZG9pbmcgYSBjYWxsIHRvXG4gICAgICogYGRpc2FibGVSb3RhdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgIG1hcC50b3VjaFpvb21Sb3RhdGUuZW5hYmxlKCk7XG4gICAgICogICBtYXAudG91Y2hab29tUm90YXRlLmVuYWJsZVJvdGF0aW9uKCk7XG4gICAgICovXG4gICAgZW5hYmxlUm90YXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9yb3RhdGlvbkRpc2FibGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIF9vblN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCAhPT0gMikgcmV0dXJuO1xuXG4gICAgICAgIHZhciBwMCA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZS50b3VjaGVzWzBdKSxcbiAgICAgICAgICAgIHAxID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlLnRvdWNoZXNbMV0pO1xuXG4gICAgICAgIHRoaXMuX3N0YXJ0VmVjID0gcDAuc3ViKHAxKTtcbiAgICAgICAgdGhpcy5fc3RhcnRTY2FsZSA9IHRoaXMuX21hcC50cmFuc2Zvcm0uc2NhbGU7XG4gICAgICAgIHRoaXMuX3N0YXJ0QmVhcmluZyA9IHRoaXMuX21hcC50cmFuc2Zvcm0uYmVhcmluZztcbiAgICAgICAgdGhpcy5fZ2VzdHVyZUludGVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faW5lcnRpYSA9IFtdO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uRW5kLCBmYWxzZSk7XG4gICAgfSxcblxuICAgIF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoICE9PSAyKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHAwID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlLnRvdWNoZXNbMF0pLFxuICAgICAgICAgICAgcDEgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUudG91Y2hlc1sxXSksXG4gICAgICAgICAgICBwID0gcDAuYWRkKHAxKS5kaXYoMiksXG4gICAgICAgICAgICB2ZWMgPSBwMC5zdWIocDEpLFxuICAgICAgICAgICAgc2NhbGUgPSB2ZWMubWFnKCkgLyB0aGlzLl9zdGFydFZlYy5tYWcoKSxcbiAgICAgICAgICAgIGJlYXJpbmcgPSB0aGlzLl9yb3RhdGlvbkRpc2FibGVkID8gMCA6IHZlYy5hbmdsZVdpdGgodGhpcy5fc3RhcnRWZWMpICogMTgwIC8gTWF0aC5QSSxcbiAgICAgICAgICAgIG1hcCA9IHRoaXMuX21hcDtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgJ2ludGVudCcgYnkgd2hpY2hldmVyIHRocmVzaG9sZCBpcyBzdXJwYXNzZWQgZmlyc3QsXG4gICAgICAgIC8vIHRoZW4ga2VlcCB0aGF0IHN0YXRlIGZvciB0aGUgZHVyYXRpb24gb2YgdGhpcyBnZXN0dXJlLlxuICAgICAgICBpZiAoIXRoaXMuX2dlc3R1cmVJbnRlbnQpIHtcbiAgICAgICAgICAgIHZhciBzY2FsaW5nU2lnbmlmaWNhbnRseSA9IChNYXRoLmFicygxIC0gc2NhbGUpID4gc2lnbmlmaWNhbnRTY2FsZVRocmVzaG9sZCksXG4gICAgICAgICAgICAgICAgcm90YXRpbmdTaWduaWZpY2FudGx5ID0gKE1hdGguYWJzKGJlYXJpbmcpID4gc2lnbmlmaWNhbnRSb3RhdGVUaHJlc2hvbGQpO1xuXG4gICAgICAgICAgICBpZiAocm90YXRpbmdTaWduaWZpY2FudGx5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2VzdHVyZUludGVudCA9ICdyb3RhdGUnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzY2FsaW5nU2lnbmlmaWNhbnRseSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dlc3R1cmVJbnRlbnQgPSAnem9vbSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXN0dXJlSW50ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRWZWMgPSB2ZWM7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRTY2FsZSA9IG1hcC50cmFuc2Zvcm0uc2NhbGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRCZWFyaW5nID0gbWFwLnRyYW5zZm9ybS5iZWFyaW5nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSB7IGR1cmF0aW9uOiAwLCBhcm91bmQ6IG1hcC51bnByb2plY3QocCkgfTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2dlc3R1cmVJbnRlbnQgPT09ICdyb3RhdGUnKSB7XG4gICAgICAgICAgICAgICAgcGFyYW0uYmVhcmluZyA9IHRoaXMuX3N0YXJ0QmVhcmluZyArIGJlYXJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fZ2VzdHVyZUludGVudCA9PT0gJ3pvb20nIHx8IHRoaXMuX2dlc3R1cmVJbnRlbnQgPT09ICdyb3RhdGUnKSB7XG4gICAgICAgICAgICAgICAgcGFyYW0uem9vbSA9IG1hcC50cmFuc2Zvcm0uc2NhbGVab29tKHRoaXMuX3N0YXJ0U2NhbGUgKiBzY2FsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hcC5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9kcmFpbkluZXJ0aWFCdWZmZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0aWEucHVzaChbRGF0ZS5ub3coKSwgc2NhbGUsIHBdKTtcblxuICAgICAgICAgICAgbWFwLmVhc2VUbyhwYXJhbSwgeyBvcmlnaW5hbEV2ZW50OiBlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBfb25FbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25FbmQpO1xuICAgICAgICB0aGlzLl9kcmFpbkluZXJ0aWFCdWZmZXIoKTtcblxuICAgICAgICB2YXIgaW5lcnRpYSA9IHRoaXMuX2luZXJ0aWEsXG4gICAgICAgICAgICBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgaWYgKGluZXJ0aWEubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgbWFwLnNuYXBUb05vcnRoKHt9LCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdCA9IGluZXJ0aWFbaW5lcnRpYS5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIGZpcnN0ID0gaW5lcnRpYVswXSxcbiAgICAgICAgICAgIGxhc3RTY2FsZSA9IG1hcC50cmFuc2Zvcm0uc2NhbGVab29tKHRoaXMuX3N0YXJ0U2NhbGUgKiBsYXN0WzFdKSxcbiAgICAgICAgICAgIGZpcnN0U2NhbGUgPSBtYXAudHJhbnNmb3JtLnNjYWxlWm9vbSh0aGlzLl9zdGFydFNjYWxlICogZmlyc3RbMV0pLFxuICAgICAgICAgICAgc2NhbGVPZmZzZXQgPSBsYXN0U2NhbGUgLSBmaXJzdFNjYWxlLFxuICAgICAgICAgICAgc2NhbGVEdXJhdGlvbiA9IChsYXN0WzBdIC0gZmlyc3RbMF0pIC8gMTAwMCxcbiAgICAgICAgICAgIHAgPSBsYXN0WzJdO1xuXG4gICAgICAgIGlmIChzY2FsZUR1cmF0aW9uID09PSAwIHx8IGxhc3RTY2FsZSA9PT0gZmlyc3RTY2FsZSkge1xuICAgICAgICAgICAgbWFwLnNuYXBUb05vcnRoKHt9LCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxjdWxhdGUgc2NhbGUvcyBzcGVlZCBhbmQgYWRqdXN0IGZvciBpbmNyZWFzZWQgaW5pdGlhbCBhbmltYXRpb24gc3BlZWQgd2hlbiBlYXNpbmdcbiAgICAgICAgdmFyIHNwZWVkID0gc2NhbGVPZmZzZXQgKiBpbmVydGlhTGluZWFyaXR5IC8gc2NhbGVEdXJhdGlvbjsgLy8gc2NhbGUvc1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhzcGVlZCkgPiBpbmVydGlhTWF4U3BlZWQpIHtcbiAgICAgICAgICAgIGlmIChzcGVlZCA+IDApIHtcbiAgICAgICAgICAgICAgICBzcGVlZCA9IGluZXJ0aWFNYXhTcGVlZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3BlZWQgPSAtaW5lcnRpYU1heFNwZWVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGR1cmF0aW9uID0gTWF0aC5hYnMoc3BlZWQgLyAoaW5lcnRpYURlY2VsZXJhdGlvbiAqIGluZXJ0aWFMaW5lYXJpdHkpKSAqIDEwMDAsXG4gICAgICAgICAgICB0YXJnZXRTY2FsZSA9IGxhc3RTY2FsZSArIHNwZWVkICogZHVyYXRpb24gLyAyMDAwO1xuXG4gICAgICAgIGlmICh0YXJnZXRTY2FsZSA8IDApIHtcbiAgICAgICAgICAgIHRhcmdldFNjYWxlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcC5lYXNlVG8oe1xuICAgICAgICAgICAgem9vbTogdGFyZ2V0U2NhbGUsXG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgICBlYXNpbmc6IGluZXJ0aWFFYXNpbmcsXG4gICAgICAgICAgICBhcm91bmQ6IG1hcC51bnByb2plY3QocClcbiAgICAgICAgfSwgeyBvcmlnaW5hbEV2ZW50OiBlIH0pO1xuICAgIH0sXG5cbiAgICBfZHJhaW5JbmVydGlhQnVmZmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGluZXJ0aWEgPSB0aGlzLl9pbmVydGlhLFxuICAgICAgICAgICAgbm93ID0gRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGN1dG9mZiA9IDE2MDsgLy8gbXNlY1xuXG4gICAgICAgIHdoaWxlIChpbmVydGlhLmxlbmd0aCA+IDIgJiYgbm93IC0gaW5lcnRpYVswXVswXSA+IGN1dG9mZikgaW5lcnRpYS5zaGlmdCgpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qXG4gKiBBZGRzIHRoZSBtYXAncyBwb3NpdGlvbiB0byBpdHMgcGFnZSdzIGxvY2F0aW9uIGhhc2guXG4gKiBQYXNzZWQgYXMgYW4gb3B0aW9uIHRvIHRoZSBtYXAgb2JqZWN0LlxuICpcbiAqIEBjbGFzcyBtYXBib3hnbC5IYXNoXG4gKiBAcmV0dXJucyB7SGFzaH0gYHRoaXNgXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcblxuZnVuY3Rpb24gSGFzaCgpIHtcbiAgICB1dGlsLmJpbmRBbGwoW1xuICAgICAgICAnX29uSGFzaENoYW5nZScsXG4gICAgICAgICdfdXBkYXRlSGFzaCdcbiAgICBdLCB0aGlzKTtcbn1cblxuSGFzaC5wcm90b3R5cGUgPSB7XG4gICAgLypcbiAgICAgKiBNYXAgZWxlbWVudCB0byBsaXN0ZW4gZm9yIGNvb3JkaW5hdGUgY2hhbmdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcFxuICAgICAqIEByZXR1cm5zIHtIYXNofSBgdGhpc2BcbiAgICAgKi9cbiAgICBhZGRUbzogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9vbkhhc2hDaGFuZ2UsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fbWFwLm9uKCdtb3ZlZW5kJywgdGhpcy5fdXBkYXRlSGFzaCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIFJlbW92ZXMgaGFzaFxuICAgICAqXG4gICAgICogQHJldHVybnMge1BvcHVwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIHRoaXMuX29uSGFzaENoYW5nZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9tYXAub2ZmKCdtb3ZlZW5kJywgdGhpcy5fdXBkYXRlSGFzaCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tYXA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfb25IYXNoQ2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxvYyA9IGxvY2F0aW9uLmhhc2gucmVwbGFjZSgnIycsICcnKS5zcGxpdCgnLycpO1xuICAgICAgICBpZiAobG9jLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuanVtcFRvKHtcbiAgICAgICAgICAgICAgICBjZW50ZXI6IFsrbG9jWzJdLCArbG9jWzFdXSxcbiAgICAgICAgICAgICAgICB6b29tOiArbG9jWzBdLFxuICAgICAgICAgICAgICAgIGJlYXJpbmc6ICsobG9jWzNdIHx8IDApXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUhhc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpLFxuICAgICAgICAgICAgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCksXG4gICAgICAgICAgICBiZWFyaW5nID0gdGhpcy5fbWFwLmdldEJlYXJpbmcoKSxcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbChNYXRoLmxvZyh6b29tKSAvIE1hdGguTE4yKSksXG5cbiAgICAgICAgICAgIGhhc2ggPSAnIycgKyAoTWF0aC5yb3VuZCh6b29tICogMTAwKSAvIDEwMCkgK1xuICAgICAgICAgICAgICAgICcvJyArIGNlbnRlci5sYXQudG9GaXhlZChwcmVjaXNpb24pICtcbiAgICAgICAgICAgICAgICAnLycgKyBjZW50ZXIubG5nLnRvRml4ZWQocHJlY2lzaW9uKSArXG4gICAgICAgICAgICAgICAgKGJlYXJpbmcgPyAnLycgKyAoTWF0aC5yb3VuZChiZWFyaW5nICogMTApIC8gMTApIDogJycpO1xuXG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSgnJywgJycsIGhhc2gpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYW5kbGVycyA9IHtcbiAgICBzY3JvbGxab29tOiByZXF1aXJlKCcuL2hhbmRsZXIvc2Nyb2xsX3pvb20nKSxcbiAgICBib3hab29tOiByZXF1aXJlKCcuL2hhbmRsZXIvYm94X3pvb20nKSxcbiAgICBkcmFnUm90YXRlOiByZXF1aXJlKCcuL2hhbmRsZXIvZHJhZ19yb3RhdGUnKSxcbiAgICBkcmFnUGFuOiByZXF1aXJlKCcuL2hhbmRsZXIvZHJhZ19wYW4nKSxcbiAgICBrZXlib2FyZDogcmVxdWlyZSgnLi9oYW5kbGVyL2tleWJvYXJkJyksXG4gICAgZG91YmxlQ2xpY2tab29tOiByZXF1aXJlKCcuL2hhbmRsZXIvZGJsY2xpY2tfem9vbScpLFxuICAgIHRvdWNoWm9vbVJvdGF0ZTogcmVxdWlyZSgnLi9oYW5kbGVyL3RvdWNoX3pvb21fcm90YXRlJylcbn07XG5cbnZhciBET00gPSByZXF1aXJlKCcuLi91dGlsL2RvbScpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKSxcbiAgICBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJhY3Rpb247XG5cbmZ1bmN0aW9uIEludGVyYWN0aW9uKG1hcCkge1xuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB0aGlzLl9lbCA9IG1hcC5nZXRDYW52YXNDb250YWluZXIoKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gaGFuZGxlcnMpIHtcbiAgICAgICAgbWFwW25hbWVdID0gbmV3IGhhbmRsZXJzW25hbWVdKG1hcCk7XG4gICAgfVxuXG4gICAgdXRpbC5iaW5kSGFuZGxlcnModGhpcyk7XG59XG5cbkludGVyYWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9tYXAub3B0aW9ucyxcbiAgICAgICAgICAgIGVsID0gdGhpcy5fZWw7XG5cbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBoYW5kbGVycykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnNbbmFtZV0pIHRoaXMuX21hcFtuYW1lXS5lbmFibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCBmYWxzZSk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXAsIGZhbHNlKTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgZmFsc2UpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQsIGZhbHNlKTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIGZhbHNlKTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLl9vblRvdWNoQ2FuY2VsLCBmYWxzZSk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljaywgZmFsc2UpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMuX29uRGJsQ2xpY2ssIGZhbHNlKTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLl9vbkNvbnRleHRNZW51LCBmYWxzZSk7XG4gICAgfSxcblxuICAgIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9tYXAub3B0aW9ucyxcbiAgICAgICAgICAgIGVsID0gdGhpcy5fZWw7XG5cbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBoYW5kbGVycykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnNbbmFtZV0pIHRoaXMuX21hcFtuYW1lXS5kaXNhYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93bik7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQpO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQpO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25Ub3VjaENhbmNlbCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljayk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcy5fb25EYmxDbGljayk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcy5fb25Db250ZXh0TWVudSk7XG4gICAgfSxcblxuICAgIF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fbWFwLnN0b3AoKTtcbiAgICAgICAgdGhpcy5fc3RhcnRQb3MgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUpO1xuICAgICAgICB0aGlzLl9maXJlTW91c2VFdmVudCgnbW91c2Vkb3duJywgZSk7XG4gICAgfSxcblxuICAgIF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gICAgICAgICAgICByb3RhdGluZyA9IG1hcC5kcmFnUm90YXRlICYmIG1hcC5kcmFnUm90YXRlLmlzQWN0aXZlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbnRleHRNZW51RXZlbnQgJiYgIXJvdGF0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlTW91c2VFdmVudCgnY29udGV4dG1lbnUnLCB0aGlzLl9jb250ZXh0TWVudUV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvbnRleHRNZW51RXZlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9maXJlTW91c2VFdmVudCgnbW91c2V1cCcsIGUpO1xuICAgIH0sXG5cbiAgICBfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gICAgICAgICAgICBlbCA9IHRoaXMuX2VsO1xuXG4gICAgICAgIGlmIChtYXAuZHJhZ1BhbiAmJiBtYXAuZHJhZ1Bhbi5pc0FjdGl2ZSgpKSByZXR1cm47XG4gICAgICAgIGlmIChtYXAuZHJhZ1JvdGF0ZSAmJiBtYXAuZHJhZ1JvdGF0ZS5pc0FjdGl2ZSgpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHRhcmdldCA9IGUudG9FbGVtZW50IHx8IGUudGFyZ2V0O1xuICAgICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gZWwpIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSBlbCkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuX2ZpcmVNb3VzZUV2ZW50KCdtb3VzZW1vdmUnLCBlKTtcbiAgICB9LFxuXG4gICAgX29uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fbWFwLnN0b3AoKTtcbiAgICAgICAgdGhpcy5fZmlyZVRvdWNoRXZlbnQoJ3RvdWNoc3RhcnQnLCBlKTtcblxuICAgICAgICBpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoID4gMSkgcmV0dXJuO1xuXG4gICAgICAgIGlmICghdGhpcy5fdGFwcGVkKSB7XG4gICAgICAgICAgICB0aGlzLl90YXBwZWQgPSBzZXRUaW1lb3V0KHRoaXMuX29uVG91Y2hUaW1lb3V0LCAzMDApO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGFwcGVkKTtcbiAgICAgICAgICAgIHRoaXMuX3RhcHBlZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9maXJlTW91c2VFdmVudCgnZGJsY2xpY2snLCBlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVUb3VjaEV2ZW50KCd0b3VjaG1vdmUnLCBlKTtcbiAgICB9LFxuXG4gICAgX29uVG91Y2hFbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVUb3VjaEV2ZW50KCd0b3VjaGVuZCcsIGUpO1xuICAgIH0sXG5cbiAgICBfb25Ub3VjaENhbmNlbDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fZmlyZVRvdWNoRXZlbnQoJ3RvdWNoY2FuY2VsJywgZSk7XG4gICAgfSxcblxuICAgIF9vblRvdWNoVGltZW91dDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90YXBwZWQgPSBudWxsO1xuICAgIH0sXG5cbiAgICBfb25DbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHBvcyA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZSk7XG5cbiAgICAgICAgaWYgKHBvcy5lcXVhbHModGhpcy5fc3RhcnRQb3MpKSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlTW91c2VFdmVudCgnY2xpY2snLCBlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfb25EYmxDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fZmlyZU1vdXNlRXZlbnQoJ2RibGNsaWNrJywgZSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgX29uQ29udGV4dE1lbnU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHRNZW51RXZlbnQgPSBlO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcblxuICAgIF9maXJlTW91c2VFdmVudDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcbiAgICAgICAgdmFyIHBvcyA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5maXJlKHR5cGUsIHtcbiAgICAgICAgICAgIGxuZ0xhdDogdGhpcy5fbWFwLnVucHJvamVjdChwb3MpLFxuICAgICAgICAgICAgcG9pbnQ6IHBvcyxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGVcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9maXJlVG91Y2hFdmVudDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBET00udG91Y2hQb3ModGhpcy5fZWwsIGUpLFxuICAgICAgICAgICAgc2luZ3VsYXIgPSB0b3VjaGVzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyciwgaSwgYXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXYuYWRkKGN1cnIuZGl2KGFyci5sZW5ndGgpKTtcbiAgICAgICAgICAgIH0sIG5ldyBQb2ludCgwLCAwKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5maXJlKHR5cGUsIHtcbiAgICAgICAgICAgIGxuZ0xhdDogdGhpcy5fbWFwLnVucHJvamVjdChzaW5ndWxhciksXG4gICAgICAgICAgICBwb2ludDogc2luZ3VsYXIsXG4gICAgICAgICAgICBsbmdMYXRzOiB0b3VjaGVzLm1hcChmdW5jdGlvbih0KSB7IHJldHVybiB0aGlzLl9tYXAudW5wcm9qZWN0KHQpOyB9LCB0aGlzKSxcbiAgICAgICAgICAgIHBvaW50czogdG91Y2hlcyxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGVcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIFdoZW4gYW4gZXZlbnQgW2ZpcmVzXXtAbGluayAjRXZlbnRlZC5maXJlfSBhcyBhIHJlc3VsdCBvZiBhXG4gKiB1c2VyIGludGVyYWN0aW9uLCB0aGUgZXZlbnQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhbiBFdmVudERhdGFcbiAqIG9iamVjdCBjb250YWluaW5nIHRoZSBvcmlnaW5hbCBET00gZXZlbnQgYWxvbmcgd2l0aCBjb29yZGluYXRlcyBvZlxuICogdGhlIGV2ZW50IHRhcmdldC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFdmVudERhdGFcbiAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnQgVGhlIG9yaWdpbmFsIERPTSBldmVudFxuICogQHByb3BlcnR5IHtQb2ludH0gcG9pbnQgVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBldmVudFxuICogQHByb3BlcnR5IHtMbmdMYXR9IGxuZ0xhdCBUaGUgZ2VvZ3JhcGhpYyBsb2NhdGlvbiBvZiB0aGUgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBtYXAub24oJ2NsaWNrJywgZnVuY3Rpb24oZGF0YSkge1xuICogICB2YXIgZSA9IGRhdGEgJiYgZGF0YS5vcmlnaW5hbEV2ZW50O1xuICogICBjb25zb2xlLmxvZygnZ290IGNsaWNrICcgKyAoZSA/ICdidXR0b24gPSAnICsgZS5idXR0b24gOiAnJykpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBNb3VzZSBkb3duIGV2ZW50LlxuICpcbiAqIEBldmVudCBtb3VzZWRvd25cbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtFdmVudERhdGF9IGRhdGEgT3JpZ2luYWwgZXZlbnQgZGF0YTogYSBbbW91c2Vkb3duIGV2ZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMvbW91c2Vkb3duKVxuICovXG5cbi8qKlxuICogTW91c2UgdXAgZXZlbnQuXG4gKlxuICogQGV2ZW50IG1vdXNldXBcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtFdmVudERhdGF9IGRhdGEgT3JpZ2luYWwgZXZlbnQgZGF0YTogYSBbbW91c2V1cCBldmVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzL21vdXNldXApXG4gKi9cblxuLyoqXG4gKiBNb3VzZSBtb3ZlIGV2ZW50LlxuICpcbiAqIEBldmVudCBtb3VzZW1vdmVcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtFdmVudERhdGF9IGRhdGEgT3JpZ2luYWwgZXZlbnQgZGF0YTogYSBbbW91c2Vtb3VzZSBldmVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzL21vdXNlbW92ZSlcbiAqL1xuXG4vKipcbiAqIFRvdWNoIHN0YXJ0IGV2ZW50LlxuICpcbiAqIEBldmVudCB0b3VjaHN0YXJ0XG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7RXZlbnREYXRhfSBkYXRhIE9yaWdpbmFsIGV2ZW50IGRhdGE6IGEgW3RvdWNoc3RhcnQgZXZlbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50cy90b3VjaHN0YXJ0KS5cbiAqL1xuXG4vKipcbiAqIFRvdWNoIGVuZCBldmVudC5cbiAqXG4gKiBAZXZlbnQgdG91Y2hlbmRcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtFdmVudERhdGF9IGRhdGEgT3JpZ2luYWwgZXZlbnQgZGF0YTogYSBbdG91Y2hjYW5jZWwgZXZlbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50cy90b3VjaGNhbmNlbCkuXG4gKi9cblxuLyoqXG4gKiBUb3VjaCBtb3ZlIGV2ZW50LlxuICpcbiAqIEBldmVudCB0b3VjaG1vdmVcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtFdmVudERhdGF9IGRhdGEgT3JpZ2luYWwgZXZlbnQgZGF0YTogYSBbdG91Y2htb3ZlIGV2ZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMvdG91Y2htb3ZlKS5cbiAqL1xuXG4vKipcbiAqIFRvdWNoIGNhbmNlbCBldmVudC5cbiAqXG4gKiBAZXZlbnQgdG91Y2hjYW5jZWxcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtFdmVudERhdGF9IGRhdGEgT3JpZ2luYWwgZXZlbnQgZGF0YTogYSBbdG91Y2hjYW5jZWwgZXZlbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50cy90b3VjaGNhbmNlbCkuXG4gKi9cblxuLyoqXG4gKiBDbGljayBldmVudC5cbiAqXG4gKiBAZXZlbnQgY2xpY2tcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtFdmVudERhdGF9IGRhdGEgT3JpZ2luYWwgZXZlbnQgZGF0YTogYSBbY2xpY2sgZXZlbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50cy9jbGljaylcbiAqL1xuXG4vKipcbiAqIERvdWJsZSBjbGljayBldmVudC5cbiAqXG4gKiBAZXZlbnQgZGJsY2xpY2tcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtFdmVudERhdGF9IGRhdGEgT3JpZ2luYWwgZXZlbnQgZGF0YVxuICovXG5cbi8qKlxuICogQ29udGV4dCBtZW51IGV2ZW50LlxuICpcbiAqIEBldmVudCBjb250ZXh0bWVudVxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge0V2ZW50RGF0YX0gZGF0YSBPcmlnaW5hbCBldmVudCBkYXRhLCBpZiBhdmFpbGFibGVcbiAqL1xuXG4vKipcbiAqIExvYWQgZXZlbnQuIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCBpbW1lZGlhdGVseSBhZnRlciBhbGwgbmVjZXNzYXJ5IHJlc291cmNlcyBoYXZlIGJlZW4gZG93bmxvYWRlZFxuICogYW5kIHRoZSBmaXJzdCB2aXN1YWxseSBjb21wbGV0ZSByZW5kZXJpbmcgaGFzIG9jY3VycmVkLlxuICpcbiAqIEBldmVudCBsb2FkXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxuLyoqXG4gKiBNb3ZlIHN0YXJ0IGV2ZW50LiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQganVzdCBiZWZvcmUgdGhlIG1hcCBiZWdpbnMgYSB0cmFuc2l0aW9uIGZyb20gb25lXG4gKiB2aWV3IHRvIGFub3RoZXIsIGVpdGhlciBhcyBhIHJlc3VsdCBvZiB1c2VyIGludGVyYWN0aW9uIG9yIHRoZSB1c2Ugb2YgbWV0aG9kcyBzdWNoIGFzIGBNYXAjanVtcFRvYC5cbiAqXG4gKiBAZXZlbnQgbW92ZXN0YXJ0XG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7RXZlbnREYXRhfSBkYXRhIE9yaWdpbmFsIGV2ZW50IGRhdGEsIGlmIGZpcmVkIGludGVyYWN0aXZlbHlcbiAqL1xuXG4vKipcbiAqIE1vdmUgZXZlbnQuIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCByZXBlYXRlZGx5IGR1cmluZyBhbmltYXRlZCB0cmFuc2l0aW9ucyBmcm9tIG9uZSB2aWV3IHRvXG4gKiBhbm90aGVyLCBlaXRoZXIgYXMgYSByZXN1bHQgb2YgdXNlciBpbnRlcmFjdGlvbiBvciB0aGUgdXNlIG9mIG1ldGhvZHMgc3VjaCBhcyBgTWFwI2p1bXBUb2AuXG4gKlxuICogQGV2ZW50IG1vdmVcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtFdmVudERhdGF9IGRhdGEgT3JpZ2luYWwgZXZlbnQgZGF0YSwgaWYgZmlyZWQgaW50ZXJhY3RpdmVseVxuICovXG5cbi8qKlxuICogTW92ZSBlbmQgZXZlbnQuIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCBqdXN0IGFmdGVyIHRoZSBtYXAgY29tcGxldGVzIGEgdHJhbnNpdGlvbiBmcm9tIG9uZVxuICogdmlldyB0byBhbm90aGVyLCBlaXRoZXIgYXMgYSByZXN1bHQgb2YgdXNlciBpbnRlcmFjdGlvbiBvciB0aGUgdXNlIG9mIG1ldGhvZHMgc3VjaCBhcyBgTWFwI2p1bXBUb2AuXG4gKlxuICogQGV2ZW50IG1vdmVlbmRcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtFdmVudERhdGF9IGRhdGEgT3JpZ2luYWwgZXZlbnQgZGF0YSwgaWYgZmlyZWQgaW50ZXJhY3RpdmVseVxuICovXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW52YXMgPSByZXF1aXJlKCcuLi91dGlsL2NhbnZhcycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZCcpO1xudmFyIERPTSA9IHJlcXVpcmUoJy4uL3V0aWwvZG9tJyk7XG5cbnZhciBTdHlsZSA9IHJlcXVpcmUoJy4uL3N0eWxlL3N0eWxlJyk7XG52YXIgQW5pbWF0aW9uTG9vcCA9IHJlcXVpcmUoJy4uL3N0eWxlL2FuaW1hdGlvbl9sb29wJyk7XG52YXIgUGFpbnRlciA9IHJlcXVpcmUoJy4uL3JlbmRlci9wYWludGVyJyk7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuLi9nZW8vdHJhbnNmb3JtJyk7XG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpO1xuXG52YXIgSW50ZXJhY3Rpb24gPSByZXF1aXJlKCcuL2ludGVyYWN0aW9uJyk7XG5cbnZhciBDYW1lcmEgPSByZXF1aXJlKCcuL2NhbWVyYScpO1xudmFyIExuZ0xhdCA9IHJlcXVpcmUoJy4uL2dlby9sbmdfbGF0Jyk7XG52YXIgTG5nTGF0Qm91bmRzID0gcmVxdWlyZSgnLi4vZ2VvL2xuZ19sYXRfYm91bmRzJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xudmFyIEF0dHJpYnV0aW9uID0gcmVxdWlyZSgnLi9jb250cm9sL2F0dHJpYnV0aW9uJyk7XG5cbnZhciBkZWZhdWx0TWluWm9vbSA9IDA7XG52YXIgZGVmYXVsdE1heFpvb20gPSAyMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGluc3RhbmNlLiBUaGlzIGlzIHVzdWFsbHkgdGhlIGJlZ2lubmluZyBvZiB5b3VyIG1hcDpcbiAqIHlvdSB0ZWxsIE1hcGJveCBHTCBKUyB3aGVyZSB0byBwdXQgdGhlIG1hcCBieSBzcGVjaWZ5aW5nIGEgYGNvbnRhaW5lcmBcbiAqIG9wdGlvbiwgYW5kIHRoZSBtYXAncyBzdHlsZSB3aXRoIGBzdHlsZWAgYW5kIG90aGVyIGF0dHJpYnV0ZXMgb2YgdGhlIG1hcCxcbiAqIGFuZCBpbiByZXR1cm4gTWFwYm94IEdMIEpTIGluaXRpYWxpemVzIHRoZSBtYXAgb24geW91ciBwYWdlIGFuZCByZXR1cm5zXG4gKiBhIG1hcCB2YXJpYWJsZSB0aGF0IGxldHMgeW91IHByb2dyYW1tYXRpY2FsbHkgY2FsbCBtZXRob2RzIG9uIHRoZSBtYXAuXG4gKiBAY2xhc3MgTWFwXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd8RWxlbWVudH0gb3B0aW9ucy5jb250YWluZXIgSFRNTCBlbGVtZW50IHRvIGluaXRpYWxpemUgdGhlIG1hcCBpbiAob3IgZWxlbWVudCBpZCBhcyBzdHJpbmcpXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWluWm9vbT0wXSBNaW5pbXVtIHpvb20gb2YgdGhlIG1hcFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFpvb209MjBdIE1heGltdW0gem9vbSBvZiB0aGUgbWFwXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRpb25zLnN0eWxlXSBNYXAgc3R5bGUuIFRoaXMgbXVzdCBiZSBhbiBhbiBvYmplY3QgY29uZm9ybWluZyB0byB0aGUgc2NoZW1hIGRlc2NyaWJlZCBpbiB0aGUgW3N0eWxlIHJlZmVyZW5jZV0oaHR0cHM6Ly9tYXBib3guY29tL21hcGJveC1nbC1zdHlsZS1zcGVjLyksIG9yIGEgVVJMIHRvIGEgSlNPTiBzdHlsZS4gVG8gbG9hZCBhIHN0eWxlIGZyb20gdGhlIE1hcGJveCBBUEksIHlvdSBjYW4gdXNlIGEgVVJMIG9mIHRoZSBmb3JtIGBtYXBib3g6Ly9zdHlsZXMvOm93bmVyLzpzdHlsZWAsIHdoZXJlIGA6b3duZXJgIGlzIHlvdXIgTWFwYm94IGFjY291bnQgbmFtZSBhbmQgYDpzdHlsZWAgaXMgdGhlIHN0eWxlIElELiBPciB5b3UgY2FuIHVzZSBvbmUgb2YgdGhlIHByZWRlZmluZWQgTWFwYm94IHN0eWxlczpcbiAqICAgKiBgbWFwYm94Oi8vc3R5bGVzL21hcGJveC9iYXNpYy12OGAgLSBTaW1wbGUgYW5kIGZsZXhpYmxlIHN0YXJ0aW5nIHRlbXBsYXRlLlxuICogICAqIGBtYXBib3g6Ly9zdHlsZXMvbWFwYm94L2JyaWdodC12OGAgLSBUZW1wbGF0ZSBmb3IgY29tcGxleCBjdXN0b20gYmFzZW1hcHMuXG4gKiAgICogYG1hcGJveDovL3N0eWxlcy9tYXBib3gvc3RyZWV0cy12OGAgLSBBIHJlYWR5LXRvLXVzZSBiYXNlbWFwLCBwZXJmZWN0IGZvciBtaW5vciBjdXN0b21pemF0aW9uIG9yIGluY29ycG9yYXRpbmcgeW91ciBvd24gZGF0YS5cbiAqICAgKiBgbWFwYm94Oi8vc3R5bGVzL21hcGJveC9saWdodC12OGAgLSBTdWJ0bGUgbGlnaHQgYmFja2Ryb3AgZm9yIGRhdGEgdml6dWFsaXphdGlvbnMuXG4gKiAgICogYG1hcGJveDovL3N0eWxlcy9tYXBib3gvZGFyay12OGAgLSBTdWJ0bGUgZGFyayBiYWNrZHJvcCBmb3IgZGF0YSB2aXp1YWxpemF0aW9ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaGFzaD1mYWxzZV0gSWYgYHRydWVgLCB0aGUgbWFwIHdpbGwgdHJhY2sgYW5kIHVwZGF0ZSB0aGUgcGFnZSBVUkwgYWNjb3JkaW5nIHRvIG1hcCBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pbnRlcmFjdGl2ZT10cnVlXSBJZiBgZmFsc2VgLCBubyBtb3VzZSwgdG91Y2gsIG9yIGtleWJvYXJkIGxpc3RlbmVycyBhcmUgYXR0YWNoZWQgdG8gdGhlIG1hcCwgc28gaXQgd2lsbCBub3QgcmVzcG9uZCB0byBpbnB1dFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmJlYXJpbmdTbmFwPTddIFNuYXAgdG8gbm9ydGggdGhyZXNob2xkIGluIGRlZ3JlZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5jbGFzc2VzXSBTdHlsZSBjbGFzcyBuYW1lcyB3aXRoIHdoaWNoIHRvIGluaXRpYWxpemUgdGhlIG1hcFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2w9dHJ1ZV0gSWYgYHRydWVgLCBhbiBhdHRyaWJ1dGlvbiBjb250cm9sIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdD1mYWxzZV0gSWYgYHRydWVgLCBtYXAgY3JlYXRpb24gd2lsbCBmYWlsIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBkZXRlcm1pbmVzIHRoYXQgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBjcmVhdGVkIFdlYkdMIGNvbnRleHQgd291bGQgYmUgZHJhbWF0aWNhbGx5IGxvd2VyIHRoYW4gZXhwZWN0ZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnByZXNlcnZlRHJhd2luZ0J1ZmZlcj1mYWxzZV0gSWYgYHRydWVgLCBUaGUgbWFwcyBjYW52YXMgY2FuIGJlIGV4cG9ydGVkIHRvIGEgUE5HIHVzaW5nIGBtYXAuZ2V0Q2FudmFzKCkudG9EYXRhVVJMKCk7YC4gVGhpcyBpcyBmYWxzZSBieSBkZWZhdWx0IGFzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLlxuICogQHBhcmFtIHtMbmdMYXRCb3VuZHN8QXJyYXk8QXJyYXk8bnVtYmVyPj59IFtvcHRpb25zLm1heEJvdW5kc10gSWYgc2V0LCB0aGUgbWFwIGlzIGNvbnN0cmFpbmVkIHRvIHRoZSBnaXZlbiBib3VuZHMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNjcm9sbFpvb209dHJ1ZV0gSWYgYHRydWVgLCBlbmFibGUgdGhlIFwic2Nyb2xsIHRvIHpvb21cIiBpbnRlcmFjdGlvbiAoc2VlIGBTY3JvbGxab29tSGFuZGxlcmApXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJveFpvb209dHJ1ZV0gSWYgYHRydWVgLCBlbmFibGUgdGhlIFwiYm94IHpvb21cIiBpbnRlcmFjdGlvbiAoc2VlIGBCb3hab29tSGFuZGxlcmApXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRyYWdSb3RhdGU9dHJ1ZV0gSWYgYHRydWVgLCBlbmFibGUgdGhlIFwiZHJhZyB0byByb3RhdGVcIiBpbnRlcmFjdGlvbiAoc2VlIGBEcmFnUm90YXRlSGFuZGxlcmApLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kcmFnUGFuPXRydWVdIElmIGB0cnVlYCwgZW5hYmxlIHRoZSBcImRyYWcgdG8gcGFuXCIgaW50ZXJhY3Rpb24gKHNlZSBgRHJhZ1BhbkhhbmRsZXJgKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMua2V5Ym9hcmQ9dHJ1ZV0gSWYgYHRydWVgLCBlbmFibGUga2V5Ym9hcmQgc2hvcnRjdXRzIChzZWUgYEtleWJvYXJkSGFuZGxlcmApLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kb3VibGVDbGlja1pvb209dHJ1ZV0gSWYgYHRydWVgLCBlbmFibGUgdGhlIFwiZG91YmxlIGNsaWNrIHRvIHpvb21cIiBpbnRlcmFjdGlvbiAoc2VlIGBEb3VibGVDbGlja1pvb21IYW5kbGVyYCkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRvdWNoWm9vbVJvdGF0ZT10cnVlXSBJZiBgdHJ1ZWAsIGVuYWJsZSB0aGUgXCJwaW5jaCB0byByb3RhdGUgYW5kIHpvb21cIiBpbnRlcmFjdGlvbiAoc2VlIGBUb3VjaFpvb21Sb3RhdGVIYW5kbGVyYCkuXG4gKiBAZXhhbXBsZVxuICogdmFyIG1hcCA9IG5ldyBtYXBib3hnbC5NYXAoe1xuICogICBjb250YWluZXI6ICdtYXAnLFxuICogICBjZW50ZXI6IFstMTIyLjQyMDY3OSwgMzcuNzcyNTM3XSxcbiAqICAgem9vbTogMTMsXG4gKiAgIHN0eWxlOiBzdHlsZV9vYmplY3QsXG4gKiAgIGhhc2g6IHRydWVcbiAqIH0pO1xuICovXG52YXIgTWFwID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gdXRpbC5pbmhlcml0KHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgdGhpcy5faW50ZXJhY3RpdmUgPSBvcHRpb25zLmludGVyYWN0aXZlO1xuICAgIHRoaXMuX2ZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQgPSBvcHRpb25zLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ7XG4gICAgdGhpcy5fcHJlc2VydmVEcmF3aW5nQnVmZmVyID0gb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXI7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29udGFpbmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRpb25zLmNvbnRhaW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG4gICAgfVxuXG4gICAgdGhpcy5hbmltYXRpb25Mb29wID0gbmV3IEFuaW1hdGlvbkxvb3AoKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0ob3B0aW9ucy5taW5ab29tLCBvcHRpb25zLm1heFpvb20pO1xuXG4gICAgaWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XG4gICAgICAgIHRoaXMuc2V0TWF4Qm91bmRzKG9wdGlvbnMubWF4Qm91bmRzKTtcbiAgICB9XG5cbiAgICB1dGlsLmJpbmRBbGwoW1xuICAgICAgICAnX2ZvcndhcmRTdHlsZUV2ZW50JyxcbiAgICAgICAgJ19mb3J3YXJkU291cmNlRXZlbnQnLFxuICAgICAgICAnX2ZvcndhcmRMYXllckV2ZW50JyxcbiAgICAgICAgJ19mb3J3YXJkVGlsZUV2ZW50JyxcbiAgICAgICAgJ19vblN0eWxlTG9hZCcsXG4gICAgICAgICdfb25TdHlsZUNoYW5nZScsXG4gICAgICAgICdfb25Tb3VyY2VBZGQnLFxuICAgICAgICAnX29uU291cmNlUmVtb3ZlJyxcbiAgICAgICAgJ19vblNvdXJjZVVwZGF0ZScsXG4gICAgICAgICdfb25XaW5kb3dSZXNpemUnLFxuICAgICAgICAnb25FcnJvcicsXG4gICAgICAgICdfdXBkYXRlJyxcbiAgICAgICAgJ19yZW5kZXInXG4gICAgXSwgdGhpcyk7XG5cbiAgICB0aGlzLl9zZXR1cENvbnRhaW5lcigpO1xuICAgIHRoaXMuX3NldHVwUGFpbnRlcigpO1xuXG4gICAgdGhpcy5vbignbW92ZScsIHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMsIGZhbHNlKSk7XG4gICAgdGhpcy5vbignem9vbScsIHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMsIHRydWUpKTtcbiAgICB0aGlzLm9uKCdtb3ZlZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uTG9vcC5zZXQoMzAwKTsgLy8gdGV4dCBmYWRpbmdcbiAgICAgICAgdGhpcy5fcmVyZW5kZXIoKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIHRoaXMuaW50ZXJhY3Rpb24gPSBuZXcgSW50ZXJhY3Rpb24odGhpcyk7XG5cbiAgICBpZiAob3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uLmVuYWJsZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2hhc2ggPSBvcHRpb25zLmhhc2ggJiYgKG5ldyBIYXNoKCkpLmFkZFRvKHRoaXMpO1xuICAgIC8vIGRvbid0IHNldCBwb3NpdGlvbiBmcm9tIG9wdGlvbnMgaWYgc2V0IHRocm91Z2ggaGFzaFxuICAgIGlmICghdGhpcy5faGFzaCB8fCAhdGhpcy5faGFzaC5fb25IYXNoQ2hhbmdlKCkpIHtcbiAgICAgICAgdGhpcy5qdW1wVG8ob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGFja3MgPSB7fTtcbiAgICB0aGlzLl9jbGFzc2VzID0gW107XG5cbiAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgaWYgKG9wdGlvbnMuY2xhc3NlcykgdGhpcy5zZXRDbGFzc2VzKG9wdGlvbnMuY2xhc3Nlcyk7XG4gICAgaWYgKG9wdGlvbnMuc3R5bGUpIHRoaXMuc2V0U3R5bGUob3B0aW9ucy5zdHlsZSk7XG4gICAgaWYgKG9wdGlvbnMuYXR0cmlidXRpb25Db250cm9sKSB0aGlzLmFkZENvbnRyb2wobmV3IEF0dHJpYnV0aW9uKG9wdGlvbnMuYXR0cmlidXRpb25Db250cm9sKSk7XG5cbiAgICB0aGlzLm9uKCdzdHlsZS5lcnJvcicsIHRoaXMub25FcnJvcik7XG4gICAgdGhpcy5vbignc291cmNlLmVycm9yJywgdGhpcy5vbkVycm9yKTtcbiAgICB0aGlzLm9uKCd0aWxlLmVycm9yJywgdGhpcy5vbkVycm9yKTtcbiAgICB0aGlzLm9uKCdsYXllci5lcnJvcicsIHRoaXMub25FcnJvcik7XG59O1xuXG51dGlsLmV4dGVuZChNYXAucHJvdG90eXBlLCBFdmVudGVkKTtcbnV0aWwuZXh0ZW5kKE1hcC5wcm90b3R5cGUsIENhbWVyYS5wcm90b3R5cGUpO1xudXRpbC5leHRlbmQoTWFwLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBNYXAucHJvdG90eXBlICove1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBjZW50ZXI6IFswLCAwXSxcbiAgICAgICAgem9vbTogMCxcbiAgICAgICAgYmVhcmluZzogMCxcbiAgICAgICAgcGl0Y2g6IDAsXG5cbiAgICAgICAgbWluWm9vbTogZGVmYXVsdE1pblpvb20sXG4gICAgICAgIG1heFpvb206IGRlZmF1bHRNYXhab29tLFxuXG4gICAgICAgIGludGVyYWN0aXZlOiB0cnVlLFxuXG4gICAgICAgIHNjcm9sbFpvb206IHRydWUsXG4gICAgICAgIGJveFpvb206IHRydWUsXG4gICAgICAgIGRyYWdSb3RhdGU6IHRydWUsXG4gICAgICAgIGRyYWdQYW46IHRydWUsXG4gICAgICAgIGtleWJvYXJkOiB0cnVlLFxuICAgICAgICBkb3VibGVDbGlja1pvb206IHRydWUsXG4gICAgICAgIHRvdWNoWm9vbVJvdGF0ZTogdHJ1ZSxcblxuICAgICAgICBiZWFyaW5nU25hcDogNyxcblxuICAgICAgICBoYXNoOiBmYWxzZSxcblxuICAgICAgICBhdHRyaWJ1dGlvbkNvbnRyb2w6IHRydWUsXG5cbiAgICAgICAgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogZmFsc2UsXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNvbnRyb2wgdG8gdGhlIG1hcCwgY2FsbGluZyBgY29udHJvbC5hZGRUbyh0aGlzKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NvbnRyb2x9IGNvbnRyb2xcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBhZGRDb250cm9sOiBmdW5jdGlvbihjb250cm9sKSB7XG4gICAgICAgIGNvbnRyb2wuYWRkVG8odGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc3R5bGUgY2xhc3MgdG8gYSBtYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2xhc3MgbmFtZSBvZiBzdHlsZSBjbGFzc1xuICAgICAqIEBwYXJhbSB7U3R5bGVPcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKiBAZmlyZXMgY2hhbmdlXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKGtsYXNzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbGFzc2VzLmluZGV4T2Yoa2xhc3MpID49IDAgfHwga2xhc3MgPT09ICcnKSByZXR1cm4gdGhpcztcbiAgICAgICAgdGhpcy5fY2xhc3Nlcy5wdXNoKGtsYXNzKTtcbiAgICAgICAgdGhpcy5fY2xhc3NPcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgICBpZiAodGhpcy5zdHlsZSkgdGhpcy5zdHlsZS51cGRhdGVDbGFzc2VzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGUodHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBzdHlsZSBjbGFzcyBmcm9tIGEgbWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtsYXNzIG5hbWUgb2Ygc3R5bGUgY2xhc3NcbiAgICAgKiBAcGFyYW0ge1N0eWxlT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQGZpcmVzIGNoYW5nZVxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbihrbGFzcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgaSA9IHRoaXMuX2NsYXNzZXMuaW5kZXhPZihrbGFzcyk7XG4gICAgICAgIGlmIChpIDwgMCB8fCBrbGFzcyA9PT0gJycpIHJldHVybiB0aGlzO1xuICAgICAgICB0aGlzLl9jbGFzc2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgdGhpcy5fY2xhc3NPcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgICBpZiAodGhpcy5zdHlsZSkgdGhpcy5zdHlsZS51cGRhdGVDbGFzc2VzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGUodHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gYWRkIG1vcmUgdGhhbiBvbmUgY2xhc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGtsYXNzZXMgQW4gYXJyYXkgb2YgY2xhc3MgbmFtZXNcbiAgICAgKiBAcGFyYW0ge1N0eWxlT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQGZpcmVzIGNoYW5nZVxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldENsYXNzZXM6IGZ1bmN0aW9uKGtsYXNzZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHVuaXF1ZUNsYXNzZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoa2xhc3Nlc1tpXSAhPT0gJycpIHVuaXF1ZUNsYXNzZXNba2xhc3Nlc1tpXV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsYXNzZXMgPSBPYmplY3Qua2V5cyh1bmlxdWVDbGFzc2VzKTtcbiAgICAgICAgdGhpcy5fY2xhc3NPcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgICBpZiAodGhpcy5zdHlsZSkgdGhpcy5zdHlsZS51cGRhdGVDbGFzc2VzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGUodHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgYSBzdHlsZSBjbGFzcyBpcyBhY3RpdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2xhc3MgTmFtZSBvZiBzdHlsZSBjbGFzc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0NsYXNzOiBmdW5jdGlvbihrbGFzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xhc3Nlcy5pbmRleE9mKGtsYXNzKSA+PSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgdGhlIGN1cnJlbnQgYWN0aXZlIHN0eWxlIGNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXRDbGFzc2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVjdCB0aGUgbWFwJ3MgbmV3IHdpZHRoIGFuZCBoZWlnaHQgYW5kIHJlc2l6ZSBpdC4gR2l2ZW5cbiAgICAgKiB0aGUgYGNvbnRhaW5lcmAgb2YgdGhlIG1hcCBzcGVjaWZpZWQgaW4gdGhlIE1hcCBjb25zdHJ1Y3RvcixcbiAgICAgKiB0aGlzIHJlYWRzIHRoZSBuZXcgd2lkdGggZnJvbSB0aGUgRE9NOiBzbyB0aGlzIG1ldGhvZCBpcyBvZnRlblxuICAgICAqIGNhbGxlZCBhZnRlciB0aGUgbWFwJ3MgY29udGFpbmVyIGlzIHJlc2l6ZWQgYnkgYW5vdGhlciBzY3JpcHRcbiAgICAgKiBvciB0aGUgbWFwIGlzIHNob3duIGFmdGVyIGJlaW5nIGluaXRpYWxseSBoaWRkZW4gd2l0aCBDU1MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgd2lkdGggPSAwLCBoZWlnaHQgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLl9jb250YWluZXIpIHtcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoIHx8IDQwMDtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgfHwgMzAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FudmFzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLnBhaW50ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAuZmlyZSgnbW92ZXN0YXJ0JylcbiAgICAgICAgICAgIC5maXJlKCdtb3ZlJylcbiAgICAgICAgICAgIC5maXJlKCdyZXNpemUnKVxuICAgICAgICAgICAgLmZpcmUoJ21vdmVlbmQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBtYXAncyBnZW9ncmFwaGljYWwgYm91bmRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0xuZ0xhdEJvdW5kc31cbiAgICAgKi9cbiAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYm91bmRzID0gbmV3IExuZ0xhdEJvdW5kcyhcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnBvaW50TG9jYXRpb24obmV3IFBvaW50KDAsIDApKSxcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnBvaW50TG9jYXRpb24odGhpcy50cmFuc2Zvcm0uc2l6ZSkpO1xuXG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybS5hbmdsZSB8fCB0aGlzLnRyYW5zZm9ybS5waXRjaCkge1xuICAgICAgICAgICAgYm91bmRzLmV4dGVuZCh0aGlzLnRyYW5zZm9ybS5wb2ludExvY2F0aW9uKG5ldyBQb2ludCh0aGlzLnRyYW5zZm9ybS5zaXplLngsIDApKSk7XG4gICAgICAgICAgICBib3VuZHMuZXh0ZW5kKHRoaXMudHJhbnNmb3JtLnBvaW50TG9jYXRpb24obmV3IFBvaW50KDAsIHRoaXMudHJhbnNmb3JtLnNpemUueSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBjb25zdHJhaW50IG9uIHRoZSBtYXAncyBnZW9ncmFwaGljYWwgYm91bmRzLiBQYW4gb3Igem9vbSBvcGVyYXRpb25zIHRoYXQgd291bGQgcmVzdWx0IGluXG4gICAgICogZGlzcGxheWluZyByZWdpb25zIHRoYXQgZmFsbCBvdXRzaWRlIG9mIHRoZSBib3VuZHMgaW5zdGVhZCByZXN1bHQgaW4gZGlzcGxheWluZyB0aGUgbWFwIGF0IHRoZVxuICAgICAqIGNsb3Nlc3QgcG9pbnQgYW5kL29yIHpvb20gbGV2ZWwgb2YgdGhlIHJlcXVlc3RlZCBvcGVyYXRpb24gdGhhdCBpcyB3aXRoaW4gdGhlIG1heCBib3VuZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xuZ0xhdEJvdW5kcyB8IEFycmF5PEFycmF5PG51bWJlcj4+IHwgbnVsbCB8IHVuZGVmaW5lZH0gbG5nbGF0Ym91bmRzIERlc2lyZWQgbWF4IGJvdW5kcyBvZiB0aGUgbWFwLiBJZiBudWxsIG9yIHVuZGVmaW5lZCwgZnVuY3Rpb24gcmVtb3ZlcyBhbnkgYm91bmRzIGNvbnN0cmFpbnRzIG9uIHRoZSBtYXAuXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgc2V0TWF4Qm91bmRzOiBmdW5jdGlvbiAobG5nbGF0Ym91bmRzKSB7XG4gICAgICAgIGlmIChsbmdsYXRib3VuZHMpIHtcbiAgICAgICAgICAgIHZhciBiID0gTG5nTGF0Qm91bmRzLmNvbnZlcnQobG5nbGF0Ym91bmRzKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmxuZ1JhbmdlID0gW2IuZ2V0V2VzdCgpLCBiLmdldEVhc3QoKV07XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5sYXRSYW5nZSA9IFtiLmdldFNvdXRoKCksIGIuZ2V0Tm9ydGgoKV07XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fY29uc3RyYWluKCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChsbmdsYXRib3VuZHMgPT09IG51bGwgfHwgbG5nbGF0Ym91bmRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmxuZ1JhbmdlID0gW107XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5sYXRSYW5nZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbWFwJ3MgbWluaW11bSB6b29tIGxldmVsLCBhbmQgem9vbXMgbWFwIHRvIHRoYXQgbGV2ZWwgaWYgaXQgaXNcbiAgICAgKiBjdXJyZW50bHkgYmVsb3cgaXQuIElmIG5vIHBhcmFtZXRlciBwcm92aWRlZCwgdW5zZXRzIHRoZSBjdXJyZW50XG4gICAgICogbWluaW11bSB6b29tIChzZXRzIGl0IHRvIDApXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluWm9vbSBNaW5pbXVtIHpvb20gbGV2ZWwuIE11c3QgYmUgYmV0d2VlbiAwIGFuZCAyMC5cbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc1xuICAgICAqL1xuICAgIHNldE1pblpvb206IGZ1bmN0aW9uKG1pblpvb20pIHtcblxuICAgICAgICBtaW5ab29tID0gbWluWm9vbSA9PT0gbnVsbCB8fCBtaW5ab29tID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TWluWm9vbSA6IG1pblpvb207XG5cbiAgICAgICAgaWYgKG1pblpvb20gPj0gZGVmYXVsdE1pblpvb20gJiYgbWluWm9vbSA8PSB0aGlzLnRyYW5zZm9ybS5tYXhab29tKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5taW5ab29tID0gbWluWm9vbTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRab29tKCkgPCBtaW5ab29tKSB0aGlzLnNldFpvb20obWluWm9vbSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ21pblpvb20gbXVzdCBiZSBiZXR3ZWVuICcgKyBkZWZhdWx0TWluWm9vbSArICcgYW5kIHRoZSBjdXJyZW50IG1heFpvb20sIGluY2x1c2l2ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIG1hcCdzIG1heGltdW0gem9vbSBsZXZlbCwgYW5kIHpvb21zIG1hcCB0byB0aGF0IGxldmVsIGlmIGl0IGlzXG4gICAgICogY3VycmVudGx5IGFib3ZlIGl0LiBJZiBubyBwYXJhbWV0ZXIgcHJvdmlkZWQsIHVuc2V0cyB0aGUgY3VycmVudFxuICAgICAqIG1heGltdW0gem9vbSAoc2V0cyBpdCB0byAyMClcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4Wm9vbSBNYXhpbXVtIHpvb20gbGV2ZWwuIE11c3QgYmUgYmV0d2VlbiAwIGFuZCAyMC5cbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzZXRNYXhab29tOiBmdW5jdGlvbihtYXhab29tKSB7XG5cbiAgICAgICAgbWF4Wm9vbSA9IG1heFpvb20gPT09IG51bGwgfHwgbWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdE1heFpvb20gOiBtYXhab29tO1xuXG4gICAgICAgIGlmIChtYXhab29tID49IHRoaXMudHJhbnNmb3JtLm1pblpvb20gJiYgbWF4Wm9vbSA8PSBkZWZhdWx0TWF4Wm9vbSkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0ubWF4Wm9vbSA9IG1heFpvb207XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Wm9vbSgpID4gbWF4Wm9vbSkgdGhpcy5zZXRab29tKG1heFpvb20pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKCdtYXhab29tIG11c3QgYmUgYmV0d2VlbiB0aGUgY3VycmVudCBtaW5ab29tIGFuZCAnICsgZGVmYXVsdE1heFpvb20gKyAnLCBpbmNsdXNpdmUnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBwaXhlbCBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgZ2l2ZW4gYSBnZW9ncmFwaGljYWxcbiAgICAgKiBsb2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG5nTGF0fSBsbmdsYXRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBgeGAgYW5kIGB5YCBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIHByb2plY3Q6IGZ1bmN0aW9uKGxuZ2xhdCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubG9jYXRpb25Qb2ludChMbmdMYXQuY29udmVydChsbmdsYXQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcywgZ2l2ZW4gcGl4ZWwgY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHBvaW50IFt4LCB5XSBwaXhlbCBjb29yZGluYXRlc1xuICAgICAqIEByZXR1cm5zIHtMbmdMYXR9XG4gICAgICovXG4gICAgdW5wcm9qZWN0OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucG9pbnRMb2NhdGlvbihQb2ludC5jb252ZXJ0KHBvaW50KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IHJlbmRlcmVkIGZlYXR1cmVzIHdpdGhpbiBhIHBvaW50IG9yIHJlY3RhbmdsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9pbnR8QXJyYXk8bnVtYmVyPnxBcnJheTxQb2ludD58QXJyYXk8QXJyYXk8bnVtYmVyPj59IFtwb2ludE9yQm94XSBFaXRoZXIgW3gsIHldIHBpeGVsIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQsIG9yIFtbeDEsIHkxXSwgW3gyLCB5Ml1dIHBpeGVsIGNvb3JkaW5hdGVzIG9mIG9wcG9zaXRlIGNvcm5lcnMgb2YgYm91bmRpbmcgcmVjdGFuZ2xlLiBPcHRpb25hbDogdXNlIGVudGlyZSB2aWV3cG9ydCBpZiBvbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMubGF5ZXJzXSBPbmx5IHF1ZXJ5IGZlYXR1cmVzIGZyb20gbGF5ZXJzIHdpdGggdGhlc2UgbGF5ZXIgSURzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJhbXMuZmlsdGVyXSBBIG1hcGJveC1nbC1zdHlsZS1zcGVjIGZpbHRlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxPYmplY3Q+fSBmZWF0dXJlcyAtIEFuIGFycmF5IG9mIFtHZW9KU09OXShodHRwOi8vZ2VvanNvbi5vcmcvKSBmZWF0dXJlc1xuICAgICAqIG1hdGNoaW5nIHRoZSBxdWVyeSBwYXJhbWV0ZXJzLiBUaGUgR2VvSlNPTiBwcm9wZXJ0aWVzIG9mIGVhY2ggZmVhdHVyZSBhcmUgdGFrZW4gZnJvbVxuICAgICAqIHRoZSBvcmlnaW5hbCBzb3VyY2UuIEVhY2ggZmVhdHVyZSBvYmplY3QgYWxzbyBjb250YWlucyBhIHRvcC1sZXZlbCBgbGF5ZXJgXG4gICAgICogcHJvcGVydHkgd2hvc2UgdmFsdWUgaXMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc3R5bGUgbGF5ZXIgdG8gd2hpY2ggdGhlXG4gICAgICogZmVhdHVyZSBiZWxvbmdzLiBMYXlvdXQgYW5kIHBhaW50IHByb3BlcnRpZXMgaW4gdGhpcyBvYmplY3QgY29udGFpbiB2YWx1ZXNcbiAgICAgKiB3aGljaCBhcmUgZnVsbHkgZXZhbHVhdGVkIGZvciB0aGUgZ2l2ZW4gem9vbSBsZXZlbCBhbmQgZmVhdHVyZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGZlYXR1cmVzID0gbWFwLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhbMjAsIDM1XSwgeyBsYXllcnM6IFsnbXktbGF5ZXItbmFtZSddIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgZmVhdHVyZXMgPSBtYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKFtbMTAsIDIwXSwgWzMwLCA1MF1dLCB7IGxheWVyczogWydteS1sYXllci1uYW1lJ10gfSk7XG4gICAgICovXG4gICAgcXVlcnlSZW5kZXJlZEZlYXR1cmVzOiBmdW5jdGlvbihwb2ludE9yQm94LCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCEocG9pbnRPckJveCBpbnN0YW5jZW9mIFBvaW50IHx8IEFycmF5LmlzQXJyYXkocG9pbnRPckJveCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBwb2ludE9yQm94O1xuICAgICAgICAgICAgcG9pbnRPckJveCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcXVlcnlHZW9tZXRyeSA9IHRoaXMuX21ha2VRdWVyeUdlb21ldHJ5KHBvaW50T3JCb3gpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5xdWVyeVJlbmRlcmVkRmVhdHVyZXMocXVlcnlHZW9tZXRyeSwgcGFyYW1zLCB0aGlzLnRyYW5zZm9ybS56b29tLCB0aGlzLnRyYW5zZm9ybS5hbmdsZSk7XG4gICAgfSxcblxuICAgIF9tYWtlUXVlcnlHZW9tZXRyeTogZnVuY3Rpb24ocG9pbnRPckJveCkge1xuICAgICAgICBpZiAocG9pbnRPckJveCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBib3VuZHMgd2FzIG9taXR0ZWQ6IHVzZSBmdWxsIHZpZXdwb3J0XG4gICAgICAgICAgICBwb2ludE9yQm94ID0gW1xuICAgICAgICAgICAgICAgIFBvaW50LmNvbnZlcnQoWzAsIDBdKSxcbiAgICAgICAgICAgICAgICBQb2ludC5jb252ZXJ0KFt0aGlzLnRyYW5zZm9ybS53aWR0aCwgdGhpcy50cmFuc2Zvcm0uaGVpZ2h0XSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcXVlcnlHZW9tZXRyeTtcbiAgICAgICAgdmFyIGlzUG9pbnQgPSBwb2ludE9yQm94IGluc3RhbmNlb2YgUG9pbnQgfHwgdHlwZW9mIHBvaW50T3JCb3hbMF0gPT09ICdudW1iZXInO1xuXG4gICAgICAgIGlmIChpc1BvaW50KSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBQb2ludC5jb252ZXJ0KHBvaW50T3JCb3gpO1xuICAgICAgICAgICAgcXVlcnlHZW9tZXRyeSA9IFtwb2ludF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYm94ID0gW1BvaW50LmNvbnZlcnQocG9pbnRPckJveFswXSksIFBvaW50LmNvbnZlcnQocG9pbnRPckJveFsxXSldO1xuICAgICAgICAgICAgcXVlcnlHZW9tZXRyeSA9IFtcbiAgICAgICAgICAgICAgICBib3hbMF0sXG4gICAgICAgICAgICAgICAgbmV3IFBvaW50KGJveFsxXS54LCBib3hbMF0ueSksXG4gICAgICAgICAgICAgICAgYm94WzFdLFxuICAgICAgICAgICAgICAgIG5ldyBQb2ludChib3hbMF0ueCwgYm94WzFdLnkpLFxuICAgICAgICAgICAgICAgIGJveFswXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXJ5R2VvbWV0cnkgPSBxdWVyeUdlb21ldHJ5Lm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucG9pbnRDb29yZGluYXRlKHApO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHJldHVybiBxdWVyeUdlb21ldHJ5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgZGF0YSBmcm9tIHZlY3RvciB0aWxlcyBhcyBhbiBhcnJheSBvZiBHZW9KU09OIEZlYXR1cmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZUlEIHNvdXJjZSBJRFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5zb3VyY2VMYXllcl0gVGhlIG5hbWUgb2YgdGhlIHZlY3RvciB0aWxlIGxheWVyIHRvIGdldCBmZWF0dXJlcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJhbXMuZmlsdGVyXSBBIG1hcGJveC1nbC1zdHlsZS1zcGVjIGZpbHRlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxPYmplY3Q+fSBmZWF0dXJlcyAtIEFuIGFycmF5IG9mIFtHZW9KU09OXShodHRwOi8vZ2VvanNvbi5vcmcvKSBmZWF0dXJlcyBtYXRjaGluZyB0aGUgcXVlcnkgcGFyYW1ldGVycy4gVGhlIEdlb0pTT04gcHJvcGVydGllcyBvZiBlYWNoIGZlYXR1cmUgYXJlIHRha2VuIGZyb20gdGhlIG9yaWdpbmFsIHNvdXJjZS4gRWFjaCBmZWF0dXJlIG9iamVjdCBhbHNvIGNvbnRhaW5zIGEgdG9wLWxldmVsIGBsYXllcmAgcHJvcGVydHkgd2hvc2UgdmFsdWUgaXMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc3R5bGUgbGF5ZXIgdG8gd2hpY2ggdGhlIGZlYXR1cmUgYmVsb25ncy4gTGF5b3V0IGFuZCBwYWludCBwcm9wZXJ0aWVzIGluIHRoaXMgb2JqZWN0IGNvbnRhaW4gdmFsdWVzIHdoaWNoIGFyZSBmdWxseSBldmFsdWF0ZWQgZm9yIHRoZSBnaXZlbiB6b29tIGxldmVsIGFuZCBmZWF0dXJlLlxuICAgICAqL1xuICAgIHF1ZXJ5U291cmNlRmVhdHVyZXM6IGZ1bmN0aW9uKHNvdXJjZUlELCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUucXVlcnlTb3VyY2VGZWF0dXJlcyhzb3VyY2VJRCwgcGFyYW1zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgdGhlIG1hcCdzIHN0eWxlIG9iamVjdCB3aXRoIGEgbmV3IHZhbHVlLiBVbmxpa2UgdGhlIGBzdHlsZWBcbiAgICAgKiBvcHRpb24gaW4gdGhlIE1hcCBjb25zdHJ1Y3RvciwgdGhpcyBtZXRob2Qgb25seSBhY2NlcHRzIGFuIG9iamVjdFxuICAgICAqIG9mIGEgbmV3IHN0eWxlLCBub3QgYSBVUkwgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIEEgc3R5bGUgb2JqZWN0IGZvcm1hdHRlZCBhcyBKU09OXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgc2V0U3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlXG4gICAgICAgICAgICAgICAgLm9mZignbG9hZCcsIHRoaXMuX29uU3R5bGVMb2FkKVxuICAgICAgICAgICAgICAgIC5vZmYoJ2Vycm9yJywgdGhpcy5fZm9yd2FyZFN0eWxlRXZlbnQpXG4gICAgICAgICAgICAgICAgLm9mZignY2hhbmdlJywgdGhpcy5fb25TdHlsZUNoYW5nZSlcbiAgICAgICAgICAgICAgICAub2ZmKCdzb3VyY2UuYWRkJywgdGhpcy5fb25Tb3VyY2VBZGQpXG4gICAgICAgICAgICAgICAgLm9mZignc291cmNlLnJlbW92ZScsIHRoaXMuX29uU291cmNlUmVtb3ZlKVxuICAgICAgICAgICAgICAgIC5vZmYoJ3NvdXJjZS5sb2FkJywgdGhpcy5fb25Tb3VyY2VVcGRhdGUpXG4gICAgICAgICAgICAgICAgLm9mZignc291cmNlLmVycm9yJywgdGhpcy5fZm9yd2FyZFNvdXJjZUV2ZW50KVxuICAgICAgICAgICAgICAgIC5vZmYoJ3NvdXJjZS5jaGFuZ2UnLCB0aGlzLl9vblNvdXJjZVVwZGF0ZSlcbiAgICAgICAgICAgICAgICAub2ZmKCdsYXllci5hZGQnLCB0aGlzLl9mb3J3YXJkTGF5ZXJFdmVudClcbiAgICAgICAgICAgICAgICAub2ZmKCdsYXllci5yZW1vdmUnLCB0aGlzLl9mb3J3YXJkTGF5ZXJFdmVudClcbiAgICAgICAgICAgICAgICAub2ZmKCdsYXllci5lcnJvcicsIHRoaXMuX2ZvcndhcmRMYXllckV2ZW50KVxuICAgICAgICAgICAgICAgIC5vZmYoJ3RpbGUuYWRkJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgICAgICAub2ZmKCd0aWxlLnJlbW92ZScsIHRoaXMuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAgICAgLm9mZigndGlsZS5sb2FkJywgdGhpcy5fdXBkYXRlKVxuICAgICAgICAgICAgICAgIC5vZmYoJ3RpbGUuZXJyb3InLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgICAgIC5vZmYoJ3RpbGUuc3RhdHMnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgICAgIC5fcmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIHRoaXMub2ZmKCdyb3RhdGUnLCB0aGlzLnN0eWxlLl9yZWRvUGxhY2VtZW50KTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdwaXRjaCcsIHRoaXMuc3R5bGUuX3JlZG9QbGFjZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZSBpbnN0YW5jZW9mIFN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKHN0eWxlLCB0aGlzLmFuaW1hdGlvbkxvb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdHlsZVxuICAgICAgICAgICAgLm9uKCdsb2FkJywgdGhpcy5fb25TdHlsZUxvYWQpXG4gICAgICAgICAgICAub24oJ2Vycm9yJywgdGhpcy5fZm9yd2FyZFN0eWxlRXZlbnQpXG4gICAgICAgICAgICAub24oJ2NoYW5nZScsIHRoaXMuX29uU3R5bGVDaGFuZ2UpXG4gICAgICAgICAgICAub24oJ3NvdXJjZS5hZGQnLCB0aGlzLl9vblNvdXJjZUFkZClcbiAgICAgICAgICAgIC5vbignc291cmNlLnJlbW92ZScsIHRoaXMuX29uU291cmNlUmVtb3ZlKVxuICAgICAgICAgICAgLm9uKCdzb3VyY2UubG9hZCcsIHRoaXMuX29uU291cmNlVXBkYXRlKVxuICAgICAgICAgICAgLm9uKCdzb3VyY2UuZXJyb3InLCB0aGlzLl9mb3J3YXJkU291cmNlRXZlbnQpXG4gICAgICAgICAgICAub24oJ3NvdXJjZS5jaGFuZ2UnLCB0aGlzLl9vblNvdXJjZVVwZGF0ZSlcbiAgICAgICAgICAgIC5vbignbGF5ZXIuYWRkJywgdGhpcy5fZm9yd2FyZExheWVyRXZlbnQpXG4gICAgICAgICAgICAub24oJ2xheWVyLnJlbW92ZScsIHRoaXMuX2ZvcndhcmRMYXllckV2ZW50KVxuICAgICAgICAgICAgLm9uKCdsYXllci5lcnJvcicsIHRoaXMuX2ZvcndhcmRMYXllckV2ZW50KVxuICAgICAgICAgICAgLm9uKCd0aWxlLmFkZCcsIHRoaXMuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAub24oJ3RpbGUucmVtb3ZlJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgIC5vbigndGlsZS5sb2FkJywgdGhpcy5fdXBkYXRlKVxuICAgICAgICAgICAgLm9uKCd0aWxlLmVycm9yJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgIC5vbigndGlsZS5zdGF0cycsIHRoaXMuX2ZvcndhcmRUaWxlRXZlbnQpO1xuXG4gICAgICAgIHRoaXMub24oJ3JvdGF0ZScsIHRoaXMuc3R5bGUuX3JlZG9QbGFjZW1lbnQpO1xuICAgICAgICB0aGlzLm9uKCdwaXRjaCcsIHRoaXMuc3R5bGUuX3JlZG9QbGFjZW1lbnQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzdHlsZSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZWNyZWF0ZSB0aGUgbWFwJ3Mgc3R5bGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBzdHlsZVxuICAgICAqL1xuICAgIGdldFN0eWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuc2VyaWFsaXplKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHNvdXJjZSB0byB0aGUgbWFwIHN0eWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBzb3VyY2UuIE11c3Qgbm90IGJlIHVzZWQgYnkgYW55IGV4aXN0aW5nIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIHNvdXJjZSBzcGVjaWZpY2F0aW9uLCBmb2xsb3dpbmcgdGhlXG4gICAgICogW01hcGJveCBHTCBTdHlsZSBSZWZlcmVuY2VdKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvI3NvdXJjZXMpXG4gICAgICogQGZpcmVzIHNvdXJjZS5hZGRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBhZGRTb3VyY2U6IGZ1bmN0aW9uKGlkLCBzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5zdHlsZS5hZGRTb3VyY2UoaWQsIHNvdXJjZSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBleGlzdGluZyBzb3VyY2UgZnJvbSB0aGUgbWFwIHN0eWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBzb3VyY2UgdG8gcmVtb3ZlXG4gICAgICogQGZpcmVzIHNvdXJjZS5yZW1vdmVcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZW1vdmVTb3VyY2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHRoaXMuc3R5bGUucmVtb3ZlU291cmNlKGlkKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlKHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBzdHlsZSBzb3VyY2Ugb2JqZWN0IHdpdGggdGhlIGdpdmVuIGBpZGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgc291cmNlIElEXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRTb3VyY2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLmdldFNvdXJjZShpZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGxheWVyIHRvIHRoZSBtYXAgc3R5bGUuIFRoZSBsYXllciB3aWxsIGJlIGluc2VydGVkIGJlZm9yZSB0aGUgbGF5ZXIgd2l0aFxuICAgICAqIElEIGBiZWZvcmVgLCBvciBhcHBlbmRlZCBpZiBgYmVmb3JlYCBpcyBvbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7U3R5bGVMYXllcnxPYmplY3R9IGxheWVyXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBiZWZvcmUgIElEIG9mIGFuIGV4aXN0aW5nIGxheWVyIHRvIGluc2VydCBiZWZvcmVcbiAgICAgKiBAZmlyZXMgbGF5ZXIuYWRkXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgYWRkTGF5ZXI6IGZ1bmN0aW9uKGxheWVyLCBiZWZvcmUpIHtcbiAgICAgICAgdGhpcy5zdHlsZS5hZGRMYXllcihsYXllciwgYmVmb3JlKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlKHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBgaWRgIGZyb20gdGhlIG1hcC4gQW55IGxheWVycyB3aGljaCByZWZlciB0byB0aGVcbiAgICAgKiBzcGVjaWZpZWQgbGF5ZXIgdmlhIGEgYHJlZmAgcHJvcGVydHkgYXJlIGFsc28gcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBsYXllciBpZFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBsYXllciB3aXRoIHRoZSBnaXZlbiBgaWRgIGV4aXN0c1xuICAgICAqIEBmaXJlcyBsYXllci5yZW1vdmVcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZW1vdmVMYXllcjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdGhpcy5zdHlsZS5yZW1vdmVMYXllcihpZCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgc3R5bGUgbGF5ZXIgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGBpZGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgbGF5ZXIgaWRcbiAgICAgKiBAcmV0dXJucyB7P09iamVjdH0gYSBsYXllciwgaWYgb25lIHdpdGggdGhlIGdpdmVuIGBpZGAgZXhpc3RzXG4gICAgICovXG4gICAgZ2V0TGF5ZXI6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLmdldExheWVyKGlkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmaWx0ZXIgZm9yIGEgZ2l2ZW4gc3R5bGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgSUQgb2YgYSBsYXllclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlciBmaWx0ZXIgc3BlY2lmaWNhdGlvbiwgYXMgZGVmaW5lZCBpbiB0aGUgW1N0eWxlIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvI3R5cGVzLWZpbHRlcilcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG1hcC5zZXRGaWx0ZXIoJ215LWxheWVyJywgWyc9PScsICduYW1lJywgJ1VTQSddKTtcbiAgICAgKi9cbiAgICBzZXRGaWx0ZXI6IGZ1bmN0aW9uKGxheWVyLCBmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5zdHlsZS5zZXRGaWx0ZXIobGF5ZXIsIGZpbHRlcik7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgem9vbSBleHRlbnQgZm9yIGEgZ2l2ZW4gc3R5bGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJJZCBJRCBvZiBhIGxheWVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbnpvb20gbWluaW11bSB6b29tIGV4dGVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXh6b29tIG1heGltdW0gem9vbSBleHRlbnRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG1hcC5zZXRMYXllclpvb21SYW5nZSgnbXktbGF5ZXInLCAyLCA1KTtcbiAgICAgKi9cbiAgICBzZXRMYXllclpvb21SYW5nZTogZnVuY3Rpb24obGF5ZXJJZCwgbWluem9vbSwgbWF4em9vbSkge1xuICAgICAgICB0aGlzLnN0eWxlLnNldExheWVyWm9vbVJhbmdlKGxheWVySWQsIG1pbnpvb20sIG1heHpvb20pO1xuICAgICAgICB0aGlzLl91cGRhdGUodHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZpbHRlciBmb3IgYSBnaXZlbiBzdHlsZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciBJRCBvZiBhIGxheWVyXG4gICAgICogQHJldHVybnMge0FycmF5fSBmaWx0ZXIgc3BlY2lmaWNhdGlvbiwgYXMgZGVmaW5lZCBpbiB0aGUgW1N0eWxlIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvI2ZpbHRlcilcbiAgICAgKi9cbiAgICBnZXRGaWx0ZXI6IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLmdldEZpbHRlcihsYXllcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgb2YgYSBwYWludCBwcm9wZXJ0eSBpbiBhIGdpdmVuIHN0eWxlIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyIElEIG9mIGEgbGF5ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIGEgcGFpbnQgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIHZhbHVlIGZvciB0aGUgcGFpbnQgcHJvcGVyeTsgbXVzdCBoYXZlIHRoZSB0eXBlIGFwcHJvcHJpYXRlIGZvciB0aGUgcHJvcGVydHkgYXMgZGVmaW5lZCBpbiB0aGUgW1N0eWxlIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0ga2xhc3Mgb3B0aW9uYWwgY2xhc3Mgc3BlY2lmaWVyIGZvciB0aGUgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG1hcC5zZXRQYWludFByb3BlcnR5KCdteS1sYXllcicsICdmaWxsLWNvbG9yJywgJyNmYWFmZWUnKTtcbiAgICAgKi9cbiAgICBzZXRQYWludFByb3BlcnR5OiBmdW5jdGlvbihsYXllciwgbmFtZSwgdmFsdWUsIGtsYXNzKSB7XG4gICAgICAgIHRoaXMuc3R5bGUuc2V0UGFpbnRQcm9wZXJ0eShsYXllciwgbmFtZSwgdmFsdWUsIGtsYXNzKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlKHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiBhIHBhaW50IHByb3BlcnR5IGluIGEgZ2l2ZW4gc3R5bGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgSUQgb2YgYSBsYXllclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgYSBwYWludCBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0ga2xhc3Mgb3B0aW9uYWwgY2xhc3Mgc3BlY2lmaWVyIGZvciB0aGUgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJucyB7Kn0gdmFsdWUgZm9yIHRoZSBwYWludCBwcm9wZXJ5XG4gICAgICovXG4gICAgZ2V0UGFpbnRQcm9wZXJ0eTogZnVuY3Rpb24obGF5ZXIsIG5hbWUsIGtsYXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLmdldFBhaW50UHJvcGVydHkobGF5ZXIsIG5hbWUsIGtsYXNzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiBhIGxheW91dCBwcm9wZXJ0eSBpbiBhIGdpdmVuIHN0eWxlIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyIElEIG9mIGEgbGF5ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIGEgbGF5b3V0IHByb3BlcnR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSB2YWx1ZSBmb3IgdGhlIGxheW91dCBwcm9wZXJ5OyBtdXN0IGhhdmUgdGhlIHR5cGUgYXBwcm9wcmlhdGUgZm9yIHRoZSBwcm9wZXJ0eSBhcyBkZWZpbmVkIGluIHRoZSBbU3R5bGUgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8pXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBtYXAuc2V0TGF5b3V0UHJvcGVydHkoJ215LWxheWVyJywgJ3Zpc2liaWxpdHknLCAnbm9uZScpO1xuICAgICAqL1xuICAgIHNldExheW91dFByb3BlcnR5OiBmdW5jdGlvbihsYXllciwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdHlsZS5zZXRMYXlvdXRQcm9wZXJ0eShsYXllciwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB0aGlzLl91cGRhdGUodHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIGEgbGF5b3V0IHByb3BlcnR5IGluIGEgZ2l2ZW4gc3R5bGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgSUQgb2YgYSBsYXllclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgYSBsYXlvdXQgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGtsYXNzIG9wdGlvbmFsIGNsYXNzIHNwZWNpZmllciBmb3IgdGhlIHByb3BlcnR5XG4gICAgICogQHJldHVybnMgeyp9IHZhbHVlIGZvciB0aGUgbGF5b3V0IHByb3BlcnlcbiAgICAgKi9cbiAgICBnZXRMYXlvdXRQcm9wZXJ0eTogZnVuY3Rpb24obGF5ZXIsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuZ2V0TGF5b3V0UHJvcGVydHkobGF5ZXIsIG5hbWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIE1hcCdzIGNvbnRhaW5lciBhcyBhbiBIVE1MIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICAgICAqL1xuICAgIGdldENvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29udGFpbmVyIGZvciB0aGUgbWFwIGBjYW52YXNgIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiB5b3Ugd2FudCB0byBhZGQgbm9uLUdMIG92ZXJsYXlzIHRvIHRoZSBtYXAsIHlvdSBzaG91bGQgYXBwZW5kIHRoZW0gdG8gdGhpcyBlbGVtZW50LiBUaGlzXG4gICAgICogaXMgdGhlIGVsZW1lbnQgdG8gd2hpY2ggZXZlbnQgYmluZGluZ3MgZm9yIG1hcCBpbnRlcmFjdGl2aXR5IHN1Y2ggYXMgcGFubmluZyBhbmQgem9vbWluZyBhcmVcbiAgICAgKiBhdHRhY2hlZC4gSXQgd2lsbCByZWNlaXZlIGJ1YmJsZWQgZXZlbnRzIGZvciBjaGlsZCBlbGVtZW50cyBzdWNoIGFzIHRoZSBgY2FudmFzYCwgYnV0IG5vdCBmb3JcbiAgICAgKiBtYXAgY29udHJvbHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICAgICAqL1xuICAgIGdldENhbnZhc0NvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXNDb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgTWFwJ3MgY2FudmFzIGFzIGFuIEhUTUwgY2FudmFzXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBjYW52YXNcbiAgICAgKi9cbiAgICBnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzLmdldEVsZW1lbnQoKTtcbiAgICB9LFxuXG4gICAgX3NldHVwQ29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ21hcGJveGdsLW1hcCcpO1xuXG4gICAgICAgIHZhciBjYW52YXNDb250YWluZXIgPSB0aGlzLl9jYW52YXNDb250YWluZXIgPSBET00uY3JlYXRlKCdkaXYnLCAnbWFwYm94Z2wtY2FudmFzLWNvbnRhaW5lcicsIGNvbnRhaW5lcik7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcmFjdGl2ZSkge1xuICAgICAgICAgICAgY2FudmFzQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ21hcGJveGdsLWludGVyYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FudmFzID0gbmV3IENhbnZhcyh0aGlzLCBjYW52YXNDb250YWluZXIpO1xuXG4gICAgICAgIHZhciBjb250cm9sQ29udGFpbmVyID0gdGhpcy5fY29udHJvbENvbnRhaW5lciA9IERPTS5jcmVhdGUoJ2RpdicsICdtYXBib3hnbC1jb250cm9sLWNvbnRhaW5lcicsIGNvbnRhaW5lcik7XG4gICAgICAgIHZhciBjb3JuZXJzID0gdGhpcy5fY29udHJvbENvcm5lcnMgPSB7fTtcbiAgICAgICAgWyd0b3AtbGVmdCcsICd0b3AtcmlnaHQnLCAnYm90dG9tLWxlZnQnLCAnYm90dG9tLXJpZ2h0J10uZm9yRWFjaChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgICBjb3JuZXJzW3Bvc10gPSBET00uY3JlYXRlKCdkaXYnLCAnbWFwYm94Z2wtY3RybC0nICsgcG9zLCBjb250cm9sQ29udGFpbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9zZXR1cFBhaW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLl9jYW52YXMuZ2V0V2ViR0xDb250ZXh0KHtcbiAgICAgICAgICAgIGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IHRoaXMuX2ZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQsXG4gICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRoaXMuX3ByZXNlcnZlRHJhd2luZ0J1ZmZlclxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWdsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBXZWJHTCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYWludGVyID0gbmV3IFBhaW50ZXIoZ2wsIHRoaXMudHJhbnNmb3JtKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2ViR0wgQ29udGV4dCBMb3N0IGV2ZW50LlxuICAgICAqXG4gICAgICogQGV2ZW50IHdlYmdsY29udGV4dGxvc3RcbiAgICAgKiBAbWVtYmVyb2YgTWFwXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50IHRoZSBvcmlnaW5hbCBET00gZXZlbnRcbiAgICAgKi9cbiAgICBfY29udGV4dExvc3Q6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICh0aGlzLl9mcmFtZUlkKSB7XG4gICAgICAgICAgICBicm93c2VyLmNhbmNlbEZyYW1lKHRoaXMuX2ZyYW1lSWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlyZShcIndlYmdsY29udGV4dGxvc3RcIiwge29yaWdpbmFsRXZlbnQ6IGV2ZW50fSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdlYkdMIENvbnRleHQgUmVzdG9yZWQgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgd2ViZ2xjb250ZXh0cmVzdG9yZWRcbiAgICAgKiBAbWVtYmVyb2YgTWFwXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBfY29udGV4dFJlc3RvcmVkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLl9zZXR1cFBhaW50ZXIoKTtcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIHRoaXMuZmlyZShcIndlYmdsY29udGV4dHJlc3RvcmVkXCIsIHtvcmlnaW5hbEV2ZW50OiBldmVudH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGlzIG1hcCBmdWxseSBsb2FkZWQ/IElmIHRoZSBzdHlsZSBpc24ndCBsb2FkZWRcbiAgICAgKiBvciBpdCBoYXMgYSBjaGFuZ2UgdG8gdGhlIHNvdXJjZXMgb3Igc3R5bGUgdGhhdCBpc24ndFxuICAgICAqIHByb3BhZ2F0ZWQgdG8gaXRzIHN0eWxlLCByZXR1cm4gZmFsc2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgbWFwIGlzIGxvYWRlZFxuICAgICAqL1xuICAgIGxvYWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHlsZURpcnR5IHx8IHRoaXMuX3NvdXJjZXNEaXJ0eSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLnN0eWxlIHx8ICF0aGlzLnN0eWxlLmxvYWRlZCgpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoaXMgbWFwJ3Mgc3R5bGUgYW5kIHNvdXJjZXMsIGFuZCByZS1yZW5kZXIgdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXBkYXRlU3R5bGUgbWFyayB0aGUgbWFwJ3Mgc3R5bGUgZm9yIHJlcHJvY2Vzc2luZyBhc1xuICAgICAqIHdlbGwgYXMgaXRzIHNvdXJjZXNcbiAgICAgKiBAcmV0dXJucyB7TWFwfSB0aGlzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlOiBmdW5jdGlvbih1cGRhdGVTdHlsZSkge1xuICAgICAgICBpZiAoIXRoaXMuc3R5bGUpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIHRoaXMuX3N0eWxlRGlydHkgPSB0aGlzLl9zdHlsZURpcnR5IHx8IHVwZGF0ZVN0eWxlO1xuICAgICAgICB0aGlzLl9zb3VyY2VzRGlydHkgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX3JlcmVuZGVyKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGwgd2hlbiBhIChyZS0pcmVuZGVyIG9mIHRoZSBtYXAgaXMgcmVxdWlyZWQsIGUuZy4gd2hlbiB0aGVcbiAgICAgKiB1c2VyIHBhbm5lZCBvciB6b29tZWQsZiBvciBuZXcgZGF0YSBpcyBhdmFpbGFibGUuXG4gICAgICogQHJldHVybnMge01hcH0gdGhpc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlICYmIHRoaXMuX3N0eWxlRGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUudXBkYXRlKHRoaXMuX2NsYXNzZXMsIHRoaXMuX2NsYXNzT3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl9jbGFzc09wdGlvbnMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5fcmVjYWxjdWxhdGUodGhpcy50cmFuc2Zvcm0uem9vbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdHlsZSAmJiB0aGlzLl9zb3VyY2VzRGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5fdXBkYXRlU291cmNlcyh0aGlzLnRyYW5zZm9ybSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhaW50ZXIucmVuZGVyKHRoaXMuc3R5bGUsIHtcbiAgICAgICAgICAgIGRlYnVnOiB0aGlzLnNob3dUaWxlQm91bmRhcmllcyxcbiAgICAgICAgICAgIHNob3dPdmVyZHJhd0luc3BlY3RvcjogdGhpcy5fc2hvd092ZXJkcmF3SW5zcGVjdG9yLFxuICAgICAgICAgICAgdmVydGljZXM6IHRoaXMudmVydGljZXMsXG4gICAgICAgICAgICByb3RhdGluZzogdGhpcy5yb3RhdGluZyxcbiAgICAgICAgICAgIHpvb21pbmc6IHRoaXMuem9vbWluZ1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmZpcmUoJ3JlbmRlcicpO1xuXG4gICAgICAgIGlmICh0aGlzLmxvYWRlZCgpICYmICF0aGlzLl9sb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2xvYWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZyYW1lSWQgPSBudWxsO1xuXG4gICAgICAgIGlmICghdGhpcy5hbmltYXRpb25Mb29wLnN0b3BwZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fc3R5bGVEaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc291cmNlc0RpcnR5IHx8IHRoaXMuX3JlcGFpbnQgfHwgIXRoaXMuYW5pbWF0aW9uTG9vcC5zdG9wcGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcmVuZGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIG1hcCdzIHVuZGVybHlpbmcgcmVzb3VyY2VzLCBpbmNsdWRpbmcgd2ViIHdvcmtlcnMgYW5kIERPTSBlbGVtZW50cy4gQWZ0ZXJ3YXJkcyxcbiAgICAgKiB5b3UgbXVzdCBub3QgY2FsbCBhbnkgZnVydGhlciBtZXRob2RzIG9uIHRoaXMgTWFwIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5faGFzaCkgdGhpcy5faGFzaC5yZW1vdmUoKTtcbiAgICAgICAgYnJvd3Nlci5jYW5jZWxGcmFtZSh0aGlzLl9mcmFtZUlkKTtcbiAgICAgICAgdGhpcy5zZXRTdHlsZShudWxsKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25XaW5kb3dSZXNpemUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVOb2RlKHRoaXMuX2NhbnZhc0NvbnRhaW5lcik7XG4gICAgICAgIHJlbW92ZU5vZGUodGhpcy5fY29udHJvbENvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdtYXBib3hnbC1tYXAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSBkZWZhdWx0IGVycm9yIGhhbmRsZXIgZm9yIGBzdHlsZS5lcnJvcmAsIGBzb3VyY2UuZXJyb3JgLCBgbGF5ZXIuZXJyb3JgLFxuICAgICAqIGFuZCBgdGlsZS5lcnJvcmAgZXZlbnRzLlxuICAgICAqIEl0IGxvZ3MgdGhlIGVycm9yIHZpYSBgY29uc29sZS5lcnJvcmAuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIERpc2FibGUgdGhlIGRlZmF1bHQgZXJyb3IgaGFuZGxlclxuICAgICAqIG1hcC5vZmYoJ3N0eWxlLmVycm9yJywgbWFwLm9uRXJyb3IpO1xuICAgICAqIG1hcC5vZmYoJ3NvdXJjZS5lcnJvcicsIG1hcC5vbkVycm9yKTtcbiAgICAgKiBtYXAub2ZmKCd0aWxlLmVycm9yJywgbWFwLm9uRXJyb3IpO1xuICAgICAqIG1hcC5vZmYoJ2xheWVyLmVycm9yJywgbWFwLm9uRXJyb3IpO1xuICAgICAqL1xuICAgIG9uRXJyb3I6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlLmVycm9yKTtcbiAgICB9LFxuXG4gICAgX3JlcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUgJiYgIXRoaXMuX2ZyYW1lSWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lSWQgPSBicm93c2VyLmZyYW1lKHRoaXMuX3JlbmRlcik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2ZvcndhcmRTdHlsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnc3R5bGUuJyArIGUudHlwZSwgdXRpbC5leHRlbmQoe3N0eWxlOiBlLnRhcmdldH0sIGUpKTtcbiAgICB9LFxuXG4gICAgX2ZvcndhcmRTb3VyY2VFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmZpcmUoZS50eXBlLCB1dGlsLmV4dGVuZCh7c3R5bGU6IGUudGFyZ2V0fSwgZSkpO1xuICAgIH0sXG5cbiAgICBfZm9yd2FyZExheWVyRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5maXJlKGUudHlwZSwgdXRpbC5leHRlbmQoe3N0eWxlOiBlLnRhcmdldH0sIGUpKTtcbiAgICB9LFxuXG4gICAgX2ZvcndhcmRUaWxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5maXJlKGUudHlwZSwgdXRpbC5leHRlbmQoe3N0eWxlOiBlLnRhcmdldH0sIGUpKTtcbiAgICB9LFxuXG4gICAgX29uU3R5bGVMb2FkOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybS51bm1vZGlmaWVkKSB7XG4gICAgICAgICAgICB0aGlzLmp1bXBUbyh0aGlzLnN0eWxlLnN0eWxlc2hlZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3R5bGUudXBkYXRlKHRoaXMuX2NsYXNzZXMsIHt0cmFuc2l0aW9uOiBmYWxzZX0pO1xuICAgICAgICB0aGlzLl9mb3J3YXJkU3R5bGVFdmVudChlKTtcbiAgICB9LFxuXG4gICAgX29uU3R5bGVDaGFuZ2U6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKHRydWUpO1xuICAgICAgICB0aGlzLl9mb3J3YXJkU3R5bGVFdmVudChlKTtcbiAgICB9LFxuXG4gICAgX29uU291cmNlQWRkOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBlLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZS5vbkFkZClcbiAgICAgICAgICAgIHNvdXJjZS5vbkFkZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fZm9yd2FyZFNvdXJjZUV2ZW50KGUpO1xuICAgIH0sXG5cbiAgICBfb25Tb3VyY2VSZW1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGUuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlLm9uUmVtb3ZlKVxuICAgICAgICAgICAgc291cmNlLm9uUmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLl9mb3J3YXJkU291cmNlRXZlbnQoZSk7XG4gICAgfSxcblxuICAgIF9vblNvdXJjZVVwZGF0ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgdGhpcy5fZm9yd2FyZFNvdXJjZUV2ZW50KGUpO1xuICAgIH0sXG5cbiAgICBfb25XaW5kb3dSZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0b3AoKS5yZXNpemUoKS5fdXBkYXRlKCk7XG4gICAgfVxufSk7XG5cbnV0aWwuZXh0ZW5kQWxsKE1hcC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgTWFwLnByb3RvdHlwZSAqL3tcblxuICAgIC8qKlxuICAgICAqIERyYXcgYW4gb3V0bGluZSBhcm91bmQgZWFjaCByZW5kZXJlZCB0aWxlIGZvciBkZWJ1Z2dpbmcuXG4gICAgICpcbiAgICAgKiBAbmFtZSBzaG93VGlsZUJvdW5kYXJpZXNcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBfc2hvd1RpbGVCb3VuZGFyaWVzOiBmYWxzZSxcbiAgICBnZXQgc2hvd1RpbGVCb3VuZGFyaWVzKCkgeyByZXR1cm4gdGhpcy5fc2hvd1RpbGVCb3VuZGFyaWVzOyB9LFxuICAgIHNldCBzaG93VGlsZUJvdW5kYXJpZXModmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Nob3dUaWxlQm91bmRhcmllcyA9PT0gdmFsdWUpIHJldHVybjtcbiAgICAgICAgdGhpcy5fc2hvd1RpbGVCb3VuZGFyaWVzID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGJveGVzIGFyb3VuZCBhbGwgc3ltYm9scyBpbiB0aGUgZGF0YSBzb3VyY2UsIHNob3dpbmcgd2hpY2ggd2VyZVxuICAgICAqIHJlbmRlcmVkIGFuZCB3aGljaCB3ZXJlIGhpZGRlbiBkdWUgdG8gY29sbGlzaW9ucyB3aXRoIG90aGVyIHN5bWJvbHMgZm9yXG4gICAgICogc3R5bGUgZGVidWdnaW5nLlxuICAgICAqXG4gICAgICogQG5hbWUgc2hvd0NvbGxpc2lvbkJveGVzXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgX3Nob3dDb2xsaXNpb25Cb3hlczogZmFsc2UsXG4gICAgZ2V0IHNob3dDb2xsaXNpb25Cb3hlcygpIHsgcmV0dXJuIHRoaXMuX3Nob3dDb2xsaXNpb25Cb3hlczsgfSxcbiAgICBzZXQgc2hvd0NvbGxpc2lvbkJveGVzKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zaG93Q29sbGlzaW9uQm94ZXMgPT09IHZhbHVlKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3Nob3dDb2xsaXNpb25Cb3hlcyA9IHZhbHVlO1xuICAgICAgICB0aGlzLnN0eWxlLl9yZWRvUGxhY2VtZW50KCk7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogU2hvdyBob3cgbWFueSB0aW1lcyBlYWNoIGZyYWdtZW50IGhhcyBiZWVuIHNoYWRlZC4gV2hpdGUgZnJhZ21lbnRzIGhhdmVcbiAgICAgKiBiZWVuIHNoYWRlZCA4IG9yIG1vcmUgdGltZXMuIEJsYWNrIGZyYWdtZW50cyBoYXZlIGJlZW4gc2hhZGVkIDAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAbmFtZSBzaG93T3ZlcmRyYXdcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBfc2hvd092ZXJkcmF3SW5zcGVjdG9yOiBmYWxzZSxcbiAgICBnZXQgc2hvd092ZXJkcmF3SW5zcGVjdG9yKCkgeyByZXR1cm4gdGhpcy5fc2hvd092ZXJkcmF3SW5zcGVjdG9yOyB9LFxuICAgIHNldCBzaG93T3ZlcmRyYXdJbnNwZWN0b3IodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Nob3dPdmVyZHJhd0luc3BlY3RvciA9PT0gdmFsdWUpIHJldHVybjtcbiAgICAgICAgdGhpcy5fc2hvd092ZXJkcmF3SW5zcGVjdG9yID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgY29udGludW91cyByZXBhaW50IHRvIGFuYWx5emUgcGVyZm9ybWFuY2UuXG4gICAgICpcbiAgICAgKiBAbmFtZSByZXBhaW50XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgX3JlcGFpbnQ6IGZhbHNlLFxuICAgIGdldCByZXBhaW50KCkgeyByZXR1cm4gdGhpcy5fcmVwYWludDsgfSxcbiAgICBzZXQgcmVwYWludCh2YWx1ZSkgeyB0aGlzLl9yZXBhaW50ID0gdmFsdWU7IHRoaXMuX3VwZGF0ZSgpOyB9LFxuXG4gICAgLy8gc2hvdyB2ZXJ0aWNlc1xuICAgIF92ZXJ0aWNlczogZmFsc2UsXG4gICAgZ2V0IHZlcnRpY2VzKCkgeyByZXR1cm4gdGhpcy5fdmVydGljZXM7IH0sXG4gICAgc2V0IHZlcnRpY2VzKHZhbHVlKSB7IHRoaXMuX3ZlcnRpY2VzID0gdmFsdWU7IHRoaXMuX3VwZGF0ZSgpOyB9XG59KTtcblxuZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlKSB7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnMgY29tbW9uIHRvIE1hcCNhZGRDbGFzcywgTWFwI3JlbW92ZUNsYXNzLCBhbmQgTWFwI3NldENsYXNzZXMsIGNvbnRyb2xsaW5nXG4gKiB3aGV0aGVyIG9yIG5vdCB0byBzbW9vdGhseSB0cmFuc2l0aW9uIHByb3BlcnR5IGNoYW5nZXMgdHJpZ2dlcmVkIGJ5IHRoZSBjbGFzcyBjaGFuZ2UuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gU3R5bGVPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHRyYW5zaXRpb25cbiAqL1xuXG4gLyoqXG4gICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuZXZlciB0aGUgbWFwIGlzIGRyYXduIHRvIHRoZSBzY3JlZW4gYmVjYXVzZSBvZlxuICAqXG4gICogIC0gYSBjaGFuZ2UgaW4gbWFwIHBvc2l0aW9uLCB6b29tLCBwaXRjaCwgb3IgYmVhcmluZ1xuICAqICAtIGEgY2hhbmdlIHRvIHRoZSBtYXAgc3R5bGVcbiAgKiAgLSBhIGNoYW5nZSB0byBhIEdlb0pTT04gc291cmNlXG4gICogIC0gYSB2ZWN0b3IgdGlsZSwgR2VvSlNPTiBmaWxlLCBnbHlwaCwgb3Igc3ByaXRlIGJlaW5nIGxvYWRlZFxuICAqXG4gICogQGV2ZW50IHJlbmRlclxuICAqIEBtZW1iZXJvZiBNYXBcbiAgKiBAaW5zdGFuY2VcbiAgKi9cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQb3B1cDtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgRE9NID0gcmVxdWlyZSgnLi4vdXRpbC9kb20nKTtcbnZhciBMbmdMYXQgPSByZXF1aXJlKCcuLi9nZW8vbG5nX2xhdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBwb3B1cCBjb21wb25lbnRcbiAqIEBjbGFzcyBQb3B1cFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jbG9zZUJ1dHRvbiB3aGV0aGVyIHRvIHNob3cgYSBjbG9zZSBidXR0b24gaW4gdGhlXG4gKiB0b3AgcmlnaHQgY29ybmVyIG9mIHRoZSBwb3B1cC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jbG9zZU9uQ2xpY2sgd2hldGhlciB0byBjbG9zZSB0aGUgcG9wdXAgd2hlbiB0aGVcbiAqIG1hcCBpcyBjbGlja2VkLlxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYW5jaG9yIC0gT25lIG9mIFwidG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwidG9wLWxlZnRcIixcbiAqIFwidG9wLXJpZ2h0XCIsIFwiYm90dG9tLWxlZnRcIiwgb3IgXCJib3R0b20tcmlnaHRcIiwgZGVzY3JpYmluZyB3aGVyZSB0aGUgcG9wdXAncyBhbmNob3JcbiAqIHJlbGF0aXZlIHRvIHRoZSBjb29yZGluYXRlIHNldCB2aWEgYHNldExuZ0xhdGAuXG4gKiBAZXhhbXBsZVxuICogdmFyIHRvb2x0aXAgPSBuZXcgbWFwYm94Z2wuUG9wdXAoKVxuICogICAuc2V0TG5nTGF0KGUubG5nTGF0KVxuICogICAuc2V0SFRNTChcIjxoMT5IZWxsbyBXb3JsZCE8L2gxPlwiKVxuICogICAuYWRkVG8obWFwKTtcbiAqL1xuZnVuY3Rpb24gUG9wdXAob3B0aW9ucykge1xuICAgIHV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICB1dGlsLmJpbmRBbGwoW1xuICAgICAgICAnX3VwZGF0ZScsXG4gICAgICAgICdfb25DbGlja0Nsb3NlJ10sXG4gICAgICAgIHRoaXMpO1xufVxuXG5Qb3B1cC5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoRXZlbnRlZCwgLyoqIEBsZW5kcyBQb3B1cC5wcm90b3R5cGUgKi97XG4gICAgb3B0aW9uczoge1xuICAgICAgICBjbG9zZUJ1dHRvbjogdHJ1ZSxcbiAgICAgICAgY2xvc2VPbkNsaWNrOiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHRoZSBwb3B1cCB0byBhIG1hcFxuICAgICAqIEBwYXJhbSB7TWFwfSBtYXBcbiAgICAgKiBAcmV0dXJucyB7UG9wdXB9IGB0aGlzYFxuICAgICAqL1xuICAgIGFkZFRvOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB0aGlzLl9tYXAub24oJ21vdmUnLCB0aGlzLl91cGRhdGUpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljaykge1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuX29uQ2xpY2tDbG9zZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBwb3B1cCBmcm9tIGEgbWFwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcG9wdXAgPSBuZXcgbWFwYm94Z2wuUG9wdXAoKS5hZGRUbyhtYXApO1xuICAgICAqIHBvcHVwLnJlbW92ZSgpO1xuICAgICAqIEByZXR1cm5zIHtQb3B1cH0gYHRoaXNgXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnQgJiYgdGhpcy5fY29udGVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fY29udGVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fY29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9tYXApIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5vZmYoJ21vdmUnLCB0aGlzLl91cGRhdGUpO1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9mZignY2xpY2snLCB0aGlzLl9vbkNsaWNrQ2xvc2UpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX21hcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBvcHVwJ3MgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uXG4gICAgICogQHJldHVybnMge0xuZ0xhdH1cbiAgICAgKi9cbiAgICBnZXRMbmdMYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG5nTGF0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBvcHVwJ3MgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIGFuZCBtb3ZlIGl0LlxuICAgICAqIEBwYXJhbSB7TG5nTGF0fSBsbmdsYXRcbiAgICAgKiBAcmV0dXJucyB7UG9wdXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldExuZ0xhdDogZnVuY3Rpb24obG5nbGF0KSB7XG4gICAgICAgIHRoaXMuX2xuZ0xhdCA9IExuZ0xhdC5jb252ZXJ0KGxuZ2xhdCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsbCBhIHBvcHVwIGVsZW1lbnQgd2l0aCB0ZXh0IG9ubHkgY29udGVudC4gVGhpcyBjcmVhdGVzIGEgdGV4dCBub2RlXG4gICAgICogaW4gdGhlIERPTSwgc28gaXQgY2Fubm90IGVuZCB1cCBhcHBlbmRpbmcgcmF3IEhUTUwuIFVzZSB0aGlzIG1ldGhvZFxuICAgICAqIGlmIHlvdSB3YW50IGFuIGFkZGVkIGxldmVsIG9mIHNlY3VyaXR5IGFnYWluc3QgWFNTIGlmIHRoZSBwb3B1cFxuICAgICAqIGNvbnRlbnQgaXMgdXNlci1wcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtQb3B1cH0gYHRoaXNgXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgdG9vbHRpcCA9IG5ldyBtYXBib3hnbC5Qb3B1cCgpXG4gICAgICogICAuc2V0TG5nTGF0KGUubG5nTGF0KVxuICAgICAqICAgLnNldFRleHQoJ0hlbGxvLCB3b3JsZCEnKVxuICAgICAqICAgLmFkZFRvKG1hcCk7XG4gICAgICovXG4gICAgc2V0VGV4dDogZnVuY3Rpb24odGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRET01Db250ZW50KGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsbCBhIHBvcHVwIGVsZW1lbnQgd2l0aCBIVE1MIGNvbnRlbnQsIHByb3ZpZGVkIGFzIGEgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gICAgICogQHJldHVybnMge1BvcHVwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzZXRIVE1MOiBmdW5jdGlvbihodG1sKSB7XG4gICAgICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICB2YXIgdGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JvZHknKSwgY2hpbGQ7XG4gICAgICAgIHRlbXAuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNoaWxkID0gdGVtcC5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKCFjaGlsZCkgYnJlYWs7XG4gICAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnNldERPTUNvbnRlbnQoZnJhZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbGwgYSBwb3B1cCBlbGVtZW50IHdpdGggRE9NIGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge05vZGV9IGh0bWxOb2RlIFBvcHVwIGNvbnRlbnQgYXMgYSBET00gbm9kZVxuICAgICAqIEByZXR1cm5zIHtQb3B1cH0gYHRoaXNgXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBjcmVhdGUgYW4gZWxlbWVudCB3aXRoIHRoZSBwb3B1cCBjb250ZW50XG4gICAgICogdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAqIGRpdi5pbm5lckhUTUwgPSAnSGVsbG8sIHdvcmxkISc7XG4gICAgICogdmFyIHRvb2x0aXAgPSBuZXcgbWFwYm94Z2wuUG9wdXAoKVxuICAgICAqICAgLnNldExuZ0xhdChlLmxuZ0xhdClcbiAgICAgKiAgIC5zZXRET01Db250ZW50KGRpdilcbiAgICAgKiAgIC5hZGRUbyhtYXApO1xuICAgICAqL1xuICAgIHNldERPTUNvbnRlbnQ6IGZ1bmN0aW9uKGh0bWxOb2RlKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUNvbnRlbnQoKTtcbiAgICAgICAgdGhpcy5fY29udGVudC5hcHBlbmRDaGlsZChodG1sTm9kZSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2NyZWF0ZUNvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fY29udGVudCAmJiB0aGlzLl9jb250ZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9jb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBET00uY3JlYXRlKCdkaXYnLCAnbWFwYm94Z2wtcG9wdXAtY29udGVudCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VCdXR0b24gPSBET00uY3JlYXRlKCdidXR0b24nLCAnbWFwYm94Z2wtcG9wdXAtY2xvc2UtYnV0dG9uJywgdGhpcy5fY29udGVudCk7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSAnJiMyMTU7JztcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGlja0Nsb3NlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tYXAgfHwgIXRoaXMuX2xuZ0xhdCB8fCAhdGhpcy5fY29udGVudCkgeyByZXR1cm47IH1cblxuICAgICAgICBpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyID0gRE9NLmNyZWF0ZSgnZGl2JywgJ21hcGJveGdsLXBvcHVwJywgdGhpcy5fbWFwLmdldENvbnRhaW5lcigpKTtcbiAgICAgICAgICAgIHRoaXMuX3RpcCAgICAgICA9IERPTS5jcmVhdGUoJ2RpdicsICdtYXBib3hnbC1wb3B1cC10aXAnLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2xuZ0xhdCkucm91bmQoKSxcbiAgICAgICAgICAgIGFuY2hvciA9IHRoaXMub3B0aW9ucy5hbmNob3I7XG5cbiAgICAgICAgaWYgKCFhbmNob3IpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAocG9zLnkgPCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSBbJ3RvcCddO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb3MueSA+IHRoaXMuX21hcC50cmFuc2Zvcm0uaGVpZ2h0IC0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gWydib3R0b20nXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb3MueCA8IHdpZHRoIC8gMikge1xuICAgICAgICAgICAgICAgIGFuY2hvci5wdXNoKCdsZWZ0Jyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvcy54ID4gdGhpcy5fbWFwLnRyYW5zZm9ybS53aWR0aCAtIHdpZHRoIC8gMikge1xuICAgICAgICAgICAgICAgIGFuY2hvci5wdXNoKCdyaWdodCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYW5jaG9yLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGFuY2hvciA9ICdib3R0b20nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSBhbmNob3Iuam9pbignLScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFuY2hvclRyYW5zbGF0ZSA9IHtcbiAgICAgICAgICAgICd0b3AnOiAndHJhbnNsYXRlKC01MCUsMCknLFxuICAgICAgICAgICAgJ3RvcC1sZWZ0JzogJ3RyYW5zbGF0ZSgwLDApJyxcbiAgICAgICAgICAgICd0b3AtcmlnaHQnOiAndHJhbnNsYXRlKC0xMDAlLDApJyxcbiAgICAgICAgICAgICdib3R0b20nOiAndHJhbnNsYXRlKC01MCUsLTEwMCUpJyxcbiAgICAgICAgICAgICdib3R0b20tbGVmdCc6ICd0cmFuc2xhdGUoMCwtMTAwJSknLFxuICAgICAgICAgICAgJ2JvdHRvbS1yaWdodCc6ICd0cmFuc2xhdGUoLTEwMCUsLTEwMCUpJyxcbiAgICAgICAgICAgICdsZWZ0JzogJ3RyYW5zbGF0ZSgwLC01MCUpJyxcbiAgICAgICAgICAgICdyaWdodCc6ICd0cmFuc2xhdGUoLTEwMCUsLTUwJSknXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNsYXNzTGlzdCA9IHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3Q7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhbmNob3JUcmFuc2xhdGUpIHtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ21hcGJveGdsLXBvcHVwLWFuY2hvci0nICsga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdtYXBib3hnbC1wb3B1cC1hbmNob3ItJyArIGFuY2hvcik7XG5cbiAgICAgICAgRE9NLnNldFRyYW5zZm9ybSh0aGlzLl9jb250YWluZXIsIGFuY2hvclRyYW5zbGF0ZVthbmNob3JdICsgJyB0cmFuc2xhdGUoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCknKTtcbiAgICB9LFxuXG4gICAgX29uQ2xpY2tDbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQWN0b3I7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIFtBY3RvciBkZXNpZ24gcGF0dGVybl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BY3Rvcl9tb2RlbClcbiAqIHRoYXQgbWFpbnRhaW5zIHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiBhc3luY2hyb25vdXMgdGFza3MgYW5kIHRoZSBvYmplY3RzXG4gKiB0aGF0IHNwaW4gdGhlbSBvZmYgLSBpbiB0aGlzIGNhc2UsIHRhc2tzIGxpa2UgcGFyc2luZyBwYXJ0cyBvZiBzdHlsZXMsXG4gKiBvd25lZCBieSB0aGUgc3R5bGVzXG4gKlxuICogQHBhcmFtIHtXZWJXb3JrZXJ9IHRhcmdldFxuICogQHBhcmFtIHtXZWJXb3JrZXJ9IHBhcmVudFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQWN0b3IodGFyZ2V0LCBwYXJlbnQpIHtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IHt9O1xuICAgIHRoaXMuY2FsbGJhY2tJRCA9IDA7XG4gICAgdGhpcy5yZWNlaXZlID0gdGhpcy5yZWNlaXZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMucmVjZWl2ZSwgZmFsc2UpO1xufVxuXG5BY3Rvci5wcm90b3R5cGUucmVjZWl2ZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICB2YXIgZGF0YSA9IG1lc3NhZ2UuZGF0YSxcbiAgICAgICAgY2FsbGJhY2s7XG5cbiAgICBpZiAoZGF0YS50eXBlID09PSAnPHJlc3BvbnNlPicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrc1tkYXRhLmlkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tzW2RhdGEuaWRdO1xuICAgICAgICBjYWxsYmFjayhkYXRhLmVycm9yIHx8IG51bGwsIGRhdGEuZGF0YSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YS5pZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGlkID0gZGF0YS5pZDtcbiAgICAgICAgdGhpcy5wYXJlbnRbZGF0YS50eXBlXShkYXRhLmRhdGEsIGZ1bmN0aW9uKGVyciwgZGF0YSwgYnVmZmVycykge1xuICAgICAgICAgICAgdGhpcy5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJzxyZXNwb25zZT4nLFxuICAgICAgICAgICAgICAgIGlkOiBTdHJpbmcoaWQpLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnIgPyBTdHJpbmcoZXJyKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgfSwgYnVmZmVycyk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJlbnRbZGF0YS50eXBlXShkYXRhLmRhdGEpO1xuICAgIH1cbn07XG5cbkFjdG9yLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24odHlwZSwgZGF0YSwgY2FsbGJhY2ssIGJ1ZmZlcnMpIHtcbiAgICB2YXIgaWQgPSBudWxsO1xuICAgIGlmIChjYWxsYmFjaykgdGhpcy5jYWxsYmFja3NbaWQgPSB0aGlzLmNhbGxiYWNrSUQrK10gPSBjYWxsYmFjaztcbiAgICB0aGlzLnBvc3RNZXNzYWdlKHsgdHlwZTogdHlwZSwgaWQ6IFN0cmluZyhpZCksIGRhdGE6IGRhdGEgfSwgYnVmZmVycyk7XG59O1xuXG4vKipcbiAqIFdyYXBwZWQgcG9zdE1lc3NhZ2UgQVBJIHRoYXQgYWJzdHJhY3RzIGFyb3VuZCBJRSdzIGxhY2sgb2ZcbiAqIGB0cmFuc2Zlckxpc3RgIHN1cHBvcnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zlckxpc3RcbiAqIEBwcml2YXRlXG4gKi9cbkFjdG9yLnByb3RvdHlwZS5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHRyYW5zZmVyTGlzdCkge1xuICAgIHRoaXMudGFyZ2V0LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyTGlzdCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmdldEpTT04gPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBjYWxsYmFjayhlKTtcbiAgICB9O1xuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDAgJiYgeGhyLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoeGhyLnN0YXR1c1RleHQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgeGhyLnNlbmQoKTtcbiAgICByZXR1cm4geGhyO1xufTtcblxuZXhwb3J0cy5nZXRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGNhbGxiYWNrKGUpO1xuICAgIH07XG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCAmJiB4aHIucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHhoci5yZXNwb25zZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoeGhyLnN0YXR1c1RleHQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgeGhyLnNlbmQoKTtcbiAgICByZXR1cm4geGhyO1xufTtcblxuZnVuY3Rpb24gc2FtZU9yaWdpbih1cmwpIHtcbiAgICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICBhLmhyZWYgPSB1cmw7XG4gICAgcmV0dXJuIGEucHJvdG9jb2wgPT09IGRvY3VtZW50LmxvY2F0aW9uLnByb3RvY29sICYmIGEuaG9zdCA9PT0gZG9jdW1lbnQubG9jYXRpb24uaG9zdDtcbn1cblxuZXhwb3J0cy5nZXRJbWFnZSA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZXhwb3J0cy5nZXRBcnJheUJ1ZmZlcih1cmwsIGZ1bmN0aW9uKGVyciwgaW1nRGF0YSkge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBpbWcpO1xuICAgICAgICAgICAgKHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCkucmV2b2tlT2JqZWN0VVJMKGltZy5zcmMpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShpbWdEYXRhKV0sIHsgdHlwZTogJ2ltYWdlL3BuZycgfSk7XG4gICAgICAgIGltZy5zcmMgPSAod2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMKS5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIGltZy5nZXREYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gaW1nLndpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGltZy5oZWlnaHQ7XG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGltZy53aWR0aCwgaW1nLmhlaWdodCkuZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGltZztcbiAgICB9KTtcbn07XG5cbmV4cG9ydHMuZ2V0VmlkZW8gPSBmdW5jdGlvbih1cmxzLCBjYWxsYmFjaykge1xuICAgIHZhciB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgdmlkZW8ub25sb2Fkc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgdmlkZW8pO1xuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJyk7XG4gICAgICAgIGlmICghc2FtZU9yaWdpbih1cmxzW2ldKSkge1xuICAgICAgICAgICAgdmlkZW8uY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcbiAgICAgICAgfVxuICAgICAgICBzLnNyYyA9IHVybHNbaV07XG4gICAgICAgIHZpZGVvLmFwcGVuZENoaWxkKHMpO1xuICAgIH1cbiAgICB2aWRlby5nZXREYXRhID0gZnVuY3Rpb24oKSB7IHJldHVybiB2aWRlbzsgfTtcbiAgICByZXR1cm4gdmlkZW87XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVubGlrZSBqcy91dGlsL2Jyb3dzZXIuanMsIHRoaXMgY29kZSBpcyB3cml0dGVuIHdpdGggdGhlIGV4cGVjdGF0aW9uXG4gKiBvZiBhIGJyb3dzZXIgZW52aXJvbm1lbnQgd2l0aCBhIGdsb2JhbCAnd2luZG93JyBvYmplY3RcbiAqIEBtb2R1bGUgYnJvd3NlclxuICogQHByaXZhdGVcbiAqL1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgZnVuY3Rpb24gdGhhdCBvdXRwdXRzIG1pbGxpc2Vjb25kczogZWl0aGVyIHBlcmZvcm1hbmNlLm5vdygpXG4gKiBvciBhIGZhbGxiYWNrIHRvIERhdGUubm93KClcbiAqL1xubW9kdWxlLmV4cG9ydHMubm93ID0gKGZ1bmN0aW9uKCkge1xuICAgIGlmICh3aW5kb3cucGVyZm9ybWFuY2UgJiZcbiAgICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm5vdykge1xuICAgICAgICByZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlLm5vdy5iaW5kKHdpbmRvdy5wZXJmb3JtYW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93LmJpbmQoRGF0ZSk7XG4gICAgfVxufSgpKTtcblxudmFyIGZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG5leHBvcnRzLmZyYW1lID0gZnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gZnJhbWUoZm4pO1xufTtcblxudmFyIGNhbmNlbCA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lO1xuXG5leHBvcnRzLmNhbmNlbEZyYW1lID0gZnVuY3Rpb24oaWQpIHtcbiAgICBjYW5jZWwoaWQpO1xufTtcblxuZXhwb3J0cy50aW1lZCA9IGZ1bmN0aW9uIChmbiwgZHVyLCBjdHgpIHtcbiAgICBpZiAoIWR1cikge1xuICAgICAgICBmbi5jYWxsKGN0eCwgMSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBhYm9ydCA9IGZhbHNlLFxuICAgICAgICBzdGFydCA9IG1vZHVsZS5leHBvcnRzLm5vdygpO1xuXG4gICAgZnVuY3Rpb24gdGljayhub3cpIHtcbiAgICAgICAgaWYgKGFib3J0KSByZXR1cm47XG4gICAgICAgIG5vdyA9IG1vZHVsZS5leHBvcnRzLm5vdygpO1xuXG4gICAgICAgIGlmIChub3cgPj0gc3RhcnQgKyBkdXIpIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCAobm93IC0gc3RhcnQpIC8gZHVyKTtcbiAgICAgICAgICAgIGV4cG9ydHMuZnJhbWUodGljayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzLmZyYW1lKHRpY2spO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyBhYm9ydCA9IHRydWU7IH07XG59O1xuXG4vKipcbiAqIFRlc3QgaWYgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBNYXBib3ggR0wgSlNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ9ZmFsc2VdIFJldHVybiBgZmFsc2VgXG4gKiAgIGlmIHRoZSBwZXJmb3JtYW5jZSBvZiBNYXBib3ggR0wgSlMgd291bGQgYmUgZHJhbWF0aWNhbGx5IHdvcnNlIHRoYW5cbiAqICAgZXhwZWN0ZWQgKGkuZS4gYSBzb2Z0d2FyZSByZW5kZXJlciB3b3VsZCBiZSB1c2VkKVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5zdXBwb3J0ZWQgPSByZXF1aXJlKCdtYXBib3gtZ2wtanMtc3VwcG9ydGVkJyk7XG5cbmV4cG9ydHMuaGFyZHdhcmVDb25jdXJyZW5jeSA9IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5IHx8IDg7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZGV2aWNlUGl4ZWxSYXRpbycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87IH1cbn0pO1xuXG5leHBvcnRzLnN1cHBvcnRzV2VicCA9IGZhbHNlO1xuXG52YXIgd2VicEltZ1Rlc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbndlYnBJbWdUZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGV4cG9ydHMuc3VwcG9ydHNXZWJwID0gdHJ1ZTtcbn07XG53ZWJwSW1nVGVzdC5zcmMgPSAnZGF0YTppbWFnZS93ZWJwO2Jhc2U2NCxVa2xHUmg0QUFBQlhSVUpRVmxBNFRCRUFBQUF2QVFBQUFBZlEvLzczdi8rQmlPaC9BQUE9JztcblxuZXhwb3J0cy5zdXBwb3J0c0dlb2xvY2F0aW9uID0gISFuYXZpZ2F0b3IuZ2VvbG9jYXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIGlzU3VwcG9ydGVkID0gcmVxdWlyZSgnbWFwYm94LWdsLWpzLXN1cHBvcnRlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhcztcblxuZnVuY3Rpb24gQ2FudmFzKHBhcmVudCwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgIGlmIChwYXJlbnQgJiYgY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGhpcy5jYW52YXMuY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtY2FudmFzJyk7XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCBwYXJlbnQuX2NvbnRleHRMb3N0LmJpbmQocGFyZW50KSwgZmFsc2UpO1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHBhcmVudC5fY29udGV4dFJlc3RvcmVkLmJpbmQocGFyZW50KSwgZmFsc2UpO1xuICAgICAgICB0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgfVxufVxuXG5DYW52YXMucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cbiAgICAvLyBSZXF1ZXN0IHRoZSByZXF1aXJlZCBjYW52YXMgc2l6ZSB0YWtpbmcgdGhlIHBpeGVscmF0aW8gaW50byBhY2NvdW50LlxuICAgIHRoaXMuY2FudmFzLndpZHRoID0gcGl4ZWxSYXRpbyAqIHdpZHRoO1xuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHBpeGVsUmF0aW8gKiBoZWlnaHQ7XG5cbiAgICAvLyBNYWludGFpbiB0aGUgc2FtZSBjYW52YXMgc2l6ZSwgcG90ZW50aWFsbHkgZG93bnNjYWxpbmcgaXQgZm9yIEhpRFBJIGRpc3BsYXlzXG4gICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgdGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4Jztcbn07XG5cbkNhbnZhcy5wcm90b3R5cGUuZ2V0V2ViR0xDb250ZXh0ID0gZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgIGF0dHJpYnV0ZXMgPSB1dGlsLmV4dGVuZCh7fSwgYXR0cmlidXRlcywgaXNTdXBwb3J0ZWQud2ViR0xDb250ZXh0QXR0cmlidXRlcyk7XG5cbiAgICByZXR1cm4gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBhdHRyaWJ1dGVzKSB8fFxuICAgICAgICB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBhdHRyaWJ1dGVzKTtcbn07XG5cbkNhbnZhcy5wcm90b3R5cGUuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBBY3RvciA9IHJlcXVpcmUoJy4uL2FjdG9yJyk7XG52YXIgV2ViV29ya2lmeSA9IHJlcXVpcmUoJ3dlYndvcmtpZnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaXNwYXRjaGVyO1xuXG5mdW5jdGlvbiBEaXNwYXRjaGVyKGxlbmd0aCwgcGFyZW50KSB7XG4gICAgdGhpcy5hY3RvcnMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRBY3RvciA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgd29ya2VyID0gbmV3IFdlYldvcmtpZnkocmVxdWlyZSgnLi4vLi4vc291cmNlL3dvcmtlcicpKTtcbiAgICAgICAgdmFyIGFjdG9yID0gbmV3IEFjdG9yKHdvcmtlciwgcGFyZW50KTtcbiAgICAgICAgYWN0b3IubmFtZSA9IFwiV29ya2VyIFwiICsgaTtcbiAgICAgICAgdGhpcy5hY3RvcnMucHVzaChhY3Rvcik7XG4gICAgfVxufVxuXG5EaXNwYXRjaGVyLnByb3RvdHlwZSA9IHtcbiAgICBicm9hZGNhc3Q6IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hY3RvcnNbaV0uc2VuZCh0eXBlLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZW5kOiBmdW5jdGlvbih0eXBlLCBkYXRhLCBjYWxsYmFjaywgdGFyZ2V0SUQsIGJ1ZmZlcnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRJRCAhPT0gJ251bWJlcicgfHwgaXNOYU4odGFyZ2V0SUQpKSB7XG4gICAgICAgICAgICAvLyBVc2Ugcm91bmQgcm9iaW4gdG8gc2VuZCByZXF1ZXN0cyB0byB3ZWIgd29ya2Vycy5cbiAgICAgICAgICAgIHRhcmdldElEID0gdGhpcy5jdXJyZW50QWN0b3IgPSAodGhpcy5jdXJyZW50QWN0b3IgKyAxKSAlIHRoaXMuYWN0b3JzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWN0b3JzW3RhcmdldElEXS5zZW5kKHR5cGUsIGRhdGEsIGNhbGxiYWNrLCBidWZmZXJzKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldElEO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmFjdG9yc1tpXS50YXJnZXQudGVybWluYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RvcnMgPSBbXTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgaWYgKGNsYXNzTmFtZSkgZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgIGlmIChjb250YWluZXIpIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gICAgcmV0dXJuIGVsO1xufTtcblxudmFyIGRvY1N0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuXG5mdW5jdGlvbiB0ZXN0UHJvcChwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHByb3BzW2ldIGluIGRvY1N0eWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcHNbaV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBzZWxlY3RQcm9wID0gdGVzdFByb3AoWyd1c2VyU2VsZWN0JywgJ01velVzZXJTZWxlY3QnLCAnV2Via2l0VXNlclNlbGVjdCcsICdtc1VzZXJTZWxlY3QnXSksXG4gICAgdXNlclNlbGVjdDtcbmV4cG9ydHMuZGlzYWJsZURyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGVjdFByb3ApIHtcbiAgICAgICAgdXNlclNlbGVjdCA9IGRvY1N0eWxlW3NlbGVjdFByb3BdO1xuICAgICAgICBkb2NTdHlsZVtzZWxlY3RQcm9wXSA9ICdub25lJztcbiAgICB9XG59O1xuZXhwb3J0cy5lbmFibGVEcmFnID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxlY3RQcm9wKSB7XG4gICAgICAgIGRvY1N0eWxlW3NlbGVjdFByb3BdID0gdXNlclNlbGVjdDtcbiAgICB9XG59O1xuXG52YXIgdHJhbnNmb3JtUHJvcCA9IHRlc3RQcm9wKFsndHJhbnNmb3JtJywgJ1dlYmtpdFRyYW5zZm9ybSddKTtcbmV4cG9ydHMuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24oZWwsIHZhbHVlKSB7XG4gICAgZWwuc3R5bGVbdHJhbnNmb3JtUHJvcF0gPSB2YWx1ZTtcbn07XG5cbi8vIFN1cHByZXNzIHRoZSBuZXh0IGNsaWNrLCBidXQgb25seSBpZiBpdCdzIGltbWVkaWF0ZS5cbmZ1bmN0aW9uIHN1cHByZXNzQ2xpY2soZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHN1cHByZXNzQ2xpY2ssIHRydWUpO1xufVxuZXhwb3J0cy5zdXBwcmVzc0NsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3VwcHJlc3NDbGljaywgdHJ1ZSk7XG4gICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHN1cHByZXNzQ2xpY2ssIHRydWUpO1xuICAgIH0sIDApO1xufTtcblxuZXhwb3J0cy5tb3VzZVBvcyA9IGZ1bmN0aW9uIChlbCwgZSkge1xuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgZSA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XG4gICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgZS5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gZWwuY2xpZW50TGVmdCxcbiAgICAgICAgZS5jbGllbnRZIC0gcmVjdC50b3AgLSBlbC5jbGllbnRUb3BcbiAgICApO1xufTtcblxuZXhwb3J0cy50b3VjaFBvcyA9IGZ1bmN0aW9uIChlbCwgZSkge1xuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIHBvaW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS50b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKG5ldyBQb2ludChcbiAgICAgICAgICAgIGUudG91Y2hlc1tpXS5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gZWwuY2xpZW50TGVmdCxcbiAgICAgICAgICAgIGUudG91Y2hlc1tpXS5jbGllbnRZIC0gcmVjdC50b3AgLSBlbC5jbGllbnRUb3BcbiAgICAgICAgKSk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBBUElfVVJMOiAnaHR0cHM6Ly9hcGkubWFwYm94LmNvbScsXG4gICAgUkVRVUlSRV9BQ0NFU1NfVE9LRU46IHRydWVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaWN0aW9uYXJ5Q29kZXI7XG5cbmZ1bmN0aW9uIERpY3Rpb25hcnlDb2RlcihzdHJpbmdzKSB7XG4gICAgdGhpcy5fc3RyaW5nVG9OdW1iZXIgPSB7fTtcbiAgICB0aGlzLl9udW1iZXJUb1N0cmluZyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3RyaW5nID0gc3RyaW5nc1tpXTtcbiAgICAgICAgdGhpcy5fc3RyaW5nVG9OdW1iZXJbc3RyaW5nXSA9IGk7XG4gICAgICAgIHRoaXMuX251bWJlclRvU3RyaW5nW2ldID0gc3RyaW5nO1xuICAgIH1cbn1cblxuRGljdGlvbmFyeUNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICBhc3NlcnQoc3RyaW5nIGluIHRoaXMuX3N0cmluZ1RvTnVtYmVyKTtcbiAgICByZXR1cm4gdGhpcy5fc3RyaW5nVG9OdW1iZXJbc3RyaW5nXTtcbn07XG5cbkRpY3Rpb25hcnlDb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24obikge1xuICAgIGFzc2VydChuIDwgdGhpcy5fbnVtYmVyVG9TdHJpbmcubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5fbnVtYmVyVG9TdHJpbmdbbl07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vKipcbiAqIE1ldGhvZHMgbWl4ZWQgaW4gdG8gb3RoZXIgY2xhc3NlcyBmb3IgZXZlbnQgY2FwYWJpbGl0aWVzLlxuICogQG1peGluIEV2ZW50ZWRcbiAqL1xudmFyIEV2ZW50ZWQgPSB7XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gYSBzcGVjaWZpZWQgZXZlbnQgd2l0aCBhIGxpc3RlbmVyIGZ1bmN0aW9uIHRoZSBsYXR0ZXIgZ2V0cyB0aGUgZGF0YSBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIHRvIGBmaXJlYCBhbmQgYWRkaXRpb25hbGx5IGB0YXJnZXRgIGFuZCBgdHlwZWAgcHJvcGVydGllc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBmaXJlZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGB0aGlzYFxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IHRoaXMuX2V2ZW50c1t0eXBlXSB8fCBbXTtcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBldmVudCBsaXN0ZW5lclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBFdmVudCB0eXBlLiBJZiBub25lIGlzIHNwZWNpZmllZCwgcmVtb3ZlIGFsbCBsaXN0ZW5lcnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbGlzdGVuZXJdIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBmaXJlZC4gSWYgbm9uZSBpcyBzcGVjaWZpZWQgYWxsIGxpc3RlbmVycyBhcmUgcmVtb3ZlZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGB0aGlzYFxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGlmIG5vIGFyZ3VtZW50cyBzcGVjaWZpZWRcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5saXN0ZW5zKHR5cGUpKSByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHZhciBpZHggPSB0aGlzLl9ldmVudHNbdHlwZV0uaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0uc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGEgZnVuY3Rpb24gb25jZSB3aGVuIGFuIGV2ZW50IGhhcyBmaXJlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBGdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSB3aGVuIHRoZSBldmVudCBpcyBmaXJlZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGB0aGlzYFxuICAgICAqL1xuICAgIG9uY2U6IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5vZmYodHlwZSwgd3JhcHBlcik7XG4gICAgICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub24odHlwZSwgd3JhcHBlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlIGV2ZW50IG9mIGEgZ2l2ZW4gc3RyaW5nIHR5cGUgd2l0aCB0aGUgZ2l2ZW4gZGF0YSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIE9wdGlvbmFsIGRhdGEgcGFzc2VkIHRvIHRoZSBldmVudCByZWNlaXZlciAoZS5nLiB7QGxpbmsgI0V2ZW50RGF0YX0pXG4gICAgICogQHJldHVybnMge09iamVjdH0gYHRoaXNgXG4gICAgICovXG4gICAgZmlyZTogZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMubGlzdGVucyh0eXBlKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgZGF0YSA9IHV0aWwuZXh0ZW5kKHt9LCBkYXRhKTtcbiAgICAgICAgdXRpbC5leHRlbmQoZGF0YSwge3R5cGU6IHR5cGUsIHRhcmdldDogdGhpc30pO1xuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSBhZGRpbmcvcmVtb3ZpbmcgbGlzdGVuZXJzIGluc2lkZSBvdGhlciBsaXN0ZW5lcnMgd29uJ3QgY2F1c2UgaW5maW5pdGUgbG9vcFxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGFuIGV2ZW50IGlzIHJlZ2lzdGVyZWQgdG8gYSB0eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHJlZ2lzdGVyZWQgbGlzdGVuZXIgZm9yIGV2ZW50cyBvZiB0eXBlIGB0eXBlYFxuICAgICAqL1xuICAgIGxpc3RlbnM6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV0pO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRlZDtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaHM7XG5cbmZ1bmN0aW9uIEdseXBocyhwYmYsIGVuZCkge1xuICAgIHRoaXMuc3RhY2tzID0gcGJmLnJlYWRGaWVsZHMocmVhZEZvbnRzdGFja3MsIFtdLCBlbmQpO1xufVxuXG5mdW5jdGlvbiByZWFkRm9udHN0YWNrcyh0YWcsIHN0YWNrcywgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMSkge1xuICAgICAgICB2YXIgZm9udHN0YWNrID0gcGJmLnJlYWRNZXNzYWdlKHJlYWRGb250c3RhY2ssIHtnbHlwaHM6IHt9fSk7XG4gICAgICAgIHN0YWNrcy5wdXNoKGZvbnRzdGFjayk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWFkRm9udHN0YWNrKHRhZywgZm9udHN0YWNrLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAxKSBmb250c3RhY2submFtZSA9IHBiZi5yZWFkU3RyaW5nKCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAyKSBmb250c3RhY2sucmFuZ2UgPSBwYmYucmVhZFN0cmluZygpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMykge1xuICAgICAgICB2YXIgZ2x5cGggPSBwYmYucmVhZE1lc3NhZ2UocmVhZEdseXBoLCB7fSk7XG4gICAgICAgIGZvbnRzdGFjay5nbHlwaHNbZ2x5cGguaWRdID0gZ2x5cGg7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWFkR2x5cGgodGFnLCBnbHlwaCwgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMSkgZ2x5cGguaWQgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMikgZ2x5cGguYml0bWFwID0gcGJmLnJlYWRCeXRlcygpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMykgZ2x5cGgud2lkdGggPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNCkgZ2x5cGguaGVpZ2h0ID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDUpIGdseXBoLmxlZnQgPSBwYmYucmVhZFNWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDYpIGdseXBoLnRvcCA9IHBiZi5yZWFkU1ZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNykgZ2x5cGguYWR2YW5jZSA9IHBiZi5yZWFkVmFyaW50KCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJwb2xhdGU7XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKGEsIGIsIHQpIHtcbiAgICByZXR1cm4gKGEgKiAoMSAtIHQpKSArIChiICogdCk7XG59XG5cbmludGVycG9sYXRlLm51bWJlciA9IGludGVycG9sYXRlO1xuXG5pbnRlcnBvbGF0ZS52ZWMyID0gZnVuY3Rpb24oZnJvbSwgdG8sIHQpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBpbnRlcnBvbGF0ZShmcm9tWzBdLCB0b1swXSwgdCksXG4gICAgICAgIGludGVycG9sYXRlKGZyb21bMV0sIHRvWzFdLCB0KVxuICAgIF07XG59O1xuXG4vKlxuICogSW50ZXJwb2xhdGUgYmV0d2VlbiB0d28gY29sb3JzIGdpdmVuIGFzIDQtZWxlbWVudCBhcnJheXMuXG4gKlxuICogQHBhcmFtIHtDb2xvcn0gZnJvbVxuICogQHBhcmFtIHtDb2xvcn0gdG9cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IGludGVycG9sYXRpb24gZmFjdG9yIGJldHdlZW4gMCBhbmQgMVxuICogQHJldHVybnMge0NvbG9yfSBpbnRlcnBvbGF0ZWQgY29sb3JcbiAqL1xuaW50ZXJwb2xhdGUuY29sb3IgPSBmdW5jdGlvbihmcm9tLCB0bywgdCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGludGVycG9sYXRlKGZyb21bMF0sIHRvWzBdLCB0KSxcbiAgICAgICAgaW50ZXJwb2xhdGUoZnJvbVsxXSwgdG9bMV0sIHQpLFxuICAgICAgICBpbnRlcnBvbGF0ZShmcm9tWzJdLCB0b1syXSwgdCksXG4gICAgICAgIGludGVycG9sYXRlKGZyb21bM10sIHRvWzNdLCB0KVxuICAgIF07XG59O1xuXG5pbnRlcnBvbGF0ZS5hcnJheSA9IGZ1bmN0aW9uKGZyb20sIHRvLCB0KSB7XG4gICAgcmV0dXJuIGZyb20ubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRlKGQsIHRvW2ldLCB0KTtcbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG11bHRpUG9seWdvbkludGVyc2VjdHNCdWZmZXJlZE11bHRpUG9pbnQ6IG11bHRpUG9seWdvbkludGVyc2VjdHNCdWZmZXJlZE11bHRpUG9pbnQsXG4gICAgbXVsdGlQb2x5Z29uSW50ZXJzZWN0c011bHRpUG9seWdvbjogbXVsdGlQb2x5Z29uSW50ZXJzZWN0c011bHRpUG9seWdvbixcbiAgICBtdWx0aVBvbHlnb25JbnRlcnNlY3RzQnVmZmVyZWRNdWx0aUxpbmU6IG11bHRpUG9seWdvbkludGVyc2VjdHNCdWZmZXJlZE11bHRpTGluZVxufTtcblxuZnVuY3Rpb24gbXVsdGlQb2x5Z29uSW50ZXJzZWN0c0J1ZmZlcmVkTXVsdGlQb2ludChtdWx0aVBvbHlnb24sIHJpbmdzLCByYWRpdXMpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG11bHRpUG9seWdvbi5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcG9seWdvbiA9IG11bHRpUG9seWdvbltqXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJpbmcgPSByaW5nc1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcmluZy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHJpbmdba107XG4gICAgICAgICAgICAgICAgaWYgKHBvbHlnb25Db250YWluc1BvaW50KHBvbHlnb24sIHBvaW50KSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50SW50ZXJzZWN0c0J1ZmZlcmVkTGluZShwb2ludCwgcG9seWdvbiwgcmFkaXVzKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtdWx0aVBvbHlnb25JbnRlcnNlY3RzTXVsdGlQb2x5Z29uKG11bHRpUG9seWdvbkEsIG11bHRpUG9seWdvbkIpIHtcblxuICAgIGlmIChtdWx0aVBvbHlnb25BLmxlbmd0aCA9PT0gMSAmJiBtdWx0aVBvbHlnb25BWzBdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbXVsdGlQb2x5Z29uQ29udGFpbnNQb2ludChtdWx0aVBvbHlnb25CLCBtdWx0aVBvbHlnb25BWzBdWzBdKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBtID0gMDsgbSA8IG11bHRpUG9seWdvbkIubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSBtdWx0aVBvbHlnb25CW21dO1xuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHJpbmcubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIGlmIChtdWx0aVBvbHlnb25Db250YWluc1BvaW50KG11bHRpUG9seWdvbkEsIHJpbmdbbl0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbXVsdGlQb2x5Z29uQS5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcG9seWdvbiA9IG11bHRpUG9seWdvbkFbal07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG11bHRpUG9seWdvbkNvbnRhaW5zUG9pbnQobXVsdGlQb2x5Z29uQiwgcG9seWdvbltpXSkpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBtdWx0aVBvbHlnb25CLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBpZiAobGluZUludGVyc2VjdHNMaW5lKHBvbHlnb24sIG11bHRpUG9seWdvbkJba10pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbXVsdGlQb2x5Z29uSW50ZXJzZWN0c0J1ZmZlcmVkTXVsdGlMaW5lKG11bHRpUG9seWdvbiwgbXVsdGlMaW5lLCByYWRpdXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11bHRpTGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGluZSA9IG11bHRpTGluZVtpXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG11bHRpUG9seWdvbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHBvbHlnb24gPSBtdWx0aVBvbHlnb25bal07XG5cbiAgICAgICAgICAgIGlmIChwb2x5Z29uLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsaW5lLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2x5Z29uQ29udGFpbnNQb2ludChwb2x5Z29uLCBsaW5lW2tdKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGluZUludGVyc2VjdHNCdWZmZXJlZExpbmUocG9seWdvbiwgbGluZSwgcmFkaXVzKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaW5lSW50ZXJzZWN0c0J1ZmZlcmVkTGluZShsaW5lQSwgbGluZUIsIHJhZGl1cykge1xuXG4gICAgaWYgKGxpbmVBLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaWYgKGxpbmVJbnRlcnNlY3RzTGluZShsaW5lQSwgbGluZUIpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIGFueSBwb2ludCBpbiBlaXRoZXIgbGluZSBpcyB3aXRoaW4gcmFkaXVzIG9mIHRoZSBvdGhlciBsaW5lXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZUIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwb2ludEludGVyc2VjdHNCdWZmZXJlZExpbmUobGluZUJbal0sIGxpbmVBLCByYWRpdXMpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGluZUEubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgaWYgKHBvaW50SW50ZXJzZWN0c0J1ZmZlcmVkTGluZShsaW5lQVtrXSwgbGluZUIsIHJhZGl1cykpIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGluZUludGVyc2VjdHNMaW5lKGxpbmVBLCBsaW5lQikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZUEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBhMCA9IGxpbmVBW2ldO1xuICAgICAgICB2YXIgYTEgPSBsaW5lQVtpICsgMV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZUIubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgICAgICB2YXIgYjAgPSBsaW5lQltqXTtcbiAgICAgICAgICAgIHZhciBiMSA9IGxpbmVCW2ogKyAxXTtcbiAgICAgICAgICAgIGlmIChsaW5lU2VnbWVudEludGVyc2VjdHNMaW5lU2VnbWVudChhMCwgYTEsIGIwLCBiMSkpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuXG4vLyBodHRwOi8vYnJ5Y2Vib2UuY29tLzIwMDYvMTAvMjMvbGluZS1zZWdtZW50LWludGVyc2VjdGlvbi1hbGdvcml0aG0vXG5mdW5jdGlvbiBpc0NvdW50ZXJDbG9ja3dpc2UoYSwgYiwgYykge1xuICAgIHJldHVybiAoYy55IC0gYS55KSAqIChiLnggLSBhLngpID4gKGIueSAtIGEueSkgKiAoYy54IC0gYS54KTtcbn1cblxuZnVuY3Rpb24gbGluZVNlZ21lbnRJbnRlcnNlY3RzTGluZVNlZ21lbnQoYTAsIGExLCBiMCwgYjEpIHtcbiAgICByZXR1cm4gaXNDb3VudGVyQ2xvY2t3aXNlKGEwLCBiMCwgYjEpICE9PSBpc0NvdW50ZXJDbG9ja3dpc2UoYTEsIGIwLCBiMSkgJiZcbiAgICAgICAgaXNDb3VudGVyQ2xvY2t3aXNlKGEwLCBhMSwgYjApICE9PSBpc0NvdW50ZXJDbG9ja3dpc2UoYTAsIGExLCBiMSk7XG59XG5cbmZ1bmN0aW9uIHBvaW50SW50ZXJzZWN0c0J1ZmZlcmVkTGluZShwLCBsaW5lLCByYWRpdXMpIHtcbiAgICB2YXIgcmFkaXVzU3F1YXJlZCA9IHJhZGl1cyAqIHJhZGl1cztcblxuICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHAuZGlzdFNxcihsaW5lWzBdKSA8IHJhZGl1c1NxdWFyZWQ7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRmluZCBsaW5lIHNlZ21lbnRzIHRoYXQgaGF2ZSBhIGRpc3RhbmNlIDw9IHJhZGl1c14yIHRvIHBcbiAgICAgICAgLy8gSW4gdGhhdCBjYXNlLCB3ZSB0cmVhdCB0aGUgbGluZSBhcyBcImNvbnRhaW5pbmcgcG9pbnQgcFwiLlxuICAgICAgICB2YXIgdiA9IGxpbmVbaSAtIDFdLCB3ID0gbGluZVtpXTtcbiAgICAgICAgaWYgKGRpc3RUb1NlZ21lbnRTcXVhcmVkKHAsIHYsIHcpIDwgcmFkaXVzU3F1YXJlZCkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE1MDE3MjUvMzMxMzc5LlxuZnVuY3Rpb24gZGlzdFRvU2VnbWVudFNxdWFyZWQocCwgdiwgdykge1xuICAgIHZhciBsMiA9IHYuZGlzdFNxcih3KTtcbiAgICBpZiAobDIgPT09IDApIHJldHVybiBwLmRpc3RTcXIodik7XG4gICAgdmFyIHQgPSAoKHAueCAtIHYueCkgKiAody54IC0gdi54KSArIChwLnkgLSB2LnkpICogKHcueSAtIHYueSkpIC8gbDI7XG4gICAgaWYgKHQgPCAwKSByZXR1cm4gcC5kaXN0U3FyKHYpO1xuICAgIGlmICh0ID4gMSkgcmV0dXJuIHAuZGlzdFNxcih3KTtcbiAgICByZXR1cm4gcC5kaXN0U3FyKHcuc3ViKHYpLl9tdWx0KHQpLl9hZGQodikpO1xufVxuXG4vLyBwb2ludCBpbiBwb2x5Z29uIHJheSBjYXN0aW5nIGFsZ29yaXRobVxuZnVuY3Rpb24gbXVsdGlQb2x5Z29uQ29udGFpbnNQb2ludChyaW5ncywgcCkge1xuICAgIHZhciBjID0gZmFsc2UsXG4gICAgICAgIHJpbmcsIHAxLCBwMjtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcmluZ3MubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgcmluZyA9IHJpbmdzW2tdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHJpbmcubGVuZ3RoIC0gMTsgaSA8IHJpbmcubGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgICAgICAgICBwMSA9IHJpbmdbaV07XG4gICAgICAgICAgICBwMiA9IHJpbmdbal07XG4gICAgICAgICAgICBpZiAoKChwMS55ID4gcC55KSAhPT0gKHAyLnkgPiBwLnkpKSAmJiAocC54IDwgKHAyLnggLSBwMS54KSAqIChwLnkgLSBwMS55KSAvIChwMi55IC0gcDEueSkgKyBwMS54KSkge1xuICAgICAgICAgICAgICAgIGMgPSAhYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gcG9seWdvbkNvbnRhaW5zUG9pbnQocmluZywgcCkge1xuICAgIHZhciBjID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSByaW5nLmxlbmd0aCAtIDE7IGkgPCByaW5nLmxlbmd0aDsgaiA9IGkrKykge1xuICAgICAgICB2YXIgcDEgPSByaW5nW2ldO1xuICAgICAgICB2YXIgcDIgPSByaW5nW2pdO1xuICAgICAgICBpZiAoKChwMS55ID4gcC55KSAhPT0gKHAyLnkgPiBwLnkpKSAmJiAocC54IDwgKHAyLnggLSBwMS54KSAqIChwLnkgLSBwMS55KSAvIChwMi55IC0gcDEueSkgKyBwMS54KSkge1xuICAgICAgICAgICAgYyA9ICFjO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExSVUNhY2hlO1xuXG4vKipcbiAqIEEgW2xlYXN0LXJlY2VudGx5LXVzZWQgY2FjaGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FjaGVfYWxnb3JpdGhtcylcbiAqIHdpdGggaGFzaCBsb29rdXAgbWFkZSBwb3NzaWJsZSBieSBrZWVwaW5nIGEgbGlzdCBvZiBrZXlzIGluIHBhcmFsbGVsIHRvXG4gKiBhbiBhcnJheSBvZiBkaWN0aW9uYXJ5IG9mIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggbnVtYmVyIG9mIHBlcm1pdHRlZCB2YWx1ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVtb3ZlIGNhbGxiYWNrIGNhbGxlZCB3aXRoIGl0ZW1zIHdoZW4gdGhleSBleHBpcmVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIExSVUNhY2hlKG1heCwgb25SZW1vdmUpIHtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgICB0aGlzLm9uUmVtb3ZlID0gb25SZW1vdmU7XG4gICAgdGhpcy5yZXNldCgpO1xufVxuXG4vKipcbiAqIENsZWFyIHRoZSBjYWNoZVxuICpcbiAqIEByZXR1cm5zIHtMUlVDYWNoZX0gdGhpcyBjYWNoZVxuICogQHByaXZhdGVcbiAqL1xuTFJVQ2FjaGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuZGF0YSkge1xuICAgICAgICB0aGlzLm9uUmVtb3ZlKHRoaXMuZGF0YVtrZXldKTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICB0aGlzLm9yZGVyID0gW107XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEga2V5LCB2YWx1ZSBjb21iaW5hdGlvbiB0byB0aGUgY2FjaGUsIHRyaW1taW5nIGl0cyBzaXplIGlmIHRoaXMgcHVzaGVzXG4gKiBpdCBvdmVyIG1heCBsZW5ndGguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBsb29rdXAga2V5IGZvciB0aGUgaXRlbVxuICogQHBhcmFtIHsqfSBkYXRhIGFueSB2YWx1ZVxuICpcbiAqIEByZXR1cm5zIHtMUlVDYWNoZX0gdGhpcyBjYWNoZVxuICogQHByaXZhdGVcbiAqL1xuTFJVQ2FjaGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGtleSwgZGF0YSkge1xuXG4gICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgdGhpcy5vcmRlci5zcGxpY2UodGhpcy5vcmRlci5pbmRleE9mKGtleSksIDEpO1xuICAgICAgICB0aGlzLmRhdGFba2V5XSA9IGRhdGE7XG4gICAgICAgIHRoaXMub3JkZXIucHVzaChrZXkpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kYXRhW2tleV0gPSBkYXRhO1xuICAgICAgICB0aGlzLm9yZGVyLnB1c2goa2V5KTtcblxuICAgICAgICBpZiAodGhpcy5vcmRlci5sZW5ndGggPiB0aGlzLm1heCkge1xuICAgICAgICAgICAgdmFyIHJlbW92ZWREYXRhID0gdGhpcy5nZXQodGhpcy5vcmRlclswXSk7XG4gICAgICAgICAgICBpZiAocmVtb3ZlZERhdGEpIHRoaXMub25SZW1vdmUocmVtb3ZlZERhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIHRoZSB2YWx1ZSBhdHRhY2hlZCB0byBga2V5YCBpcyBwcmVzZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0aGUga2V5IHRvIGJlIGxvb2tlZC11cFxuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIGNhY2hlIGhhcyB0aGlzIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5MUlVDYWNoZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGtleSBpbiB0aGlzLmRhdGE7XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIGtleXMgaW4gdGhlIGNhY2hlXG4gKlxuICogQHJldHVybnMge0FycmF5PHN0cmluZz59IGFuIGFycmF5IG9mIGtleXMgaW4gdGhpcyBjYWNoZS5cbiAqIEBwcml2YXRlXG4gKi9cbkxSVUNhY2hlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3JkZXI7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgYXR0YWNoZWQgdG8gYSBzcGVjaWZpYyBrZXkuIElmIHRoZSBrZXkgaXMgbm90IGZvdW5kLFxuICogcmV0dXJucyBgbnVsbGBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRoZSBrZXkgdG8gbG9vayB1cFxuICogQHJldHVybnMgeyp9IHRoZSBkYXRhLCBvciBudWxsIGlmIGl0IGlzbid0IGZvdW5kXG4gKiBAcHJpdmF0ZVxuICovXG5MUlVDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCF0aGlzLmhhcyhrZXkpKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YVtrZXldO1xuXG4gICAgZGVsZXRlIHRoaXMuZGF0YVtrZXldO1xuICAgIHRoaXMub3JkZXIuc3BsaWNlKHRoaXMub3JkZXIuaW5kZXhPZihrZXkpLCAxKTtcblxuICAgIHJldHVybiBkYXRhO1xufTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIG1heCBzaXplIG9mIHRoZSBjYWNoZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IHRoZSBtYXggc2l6ZSBvZiB0aGUgY2FjaGVcbiAqIEByZXR1cm5zIHtMUlVDYWNoZX0gdGhpcyBjYWNoZVxuICogQHByaXZhdGVcbiAqL1xuTFJVQ2FjaGUucHJvdG90eXBlLnNldE1heFNpemUgPSBmdW5jdGlvbihtYXgpIHtcbiAgICB0aGlzLm1heCA9IG1heDtcblxuICAgIHdoaWxlICh0aGlzLm9yZGVyLmxlbmd0aCA+IHRoaXMubWF4KSB7XG4gICAgICAgIHZhciByZW1vdmVkRGF0YSA9IHRoaXMuZ2V0KHRoaXMub3JkZXJbMF0pO1xuICAgICAgICBpZiAocmVtb3ZlZERhdGEpIHRoaXMub25SZW1vdmUocmVtb3ZlZERhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4vYnJvd3NlcicpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVVUkwodXJsLCBwYXRoUHJlZml4LCBhY2Nlc3NUb2tlbikge1xuICAgIGFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW4gfHwgY29uZmlnLkFDQ0VTU19UT0tFTjtcblxuICAgIGlmICghYWNjZXNzVG9rZW4gJiYgY29uZmlnLlJFUVVJUkVfQUNDRVNTX1RPS0VOKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gQVBJIGFjY2VzcyB0b2tlbiBpcyByZXF1aXJlZCB0byB1c2UgTWFwYm94IEdMLiAnICtcbiAgICAgICAgICAgICdTZWUgaHR0cHM6Ly93d3cubWFwYm94LmNvbS9kZXZlbG9wZXJzL2FwaS8jYWNjZXNzLXRva2VucycpO1xuICAgIH1cblxuICAgIHVybCA9IHVybC5yZXBsYWNlKC9ebWFwYm94OlxcL1xcLy8sIGNvbmZpZy5BUElfVVJMICsgcGF0aFByZWZpeCk7XG4gICAgdXJsICs9IHVybC5pbmRleE9mKCc/JykgIT09IC0xID8gJyZhY2Nlc3NfdG9rZW49JyA6ICc/YWNjZXNzX3Rva2VuPSc7XG5cbiAgICBpZiAoY29uZmlnLlJFUVVJUkVfQUNDRVNTX1RPS0VOKSB7XG4gICAgICAgIGlmIChhY2Nlc3NUb2tlblswXSA9PT0gJ3MnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZSBhIHB1YmxpYyBhY2Nlc3MgdG9rZW4gKHBrLiopIHdpdGggTWFwYm94IEdMIEpTLCBub3QgYSBzZWNyZXQgYWNjZXNzIHRva2VuIChzay4qKS4gJyArXG4gICAgICAgICAgICAgICAgJ1NlZSBodHRwczovL3d3dy5tYXBib3guY29tL2RldmVsb3BlcnMvYXBpLyNhY2Nlc3MtdG9rZW5zJyk7XG4gICAgICAgIH1cblxuICAgICAgICB1cmwgKz0gYWNjZXNzVG9rZW47XG4gICAgfVxuXG4gICAgcmV0dXJuIHVybDtcbn1cblxubW9kdWxlLmV4cG9ydHMubm9ybWFsaXplU3R5bGVVUkwgPSBmdW5jdGlvbih1cmwsIGFjY2Vzc1Rva2VuKSB7XG4gICAgaWYgKCF1cmwubWF0Y2goL15tYXBib3g6XFwvXFwvc3R5bGVzXFwvLykpXG4gICAgICAgIHJldHVybiB1cmw7XG5cbiAgICB2YXIgc3BsaXQgPSB1cmwuc3BsaXQoJy8nKTtcbiAgICB2YXIgdXNlciA9IHNwbGl0WzNdO1xuICAgIHZhciBzdHlsZSA9IHNwbGl0WzRdO1xuICAgIHZhciBkcmFmdCA9IHNwbGl0WzVdID8gJy9kcmFmdCcgOiAnJztcbiAgICByZXR1cm4gbm9ybWFsaXplVVJMKCdtYXBib3g6Ly8nICsgdXNlciArICcvJyArIHN0eWxlICsgZHJhZnQsICcvc3R5bGVzL3YxLycsIGFjY2Vzc1Rva2VuKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLm5vcm1hbGl6ZVNvdXJjZVVSTCA9IGZ1bmN0aW9uKHVybCwgYWNjZXNzVG9rZW4pIHtcbiAgICBpZiAoIXVybC5tYXRjaCgvXm1hcGJveDpcXC9cXC8vKSlcbiAgICAgICAgcmV0dXJuIHVybDtcblxuICAgIC8vIFRpbGVKU09OIHJlcXVlc3RzIG5lZWQgYSBzZWN1cmUgZmxhZyBhcHBlbmRlZCB0byB0aGVpciBVUkxzIHNvXG4gICAgLy8gdGhhdCB0aGUgc2VydmVyIGtub3dzIHRvIHNlbmQgU1NMLWlmaWVkIHJlc291cmNlIHJlZmVyZW5jZXMuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZVVSTCh1cmwgKyAnLmpzb24nLCAnL3Y0LycsIGFjY2Vzc1Rva2VuKSArICcmc2VjdXJlJztcbn07XG5cbm1vZHVsZS5leHBvcnRzLm5vcm1hbGl6ZUdseXBoc1VSTCA9IGZ1bmN0aW9uKHVybCwgYWNjZXNzVG9rZW4pIHtcbiAgICBpZiAoIXVybC5tYXRjaCgvXm1hcGJveDpcXC9cXC8vKSlcbiAgICAgICAgcmV0dXJuIHVybDtcblxuICAgIHZhciB1c2VyID0gdXJsLnNwbGl0KCcvJylbM107XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVVSTCgnbWFwYm94Oi8vJyArIHVzZXIgKyAnL3tmb250c3RhY2t9L3tyYW5nZX0ucGJmJywgJy9mb250cy92MS8nLCBhY2Nlc3NUb2tlbik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVTcHJpdGVVUkwgPSBmdW5jdGlvbih1cmwsIGZvcm1hdCwgZXh0LCBhY2Nlc3NUb2tlbikge1xuICAgIGlmICghdXJsLm1hdGNoKC9ebWFwYm94OlxcL1xcL3Nwcml0ZXNcXC8vKSlcbiAgICAgICAgcmV0dXJuIHVybCArIGZvcm1hdCArIGV4dDtcblxuICAgIHZhciBzcGxpdCA9IHVybC5zcGxpdCgnLycpO1xuICAgIHZhciB1c2VyID0gc3BsaXRbM107XG4gICAgdmFyIHN0eWxlID0gc3BsaXRbNF07XG4gICAgdmFyIGRyYWZ0ID0gc3BsaXRbNV0gPyAnL2RyYWZ0JyA6ICcnO1xuICAgIHJldHVybiBub3JtYWxpemVVUkwoJ21hcGJveDovLycgKyB1c2VyICsgJy8nICsgc3R5bGUgKyBkcmFmdCArICcvc3ByaXRlJyArIGZvcm1hdCArIGV4dCwgJy9zdHlsZXMvdjEvJywgYWNjZXNzVG9rZW4pO1xufTtcblxubW9kdWxlLmV4cG9ydHMubm9ybWFsaXplVGlsZVVSTCA9IGZ1bmN0aW9uKHVybCwgc291cmNlVXJsLCB0aWxlU2l6ZSkge1xuICAgIGlmICghc291cmNlVXJsIHx8ICFzb3VyY2VVcmwubWF0Y2goL15tYXBib3g6XFwvXFwvLykpXG4gICAgICAgIHJldHVybiB1cmw7XG5cbiAgICAvLyBUaGUgdjQgbWFwYm94IHRpbGUgQVBJIHN1cHBvcnRzIDUxMng1MTIgaW1hZ2UgdGlsZXMgb25seSB3aGVuIEAyeFxuICAgIC8vIGlzIGFwcGVuZGVkIHRvIHRoZSB0aWxlIFVSTC4gSWYgYHRpbGVTaXplOiA1MTJgIGlzIHNwZWNpZmllZCBmb3JcbiAgICAvLyBhIE1hcGJveCByYXN0ZXIgc291cmNlIGZvcmNlIHRoZSBAMnggc3VmZml4IGV2ZW4gaWYgYSBub24gaGlkcGlcbiAgICAvLyBkZXZpY2UuXG4gICAgdXJsID0gdXJsLnJlcGxhY2UoLyhbPyZdYWNjZXNzX3Rva2VuPSl0a1xcLlteJl0rLywgJyQxJyArIGNvbmZpZy5BQ0NFU1NfVE9LRU4pO1xuICAgIHZhciBleHRlbnNpb24gPSBicm93c2VyLnN1cHBvcnRzV2VicCA/ICd3ZWJwJyA6ICckMSc7XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKC9cXC4oKD86cG5nfGpwZylcXGQqKSg/PSR8XFw/KS8sIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyA+PSAyIHx8IHRpbGVTaXplID09PSA1MTIgPyAnQDJ4LicgKyBleHRlbnNpb24gOiAnLicgKyBleHRlbnNpb24pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogYWxsIFwic2l6ZXNcIiBhcmUgbWVhc3VyZWQgaW4gYnl0ZXNcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cnVjdEFycmF5VHlwZTtcblxudmFyIHZpZXdUeXBlcyA9IHtcbiAgICAnSW50OCc6IEludDhBcnJheSxcbiAgICAnVWludDgnOiBVaW50OEFycmF5LFxuICAgICdVaW50OENsYW1wZWQnOiBVaW50OENsYW1wZWRBcnJheSxcbiAgICAnSW50MTYnOiBJbnQxNkFycmF5LFxuICAgICdVaW50MTYnOiBVaW50MTZBcnJheSxcbiAgICAnSW50MzInOiBJbnQzMkFycmF5LFxuICAgICdVaW50MzInOiBVaW50MzJBcnJheSxcbiAgICAnRmxvYXQzMic6IEZsb2F0MzJBcnJheSxcbiAgICAnRmxvYXQ2NCc6IEZsb2F0NjRBcnJheVxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiBTdHJ1Y3RNZW1iZXJcbiAqIEBwcml2YXRlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb21wb25lbnRzXG4gKi9cblxudmFyIHN0cnVjdEFycmF5VHlwZUNhY2hlID0ge307XG5cbi8qKlxuICogYFN0cnVjdEFycmF5VHlwZWAgaXMgdXNlZCB0byBjcmVhdGUgbmV3IGBTdHJ1Y3RBcnJheWAgdHlwZXMuXG4gKlxuICogYFN0cnVjdEFycmF5YCBwcm92aWRlcyBhbiBhYnN0cmFjdGlvbiBvdmVyIGBBcnJheUJ1ZmZlcmAgYW5kIGBUeXBlZEFycmF5YCBtYWtpbmcgaXQgYmVoYXZlIGxpa2VcbiAqIGFuIGFycmF5IG9mIHR5cGVkIHN0cnVjdHMuIEEgU3RydWN0QXJyYXkgaXMgY29tcHJpc2VkIG9mIGVsZW1lbnRzLiBFYWNoIGVsZW1lbnQgaGFzIGEgc2V0IG9mXG4gKiBtZW1iZXJzIHRoYXQgYXJlIGRlZmluZWQgd2hlbiB0aGUgYFN0cnVjdEFycmF5VHlwZWAgaXMgY3JlYXRlZC5cbiAqXG4gKiBTdHJ1Y3RBcnJheXMgdXNlZnVsIGZvciBjcmVhdGluZyBsYXJnZSBhcnJheXMgdGhhdDpcbiAqIC0gY2FuIGJlIHRyYW5zZmVycmVkIGZyb20gd29ya2VycyBhcyBhIFRyYW5zZmVyYWJsZSBvYmplY3RcbiAqIC0gY2FuIGJlIGNvcGllZCBjaGVhcGx5XG4gKiAtIHVzZSBsZXNzIG1lbW9yeSBmb3IgbG93ZXItcHJlY2lzaW9uIG1lbWJlcnNcbiAqIC0gY2FuIGJlIHVzZWQgYXMgYnVmZmVycyBpbiBXZWJHTC5cbiAqXG4gKiBAY2xhc3MgU3RydWN0QXJyYXlUeXBlXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJ1Y3RNZW1iZXI+fVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmFsaWdubWVudCBVc2UgYDRgIHRvIGFsaWduIG1lbWJlcnMgdG8gNCBieXRlIGJvdW5kYXJpZXMuIERlZmF1bHQgaXMgMS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBQb2ludEFycmF5VHlwZSA9IG5ldyBTdHJ1Y3RBcnJheVR5cGUoe1xuICogIG1lbWJlcnM6IFtcbiAqICAgICAgeyB0eXBlOiAnSW50MTYnLCBuYW1lOiAneCcgfSxcbiAqICAgICAgeyB0eXBlOiAnSW50MTYnLCBuYW1lOiAneScgfVxuICogIF19KTtcbiAqXG4gKiAgdmFyIHBvaW50QXJyYXkgPSBuZXcgUG9pbnRBcnJheVR5cGUoKTtcbiAqICBwb2ludEFycmF5LmVtcGxhY2VCYWNrKDEwLCAxNSk7XG4gKiAgcG9pbnRBcnJheS5lbXBsYWNlQmFjaygyMCwgMzUpO1xuICpcbiAqICBwb2ludCA9IHBvaW50QXJyYXkuZ2V0KDApO1xuICogIGFzc2VydChwb2ludC54ID09PSAxMCk7XG4gKiAgYXNzZXJ0KHBvaW50LnkgPT09IDE1KTtcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBTdHJ1Y3RBcnJheVR5cGUob3B0aW9ucykge1xuXG4gICAgdmFyIGtleSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICAgIGlmIChzdHJ1Y3RBcnJheVR5cGVDYWNoZVtrZXldKSB7XG4gICAgICAgIHJldHVybiBzdHJ1Y3RBcnJheVR5cGVDYWNoZVtrZXldO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFsaWdubWVudCA9PT0gdW5kZWZpbmVkKSBvcHRpb25zLmFsaWdubWVudCA9IDE7XG5cbiAgICBmdW5jdGlvbiBTdHJ1Y3RUeXBlKCkge1xuICAgICAgICBTdHJ1Y3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBTdHJ1Y3RUeXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3RydWN0LnByb3RvdHlwZSk7XG5cbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICB2YXIgbWF4U2l6ZSA9IDA7XG4gICAgdmFyIHVzZWRUeXBlcyA9IFsnVWludDgnXTtcblxuICAgIFN0cnVjdFR5cGUucHJvdG90eXBlLm1lbWJlcnMgPSBvcHRpb25zLm1lbWJlcnMubWFwKGZ1bmN0aW9uKG1lbWJlcikge1xuICAgICAgICBtZW1iZXIgPSB7XG4gICAgICAgICAgICBuYW1lOiBtZW1iZXIubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IG1lbWJlci50eXBlLFxuICAgICAgICAgICAgY29tcG9uZW50czogbWVtYmVyLmNvbXBvbmVudHMgfHwgMVxuICAgICAgICB9O1xuXG4gICAgICAgIGFzc2VydChtZW1iZXIubmFtZS5sZW5ndGgpO1xuICAgICAgICBhc3NlcnQobWVtYmVyLnR5cGUgaW4gdmlld1R5cGVzKTtcblxuICAgICAgICBpZiAodXNlZFR5cGVzLmluZGV4T2YobWVtYmVyLnR5cGUpIDwgMCkgdXNlZFR5cGVzLnB1c2gobWVtYmVyLnR5cGUpO1xuXG4gICAgICAgIHZhciB0eXBlU2l6ZSA9IHNpemVPZihtZW1iZXIudHlwZSk7XG4gICAgICAgIG1heFNpemUgPSBNYXRoLm1heChtYXhTaXplLCB0eXBlU2l6ZSk7XG4gICAgICAgIG1lbWJlci5vZmZzZXQgPSBvZmZzZXQgPSBhbGlnbihvZmZzZXQsIE1hdGgubWF4KG9wdGlvbnMuYWxpZ25tZW50LCB0eXBlU2l6ZSkpO1xuXG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbWVtYmVyLmNvbXBvbmVudHM7IGMrKykge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cnVjdFR5cGUucHJvdG90eXBlLCBtZW1iZXIubmFtZSArIChtZW1iZXIuY29tcG9uZW50cyA9PT0gMSA/ICcnIDogYyksIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGNyZWF0ZUdldHRlcihtZW1iZXIsIGMpLFxuICAgICAgICAgICAgICAgIHNldDogY3JlYXRlU2V0dGVyKG1lbWJlciwgYylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgb2Zmc2V0ICs9IHR5cGVTaXplICogbWVtYmVyLmNvbXBvbmVudHM7XG5cbiAgICAgICAgcmV0dXJuIG1lbWJlcjtcbiAgICB9KTtcblxuICAgIFN0cnVjdFR5cGUucHJvdG90eXBlLmFsaWdubWVudCA9IG9wdGlvbnMuYWxpZ25tZW50O1xuICAgIFN0cnVjdFR5cGUucHJvdG90eXBlLnNpemUgPSBhbGlnbihvZmZzZXQsIE1hdGgubWF4KG1heFNpemUsIG9wdGlvbnMuYWxpZ25tZW50KSk7XG5cbiAgICBmdW5jdGlvbiBTdHJ1Y3RBcnJheVR5cGUoKSB7XG4gICAgICAgIFN0cnVjdEFycmF5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IFN0cnVjdFR5cGUucHJvdG90eXBlLm1lbWJlcnM7XG4gICAgfVxuXG4gICAgU3RydWN0QXJyYXlUeXBlLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZVN0cnVjdEFycmF5VHlwZTtcblxuICAgIFN0cnVjdEFycmF5VHlwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN0cnVjdEFycmF5LnByb3RvdHlwZSk7XG4gICAgU3RydWN0QXJyYXlUeXBlLnByb3RvdHlwZS5TdHJ1Y3RUeXBlID0gU3RydWN0VHlwZTtcbiAgICBTdHJ1Y3RBcnJheVR5cGUucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IFN0cnVjdFR5cGUucHJvdG90eXBlLnNpemU7XG4gICAgU3RydWN0QXJyYXlUeXBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGNyZWF0ZUVtcGxhY2VCYWNrKFN0cnVjdFR5cGUucHJvdG90eXBlLm1lbWJlcnMsIFN0cnVjdFR5cGUucHJvdG90eXBlLnNpemUpO1xuICAgIFN0cnVjdEFycmF5VHlwZS5wcm90b3R5cGUuX3VzZWRUeXBlcyA9IHVzZWRUeXBlcztcblxuXG4gICAgc3RydWN0QXJyYXlUeXBlQ2FjaGVba2V5XSA9IFN0cnVjdEFycmF5VHlwZTtcblxuICAgIHJldHVybiBTdHJ1Y3RBcnJheVR5cGU7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBTdHJ1Y3RBcnJheSB0eXBlLiBUaGlzIHNlcmlhbGl6ZXMgdGhlICp0eXBlKiBub3QgYW4gaW5zdGFuY2Ugb2YgdGhlIHR5cGUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVTdHJ1Y3RBcnJheVR5cGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVtYmVyczogdGhpcy5wcm90b3R5cGUuU3RydWN0VHlwZS5wcm90b3R5cGUubWVtYmVycyxcbiAgICAgICAgYWxpZ25tZW50OiB0aGlzLnByb3RvdHlwZS5TdHJ1Y3RUeXBlLnByb3RvdHlwZS5hbGlnbm1lbnQsXG4gICAgICAgIGJ5dGVzUGVyRWxlbWVudDogdGhpcy5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50XG4gICAgfTtcbn1cblxuXG5mdW5jdGlvbiBhbGlnbihvZmZzZXQsIHNpemUpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKG9mZnNldCAvIHNpemUpICogc2l6ZTtcbn1cblxuZnVuY3Rpb24gc2l6ZU9mKHR5cGUpIHtcbiAgICByZXR1cm4gdmlld1R5cGVzW3R5cGVdLkJZVEVTX1BFUl9FTEVNRU5UO1xufVxuXG5mdW5jdGlvbiBnZXRBcnJheVZpZXdOYW1lKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZS50b0xvd2VyQ2FzZSgpO1xufVxuXG5cbi8qXG4gKiA+IEkgc2F3IG1ham9yIHBlcmYgZ2FpbnMgYnkgc2hvcnRlbmluZyB0aGUgc291cmNlIG9mIHRoZXNlIGdlbmVyYXRlZCBtZXRob2RzIChpLmUuIHJlbmFtaW5nXG4gKiA+IGVsZW1lbnRJbmRleCB0byBpKSAobGlrZWx5IGR1ZSB0byB2OCBpbmxpbmluZyBoZXVyaXN0aWNzKS5cbiAqIC0gbHVjYXN3b2pcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW1wbGFjZUJhY2sobWVtYmVycywgYnl0ZXNQZXJFbGVtZW50KSB7XG4gICAgdmFyIHVzZWRUeXBlU2l6ZXMgPSBbXTtcbiAgICB2YXIgYXJnTmFtZXMgPSBbXTtcbiAgICB2YXIgYm9keSA9ICcnICtcbiAgICAndmFyIGkgPSB0aGlzLmxlbmd0aDtcXG4nICtcbiAgICAndGhpcy5yZXNpemUodGhpcy5sZW5ndGggKyAxKTtcXG4nO1xuXG4gICAgZm9yICh2YXIgbSA9IDA7IG0gPCBtZW1iZXJzLmxlbmd0aDsgbSsrKSB7XG4gICAgICAgIHZhciBtZW1iZXIgPSBtZW1iZXJzW21dO1xuICAgICAgICB2YXIgc2l6ZSA9IHNpemVPZihtZW1iZXIudHlwZSk7XG5cbiAgICAgICAgaWYgKHVzZWRUeXBlU2l6ZXMuaW5kZXhPZihzaXplKSA8IDApIHtcbiAgICAgICAgICAgIHVzZWRUeXBlU2l6ZXMucHVzaChzaXplKTtcbiAgICAgICAgICAgIGJvZHkgKz0gJ3ZhciBvJyArIHNpemUudG9GaXhlZCgwKSArICcgPSBpICogJyArIChieXRlc1BlckVsZW1lbnQgLyBzaXplKS50b0ZpeGVkKDApICsgJztcXG4nO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBtZW1iZXIuY29tcG9uZW50czsgYysrKSB7XG4gICAgICAgICAgICB2YXIgYXJnTmFtZSA9ICd2JyArIGFyZ05hbWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9ICdvJyArIHNpemUudG9GaXhlZCgwKSArICcgKyAnICsgKG1lbWJlci5vZmZzZXQgLyBzaXplICsgYykudG9GaXhlZCgwKTtcbiAgICAgICAgICAgIGJvZHkgKz0gJ3RoaXMuJyArIGdldEFycmF5Vmlld05hbWUobWVtYmVyLnR5cGUpICsgJ1snICsgaW5kZXggKyAnXSA9ICcgKyBhcmdOYW1lICsgJztcXG4nO1xuICAgICAgICAgICAgYXJnTmFtZXMucHVzaChhcmdOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJvZHkgKz0gJ3JldHVybiBpOyc7XG5cbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGFyZ05hbWVzLCBib2R5KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWVtYmVyQ29tcG9uZW50U3RyaW5nKG1lbWJlciwgY29tcG9uZW50KSB7XG4gICAgdmFyIGVsZW1lbnRPZmZzZXQgPSAndGhpcy5fcG9zJyArIHNpemVPZihtZW1iZXIudHlwZSkudG9GaXhlZCgwKTtcbiAgICB2YXIgY29tcG9uZW50T2Zmc2V0ID0gKG1lbWJlci5vZmZzZXQgLyBzaXplT2YobWVtYmVyLnR5cGUpICsgY29tcG9uZW50KS50b0ZpeGVkKDApO1xuICAgIHZhciBpbmRleCA9IGVsZW1lbnRPZmZzZXQgKyAnICsgJyArIGNvbXBvbmVudE9mZnNldDtcbiAgICByZXR1cm4gJ3RoaXMuX3N0cnVjdEFycmF5LicgKyBnZXRBcnJheVZpZXdOYW1lKG1lbWJlci50eXBlKSArICdbJyArIGluZGV4ICsgJ10nO1xuXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdldHRlcihtZW1iZXIsIGMpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFtdLCAncmV0dXJuICcgKyBjcmVhdGVNZW1iZXJDb21wb25lbnRTdHJpbmcobWVtYmVyLCBjKSArICc7Jyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNldHRlcihtZW1iZXIsIGMpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFsneCddLCBjcmVhdGVNZW1iZXJDb21wb25lbnRTdHJpbmcobWVtYmVyLCBjKSArICcgPSB4OycpO1xufVxuXG4vKipcbiAqIEBjbGFzcyBTdHJ1Y3RcbiAqIEBwYXJhbSB7U3RydWN0QXJyYXl9IHN0cnVjdEFycmF5IFRoZSBTdHJ1Y3RBcnJheSB0aGUgc3RydWN0IGlzIHN0b3JlZCBpblxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgc3RydWN0IGluIHRoZSBTdHJ1Y3RBcnJheS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFN0cnVjdChzdHJ1Y3RBcnJheSwgaW5kZXgpIHtcbiAgICB0aGlzLl9zdHJ1Y3RBcnJheSA9IHN0cnVjdEFycmF5O1xuICAgIHRoaXMuX3BvczEgPSBpbmRleCAqIHRoaXMuc2l6ZTtcbiAgICB0aGlzLl9wb3MyID0gdGhpcy5fcG9zMSAvIDI7XG4gICAgdGhpcy5fcG9zNCA9IHRoaXMuX3BvczEgLyA0O1xuICAgIHRoaXMuX3BvczggPSB0aGlzLl9wb3MxIC8gODtcbn1cblxuLyoqXG4gKiBAY2xhc3MgU3RydWN0QXJyYXlcbiAqIFRoZSBTdHJ1Y3RBcnJheSBjbGFzcyBpcyBpbmhlcml0ZWQgYnkgdGhlIGN1c3RvbSBTdHJ1Y3RBcnJheVR5cGUgY2xhc3NlcyBjcmVhdGVkIHdpdGhcbiAqIGBuZXcgU3RydWN0QXJyYXlUeXBlKG1lbWJlcnMsIG9wdGlvbnMpYC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFN0cnVjdEFycmF5KHNlcmlhbGl6ZWQpIHtcbiAgICBpZiAoc2VyaWFsaXplZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gQ3JlYXRlIGZyb20gYW4gc2VyaWFsaXplZCBTdHJ1Y3RBcnJheVxuICAgICAgICB0aGlzLmFycmF5QnVmZmVyID0gc2VyaWFsaXplZC5hcnJheUJ1ZmZlcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBzZXJpYWxpemVkLmxlbmd0aDtcbiAgICAgICAgdGhpcy5jYXBhY2l0eSA9IHRoaXMuYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCAvIHRoaXMuYnl0ZXNQZXJFbGVtZW50O1xuICAgICAgICB0aGlzLl9yZWZyZXNoVmlld3MoKTtcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBTdHJ1Y3RBcnJheVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FwYWNpdHkgPSAtMTtcbiAgICAgICAgdGhpcy5yZXNpemUoMCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqIEByZWFkb25seVxuICovXG5TdHJ1Y3RBcnJheS5wcm90b3R5cGUuREVGQVVMVF9DQVBBQ0lUWSA9IDEyODtcblxuLyoqXG4gKiBAcHJvcGVydHkge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKiBAcmVhZG9ubHlcbiAqL1xuU3RydWN0QXJyYXkucHJvdG90eXBlLlJFU0laRV9NVUxUSVBMSUVSID0gNTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhpcyBTdHJ1Y3RBcnJheSBpbnN0YW5jZVxuICogQHByaXZhdGVcbiAqL1xuU3RydWN0QXJyYXkucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudHJpbSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlbmd0aDogdGhpcy5sZW5ndGgsXG4gICAgICAgIGFycmF5QnVmZmVyOiB0aGlzLmFycmF5QnVmZmVyXG4gICAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBTdHJ1Y3QgYXQgdGhlIGdpdmVuIGxvY2F0aW9uIGluIHRoZSBhcnJheS5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICovXG5TdHJ1Y3RBcnJheS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuU3RydWN0VHlwZSh0aGlzLCBpbmRleCk7XG59O1xuXG4vKipcbiAqIFJlc2l6ZSB0aGUgYXJyYXkgdG8gZGlzY2FyZCB1bnVzZWQgY2FwYWNpdHkuXG4gKiBAcHJpdmF0ZVxuICovXG5TdHJ1Y3RBcnJheS5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gdGhpcy5jYXBhY2l0eSkge1xuICAgICAgICB0aGlzLmNhcGFjaXR5ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSB0aGlzLmFycmF5QnVmZmVyLnNsaWNlKDAsIHRoaXMubGVuZ3RoICogdGhpcy5ieXRlc1BlckVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9yZWZyZXNoVmlld3MoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlc2l6ZSB0aGUgYXJyYXkuXG4gKiBJZiBgbmAgaXMgZ3JlYXRlciB0aGFuIHRoZSBjdXJyZW50IGxlbmd0aCB0aGVuIGFkZGl0aW9uYWwgZWxlbWVudHMgd2l0aCB1bmRlZmluZWQgdmFsdWVzIGFyZSBhZGRlZC5cbiAqIElmIGBuYCBpcyBsZXNzIHRoYW4gdGhlIGN1cnJlbnQgbGVuZ3RoIHRoZW4gdGhlIGFycmF5IHdpbGwgYmUgcmVkdWNlZCB0byB0aGUgZmlyc3QgYG5gIGVsZW1lbnRzLlxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG5ldyBzaXplIG9mIHRoZSBhcnJheS5cbiAqL1xuU3RydWN0QXJyYXkucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0aGlzLmxlbmd0aCA9IG47XG4gICAgaWYgKG4gPiB0aGlzLmNhcGFjaXR5KSB7XG4gICAgICAgIHRoaXMuY2FwYWNpdHkgPSBNYXRoLm1heChuLCBNYXRoLmZsb29yKHRoaXMuY2FwYWNpdHkgKiB0aGlzLlJFU0laRV9NVUxUSVBMSUVSKSwgdGhpcy5ERUZBVUxUX0NBUEFDSVRZKTtcbiAgICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmNhcGFjaXR5ICogdGhpcy5ieXRlc1BlckVsZW1lbnQpO1xuXG4gICAgICAgIHZhciBvbGRVaW50OEFycmF5ID0gdGhpcy51aW50ODtcbiAgICAgICAgdGhpcy5fcmVmcmVzaFZpZXdzKCk7XG4gICAgICAgIGlmIChvbGRVaW50OEFycmF5KSB0aGlzLnVpbnQ4LnNldChvbGRVaW50OEFycmF5KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBUeXBlZEFycmF5IHZpZXdzIGZvciB0aGUgY3VycmVudCBBcnJheUJ1ZmZlci5cbiAqIEBwcml2YXRlXG4gKi9cblN0cnVjdEFycmF5LnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCB0aGlzLl91c2VkVHlwZXMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLl91c2VkVHlwZXNbdF07XG4gICAgICAgIHRoaXNbZ2V0QXJyYXlWaWV3TmFtZSh0eXBlKV0gPSBuZXcgdmlld1R5cGVzW3R5cGVdKHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVzb2x2ZVRva2VucztcblxuLyoqXG4gKiBSZXBsYWNlIHRva2VucyBpbiBhIHN0cmluZyB0ZW1wbGF0ZSB3aXRoIHZhbHVlcyBpbiBhbiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBhIGtleS92YWx1ZSByZWxhdGlvbnNoaXAgYmV0d2VlbiB0b2tlbnMgYW5kIHJlcGxhY2VtZW50c1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgdGhlIHRlbXBsYXRlIHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gdGhlIHRlbXBsYXRlIHdpdGggdG9rZW5zIHJlcGxhY2VkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlVG9rZW5zKHByb3BlcnRpZXMsIHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC97KFtee30oKVxcW1xcXTw+JD06Oy4sXl0rKX0vZywgZnVuY3Rpb24obWF0Y2gsIGtleSkge1xuICAgICAgICByZXR1cm4ga2V5IGluIHByb3BlcnRpZXMgPyBwcm9wZXJ0aWVzW2tleV0gOiAnJztcbiAgICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFVuaXRCZXppZXIgPSByZXF1aXJlKCd1bml0YmV6aWVyJyk7XG52YXIgQ29vcmRpbmF0ZSA9IHJlcXVpcmUoJy4uL2dlby9jb29yZGluYXRlJyk7XG5cbi8qKlxuICogR2l2ZW4gYSB2YWx1ZSBgdGAgdGhhdCB2YXJpZXMgYmV0d2VlbiAwIGFuZCAxLCByZXR1cm5cbiAqIGFuIGludGVycG9sYXRpb24gZnVuY3Rpb24gdGhhdCBlYXNlcyBiZXR3ZWVuIDAgYW5kIDEgaW4gYSBwbGVhc2luZ1xuICogY3ViaWMgaW4tb3V0IGZhc2hpb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHQgaW5wdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGlucHV0XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmVhc2VDdWJpY0luT3V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICBpZiAodCA8PSAwKSByZXR1cm4gMDtcbiAgICBpZiAodCA+PSAxKSByZXR1cm4gMTtcbiAgICB2YXIgdDIgPSB0ICogdCxcbiAgICAgICAgdDMgPSB0MiAqIHQ7XG4gICAgcmV0dXJuIDQgKiAodCA8IDAuNSA/IHQzIDogMyAqICh0IC0gdDIpICsgdDMgLSAwLjc1KTtcbn07XG5cbi8qKlxuICogR2l2ZW4gZ2l2ZW4gKHgsIHkpLCAoeDEsIHkxKSBjb250cm9sIHBvaW50cyBmb3IgYSBiZXppZXIgY3VydmUsXG4gKiByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGludGVycG9sYXRlcyBhbG9uZyB0aGF0IGN1cnZlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBwMXggY29udHJvbCBwb2ludCAxIHggY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHAxeSBjb250cm9sIHBvaW50IDEgeSBjb29yZGluYXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcDJ4IGNvbnRyb2wgcG9pbnQgMiB4IGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBwMnkgY29udHJvbCBwb2ludCAyIHkgY29vcmRpbmF0ZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBpbnRlcnBvbGF0b3I6IHJlY2VpdmVzIG51bWJlciB2YWx1ZSwgcmV0dXJuc1xuICogbnVtYmVyIHZhbHVlLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5iZXppZXIgPSBmdW5jdGlvbihwMXgsIHAxeSwgcDJ4LCBwMnkpIHtcbiAgICB2YXIgYmV6aWVyID0gbmV3IFVuaXRCZXppZXIocDF4LCBwMXksIHAyeCwgcDJ5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gYmV6aWVyLnNvbHZlKHQpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIEEgZGVmYXVsdCBiZXppZXItY3VydmUgcG93ZXJlZCBlYXNpbmcgZnVuY3Rpb24gd2l0aFxuICogY29udHJvbCBwb2ludHMgKDAuMjUsIDAuMSkgYW5kICgwLjI1LCAxKVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBvdXRwdXRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZWFzZSA9IGV4cG9ydHMuYmV6aWVyKDAuMjUsIDAuMSwgMC4yNSwgMSk7XG5cbi8qKlxuICogR2l2ZW4gYSBmb3VyLWVsZW1lbnQgYXJyYXkgb2YgbnVtYmVycyB0aGF0IHJlcHJlc2VudHMgYSBjb2xvciBpblxuICogUkdCQSwgcmV0dXJuIGEgdmVyc2lvbiBmb3Igd2hpY2ggdGhlIFJHQiBjb21wb25lbnRzIGFyZSBtdWx0aXBsaWVkXG4gKiBieSB0aGUgQSAoYWxwaGEpIGNvbXBvbmVudFxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29sb3IgY29sb3IgYXJyYXlcbiAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBwcmVtdWx0aXBsaWVkIGNvbG9yIGFycmF5XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLnByZW11bHRpcGx5ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvcikgcmV0dXJuIG51bGw7XG4gICAgdmFyIG9wYWNpdHkgPSBjb2xvclszXTtcbiAgICByZXR1cm4gW1xuICAgICAgICBjb2xvclswXSAqIG9wYWNpdHksXG4gICAgICAgIGNvbG9yWzFdICogb3BhY2l0eSxcbiAgICAgICAgY29sb3JbMl0gKiBvcGFjaXR5LFxuICAgICAgICBvcGFjaXR5XG4gICAgXTtcbn07XG5cbi8qKlxuICogY29uc3RyYWluIG4gdG8gdGhlIGdpdmVuIHJhbmdlIHZpYSBtaW4gKyBtYXhcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbiB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiB0aGUgbWluaW11bSB2YWx1ZSB0byBiZSByZXR1cm5lZFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCB0aGUgbWF4aW11bSB2YWx1ZSB0byBiZSByZXR1cm5lZFxuICogQHJldHVybnMge251bWJlcn0gdGhlIGNsYW1wZWQgdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuY2xhbXAgPSBmdW5jdGlvbiAobiwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIG4pKTtcbn07XG5cbi8qXG4gKiBjb25zdHJhaW4gbiB0byB0aGUgZ2l2ZW4gcmFuZ2UsIGV4Y2x1ZGluZyB0aGUgbWluaW11bSwgdmlhIG1vZHVsYXIgYXJpdGhtZXRpY1xuICogQHBhcmFtIHtudW1iZXJ9IG4gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gdGhlIG1pbmltdW0gdmFsdWUgdG8gYmUgcmV0dXJuZWQsIGV4Y2x1c2l2ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1heCB0aGUgbWF4aW11bSB2YWx1ZSB0byBiZSByZXR1cm5lZCwgaW5jbHVzaXZlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBjb25zdHJhaW5lZCBudW1iZXJcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMud3JhcCA9IGZ1bmN0aW9uIChuLCBtaW4sIG1heCkge1xuICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgIHZhciB3ID0gKChuIC0gbWluKSAlIGQgKyBkKSAlIGQgKyBtaW47XG4gICAgcmV0dXJuICh3ID09PSBtaW4pID8gbWF4IDogdztcbn07XG5cbi8qXG4gKiByZXR1cm4gdGhlIGZpcnN0IG5vbi1udWxsIGFuZCBub24tdW5kZWZpbmVkIGFyZ3VtZW50IHRvIHRoaXMgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7Kn0gYXJndW1lbnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuY29hbGVzY2UgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpZiAoYXJnICE9PSBudWxsICYmIGFyZyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG59O1xuXG4vKlxuICogQ2FsbCBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gb24gYW4gYXJyYXkgb2YgYXJndW1lbnRzLFxuICogY2FsbGluZyBgY2FsbGJhY2tgIHdpdGggdGhlIGNvbXBsZXRlZCByZXN1bHRzIG9mIGFsbCBjYWxscy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhcnJheSBpbnB1dCB0byBlYWNoIGNhbGwgb2YgdGhlIGFzeW5jIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gYW4gYXN5bmMgZnVuY3Rpb24gd2l0aCBzaWduYXR1cmUgKGRhdGEsIGNhbGxiYWNrKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBjYWxsYmFjayBydW4gYWZ0ZXIgYWxsIGFzeW5jIHdvcmsgaXMgZG9uZS5cbiAqIGNhbGxlZCB3aXRoIGFuIGFycmF5LCBjb250YWluaW5nIHRoZSByZXN1bHRzIG9mIGVhY2ggYXN5bmMgY2FsbC5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmFzeW5jQWxsID0gZnVuY3Rpb24gKGFycmF5LCBmbiwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWFycmF5Lmxlbmd0aCkgeyByZXR1cm4gY2FsbGJhY2sobnVsbCwgW10pOyB9XG4gICAgdmFyIHJlbWFpbmluZyA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShhcnJheS5sZW5ndGgpO1xuICAgIHZhciBlcnJvciA9IG51bGw7XG4gICAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICBmbihpdGVtLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGlmICgtLXJlbWFpbmluZyA9PT0gMCkgY2FsbGJhY2soZXJyb3IsIHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qXG4gKiBDb21wdXRlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGtleXMgaW4gb25lIG9iamVjdCBhbmQgdGhlIGtleXNcbiAqIGluIGFub3RoZXIgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlclxuICogQHJldHVybnMge0FycmF5PHN0cmluZz59IGtleXMgZGlmZmVyZW5jZVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5rZXlzRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChvYmosIG90aGVyKSB7XG4gICAgdmFyIGRpZmZlcmVuY2UgPSBbXTtcbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgICBpZiAoIShpIGluIG90aGVyKSkge1xuICAgICAgICAgICAgZGlmZmVyZW5jZS5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWZmZXJlbmNlO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIGRlc3RpbmF0aW9uIG9iamVjdCBhbmQgb3B0aW9uYWxseSBtYW55IHNvdXJjZSBvYmplY3RzLFxuICogY29weSBhbGwgcHJvcGVydGllcyBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZSBkZXN0aW5hdGlvbi5cbiAqIFRoZSBsYXN0IHNvdXJjZSBvYmplY3QgZ2l2ZW4gb3ZlcnJpZGVzIHByb3BlcnRpZXMgZnJvbSBwcmV2aW91c1xuICogc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBkZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIHNvdXJjZXMgZnJvbSB3aGljaCBwcm9wZXJ0aWVzIGFyZSBwdWxsZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3JjID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBmb3IgKHZhciBrIGluIHNyYykge1xuICAgICAgICAgICAgZGVzdFtrXSA9IHNyY1trXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn07XG5cbi8qKlxuICogRXh0ZW5kIGEgZGVzdGluYXRpb24gb2JqZWN0IHdpdGggYWxsIHByb3BlcnRpZXMgb2YgdGhlIHNyYyBvYmplY3QsXG4gKiB1c2luZyBkZWZpbmVQcm9wZXJ0eSBpbnN0ZWFkIG9mIHNpbXBsZSBhc3NpZ25tZW50LlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZXh0ZW5kQWxsID0gZnVuY3Rpb24gKGRlc3QsIHNyYykge1xuICAgIGZvciAodmFyIGkgaW4gc3JjKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0LCBpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNyYywgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn07XG5cbi8qKlxuICogRXh0ZW5kIGEgcGFyZW50J3MgcHJvdG90eXBlIHdpdGggYWxsIHByb3BlcnRpZXMgaW4gYSBwcm9wZXJ0aWVzXG4gKiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5pbmhlcml0ID0gZnVuY3Rpb24gKHBhcmVudCwgcHJvcHMpIHtcbiAgICB2YXIgcGFyZW50UHJvdG8gPSB0eXBlb2YgcGFyZW50ID09PSAnZnVuY3Rpb24nID8gcGFyZW50LnByb3RvdHlwZSA6IHBhcmVudCxcbiAgICAgICAgcHJvdG8gPSBPYmplY3QuY3JlYXRlKHBhcmVudFByb3RvKTtcbiAgICBleHBvcnRzLmV4dGVuZEFsbChwcm90bywgcHJvcHMpO1xuICAgIHJldHVybiBwcm90bztcbn07XG5cbi8qKlxuICogR2l2ZW4gYW4gb2JqZWN0IGFuZCBhIG51bWJlciBvZiBwcm9wZXJ0aWVzIGFzIHN0cmluZ3MsIHJldHVybiB2ZXJzaW9uXG4gKiBvZiB0aGF0IG9iamVjdCB3aXRoIG9ubHkgdGhvc2UgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3JjIHRoZSBvYmplY3RcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gcHJvcGVydGllcyBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBjaG9zZW5cbiAqIHRvIGFwcGVhciBvbiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCB3aXRoIGxpbWl0ZWQgcHJvcGVydGllcy5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZm9vID0geyBuYW1lOiAnQ2hhcmxpZScsIGFnZTogMTAgfTtcbiAqIHZhciBqdXN0TmFtZSA9IHBpY2soZm9vLCBbJ25hbWUnXSk7XG4gKiAvLyBqdXN0TmFtZSA9IHsgbmFtZTogJ0NoYXJsaWUnIH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMucGljayA9IGZ1bmN0aW9uIChzcmMsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgaWYgKGsgaW4gc3JjKSB7XG4gICAgICAgICAgICByZXN1bHRba10gPSBzcmNba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBpZCA9IDE7XG5cbi8qKlxuICogUmV0dXJuIGEgdW5pcXVlIG51bWVyaWMgaWQsIHN0YXJ0aW5nIGF0IDEgYW5kIGluY3JlbWVudGluZyB3aXRoXG4gKiBlYWNoIGNhbGwuXG4gKlxuICogQHJldHVybnMge251bWJlcn0gdW5pcXVlIG51bWVyaWMgaWQuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLnVuaXF1ZUlkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpZCsrO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSB2ZXJzaW9uIG9mIGBmbmAgdGhhdCBpcyBvbmx5IGNhbGxlZCBgdGltZWAgbWlsbGlzZWNvbmRzXG4gKiBhZnRlciBpdHMgbGFzdCBpbnZvY2F0aW9uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdGhlIGZ1bmN0aW9uIHRvIGJlIGRlYm91bmNlZFxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgbWlsbHNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZGVib3VuY2UgPSBmdW5jdGlvbihmbiwgdGltZSkge1xuICAgIHZhciB0aW1lciwgYXJncztcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSwgdGltZSk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2YgbWVtYmVyIGZ1bmN0aW9uIG5hbWVzIGFzIHN0cmluZ3MsIHJlcGxhY2UgYWxsIG9mIHRoZW1cbiAqIHdpdGggYm91bmQgdmVyc2lvbnMgdGhhdCB3aWxsIGFsd2F5cyByZWZlciB0byBgY29udGV4dGAgYXMgYHRoaXNgLiBUaGlzXG4gKiBpcyB1c2VmdWwgZm9yIGNsYXNzZXMgd2hlcmUgb3RoZXJ3aXNlIGV2ZW50IGJpbmRpbmdzIHdvdWxkIHJlYXNzaWduXG4gKiBgdGhpc2AgdG8gdGhlIGV2ZW50ZWQgb2JqZWN0IG9yIHNvbWUgb3RoZXIgdmFsdWU6IHRoaXMgbGV0cyB5b3UgZW5zdXJlXG4gKiB0aGUgYHRoaXNgIHZhbHVlIGFsd2F5cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGZucyBsaXN0IG9mIG1lbWJlciBmdW5jdGlvbiBuYW1lc1xuICogQHBhcmFtIHsqfSBjb250ZXh0IHRoZSBjb250ZXh0IHZhbHVlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfSBjaGFuZ2VzIGZ1bmN0aW9ucyBpbi1wbGFjZVxuICogQGV4YW1wbGVcbiAqIGZ1bmN0aW9uIE15Q2xhc3MoKSB7XG4gKiAgIGJpbmRBbGwoWydvbnRpbWVyJ10sIHRoaXMpO1xuICogICB0aGlzLm5hbWUgPSAnVG9tJztcbiAqIH1cbiAqIE15Q2xhc3MucHJvdG90eXBlLm9udGltZXIgPSBmdW5jdGlvbigpIHtcbiAqICAgYWxlcnQodGhpcy5uYW1lKTtcbiAqIH07XG4gKiB2YXIgbXlDbGFzcyA9IG5ldyBNeUNsYXNzKCk7XG4gKiBzZXRUaW1lb3V0KG15Q2xhc3Mub250aW1lciwgMTAwKTtcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuYmluZEFsbCA9IGZ1bmN0aW9uKGZucywgY29udGV4dCkge1xuICAgIGZucy5mb3JFYWNoKGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIGNvbnRleHRbZm5dID0gY29udGV4dFtmbl0uYmluZChjb250ZXh0KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBjbGFzcywgYmluZCBhbGwgb2YgdGhlIG1ldGhvZHMgdGhhdCBsb29rIGxpa2UgaGFuZGxlcnM6IHRoYXRcbiAqIGJlZ2luIHdpdGggX29uLCBhbmQgYmluZCB0aGVtIHRvIHRoZSBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBhbiBvYmplY3Qgd2l0aCBtZXRob2RzXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmJpbmRIYW5kbGVycyA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpIGluIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0W2ldID09PSAnZnVuY3Rpb24nICYmIGkuaW5kZXhPZignX29uJykgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRleHRbaV0gPSBjb250ZXh0W2ldLmJpbmQoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgJ29wdGlvbnMnIHByb3BlcnR5IG9uIGBvYmpgIHdpdGggcHJvcGVydGllc1xuICogZnJvbSB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50LiBQcm9wZXJ0aWVzIGluIHRoZSBgb3B0aW9uc2BcbiAqIG9iamVjdCB3aWxsIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBkZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9iamVjdCBvZiBvdmVycmlkZSBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXJpdmVkIG9wdGlvbnMgb2JqZWN0LlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5zZXRPcHRpb25zID0gZnVuY3Rpb24ob2JqLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoJ29wdGlvbnMnKSkge1xuICAgICAgICBvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gT2JqZWN0LmNyZWF0ZShvYmoub3B0aW9ucykgOiB7fTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICAgIG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iai5vcHRpb25zO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIGxpc3Qgb2YgY29vcmRpbmF0ZXMsIGdldCB0aGVpciBjZW50ZXIgYXMgYSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtBcnJheTxDb29yZGluYXRlPn0gY29vcmRzXG4gKiBAcmV0dXJucyB7Q29vcmRpbmF0ZX0gY2VudGVycG9pbnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZ2V0Q29vcmRpbmF0ZXNDZW50ZXIgPSBmdW5jdGlvbihjb29yZHMpIHtcbiAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFggPSAtSW5maW5pdHk7XG4gICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgY29vcmRzW2ldLmNvbHVtbik7XG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBjb29yZHNbaV0ucm93KTtcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIGNvb3Jkc1tpXS5jb2x1bW4pO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgY29vcmRzW2ldLnJvdyk7XG4gICAgfVxuXG4gICAgdmFyIGR4ID0gbWF4WCAtIG1pblg7XG4gICAgdmFyIGR5ID0gbWF4WSAtIG1pblk7XG4gICAgdmFyIGRNYXggPSBNYXRoLm1heChkeCwgZHkpO1xuICAgIHJldHVybiBuZXcgQ29vcmRpbmF0ZSgobWluWCArIG1heFgpIC8gMiwgKG1pblkgKyBtYXhZKSAvIDIsIDApXG4gICAgICAgIC56b29tVG8oTWF0aC5mbG9vcigtTWF0aC5sb2coZE1heCkgLyBNYXRoLkxOMikpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSBzdHJpbmcgZW5kcyB3aXRoIGEgcGFydGljdWxhciBzdWJzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdWZmaXhcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5lbmRzV2l0aCA9IGZ1bmN0aW9uKHN0cmluZywgc3VmZml4KSB7XG4gICAgcmV0dXJuIHN0cmluZy5pbmRleE9mKHN1ZmZpeCwgc3RyaW5nLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpICE9PSAtMTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoIGEgcGFydGljdWxhciBzdWJzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5zdGFydHNXaXRoID0gZnVuY3Rpb24oc3RyaW5nLCBwcmVmaXgpIHtcbiAgICByZXR1cm4gc3RyaW5nLmluZGV4T2YocHJlZml4KSA9PT0gMDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIG9iamVjdCBieSBtYXBwaW5nIGFsbCB0aGUgdmFsdWVzIG9mIGFuIGV4aXN0aW5nIG9iamVjdCB3aGlsZVxuICogcHJlc2VydmluZyB0aGVpciBrZXlzLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMubWFwT2JqZWN0ID0gZnVuY3Rpb24oaW5wdXQsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIG91dHB1dCA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBpbnB1dCkge1xuICAgICAgICBvdXRwdXRba2V5XSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCB8fCB0aGlzLCBpbnB1dFtrZXldLCBrZXksIGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIG9iamVjdCBieSBmaWx0ZXJpbmcgb3V0IHZhbHVlcyBvZiBhbiBleGlzdGluZyBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmZpbHRlck9iamVjdCA9IGZ1bmN0aW9uKGlucHV0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciBvdXRwdXQgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCB8fCB0aGlzLCBpbnB1dFtrZXldLCBrZXksIGlucHV0KSkge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBpbnB1dFtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIERlZXBseSBjb21wYXJlcyB0d28gb2JqZWN0IGxpdGVyYWxzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iajFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYikgfHwgYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoISh0eXBlb2YgYiA9PT0gJ29iamVjdCcpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhKSB7XG4gICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGEgPT09IGI7XG59O1xuXG4vKipcbiAqIERlZXBseSBjbG9uZXMgdHdvIG9iamVjdHMuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMVxuICogQHBhcmFtIHtPYmplY3R9IG9iajJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5jbG9uZSA9IGZ1bmN0aW9uIGRlZXBFcXVhbChpbnB1dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gaW5wdXQubWFwKGV4cG9ydHMuY2xvbmUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5tYXBPYmplY3QoaW5wdXQsIGV4cG9ydHMuY2xvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHR3byBhcnJheXMgaGF2ZSBhdCBsZWFzdCBvbmUgY29tbW9uIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0FycmF5fSBhXG4gKiBAcGFyYW0ge0FycmF5fSBiXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuYXJyYXlzSW50ZXJzZWN0ID0gZnVuY3Rpb24oYSwgYikge1xuICAgIGZvciAodmFyIGwgPSAwOyBsIDwgYS5sZW5ndGg7IGwrKykge1xuICAgICAgICBpZiAoYi5pbmRleE9mKGFbbF0pID49IDApIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmVjdG9yVGlsZUZlYXR1cmUgPSByZXF1aXJlKCd2ZWN0b3ItdGlsZScpLlZlY3RvclRpbGVGZWF0dXJlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZlYXR1cmU7XG5cbmZ1bmN0aW9uIEZlYXR1cmUodmVjdG9yVGlsZUZlYXR1cmUsIHosIHgsIHkpIHtcbiAgICB0aGlzLl92ZWN0b3JUaWxlRmVhdHVyZSA9IHZlY3RvclRpbGVGZWF0dXJlO1xuICAgIHZlY3RvclRpbGVGZWF0dXJlLl96ID0gejtcbiAgICB2ZWN0b3JUaWxlRmVhdHVyZS5feCA9IHg7XG4gICAgdmVjdG9yVGlsZUZlYXR1cmUuX3kgPSB5O1xuXG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gdmVjdG9yVGlsZUZlYXR1cmUucHJvcGVydGllcztcblxuICAgIGlmICh2ZWN0b3JUaWxlRmVhdHVyZS5faWQpIHtcbiAgICAgICAgdGhpcy5pZCA9IHZlY3RvclRpbGVGZWF0dXJlLl9pZDtcbiAgICB9XG59XG5cbkZlYXR1cmUucHJvdG90eXBlID0ge1xuICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuXG4gICAgZ2V0IGdlb21ldHJ5KCkge1xuICAgICAgICBpZiAodGhpcy5fZ2VvbWV0cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSB0aGlzLl92ZWN0b3JUaWxlRmVhdHVyZTtcbiAgICAgICAgICAgIHZhciBjb29yZHMgPSBwcm9qZWN0Q29vcmRzKFxuICAgICAgICAgICAgICAgIGZlYXR1cmUubG9hZEdlb21ldHJ5KCksXG4gICAgICAgICAgICAgICAgZmVhdHVyZS5leHRlbnQsXG4gICAgICAgICAgICAgICAgZmVhdHVyZS5feiwgZmVhdHVyZS5feCwgZmVhdHVyZS5feSk7XG5cbiAgICAgICAgICAgIHZhciB0eXBlID0gVmVjdG9yVGlsZUZlYXR1cmUudHlwZXNbZmVhdHVyZS50eXBlXTtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdQb2ludCcgJiYgY29vcmRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNvb3JkcyA9IGNvb3Jkc1swXVswXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1BvaW50Jykge1xuICAgICAgICAgICAgICAgIGNvb3JkcyA9IGNvb3Jkc1swXTtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ011bHRpUG9pbnQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnTGluZVN0cmluZycgJiYgY29vcmRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNvb3JkcyA9IGNvb3Jkc1swXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdNdWx0aUxpbmVTdHJpbmcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9nZW9tZXRyeSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZHNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX3ZlY3RvclRpbGVGZWF0dXJlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2VvbWV0cnk7XG4gICAgfSxcblxuICAgIHNldCBnZW9tZXRyeShnKSB7XG4gICAgICAgIHRoaXMuX2dlb21ldHJ5ID0gZztcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGpzb24gPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gJ19nZW9tZXRyeScgfHwgaSA9PT0gJ192ZWN0b3JUaWxlRmVhdHVyZScpIGNvbnRpbnVlO1xuICAgICAgICAgICAganNvbltpXSA9IHRoaXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxufTtcblxuZnVuY3Rpb24gcHJvamVjdENvb3Jkcyhjb29yZHMsIGV4dGVudCwgeiwgeCwgeSkge1xuICAgIHZhciBzaXplID0gZXh0ZW50ICogTWF0aC5wb3coMiwgeiksXG4gICAgICAgIHgwID0gZXh0ZW50ICogeCxcbiAgICAgICAgeTAgPSBleHRlbnQgKiB5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lID0gY29vcmRzW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBwID0gbGluZVtqXTtcbiAgICAgICAgICAgIHZhciB5MiA9IDE4MCAtIChwLnkgKyB5MCkgKiAzNjAgLyBzaXplO1xuICAgICAgICAgICAgbGluZVtqXSA9IFtcbiAgICAgICAgICAgICAgICAocC54ICsgeDApICogMzYwIC8gc2l6ZSAtIDE4MCxcbiAgICAgICAgICAgICAgICAzNjAgLyBNYXRoLlBJICogTWF0aC5hdGFuKE1hdGguZXhwKHkyICogTWF0aC5QSSAvIDE4MCkpIC0gOTBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvb3Jkcztcbn1cbiIsIi8vIChjKSBEZWFuIE1jTmFtZWUgPGRlYW5AZ21haWwuY29tPiwgMjAxMi5cbi8vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGVhbm0vY3NzLWNvbG9yLXBhcnNlci1qc1xuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4vLyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvXG52YXIga0NTU0NvbG9yVGFibGUgPSB7XG4gIFwidHJhbnNwYXJlbnRcIjogWzAsMCwwLDBdLCBcImFsaWNlYmx1ZVwiOiBbMjQwLDI0OCwyNTUsMV0sXG4gIFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsMjM1LDIxNSwxXSwgXCJhcXVhXCI6IFswLDI1NSwyNTUsMV0sXG4gIFwiYXF1YW1hcmluZVwiOiBbMTI3LDI1NSwyMTIsMV0sIFwiYXp1cmVcIjogWzI0MCwyNTUsMjU1LDFdLFxuICBcImJlaWdlXCI6IFsyNDUsMjQ1LDIyMCwxXSwgXCJiaXNxdWVcIjogWzI1NSwyMjgsMTk2LDFdLFxuICBcImJsYWNrXCI6IFswLDAsMCwxXSwgXCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LDIzNSwyMDUsMV0sXG4gIFwiYmx1ZVwiOiBbMCwwLDI1NSwxXSwgXCJibHVldmlvbGV0XCI6IFsxMzgsNDMsMjI2LDFdLFxuICBcImJyb3duXCI6IFsxNjUsNDIsNDIsMV0sIFwiYnVybHl3b29kXCI6IFsyMjIsMTg0LDEzNSwxXSxcbiAgXCJjYWRldGJsdWVcIjogWzk1LDE1OCwxNjAsMV0sIFwiY2hhcnRyZXVzZVwiOiBbMTI3LDI1NSwwLDFdLFxuICBcImNob2NvbGF0ZVwiOiBbMjEwLDEwNSwzMCwxXSwgXCJjb3JhbFwiOiBbMjU1LDEyNyw4MCwxXSxcbiAgXCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLDE0OSwyMzcsMV0sIFwiY29ybnNpbGtcIjogWzI1NSwyNDgsMjIwLDFdLFxuICBcImNyaW1zb25cIjogWzIyMCwyMCw2MCwxXSwgXCJjeWFuXCI6IFswLDI1NSwyNTUsMV0sXG4gIFwiZGFya2JsdWVcIjogWzAsMCwxMzksMV0sIFwiZGFya2N5YW5cIjogWzAsMTM5LDEzOSwxXSxcbiAgXCJkYXJrZ29sZGVucm9kXCI6IFsxODQsMTM0LDExLDFdLCBcImRhcmtncmF5XCI6IFsxNjksMTY5LDE2OSwxXSxcbiAgXCJkYXJrZ3JlZW5cIjogWzAsMTAwLDAsMV0sIFwiZGFya2dyZXlcIjogWzE2OSwxNjksMTY5LDFdLFxuICBcImRhcmtraGFraVwiOiBbMTg5LDE4MywxMDcsMV0sIFwiZGFya21hZ2VudGFcIjogWzEzOSwwLDEzOSwxXSxcbiAgXCJkYXJrb2xpdmVncmVlblwiOiBbODUsMTA3LDQ3LDFdLCBcImRhcmtvcmFuZ2VcIjogWzI1NSwxNDAsMCwxXSxcbiAgXCJkYXJrb3JjaGlkXCI6IFsxNTMsNTAsMjA0LDFdLCBcImRhcmtyZWRcIjogWzEzOSwwLDAsMV0sXG4gIFwiZGFya3NhbG1vblwiOiBbMjMzLDE1MCwxMjIsMV0sIFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsMTg4LDE0MywxXSxcbiAgXCJkYXJrc2xhdGVibHVlXCI6IFs3Miw2MSwxMzksMV0sIFwiZGFya3NsYXRlZ3JheVwiOiBbNDcsNzksNzksMV0sXG4gIFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsNzksNzksMV0sIFwiZGFya3R1cnF1b2lzZVwiOiBbMCwyMDYsMjA5LDFdLFxuICBcImRhcmt2aW9sZXRcIjogWzE0OCwwLDIxMSwxXSwgXCJkZWVwcGlua1wiOiBbMjU1LDIwLDE0NywxXSxcbiAgXCJkZWVwc2t5Ymx1ZVwiOiBbMCwxOTEsMjU1LDFdLCBcImRpbWdyYXlcIjogWzEwNSwxMDUsMTA1LDFdLFxuICBcImRpbWdyZXlcIjogWzEwNSwxMDUsMTA1LDFdLCBcImRvZGdlcmJsdWVcIjogWzMwLDE0NCwyNTUsMV0sXG4gIFwiZmlyZWJyaWNrXCI6IFsxNzgsMzQsMzQsMV0sIFwiZmxvcmFsd2hpdGVcIjogWzI1NSwyNTAsMjQwLDFdLFxuICBcImZvcmVzdGdyZWVuXCI6IFszNCwxMzksMzQsMV0sIFwiZnVjaHNpYVwiOiBbMjU1LDAsMjU1LDFdLFxuICBcImdhaW5zYm9yb1wiOiBbMjIwLDIyMCwyMjAsMV0sIFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LDI0OCwyNTUsMV0sXG4gIFwiZ29sZFwiOiBbMjU1LDIxNSwwLDFdLCBcImdvbGRlbnJvZFwiOiBbMjE4LDE2NSwzMiwxXSxcbiAgXCJncmF5XCI6IFsxMjgsMTI4LDEyOCwxXSwgXCJncmVlblwiOiBbMCwxMjgsMCwxXSxcbiAgXCJncmVlbnllbGxvd1wiOiBbMTczLDI1NSw0NywxXSwgXCJncmV5XCI6IFsxMjgsMTI4LDEyOCwxXSxcbiAgXCJob25leWRld1wiOiBbMjQwLDI1NSwyNDAsMV0sIFwiaG90cGlua1wiOiBbMjU1LDEwNSwxODAsMV0sXG4gIFwiaW5kaWFucmVkXCI6IFsyMDUsOTIsOTIsMV0sIFwiaW5kaWdvXCI6IFs3NSwwLDEzMCwxXSxcbiAgXCJpdm9yeVwiOiBbMjU1LDI1NSwyNDAsMV0sIFwia2hha2lcIjogWzI0MCwyMzAsMTQwLDFdLFxuICBcImxhdmVuZGVyXCI6IFsyMzAsMjMwLDI1MCwxXSwgXCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsMjQwLDI0NSwxXSxcbiAgXCJsYXduZ3JlZW5cIjogWzEyNCwyNTIsMCwxXSwgXCJsZW1vbmNoaWZmb25cIjogWzI1NSwyNTAsMjA1LDFdLFxuICBcImxpZ2h0Ymx1ZVwiOiBbMTczLDIxNiwyMzAsMV0sIFwibGlnaHRjb3JhbFwiOiBbMjQwLDEyOCwxMjgsMV0sXG4gIFwibGlnaHRjeWFuXCI6IFsyMjQsMjU1LDI1NSwxXSwgXCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLDI1MCwyMTAsMV0sXG4gIFwibGlnaHRncmF5XCI6IFsyMTEsMjExLDIxMSwxXSwgXCJsaWdodGdyZWVuXCI6IFsxNDQsMjM4LDE0NCwxXSxcbiAgXCJsaWdodGdyZXlcIjogWzIxMSwyMTEsMjExLDFdLCBcImxpZ2h0cGlua1wiOiBbMjU1LDE4MiwxOTMsMV0sXG4gIFwibGlnaHRzYWxtb25cIjogWzI1NSwxNjAsMTIyLDFdLCBcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLDE3OCwxNzAsMV0sXG4gIFwibGlnaHRza3libHVlXCI6IFsxMzUsMjA2LDI1MCwxXSwgXCJsaWdodHNsYXRlZ3JheVwiOiBbMTE5LDEzNiwxNTMsMV0sXG4gIFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwxMzYsMTUzLDFdLCBcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsMTk2LDIyMiwxXSxcbiAgXCJsaWdodHllbGxvd1wiOiBbMjU1LDI1NSwyMjQsMV0sIFwibGltZVwiOiBbMCwyNTUsMCwxXSxcbiAgXCJsaW1lZ3JlZW5cIjogWzUwLDIwNSw1MCwxXSwgXCJsaW5lblwiOiBbMjUwLDI0MCwyMzAsMV0sXG4gIFwibWFnZW50YVwiOiBbMjU1LDAsMjU1LDFdLCBcIm1hcm9vblwiOiBbMTI4LDAsMCwxXSxcbiAgXCJtZWRpdW1hcXVhbWFyaW5lXCI6IFsxMDIsMjA1LDE3MCwxXSwgXCJtZWRpdW1ibHVlXCI6IFswLDAsMjA1LDFdLFxuICBcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LDg1LDIxMSwxXSwgXCJtZWRpdW1wdXJwbGVcIjogWzE0NywxMTIsMjE5LDFdLFxuICBcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwxNzksMTEzLDFdLCBcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLDEwNCwyMzgsMV0sXG4gIFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogWzAsMjUwLDE1NCwxXSwgXCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLDIwOSwyMDQsMV0sXG4gIFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksMjEsMTMzLDFdLCBcIm1pZG5pZ2h0Ymx1ZVwiOiBbMjUsMjUsMTEyLDFdLFxuICBcIm1pbnRjcmVhbVwiOiBbMjQ1LDI1NSwyNTAsMV0sIFwibWlzdHlyb3NlXCI6IFsyNTUsMjI4LDIyNSwxXSxcbiAgXCJtb2NjYXNpblwiOiBbMjU1LDIyOCwxODEsMV0sIFwibmF2YWpvd2hpdGVcIjogWzI1NSwyMjIsMTczLDFdLFxuICBcIm5hdnlcIjogWzAsMCwxMjgsMV0sIFwib2xkbGFjZVwiOiBbMjUzLDI0NSwyMzAsMV0sXG4gIFwib2xpdmVcIjogWzEyOCwxMjgsMCwxXSwgXCJvbGl2ZWRyYWJcIjogWzEwNywxNDIsMzUsMV0sXG4gIFwib3JhbmdlXCI6IFsyNTUsMTY1LDAsMV0sIFwib3JhbmdlcmVkXCI6IFsyNTUsNjksMCwxXSxcbiAgXCJvcmNoaWRcIjogWzIxOCwxMTIsMjE0LDFdLCBcInBhbGVnb2xkZW5yb2RcIjogWzIzOCwyMzIsMTcwLDFdLFxuICBcInBhbGVncmVlblwiOiBbMTUyLDI1MSwxNTIsMV0sIFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LDIzOCwyMzgsMV0sXG4gIFwicGFsZXZpb2xldHJlZFwiOiBbMjE5LDExMiwxNDcsMV0sIFwicGFwYXlhd2hpcFwiOiBbMjU1LDIzOSwyMTMsMV0sXG4gIFwicGVhY2hwdWZmXCI6IFsyNTUsMjE4LDE4NSwxXSwgXCJwZXJ1XCI6IFsyMDUsMTMzLDYzLDFdLFxuICBcInBpbmtcIjogWzI1NSwxOTIsMjAzLDFdLCBcInBsdW1cIjogWzIyMSwxNjAsMjIxLDFdLFxuICBcInBvd2RlcmJsdWVcIjogWzE3NiwyMjQsMjMwLDFdLCBcInB1cnBsZVwiOiBbMTI4LDAsMTI4LDFdLFxuICBcInJlZFwiOiBbMjU1LDAsMCwxXSwgXCJyb3N5YnJvd25cIjogWzE4OCwxNDMsMTQzLDFdLFxuICBcInJveWFsYmx1ZVwiOiBbNjUsMTA1LDIyNSwxXSwgXCJzYWRkbGVicm93blwiOiBbMTM5LDY5LDE5LDFdLFxuICBcInNhbG1vblwiOiBbMjUwLDEyOCwxMTQsMV0sIFwic2FuZHlicm93blwiOiBbMjQ0LDE2NCw5NiwxXSxcbiAgXCJzZWFncmVlblwiOiBbNDYsMTM5LDg3LDFdLCBcInNlYXNoZWxsXCI6IFsyNTUsMjQ1LDIzOCwxXSxcbiAgXCJzaWVubmFcIjogWzE2MCw4Miw0NSwxXSwgXCJzaWx2ZXJcIjogWzE5MiwxOTIsMTkyLDFdLFxuICBcInNreWJsdWVcIjogWzEzNSwyMDYsMjM1LDFdLCBcInNsYXRlYmx1ZVwiOiBbMTA2LDkwLDIwNSwxXSxcbiAgXCJzbGF0ZWdyYXlcIjogWzExMiwxMjgsMTQ0LDFdLCBcInNsYXRlZ3JleVwiOiBbMTEyLDEyOCwxNDQsMV0sXG4gIFwic25vd1wiOiBbMjU1LDI1MCwyNTAsMV0sIFwic3ByaW5nZ3JlZW5cIjogWzAsMjU1LDEyNywxXSxcbiAgXCJzdGVlbGJsdWVcIjogWzcwLDEzMCwxODAsMV0sIFwidGFuXCI6IFsyMTAsMTgwLDE0MCwxXSxcbiAgXCJ0ZWFsXCI6IFswLDEyOCwxMjgsMV0sIFwidGhpc3RsZVwiOiBbMjE2LDE5MSwyMTYsMV0sXG4gIFwidG9tYXRvXCI6IFsyNTUsOTksNzEsMV0sIFwidHVycXVvaXNlXCI6IFs2NCwyMjQsMjA4LDFdLFxuICBcInZpb2xldFwiOiBbMjM4LDEzMCwyMzgsMV0sIFwid2hlYXRcIjogWzI0NSwyMjIsMTc5LDFdLFxuICBcIndoaXRlXCI6IFsyNTUsMjU1LDI1NSwxXSwgXCJ3aGl0ZXNtb2tlXCI6IFsyNDUsMjQ1LDI0NSwxXSxcbiAgXCJ5ZWxsb3dcIjogWzI1NSwyNTUsMCwxXSwgXCJ5ZWxsb3dncmVlblwiOiBbMTU0LDIwNSw1MCwxXX1cblxuZnVuY3Rpb24gY2xhbXBfY3NzX2J5dGUoaSkgeyAgLy8gQ2xhbXAgdG8gaW50ZWdlciAwIC4uIDI1NS5cbiAgaSA9IE1hdGgucm91bmQoaSk7ICAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cbiAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAyNTUgPyAyNTUgOiBpO1xufVxuXG5mdW5jdGlvbiBjbGFtcF9jc3NfZmxvYXQoZikgeyAgLy8gQ2xhbXAgdG8gZmxvYXQgMC4wIC4uIDEuMC5cbiAgcmV0dXJuIGYgPCAwID8gMCA6IGYgPiAxID8gMSA6IGY7XG59XG5cbmZ1bmN0aW9uIHBhcnNlX2Nzc19pbnQoc3RyKSB7ICAvLyBpbnQgb3IgcGVyY2VudGFnZS5cbiAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICclJylcbiAgICByZXR1cm4gY2xhbXBfY3NzX2J5dGUocGFyc2VGbG9hdChzdHIpIC8gMTAwICogMjU1KTtcbiAgcmV0dXJuIGNsYW1wX2Nzc19ieXRlKHBhcnNlSW50KHN0cikpO1xufVxuXG5mdW5jdGlvbiBwYXJzZV9jc3NfZmxvYXQoc3RyKSB7ICAvLyBmbG9hdCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJyUnKVxuICAgIHJldHVybiBjbGFtcF9jc3NfZmxvYXQocGFyc2VGbG9hdChzdHIpIC8gMTAwKTtcbiAgcmV0dXJuIGNsYW1wX2Nzc19mbG9hdChwYXJzZUZsb2F0KHN0cikpO1xufVxuXG5mdW5jdGlvbiBjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgpIHtcbiAgaWYgKGggPCAwKSBoICs9IDE7XG4gIGVsc2UgaWYgKGggPiAxKSBoIC09IDE7XG5cbiAgaWYgKGggKiA2IDwgMSkgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7XG4gIGlmIChoICogMiA8IDEpIHJldHVybiBtMjtcbiAgaWYgKGggKiAzIDwgMikgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIvMyAtIGgpICogNjtcbiAgcmV0dXJuIG0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNTU0NvbG9yKGNzc19zdHIpIHtcbiAgLy8gUmVtb3ZlIGFsbCB3aGl0ZXNwYWNlLCBub3QgY29tcGxpYW50LCBidXQgc2hvdWxkIGp1c3QgYmUgbW9yZSBhY2NlcHRpbmcuXG4gIHZhciBzdHIgPSBjc3Nfc3RyLnJlcGxhY2UoLyAvZywgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gQ29sb3Iga2V5d29yZHMgKGFuZCB0cmFuc3BhcmVudCkgbG9va3VwLlxuICBpZiAoc3RyIGluIGtDU1NDb2xvclRhYmxlKSByZXR1cm4ga0NTU0NvbG9yVGFibGVbc3RyXS5zbGljZSgpOyAgLy8gZHVwLlxuXG4gIC8vICNhYmMgYW5kICNhYmMxMjMgc3ludGF4LlxuICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmKSkgcmV0dXJuIG51bGw7ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgcmV0dXJuIFsoKGl2ICYgMHhmMDApID4+IDQpIHwgKChpdiAmIDB4ZjAwKSA+PiA4KSxcbiAgICAgICAgICAgICAgKGl2ICYgMHhmMCkgfCAoKGl2ICYgMHhmMCkgPj4gNCksXG4gICAgICAgICAgICAgIChpdiAmIDB4ZikgfCAoKGl2ICYgMHhmKSA8PCA0KSxcbiAgICAgICAgICAgICAgMV07XG4gICAgfSBlbHNlIGlmIChzdHIubGVuZ3RoID09PSA3KSB7XG4gICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmZmZmYpKSByZXR1cm4gbnVsbDsgIC8vIENvdmVycyBOYU4uXG4gICAgICByZXR1cm4gWyhpdiAmIDB4ZmYwMDAwKSA+PiAxNixcbiAgICAgICAgICAgICAgKGl2ICYgMHhmZjAwKSA+PiA4LFxuICAgICAgICAgICAgICBpdiAmIDB4ZmYsXG4gICAgICAgICAgICAgIDFdO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG9wID0gc3RyLmluZGV4T2YoJygnKSwgZXAgPSBzdHIuaW5kZXhPZignKScpO1xuICBpZiAob3AgIT09IC0xICYmIGVwICsgMSA9PT0gc3RyLmxlbmd0aCkge1xuICAgIHZhciBmbmFtZSA9IHN0ci5zdWJzdHIoMCwgb3ApO1xuICAgIHZhciBwYXJhbXMgPSBzdHIuc3Vic3RyKG9wKzEsIGVwLShvcCsxKSkuc3BsaXQoJywnKTtcbiAgICB2YXIgYWxwaGEgPSAxOyAgLy8gVG8gYWxsb3cgY2FzZSBmYWxsdGhyb3VnaC5cbiAgICBzd2l0Y2ggKGZuYW1lKSB7XG4gICAgICBjYXNlICdyZ2JhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHJldHVybiBudWxsO1xuICAgICAgICBhbHBoYSA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICdyZ2InOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBbcGFyc2VfY3NzX2ludChwYXJhbXNbMF0pLFxuICAgICAgICAgICAgICAgIHBhcnNlX2Nzc19pbnQocGFyYW1zWzFdKSxcbiAgICAgICAgICAgICAgICBwYXJzZV9jc3NfaW50KHBhcmFtc1syXSksXG4gICAgICAgICAgICAgICAgYWxwaGFdO1xuICAgICAgY2FzZSAnaHNsYSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgYWxwaGEgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zLnBvcCgpKTtcbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuICAgICAgY2FzZSAnaHNsJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgaCA9ICgoKHBhcnNlRmxvYXQocGFyYW1zWzBdKSAlIDM2MCkgKyAzNjApICUgMzYwKSAvIDM2MDsgIC8vIDAgLi4gMVxuICAgICAgICAvLyBOT1RFKGRlYW5tKTogQWNjb3JkaW5nIHRvIHRoZSBDU1Mgc3BlYyBzL2wgc2hvdWxkIG9ubHkgYmVcbiAgICAgICAgLy8gcGVyY2VudGFnZXMsIGJ1dCB3ZSBkb24ndCBib3RoZXIgYW5kIGxldCBmbG9hdCBvciBwZXJjZW50YWdlLlxuICAgICAgICB2YXIgcyA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMV0pO1xuICAgICAgICB2YXIgbCA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMl0pO1xuICAgICAgICB2YXIgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIG0xID0gbCAqIDIgLSBtMjtcbiAgICAgICAgcmV0dXJuIFtjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgrMS8zKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoLTEvMykgKiAyNTUpLFxuICAgICAgICAgICAgICAgIGFscGhhXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG50cnkgeyBleHBvcnRzLnBhcnNlQ1NTQ29sb3IgPSBwYXJzZUNTU0NvbG9yIH0gY2F0Y2goZSkgeyB9XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRmlsdGVyO1xuXG52YXIgdHlwZXMgPSBbJ1Vua25vd24nLCAnUG9pbnQnLCAnTGluZVN0cmluZycsICdQb2x5Z29uJ107XG5cbi8qKlxuICogR2l2ZW4gYSBmaWx0ZXIgZXhwcmVzc2VkIGFzIG5lc3RlZCBhcnJheXMsIHJldHVybiBhIG5ldyBmdW5jdGlvblxuICogdGhhdCBldmFsdWF0ZXMgd2hldGhlciBhIGdpdmVuIGZlYXR1cmUgKHdpdGggYSAucHJvcGVydGllcyBvciAudGFncyBwcm9wZXJ0eSlcbiAqIHBhc3NlcyBpdHMgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXIgbWFwYm94IGdsIGZpbHRlclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBmaWx0ZXItZXZhbHVhdGluZyBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBjcmVhdGVGaWx0ZXIoZmlsdGVyKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbignZicsICd2YXIgcCA9IChmICYmIGYucHJvcGVydGllcyB8fCB7fSk7IHJldHVybiAnICsgY29tcGlsZShmaWx0ZXIpKTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZShmaWx0ZXIpIHtcbiAgICBpZiAoIWZpbHRlcikgcmV0dXJuICd0cnVlJztcbiAgICB2YXIgb3AgPSBmaWx0ZXJbMF07XG4gICAgaWYgKGZpbHRlci5sZW5ndGggPD0gMSkgcmV0dXJuIG9wID09PSAnYW55JyA/ICdmYWxzZScgOiAndHJ1ZSc7XG4gICAgdmFyIHN0ciA9XG4gICAgICAgIG9wID09PSAnPT0nID8gY29tcGlsZUNvbXBhcmlzb25PcChmaWx0ZXJbMV0sIGZpbHRlclsyXSwgJz09PScsIGZhbHNlKSA6XG4gICAgICAgIG9wID09PSAnIT0nID8gY29tcGlsZUNvbXBhcmlzb25PcChmaWx0ZXJbMV0sIGZpbHRlclsyXSwgJyE9PScsIGZhbHNlKSA6XG4gICAgICAgIG9wID09PSAnPCcgfHxcbiAgICAgICAgb3AgPT09ICc+JyB8fFxuICAgICAgICBvcCA9PT0gJzw9JyB8fFxuICAgICAgICBvcCA9PT0gJz49JyA/IGNvbXBpbGVDb21wYXJpc29uT3AoZmlsdGVyWzFdLCBmaWx0ZXJbMl0sIG9wLCB0cnVlKSA6XG4gICAgICAgIG9wID09PSAnYW55JyA/IGNvbXBpbGVMb2dpY2FsT3AoZmlsdGVyLnNsaWNlKDEpLCAnfHwnKSA6XG4gICAgICAgIG9wID09PSAnYWxsJyA/IGNvbXBpbGVMb2dpY2FsT3AoZmlsdGVyLnNsaWNlKDEpLCAnJiYnKSA6XG4gICAgICAgIG9wID09PSAnbm9uZScgPyBjb21waWxlTmVnYXRpb24oY29tcGlsZUxvZ2ljYWxPcChmaWx0ZXIuc2xpY2UoMSksICd8fCcpKSA6XG4gICAgICAgIG9wID09PSAnaW4nID8gY29tcGlsZUluT3AoZmlsdGVyWzFdLCBmaWx0ZXIuc2xpY2UoMikpIDpcbiAgICAgICAgb3AgPT09ICchaW4nID8gY29tcGlsZU5lZ2F0aW9uKGNvbXBpbGVJbk9wKGZpbHRlclsxXSwgZmlsdGVyLnNsaWNlKDIpKSkgOlxuICAgICAgICBvcCA9PT0gJ2hhcycgPyBjb21waWxlSGFzT3AoZmlsdGVyWzFdKSA6XG4gICAgICAgIG9wID09PSAnIWhhcycgPyBjb21waWxlTmVnYXRpb24oY29tcGlsZUhhc09wKFtmaWx0ZXJbMV1dKSkgOlxuICAgICAgICAndHJ1ZSc7XG4gICAgcmV0dXJuICcoJyArIHN0ciArICcpJztcbn1cblxuZnVuY3Rpb24gY29tcGlsZVByb3BlcnR5UmVmZXJlbmNlKHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIHByb3BlcnR5ID09PSAnJHR5cGUnID8gJ2YudHlwZScgOiAncFsnICsgSlNPTi5zdHJpbmdpZnkocHJvcGVydHkpICsgJ10nO1xufVxuXG5mdW5jdGlvbiBjb21waWxlQ29tcGFyaXNvbk9wKHByb3BlcnR5LCB2YWx1ZSwgb3AsIGNoZWNrVHlwZSkge1xuICAgIHZhciBsZWZ0ID0gY29tcGlsZVByb3BlcnR5UmVmZXJlbmNlKHByb3BlcnR5KTtcbiAgICB2YXIgcmlnaHQgPSBwcm9wZXJ0eSA9PT0gJyR0eXBlJyA/IHR5cGVzLmluZGV4T2YodmFsdWUpIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIHJldHVybiAoY2hlY2tUeXBlID8gJ3R5cGVvZiAnICsgbGVmdCArICc9PT0gdHlwZW9mICcgKyByaWdodCArICcmJicgOiAnJykgKyBsZWZ0ICsgb3AgKyByaWdodDtcbn1cblxuZnVuY3Rpb24gY29tcGlsZUxvZ2ljYWxPcChleHByZXNzaW9ucywgb3ApIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvbnMubWFwKGNvbXBpbGUpLmpvaW4ob3ApO1xufVxuXG5mdW5jdGlvbiBjb21waWxlSW5PcChwcm9wZXJ0eSwgdmFsdWVzKSB7XG4gICAgaWYgKHByb3BlcnR5ID09PSAnJHR5cGUnKSB2YWx1ZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB0eXBlcy5pbmRleE9mKHZhbHVlKTsgfSk7XG4gICAgdmFyIGxlZnQgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZXMuc29ydChjb21wYXJlKSk7XG4gICAgdmFyIHJpZ2h0ID0gY29tcGlsZVByb3BlcnR5UmVmZXJlbmNlKHByb3BlcnR5KTtcblxuICAgIGlmICh2YWx1ZXMubGVuZ3RoIDw9IDIwMCkgcmV0dXJuIGxlZnQgKyAnLmluZGV4T2YoJyArIHJpZ2h0ICsgJykgIT09IC0xJztcblxuICAgIHJldHVybiAnZnVuY3Rpb24odiwgYSwgaSwgaikgeycgK1xuICAgICAgICAnd2hpbGUgKGkgPD0gaikgeyB2YXIgbSA9IChpICsgaikgPj4gMTsnICtcbiAgICAgICAgJyAgICBpZiAoYVttXSA9PT0gdikgcmV0dXJuIHRydWU7IGlmIChhW21dID4gdikgaiA9IG0gLSAxOyBlbHNlIGkgPSBtICsgMTsnICtcbiAgICAgICAgJ30nICtcbiAgICAncmV0dXJuIGZhbHNlOyB9KCcgKyByaWdodCArICcsICcgKyBsZWZ0ICsgJywwLCcgKyAodmFsdWVzLmxlbmd0aCAtIDEpICsgJyknO1xufVxuXG5mdW5jdGlvbiBjb21waWxlSGFzT3AocHJvcGVydHkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocHJvcGVydHkpICsgJyBpbiBwJztcbn1cblxuZnVuY3Rpb24gY29tcGlsZU5lZ2F0aW9uKGV4cHJlc3Npb24pIHtcbiAgICByZXR1cm4gJyEoJyArIGV4cHJlc3Npb24gKyAnKSc7XG59XG5cbi8vIENvbXBhcmlzb24gZnVuY3Rpb24gdG8gc29ydCBudW1iZXJzIGFuZCBzdHJpbmdzXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG59XG4iLCJ2YXIgZ2VvanNvbkFyZWEgPSByZXF1aXJlKCdnZW9qc29uLWFyZWEnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXdpbmQ7XG5cbmZ1bmN0aW9uIHJld2luZChnaiwgb3V0ZXIpIHtcbiAgICBzd2l0Y2ggKChnaiAmJiBnai50eXBlKSB8fCBudWxsKSB7XG4gICAgICAgIGNhc2UgJ0ZlYXR1cmVDb2xsZWN0aW9uJzpcbiAgICAgICAgICAgIGdqLmZlYXR1cmVzID0gZ2ouZmVhdHVyZXMubWFwKGN1cnJ5T3V0ZXIocmV3aW5kLCBvdXRlcikpO1xuICAgICAgICAgICAgcmV0dXJuIGdqO1xuICAgICAgICBjYXNlICdGZWF0dXJlJzpcbiAgICAgICAgICAgIGdqLmdlb21ldHJ5ID0gcmV3aW5kKGdqLmdlb21ldHJ5LCBvdXRlcik7XG4gICAgICAgICAgICByZXR1cm4gZ2o7XG4gICAgICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICAgICAgcmV0dXJuIGNvcnJlY3QoZ2osIG91dGVyKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBnajtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGN1cnJ5T3V0ZXIoYSwgYikge1xuICAgIHJldHVybiBmdW5jdGlvbihfKSB7IHJldHVybiBhKF8sIGIpOyB9O1xufVxuXG5mdW5jdGlvbiBjb3JyZWN0KF8sIG91dGVyKSB7XG4gICAgaWYgKF8udHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIF8uY29vcmRpbmF0ZXMgPSBjb3JyZWN0UmluZ3MoXy5jb29yZGluYXRlcywgb3V0ZXIpO1xuICAgIH0gZWxzZSBpZiAoXy50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICBfLmNvb3JkaW5hdGVzID0gXy5jb29yZGluYXRlcy5tYXAoY3VycnlPdXRlcihjb3JyZWN0UmluZ3MsIG91dGVyKSk7XG4gICAgfVxuICAgIHJldHVybiBfO1xufVxuXG5mdW5jdGlvbiBjb3JyZWN0UmluZ3MoXywgb3V0ZXIpIHtcbiAgICBvdXRlciA9ICEhb3V0ZXI7XG4gICAgX1swXSA9IHdpbmQoX1swXSwgIW91dGVyKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IF8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX1tpXSA9IHdpbmQoX1tpXSwgb3V0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gXztcbn1cblxuZnVuY3Rpb24gd2luZChfLCBkaXIpIHtcbiAgICByZXR1cm4gY3coXykgPT09IGRpciA/IF8gOiBfLnJldmVyc2UoKTtcbn1cblxuZnVuY3Rpb24gY3coXykge1xuICAgIHJldHVybiBnZW9qc29uQXJlYS5yaW5nKF8pID49IDA7XG59XG4iLCJ2YXIgd2dzODQgPSByZXF1aXJlKCd3Z3M4NCcpO1xuXG5tb2R1bGUuZXhwb3J0cy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xubW9kdWxlLmV4cG9ydHMucmluZyA9IHJpbmdBcmVhO1xuXG5mdW5jdGlvbiBnZW9tZXRyeShfKSB7XG4gICAgaWYgKF8udHlwZSA9PT0gJ1BvbHlnb24nKSByZXR1cm4gcG9seWdvbkFyZWEoXy5jb29yZGluYXRlcyk7XG4gICAgZWxzZSBpZiAoXy50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICB2YXIgYXJlYSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgXy5jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJlYSArPSBwb2x5Z29uQXJlYShfLmNvb3JkaW5hdGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJlYTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBvbHlnb25BcmVhKGNvb3Jkcykge1xuICAgIHZhciBhcmVhID0gMDtcbiAgICBpZiAoY29vcmRzICYmIGNvb3Jkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFyZWEgKz0gTWF0aC5hYnMocmluZ0FyZWEoY29vcmRzWzBdKSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmVhIC09IE1hdGguYWJzKHJpbmdBcmVhKGNvb3Jkc1tpXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcmVhO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgYXBwcm94aW1hdGUgYXJlYSBvZiB0aGUgcG9seWdvbiB3ZXJlIGl0IHByb2plY3RlZCBvbnRvXG4gKiAgICAgdGhlIGVhcnRoLiAgTm90ZSB0aGF0IHRoaXMgYXJlYSB3aWxsIGJlIHBvc2l0aXZlIGlmIHJpbmcgaXMgb3JpZW50ZWRcbiAqICAgICBjbG9ja3dpc2UsIG90aGVyd2lzZSBpdCB3aWxsIGJlIG5lZ2F0aXZlLlxuICpcbiAqIFJlZmVyZW5jZTpcbiAqIFJvYmVydC4gRy4gQ2hhbWJlcmxhaW4gYW5kIFdpbGxpYW0gSC4gRHVxdWV0dGUsIFwiU29tZSBBbGdvcml0aG1zIGZvclxuICogICAgIFBvbHlnb25zIG9uIGEgU3BoZXJlXCIsIEpQTCBQdWJsaWNhdGlvbiAwNy0wMywgSmV0IFByb3B1bHNpb25cbiAqICAgICBMYWJvcmF0b3J5LCBQYXNhZGVuYSwgQ0EsIEp1bmUgMjAwNyBodHRwOi8vdHJzLW5ldy5qcGwubmFzYS5nb3YvZHNwYWNlL2hhbmRsZS8yMDE0LzQwNDA5XG4gKlxuICogUmV0dXJuczpcbiAqIHtmbG9hdH0gVGhlIGFwcHJveGltYXRlIHNpZ25lZCBnZW9kZXNpYyBhcmVhIG9mIHRoZSBwb2x5Z29uIGluIHNxdWFyZVxuICogICAgIG1ldGVycy5cbiAqL1xuXG5mdW5jdGlvbiByaW5nQXJlYShjb29yZHMpIHtcbiAgICB2YXIgYXJlYSA9IDA7XG5cbiAgICBpZiAoY29vcmRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdmFyIHAxLCBwMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBwMSA9IGNvb3Jkc1tpXTtcbiAgICAgICAgICAgIHAyID0gY29vcmRzW2kgKyAxXTtcbiAgICAgICAgICAgIGFyZWEgKz0gcmFkKHAyWzBdIC0gcDFbMF0pICogKDIgKyBNYXRoLnNpbihyYWQocDFbMV0pKSArIE1hdGguc2luKHJhZChwMlsxXSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZWEgPSBhcmVhICogd2dzODQuUkFESVVTICogd2dzODQuUkFESVVTIC8gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJlYTtcbn1cblxuZnVuY3Rpb24gcmFkKF8pIHtcbiAgICByZXR1cm4gXyAqIE1hdGguUEkgLyAxODA7XG59XG4iLCJtb2R1bGUuZXhwb3J0cy5SQURJVVMgPSA2Mzc4MTM3O1xubW9kdWxlLmV4cG9ydHMuRkxBVFRFTklORyA9IDEvMjk4LjI1NzIyMzU2Mztcbm1vZHVsZS5leHBvcnRzLlBPTEFSX1JBRElVUyA9IDYzNTY3NTIuMzE0MjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBjbGlwO1xuXG4vKiBjbGlwIGZlYXR1cmVzIGJldHdlZW4gdHdvIGF4aXMtcGFyYWxsZWwgbGluZXM6XG4gKiAgICAgfCAgICAgICAgfFxuICogIF9fX3xfX18gICAgIHwgICAgIC9cbiAqIC8gICB8ICAgXFxfX19ffF9fX18vXG4gKiAgICAgfCAgICAgICAgfFxuICovXG5cbmZ1bmN0aW9uIGNsaXAoZmVhdHVyZXMsIHNjYWxlLCBrMSwgazIsIGF4aXMsIGludGVyc2VjdCwgbWluQWxsLCBtYXhBbGwpIHtcblxuICAgIGsxIC89IHNjYWxlO1xuICAgIGsyIC89IHNjYWxlO1xuXG4gICAgaWYgKG1pbkFsbCA+PSBrMSAmJiBtYXhBbGwgPD0gazIpIHJldHVybiBmZWF0dXJlczsgLy8gdHJpdmlhbCBhY2NlcHRcbiAgICBlbHNlIGlmIChtaW5BbGwgPiBrMiB8fCBtYXhBbGwgPCBrMSkgcmV0dXJuIG51bGw7IC8vIHRyaXZpYWwgcmVqZWN0XG5cbiAgICB2YXIgY2xpcHBlZCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbaV0sXG4gICAgICAgICAgICBnZW9tZXRyeSA9IGZlYXR1cmUuZ2VvbWV0cnksXG4gICAgICAgICAgICB0eXBlID0gZmVhdHVyZS50eXBlLFxuICAgICAgICAgICAgbWluLCBtYXg7XG5cbiAgICAgICAgbWluID0gZmVhdHVyZS5taW5bYXhpc107XG4gICAgICAgIG1heCA9IGZlYXR1cmUubWF4W2F4aXNdO1xuXG4gICAgICAgIGlmIChtaW4gPj0gazEgJiYgbWF4IDw9IGsyKSB7IC8vIHRyaXZpYWwgYWNjZXB0XG4gICAgICAgICAgICBjbGlwcGVkLnB1c2goZmVhdHVyZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChtaW4gPiBrMiB8fCBtYXggPCBrMSkgY29udGludWU7IC8vIHRyaXZpYWwgcmVqZWN0XG5cbiAgICAgICAgdmFyIHNsaWNlcyA9IHR5cGUgPT09IDEgP1xuICAgICAgICAgICAgICAgIGNsaXBQb2ludHMoZ2VvbWV0cnksIGsxLCBrMiwgYXhpcykgOlxuICAgICAgICAgICAgICAgIGNsaXBHZW9tZXRyeShnZW9tZXRyeSwgazEsIGsyLCBheGlzLCBpbnRlcnNlY3QsIHR5cGUgPT09IDMpO1xuXG4gICAgICAgIGlmIChzbGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBpZiBhIGZlYXR1cmUgZ290IGNsaXBwZWQsIGl0IHdpbGwgbGlrZWx5IGdldCBjbGlwcGVkIG9uIHRoZSBuZXh0IHpvb20gbGV2ZWwgYXMgd2VsbCxcbiAgICAgICAgICAgIC8vIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byByZWNhbGN1bGF0ZSBiYm94ZXNcbiAgICAgICAgICAgIGNsaXBwZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IHNsaWNlcyxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIHRhZ3M6IGZlYXR1cmVzW2ldLnRhZ3MgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBtaW46IGZlYXR1cmUubWluLFxuICAgICAgICAgICAgICAgIG1heDogZmVhdHVyZS5tYXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsaXBwZWQubGVuZ3RoID8gY2xpcHBlZCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNsaXBQb2ludHMoZ2VvbWV0cnksIGsxLCBrMiwgYXhpcykge1xuICAgIHZhciBzbGljZSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYSA9IGdlb21ldHJ5W2ldLFxuICAgICAgICAgICAgYWsgPSBhW2F4aXNdO1xuXG4gICAgICAgIGlmIChhayA+PSBrMSAmJiBhayA8PSBrMikgc2xpY2UucHVzaChhKTtcbiAgICB9XG4gICAgcmV0dXJuIHNsaWNlO1xufVxuXG5mdW5jdGlvbiBjbGlwR2VvbWV0cnkoZ2VvbWV0cnksIGsxLCBrMiwgYXhpcywgaW50ZXJzZWN0LCBjbG9zZWQpIHtcblxuICAgIHZhciBzbGljZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICB2YXIgYWsgPSAwLFxuICAgICAgICAgICAgYmsgPSAwLFxuICAgICAgICAgICAgYiA9IG51bGwsXG4gICAgICAgICAgICBwb2ludHMgPSBnZW9tZXRyeVtpXSxcbiAgICAgICAgICAgIGFyZWEgPSBwb2ludHMuYXJlYSxcbiAgICAgICAgICAgIGRpc3QgPSBwb2ludHMuZGlzdCxcbiAgICAgICAgICAgIGxlbiA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhLCBqLCBsYXN0O1xuXG4gICAgICAgIHZhciBzbGljZSA9IFtdO1xuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsZW4gLSAxOyBqKyspIHtcbiAgICAgICAgICAgIGEgPSBiIHx8IHBvaW50c1tqXTtcbiAgICAgICAgICAgIGIgPSBwb2ludHNbaiArIDFdO1xuICAgICAgICAgICAgYWsgPSBiayB8fCBhW2F4aXNdO1xuICAgICAgICAgICAgYmsgPSBiW2F4aXNdO1xuXG4gICAgICAgICAgICBpZiAoYWsgPCBrMSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKChiayA+IGsyKSkgeyAvLyAtLS18LS0tLS18LS0+XG4gICAgICAgICAgICAgICAgICAgIHNsaWNlLnB1c2goaW50ZXJzZWN0KGEsIGIsIGsxKSwgaW50ZXJzZWN0KGEsIGIsIGsyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKSBzbGljZSA9IG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiayA+PSBrMSkgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazEpKTsgLy8gLS0tfC0tPiAgfFxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFrID4gazIpIHtcblxuICAgICAgICAgICAgICAgIGlmICgoYmsgPCBrMSkpIHsgLy8gPC0tfC0tLS0tfC0tLVxuICAgICAgICAgICAgICAgICAgICBzbGljZS5wdXNoKGludGVyc2VjdChhLCBiLCBrMiksIGludGVyc2VjdChhLCBiLCBrMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNsb3NlZCkgc2xpY2UgPSBuZXdTbGljZShzbGljZXMsIHNsaWNlLCBhcmVhLCBkaXN0KTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYmsgPD0gazIpIHNsaWNlLnB1c2goaW50ZXJzZWN0KGEsIGIsIGsyKSk7IC8vIHwgIDwtLXwtLS1cblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHNsaWNlLnB1c2goYSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmsgPCBrMSkgeyAvLyA8LS18LS0tICB8XG4gICAgICAgICAgICAgICAgICAgIHNsaWNlLnB1c2goaW50ZXJzZWN0KGEsIGIsIGsxKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKSBzbGljZSA9IG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiayA+IGsyKSB7IC8vIHwgIC0tLXwtLT5cbiAgICAgICAgICAgICAgICAgICAgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHNsaWNlID0gbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHwgLS0+IHxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0aGUgbGFzdCBwb2ludFxuICAgICAgICBhID0gcG9pbnRzW2xlbiAtIDFdO1xuICAgICAgICBhayA9IGFbYXhpc107XG4gICAgICAgIGlmIChhayA+PSBrMSAmJiBhayA8PSBrMikgc2xpY2UucHVzaChhKTtcblxuICAgICAgICAvLyBjbG9zZSB0aGUgcG9seWdvbiBpZiBpdHMgZW5kcG9pbnRzIGFyZSBub3QgdGhlIHNhbWUgYWZ0ZXIgY2xpcHBpbmdcblxuICAgICAgICBsYXN0ID0gc2xpY2Vbc2xpY2UubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChjbG9zZWQgJiYgbGFzdCAmJiAoc2xpY2VbMF1bMF0gIT09IGxhc3RbMF0gfHwgc2xpY2VbMF1bMV0gIT09IGxhc3RbMV0pKSBzbGljZS5wdXNoKHNsaWNlWzBdKTtcblxuICAgICAgICAvLyBhZGQgdGhlIGZpbmFsIHNsaWNlXG4gICAgICAgIG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QpO1xuICAgIH1cblxuICAgIHJldHVybiBzbGljZXM7XG59XG5cbmZ1bmN0aW9uIG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QpIHtcbiAgICBpZiAoc2xpY2UubGVuZ3RoKSB7XG4gICAgICAgIC8vIHdlIGRvbid0IHJlY2FsY3VsYXRlIHRoZSBhcmVhL2xlbmd0aCBvZiB0aGUgdW5jbGlwcGVkIGdlb21ldHJ5IGJlY2F1c2UgdGhlIGNhc2Ugd2hlcmUgaXQgZ29lc1xuICAgICAgICAvLyBiZWxvdyB0aGUgdmlzaWJpbGl0eSB0aHJlc2hvbGQgYXMgYSByZXN1bHQgb2YgY2xpcHBpbmcgaXMgcmFyZSwgc28gd2UgYXZvaWQgZG9pbmcgdW5uZWNlc3Nhcnkgd29ya1xuICAgICAgICBzbGljZS5hcmVhID0gYXJlYTtcbiAgICAgICAgc2xpY2UuZGlzdCA9IGRpc3Q7XG5cbiAgICAgICAgc2xpY2VzLnB1c2goc2xpY2UpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gY29udmVydDtcblxudmFyIHNpbXBsaWZ5ID0gcmVxdWlyZSgnLi9zaW1wbGlmeScpO1xuXG4vLyBjb252ZXJ0cyBHZW9KU09OIGZlYXR1cmUgaW50byBhbiBpbnRlcm1lZGlhdGUgcHJvamVjdGVkIEpTT04gdmVjdG9yIGZvcm1hdCB3aXRoIHNpbXBsaWZpY2F0aW9uIGRhdGFcblxuZnVuY3Rpb24gY29udmVydChkYXRhLCB0b2xlcmFuY2UpIHtcbiAgICB2YXIgZmVhdHVyZXMgPSBbXTtcblxuICAgIGlmIChkYXRhLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb252ZXJ0RmVhdHVyZShmZWF0dXJlcywgZGF0YS5mZWF0dXJlc1tpXSwgdG9sZXJhbmNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnRmVhdHVyZScpIHtcbiAgICAgICAgY29udmVydEZlYXR1cmUoZmVhdHVyZXMsIGRhdGEsIHRvbGVyYW5jZSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzaW5nbGUgZ2VvbWV0cnkgb3IgYSBnZW9tZXRyeSBjb2xsZWN0aW9uXG4gICAgICAgIGNvbnZlcnRGZWF0dXJlKGZlYXR1cmVzLCB7Z2VvbWV0cnk6IGRhdGF9LCB0b2xlcmFuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZXM7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRGZWF0dXJlKGZlYXR1cmVzLCBmZWF0dXJlLCB0b2xlcmFuY2UpIHtcbiAgICB2YXIgZ2VvbSA9IGZlYXR1cmUuZ2VvbWV0cnksXG4gICAgICAgIHR5cGUgPSBnZW9tLnR5cGUsXG4gICAgICAgIGNvb3JkcyA9IGdlb20uY29vcmRpbmF0ZXMsXG4gICAgICAgIHRhZ3MgPSBmZWF0dXJlLnByb3BlcnRpZXMsXG4gICAgICAgIGksIGosIHJpbmdzO1xuXG4gICAgaWYgKHR5cGUgPT09ICdQb2ludCcpIHtcbiAgICAgICAgZmVhdHVyZXMucHVzaChjcmVhdGUodGFncywgMSwgW3Byb2plY3RQb2ludChjb29yZHMpXSkpO1xuXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcbiAgICAgICAgZmVhdHVyZXMucHVzaChjcmVhdGUodGFncywgMSwgcHJvamVjdChjb29yZHMpKSk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGNyZWF0ZSh0YWdzLCAyLCBbcHJvamVjdChjb29yZHMsIHRvbGVyYW5jZSldKSk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnIHx8IHR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICByaW5ncyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByaW5ncy5wdXNoKHByb2plY3QoY29vcmRzW2ldLCB0b2xlcmFuY2UpKTtcbiAgICAgICAgfVxuICAgICAgICBmZWF0dXJlcy5wdXNoKGNyZWF0ZSh0YWdzLCB0eXBlID09PSAnUG9seWdvbicgPyAzIDogMiwgcmluZ3MpKTtcblxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgcmluZ3MgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHJpbmdzLnB1c2gocHJvamVjdChjb29yZHNbaV1bal0sIHRvbGVyYW5jZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZlYXR1cmVzLnB1c2goY3JlYXRlKHRhZ3MsIDMsIHJpbmdzKSk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZW9tLmdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnZlcnRGZWF0dXJlKGZlYXR1cmVzLCB7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IGdlb20uZ2VvbWV0cmllc1tpXSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB0YWdzXG4gICAgICAgICAgICB9LCB0b2xlcmFuY2UpO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgaXMgbm90IGEgdmFsaWQgR2VvSlNPTiBvYmplY3QuJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGUodGFncywgdHlwZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgZmVhdHVyZSA9IHtcbiAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB0YWdzOiB0YWdzIHx8IG51bGwsXG4gICAgICAgIG1pbjogWzIsIDFdLCAvLyBpbml0aWFsIGJib3ggdmFsdWVzO1xuICAgICAgICBtYXg6IFstMSwgMF0gIC8vIG5vdGUgdGhhdCBjb29yZHMgYXJlIHVzdWFsbHkgaW4gWzAuLjFdIHJhbmdlXG4gICAgfTtcbiAgICBjYWxjQkJveChmZWF0dXJlKTtcbiAgICByZXR1cm4gZmVhdHVyZTtcbn1cblxuZnVuY3Rpb24gcHJvamVjdChsb25sYXRzLCB0b2xlcmFuY2UpIHtcbiAgICB2YXIgcHJvamVjdGVkID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb25sYXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByb2plY3RlZC5wdXNoKHByb2plY3RQb2ludChsb25sYXRzW2ldKSk7XG4gICAgfVxuICAgIGlmICh0b2xlcmFuY2UpIHtcbiAgICAgICAgc2ltcGxpZnkocHJvamVjdGVkLCB0b2xlcmFuY2UpO1xuICAgICAgICBjYWxjU2l6ZShwcm9qZWN0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvamVjdGVkO1xufVxuXG5mdW5jdGlvbiBwcm9qZWN0UG9pbnQocCkge1xuICAgIHZhciBzaW4gPSBNYXRoLnNpbihwWzFdICogTWF0aC5QSSAvIDE4MCksXG4gICAgICAgIHggPSAocFswXSAvIDM2MCArIDAuNSksXG4gICAgICAgIHkgPSAoMC41IC0gMC4yNSAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyBNYXRoLlBJKTtcblxuICAgIHkgPSB5IDwgLTEgPyAtMSA6XG4gICAgICAgIHkgPiAxID8gMSA6IHk7XG5cbiAgICByZXR1cm4gW3gsIHksIDBdO1xufVxuXG4vLyBjYWxjdWxhdGUgYXJlYSBhbmQgbGVuZ3RoIG9mIHRoZSBwb2x5XG5mdW5jdGlvbiBjYWxjU2l6ZShwb2ludHMpIHtcbiAgICB2YXIgYXJlYSA9IDAsXG4gICAgICAgIGRpc3QgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGEsIGI7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGEgPSBiIHx8IHBvaW50c1tpXTtcbiAgICAgICAgYiA9IHBvaW50c1tpICsgMV07XG5cbiAgICAgICAgYXJlYSArPSBhWzBdICogYlsxXSAtIGJbMF0gKiBhWzFdO1xuXG4gICAgICAgIC8vIHVzZSBNYW5oYXR0YW4gZGlzdGFuY2UgaW5zdGVhZCBvZiBFdWNsaWRpYW4gb25lIHRvIGF2b2lkIGV4cGVuc2l2ZSBzcXVhcmUgcm9vdCBjb21wdXRhdGlvblxuICAgICAgICBkaXN0ICs9IE1hdGguYWJzKGJbMF0gLSBhWzBdKSArIE1hdGguYWJzKGJbMV0gLSBhWzFdKTtcbiAgICB9XG4gICAgcG9pbnRzLmFyZWEgPSBNYXRoLmFicyhhcmVhIC8gMik7XG4gICAgcG9pbnRzLmRpc3QgPSBkaXN0O1xufVxuXG4vLyBjYWxjdWxhdGUgdGhlIGZlYXR1cmUgYm91bmRpbmcgYm94IGZvciBmYXN0ZXIgY2xpcHBpbmcgbGF0ZXJcbmZ1bmN0aW9uIGNhbGNCQm94KGZlYXR1cmUpIHtcbiAgICB2YXIgZ2VvbWV0cnkgPSBmZWF0dXJlLmdlb21ldHJ5LFxuICAgICAgICBtaW4gPSBmZWF0dXJlLm1pbixcbiAgICAgICAgbWF4ID0gZmVhdHVyZS5tYXg7XG5cbiAgICBpZiAoZmVhdHVyZS50eXBlID09PSAxKSBjYWxjUmluZ0JCb3gobWluLCBtYXgsIGdlb21ldHJ5KTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkubGVuZ3RoOyBpKyspIGNhbGNSaW5nQkJveChtaW4sIG1heCwgZ2VvbWV0cnlbaV0pO1xuXG4gICAgcmV0dXJuIGZlYXR1cmU7XG59XG5cbmZ1bmN0aW9uIGNhbGNSaW5nQkJveChtaW4sIG1heCwgcG9pbnRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgbWluWzBdID0gTWF0aC5taW4ocFswXSwgbWluWzBdKTtcbiAgICAgICAgbWF4WzBdID0gTWF0aC5tYXgocFswXSwgbWF4WzBdKTtcbiAgICAgICAgbWluWzFdID0gTWF0aC5taW4ocFsxXSwgbWluWzFdKTtcbiAgICAgICAgbWF4WzFdID0gTWF0aC5tYXgocFsxXSwgbWF4WzFdKTtcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VvanNvbnZ0O1xuXG52YXIgY29udmVydCA9IHJlcXVpcmUoJy4vY29udmVydCcpLCAgICAgLy8gR2VvSlNPTiBjb252ZXJzaW9uIGFuZCBwcmVwcm9jZXNzaW5nXG4gICAgdHJhbnNmb3JtID0gcmVxdWlyZSgnLi90cmFuc2Zvcm0nKSwgLy8gY29vcmRpbmF0ZSB0cmFuc2Zvcm1hdGlvblxuICAgIGNsaXAgPSByZXF1aXJlKCcuL2NsaXAnKSwgICAgICAgICAgIC8vIHN0cmlwZSBjbGlwcGluZyBhbGdvcml0aG1cbiAgICB3cmFwID0gcmVxdWlyZSgnLi93cmFwJyksICAgICAgICAgICAvLyBkYXRlIGxpbmUgcHJvY2Vzc2luZ1xuICAgIGNyZWF0ZVRpbGUgPSByZXF1aXJlKCcuL3RpbGUnKTsgICAgIC8vIGZpbmFsIHNpbXBsaWZpZWQgdGlsZSBnZW5lcmF0aW9uXG5cblxuZnVuY3Rpb24gZ2VvanNvbnZ0KGRhdGEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEdlb0pTT05WVChkYXRhLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gR2VvSlNPTlZUKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zID0gZXh0ZW5kKE9iamVjdC5jcmVhdGUodGhpcy5vcHRpb25zKSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuXG4gICAgaWYgKGRlYnVnKSBjb25zb2xlLnRpbWUoJ3ByZXByb2Nlc3MgZGF0YScpO1xuXG4gICAgdmFyIHoyID0gMSA8PCBvcHRpb25zLm1heFpvb20sIC8vIDJeelxuICAgICAgICBmZWF0dXJlcyA9IGNvbnZlcnQoZGF0YSwgb3B0aW9ucy50b2xlcmFuY2UgLyAoejIgKiBvcHRpb25zLmV4dGVudCkpO1xuXG4gICAgdGhpcy50aWxlcyA9IHt9O1xuICAgIHRoaXMudGlsZUNvb3JkcyA9IFtdO1xuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUudGltZUVuZCgncHJlcHJvY2VzcyBkYXRhJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdpbmRleDogbWF4Wm9vbTogJWQsIG1heFBvaW50czogJWQnLCBvcHRpb25zLmluZGV4TWF4Wm9vbSwgb3B0aW9ucy5pbmRleE1heFBvaW50cyk7XG4gICAgICAgIGNvbnNvbGUudGltZSgnZ2VuZXJhdGUgdGlsZXMnKTtcbiAgICAgICAgdGhpcy5zdGF0cyA9IHt9O1xuICAgICAgICB0aGlzLnRvdGFsID0gMDtcbiAgICB9XG5cbiAgICBmZWF0dXJlcyA9IHdyYXAoZmVhdHVyZXMsIG9wdGlvbnMuYnVmZmVyIC8gb3B0aW9ucy5leHRlbnQsIGludGVyc2VjdFgpO1xuXG4gICAgLy8gc3RhcnQgc2xpY2luZyBmcm9tIHRoZSB0b3AgdGlsZSBkb3duXG4gICAgaWYgKGZlYXR1cmVzLmxlbmd0aCkgdGhpcy5zcGxpdFRpbGUoZmVhdHVyZXMsIDAsIDAsIDApO1xuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGlmIChmZWF0dXJlcy5sZW5ndGgpIGNvbnNvbGUubG9nKCdmZWF0dXJlczogJWQsIHBvaW50czogJWQnLCB0aGlzLnRpbGVzWzBdLm51bUZlYXR1cmVzLCB0aGlzLnRpbGVzWzBdLm51bVBvaW50cyk7XG4gICAgICAgIGNvbnNvbGUudGltZUVuZCgnZ2VuZXJhdGUgdGlsZXMnKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3RpbGVzIGdlbmVyYXRlZDonLCB0aGlzLnRvdGFsLCBKU09OLnN0cmluZ2lmeSh0aGlzLnN0YXRzKSk7XG4gICAgfVxufVxuXG5HZW9KU09OVlQucHJvdG90eXBlLm9wdGlvbnMgPSB7XG4gICAgbWF4Wm9vbTogMTQsICAgICAgICAgICAgLy8gbWF4IHpvb20gdG8gcHJlc2VydmUgZGV0YWlsIG9uXG4gICAgaW5kZXhNYXhab29tOiA1LCAgICAgICAgLy8gbWF4IHpvb20gaW4gdGhlIHRpbGUgaW5kZXhcbiAgICBpbmRleE1heFBvaW50czogMTAwMDAwLCAvLyBtYXggbnVtYmVyIG9mIHBvaW50cyBwZXIgdGlsZSBpbiB0aGUgdGlsZSBpbmRleFxuICAgIHNvbGlkQ2hpbGRyZW46IGZhbHNlLCAgIC8vIHdoZXRoZXIgdG8gdGlsZSBzb2xpZCBzcXVhcmUgdGlsZXMgZnVydGhlclxuICAgIHRvbGVyYW5jZTogMywgICAgICAgICAgIC8vIHNpbXBsaWZpY2F0aW9uIHRvbGVyYW5jZSAoaGlnaGVyIG1lYW5zIHNpbXBsZXIpXG4gICAgZXh0ZW50OiA0MDk2LCAgICAgICAgICAgLy8gdGlsZSBleHRlbnRcbiAgICBidWZmZXI6IDY0LCAgICAgICAgICAgICAvLyB0aWxlIGJ1ZmZlciBvbiBlYWNoIHNpZGVcbiAgICBkZWJ1ZzogMCAgICAgICAgICAgICAgICAvLyBsb2dnaW5nIGxldmVsICgwLCAxIG9yIDIpXG59O1xuXG5HZW9KU09OVlQucHJvdG90eXBlLnNwbGl0VGlsZSA9IGZ1bmN0aW9uIChmZWF0dXJlcywgeiwgeCwgeSwgY3osIGN4LCBjeSkge1xuXG4gICAgdmFyIHN0YWNrID0gW2ZlYXR1cmVzLCB6LCB4LCB5XSxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZGVidWcgPSBvcHRpb25zLmRlYnVnLFxuICAgICAgICBzb2xpZCA9IG51bGw7XG5cbiAgICAvLyBhdm9pZCByZWN1cnNpb24gYnkgdXNpbmcgYSBwcm9jZXNzaW5nIHF1ZXVlXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB5ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHggPSBzdGFjay5wb3AoKTtcbiAgICAgICAgeiA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBmZWF0dXJlcyA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIHZhciB6MiA9IDEgPDwgeixcbiAgICAgICAgICAgIGlkID0gdG9JRCh6LCB4LCB5KSxcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLnRpbGVzW2lkXSxcbiAgICAgICAgICAgIHRpbGVUb2xlcmFuY2UgPSB6ID09PSBvcHRpb25zLm1heFpvb20gPyAwIDogb3B0aW9ucy50b2xlcmFuY2UgLyAoejIgKiBvcHRpb25zLmV4dGVudCk7XG5cbiAgICAgICAgaWYgKCF0aWxlKSB7XG4gICAgICAgICAgICBpZiAoZGVidWcgPiAxKSBjb25zb2xlLnRpbWUoJ2NyZWF0aW9uJyk7XG5cbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLnRpbGVzW2lkXSA9IGNyZWF0ZVRpbGUoZmVhdHVyZXMsIHoyLCB4LCB5LCB0aWxlVG9sZXJhbmNlLCB6ID09PSBvcHRpb25zLm1heFpvb20pO1xuICAgICAgICAgICAgdGhpcy50aWxlQ29vcmRzLnB1c2goe3o6IHosIHg6IHgsIHk6IHl9KTtcblxuICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndGlsZSB6JWQtJWQtJWQgKGZlYXR1cmVzOiAlZCwgcG9pbnRzOiAlZCwgc2ltcGxpZmllZDogJWQpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHosIHgsIHksIHRpbGUubnVtRmVhdHVyZXMsIHRpbGUubnVtUG9pbnRzLCB0aWxlLm51bVNpbXBsaWZpZWQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLnRpbWVFbmQoJ2NyZWF0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSAneicgKyB6O1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHNba2V5XSA9ICh0aGlzLnN0YXRzW2tleV0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMudG90YWwrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIGdlb21ldHJ5IGluIHRpbGUgc28gdGhhdCB3ZSBjYW4gZHJpbGwgZG93biBsYXRlciBpZiB3ZSBzdG9wIG5vd1xuICAgICAgICB0aWxlLnNvdXJjZSA9IGZlYXR1cmVzO1xuXG4gICAgICAgIC8vIGlmIGl0J3MgdGhlIGZpcnN0LXBhc3MgdGlsaW5nXG4gICAgICAgIGlmICghY3opIHtcbiAgICAgICAgICAgIC8vIHN0b3AgdGlsaW5nIGlmIHdlIHJlYWNoZWQgbWF4IHpvb20sIG9yIGlmIHRoZSB0aWxlIGlzIHRvbyBzaW1wbGVcbiAgICAgICAgICAgIGlmICh6ID09PSBvcHRpb25zLmluZGV4TWF4Wm9vbSB8fCB0aWxlLm51bVBvaW50cyA8PSBvcHRpb25zLmluZGV4TWF4UG9pbnRzKSBjb250aW51ZTtcblxuICAgICAgICAvLyBpZiBhIGRyaWxsZG93biB0byBhIHNwZWNpZmljIHRpbGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN0b3AgdGlsaW5nIGlmIHdlIHJlYWNoZWQgYmFzZSB6b29tIG9yIG91ciB0YXJnZXQgdGlsZSB6b29tXG4gICAgICAgICAgICBpZiAoeiA9PT0gb3B0aW9ucy5tYXhab29tIHx8IHogPT09IGN6KSBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gc3RvcCB0aWxpbmcgaWYgaXQncyBub3QgYW4gYW5jZXN0b3Igb2YgdGhlIHRhcmdldCB0aWxlXG4gICAgICAgICAgICB2YXIgbSA9IDEgPDwgKGN6IC0geik7XG4gICAgICAgICAgICBpZiAoeCAhPT0gTWF0aC5mbG9vcihjeCAvIG0pIHx8IHkgIT09IE1hdGguZmxvb3IoY3kgLyBtKSkgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdG9wIHRpbGluZyBpZiB0aGUgdGlsZSBpcyBzb2xpZCBjbGlwcGVkIHNxdWFyZVxuICAgICAgICBpZiAoIW9wdGlvbnMuc29saWRDaGlsZHJlbiAmJiBpc0NsaXBwZWRTcXVhcmUodGlsZSwgb3B0aW9ucy5leHRlbnQsIG9wdGlvbnMuYnVmZmVyKSkge1xuICAgICAgICAgICAgaWYgKGN6KSBzb2xpZCA9IHo7IC8vIGFuZCByZW1lbWJlciB0aGUgem9vbSBpZiB3ZSdyZSBkcmlsbGluZyBkb3duXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIHNsaWNlIGZ1cnRoZXIgZG93biwgbm8gbmVlZCB0byBrZWVwIHNvdXJjZSBnZW9tZXRyeVxuICAgICAgICB0aWxlLnNvdXJjZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS50aW1lKCdjbGlwcGluZycpO1xuXG4gICAgICAgIC8vIHZhbHVlcyB3ZSdsbCB1c2UgZm9yIGNsaXBwaW5nXG4gICAgICAgIHZhciBrMSA9IDAuNSAqIG9wdGlvbnMuYnVmZmVyIC8gb3B0aW9ucy5leHRlbnQsXG4gICAgICAgICAgICBrMiA9IDAuNSAtIGsxLFxuICAgICAgICAgICAgazMgPSAwLjUgKyBrMSxcbiAgICAgICAgICAgIGs0ID0gMSArIGsxLFxuICAgICAgICAgICAgdGwsIGJsLCB0ciwgYnIsIGxlZnQsIHJpZ2h0O1xuXG4gICAgICAgIHRsID0gYmwgPSB0ciA9IGJyID0gbnVsbDtcblxuICAgICAgICBsZWZ0ICA9IGNsaXAoZmVhdHVyZXMsIHoyLCB4IC0gazEsIHggKyBrMywgMCwgaW50ZXJzZWN0WCwgdGlsZS5taW5bMF0sIHRpbGUubWF4WzBdKTtcbiAgICAgICAgcmlnaHQgPSBjbGlwKGZlYXR1cmVzLCB6MiwgeCArIGsyLCB4ICsgazQsIDAsIGludGVyc2VjdFgsIHRpbGUubWluWzBdLCB0aWxlLm1heFswXSk7XG5cbiAgICAgICAgaWYgKGxlZnQpIHtcbiAgICAgICAgICAgIHRsID0gY2xpcChsZWZ0LCB6MiwgeSAtIGsxLCB5ICsgazMsIDEsIGludGVyc2VjdFksIHRpbGUubWluWzFdLCB0aWxlLm1heFsxXSk7XG4gICAgICAgICAgICBibCA9IGNsaXAobGVmdCwgejIsIHkgKyBrMiwgeSArIGs0LCAxLCBpbnRlcnNlY3RZLCB0aWxlLm1pblsxXSwgdGlsZS5tYXhbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgICB0ciA9IGNsaXAocmlnaHQsIHoyLCB5IC0gazEsIHkgKyBrMywgMSwgaW50ZXJzZWN0WSwgdGlsZS5taW5bMV0sIHRpbGUubWF4WzFdKTtcbiAgICAgICAgICAgIGJyID0gY2xpcChyaWdodCwgejIsIHkgKyBrMiwgeSArIGs0LCAxLCBpbnRlcnNlY3RZLCB0aWxlLm1pblsxXSwgdGlsZS5tYXhbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS50aW1lRW5kKCdjbGlwcGluZycpO1xuXG4gICAgICAgIGlmICh0bCkgc3RhY2sucHVzaCh0bCwgeiArIDEsIHggKiAyLCAgICAgeSAqIDIpO1xuICAgICAgICBpZiAoYmwpIHN0YWNrLnB1c2goYmwsIHogKyAxLCB4ICogMiwgICAgIHkgKiAyICsgMSk7XG4gICAgICAgIGlmICh0cikgc3RhY2sucHVzaCh0ciwgeiArIDEsIHggKiAyICsgMSwgeSAqIDIpO1xuICAgICAgICBpZiAoYnIpIHN0YWNrLnB1c2goYnIsIHogKyAxLCB4ICogMiArIDEsIHkgKiAyICsgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvbGlkO1xufTtcblxuR2VvSlNPTlZULnByb3RvdHlwZS5nZXRUaWxlID0gZnVuY3Rpb24gKHosIHgsIHkpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZXh0ZW50ID0gb3B0aW9ucy5leHRlbnQsXG4gICAgICAgIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcblxuICAgIHZhciB6MiA9IDEgPDwgejtcbiAgICB4ID0gKCh4ICUgejIpICsgejIpICUgejI7IC8vIHdyYXAgdGlsZSB4IGNvb3JkaW5hdGVcblxuICAgIHZhciBpZCA9IHRvSUQoeiwgeCwgeSk7XG4gICAgaWYgKHRoaXMudGlsZXNbaWRdKSByZXR1cm4gdHJhbnNmb3JtLnRpbGUodGhpcy50aWxlc1tpZF0sIGV4dGVudCk7XG5cbiAgICBpZiAoZGVidWcgPiAxKSBjb25zb2xlLmxvZygnZHJpbGxpbmcgZG93biB0byB6JWQtJWQtJWQnLCB6LCB4LCB5KTtcblxuICAgIHZhciB6MCA9IHosXG4gICAgICAgIHgwID0geCxcbiAgICAgICAgeTAgPSB5LFxuICAgICAgICBwYXJlbnQ7XG5cbiAgICB3aGlsZSAoIXBhcmVudCAmJiB6MCA+IDApIHtcbiAgICAgICAgejAtLTtcbiAgICAgICAgeDAgPSBNYXRoLmZsb29yKHgwIC8gMik7XG4gICAgICAgIHkwID0gTWF0aC5mbG9vcih5MCAvIDIpO1xuICAgICAgICBwYXJlbnQgPSB0aGlzLnRpbGVzW3RvSUQoejAsIHgwLCB5MCldO1xuICAgIH1cblxuICAgIGlmICghcGFyZW50IHx8ICFwYXJlbnQuc291cmNlKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIGlmIHdlIGZvdW5kIGEgcGFyZW50IHRpbGUgY29udGFpbmluZyB0aGUgb3JpZ2luYWwgZ2VvbWV0cnksIHdlIGNhbiBkcmlsbCBkb3duIGZyb20gaXRcbiAgICBpZiAoZGVidWcgPiAxKSBjb25zb2xlLmxvZygnZm91bmQgcGFyZW50IHRpbGUgeiVkLSVkLSVkJywgejAsIHgwLCB5MCk7XG5cbiAgICAvLyBpdCBwYXJlbnQgdGlsZSBpcyBhIHNvbGlkIGNsaXBwZWQgc3F1YXJlLCByZXR1cm4gaXQgaW5zdGVhZCBzaW5jZSBpdCdzIGlkZW50aWNhbFxuICAgIGlmIChpc0NsaXBwZWRTcXVhcmUocGFyZW50LCBleHRlbnQsIG9wdGlvbnMuYnVmZmVyKSkgcmV0dXJuIHRyYW5zZm9ybS50aWxlKHBhcmVudCwgZXh0ZW50KTtcblxuICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUudGltZSgnZHJpbGxpbmcgZG93bicpO1xuICAgIHZhciBzb2xpZCA9IHRoaXMuc3BsaXRUaWxlKHBhcmVudC5zb3VyY2UsIHowLCB4MCwgeTAsIHosIHgsIHkpO1xuICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUudGltZUVuZCgnZHJpbGxpbmcgZG93bicpO1xuXG4gICAgLy8gb25lIG9mIHRoZSBwYXJlbnQgdGlsZXMgd2FzIGEgc29saWQgY2xpcHBlZCBzcXVhcmVcbiAgICBpZiAoc29saWQgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIG0gPSAxIDw8ICh6IC0gc29saWQpO1xuICAgICAgICBpZCA9IHRvSUQoc29saWQsIE1hdGguZmxvb3IoeCAvIG0pLCBNYXRoLmZsb29yKHkgLyBtKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudGlsZXNbaWRdID8gdHJhbnNmb3JtLnRpbGUodGhpcy50aWxlc1tpZF0sIGV4dGVudCkgOiBudWxsO1xufTtcblxuZnVuY3Rpb24gdG9JRCh6LCB4LCB5KSB7XG4gICAgcmV0dXJuICgoKDEgPDwgeikgKiB5ICsgeCkgKiAzMikgKyB6O1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RYKGEsIGIsIHgpIHtcbiAgICByZXR1cm4gW3gsICh4IC0gYVswXSkgKiAoYlsxXSAtIGFbMV0pIC8gKGJbMF0gLSBhWzBdKSArIGFbMV0sIDFdO1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0WShhLCBiLCB5KSB7XG4gICAgcmV0dXJuIFsoeSAtIGFbMV0pICogKGJbMF0gLSBhWzBdKSAvIChiWzFdIC0gYVsxXSkgKyBhWzBdLCB5LCAxXTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYykge1xuICAgIGZvciAodmFyIGkgaW4gc3JjKSBkZXN0W2ldID0gc3JjW2ldO1xuICAgIHJldHVybiBkZXN0O1xufVxuXG4vLyBjaGVja3Mgd2hldGhlciBhIHRpbGUgaXMgYSB3aG9sZS1hcmVhIGZpbGwgYWZ0ZXIgY2xpcHBpbmc7IGlmIGl0IGlzLCB0aGVyZSdzIG5vIHNlbnNlIHNsaWNpbmcgaXQgZnVydGhlclxuZnVuY3Rpb24gaXNDbGlwcGVkU3F1YXJlKHRpbGUsIGV4dGVudCwgYnVmZmVyKSB7XG5cbiAgICB2YXIgZmVhdHVyZXMgPSB0aWxlLnNvdXJjZTtcbiAgICBpZiAoZmVhdHVyZXMubGVuZ3RoICE9PSAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzWzBdO1xuICAgIGlmIChmZWF0dXJlLnR5cGUgIT09IDMgfHwgZmVhdHVyZS5nZW9tZXRyeS5sZW5ndGggPiAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGVuID0gZmVhdHVyZS5nZW9tZXRyeVswXS5sZW5ndGg7XG4gICAgaWYgKGxlbiAhPT0gNSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgcCA9IHRyYW5zZm9ybS5wb2ludChmZWF0dXJlLmdlb21ldHJ5WzBdW2ldLCBleHRlbnQsIHRpbGUuejIsIHRpbGUueCwgdGlsZS55KTtcbiAgICAgICAgaWYgKChwWzBdICE9PSAtYnVmZmVyICYmIHBbMF0gIT09IGV4dGVudCArIGJ1ZmZlcikgfHxcbiAgICAgICAgICAgIChwWzFdICE9PSAtYnVmZmVyICYmIHBbMV0gIT09IGV4dGVudCArIGJ1ZmZlcikpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBzaW1wbGlmeTtcblxuLy8gY2FsY3VsYXRlIHNpbXBsaWZpY2F0aW9uIGRhdGEgdXNpbmcgb3B0aW1pemVkIERvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1cblxuZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UpIHtcblxuICAgIHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZSxcbiAgICAgICAgbGVuID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgZmlyc3QgPSAwLFxuICAgICAgICBsYXN0ID0gbGVuIC0gMSxcbiAgICAgICAgc3RhY2sgPSBbXSxcbiAgICAgICAgaSwgbWF4U3FEaXN0LCBzcURpc3QsIGluZGV4O1xuXG4gICAgLy8gYWx3YXlzIHJldGFpbiB0aGUgZW5kcG9pbnRzICgxIGlzIHRoZSBtYXggdmFsdWUpXG4gICAgcG9pbnRzW2ZpcnN0XVsyXSA9IDE7XG4gICAgcG9pbnRzW2xhc3RdWzJdID0gMTtcblxuICAgIC8vIGF2b2lkIHJlY3Vyc2lvbiBieSB1c2luZyBhIHN0YWNrXG4gICAgd2hpbGUgKGxhc3QpIHtcblxuICAgICAgICBtYXhTcURpc3QgPSAwO1xuXG4gICAgICAgIGZvciAoaSA9IGZpcnN0ICsgMTsgaSA8IGxhc3Q7IGkrKykge1xuICAgICAgICAgICAgc3FEaXN0ID0gZ2V0U3FTZWdEaXN0KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdKTtcblxuICAgICAgICAgICAgaWYgKHNxRGlzdCA+IG1heFNxRGlzdCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBtYXhTcURpc3QgPSBzcURpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4U3FEaXN0ID4gc3FUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHBvaW50c1tpbmRleF1bMl0gPSBtYXhTcURpc3Q7IC8vIHNhdmUgdGhlIHBvaW50IGltcG9ydGFuY2UgaW4gc3F1YXJlZCBwaXhlbHMgYXMgYSB6IGNvb3JkaW5hdGVcbiAgICAgICAgICAgIHN0YWNrLnB1c2goZmlyc3QpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChpbmRleCk7XG4gICAgICAgICAgICBmaXJzdCA9IGluZGV4O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBmaXJzdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBzcXVhcmUgZGlzdGFuY2UgZnJvbSBhIHBvaW50IHRvIGEgc2VnbWVudFxuZnVuY3Rpb24gZ2V0U3FTZWdEaXN0KHAsIGEsIGIpIHtcblxuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLFxuICAgICAgICBweCA9IHBbMF0sIHB5ID0gcFsxXSxcbiAgICAgICAgZHggPSBieCAtIHgsXG4gICAgICAgIGR5ID0gYnkgLSB5O1xuXG4gICAgaWYgKGR4ICE9PSAwIHx8IGR5ICE9PSAwKSB7XG5cbiAgICAgICAgdmFyIHQgPSAoKHB4IC0geCkgKiBkeCArIChweSAtIHkpICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICBpZiAodCA+IDEpIHtcbiAgICAgICAgICAgIHggPSBieDtcbiAgICAgICAgICAgIHkgPSBieTtcblxuICAgICAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICAgICAgICB4ICs9IGR4ICogdDtcbiAgICAgICAgICAgIHkgKz0gZHkgKiB0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHggPSBweCAtIHg7XG4gICAgZHkgPSBweSAtIHk7XG5cbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlVGlsZTtcblxuZnVuY3Rpb24gY3JlYXRlVGlsZShmZWF0dXJlcywgejIsIHR4LCB0eSwgdG9sZXJhbmNlLCBub1NpbXBsaWZ5KSB7XG4gICAgdmFyIHRpbGUgPSB7XG4gICAgICAgIGZlYXR1cmVzOiBbXSxcbiAgICAgICAgbnVtUG9pbnRzOiAwLFxuICAgICAgICBudW1TaW1wbGlmaWVkOiAwLFxuICAgICAgICBudW1GZWF0dXJlczogMCxcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICB4OiB0eCxcbiAgICAgICAgeTogdHksXG4gICAgICAgIHoyOiB6MixcbiAgICAgICAgdHJhbnNmb3JtZWQ6IGZhbHNlLFxuICAgICAgICBtaW46IFsyLCAxXSxcbiAgICAgICAgbWF4OiBbLTEsIDBdXG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRpbGUubnVtRmVhdHVyZXMrKztcbiAgICAgICAgYWRkRmVhdHVyZSh0aWxlLCBmZWF0dXJlc1tpXSwgdG9sZXJhbmNlLCBub1NpbXBsaWZ5KTtcblxuICAgICAgICB2YXIgbWluID0gZmVhdHVyZXNbaV0ubWluLFxuICAgICAgICAgICAgbWF4ID0gZmVhdHVyZXNbaV0ubWF4O1xuXG4gICAgICAgIGlmIChtaW5bMF0gPCB0aWxlLm1pblswXSkgdGlsZS5taW5bMF0gPSBtaW5bMF07XG4gICAgICAgIGlmIChtaW5bMV0gPCB0aWxlLm1pblsxXSkgdGlsZS5taW5bMV0gPSBtaW5bMV07XG4gICAgICAgIGlmIChtYXhbMF0gPiB0aWxlLm1heFswXSkgdGlsZS5tYXhbMF0gPSBtYXhbMF07XG4gICAgICAgIGlmIChtYXhbMV0gPiB0aWxlLm1heFsxXSkgdGlsZS5tYXhbMV0gPSBtYXhbMV07XG4gICAgfVxuICAgIHJldHVybiB0aWxlO1xufVxuXG5mdW5jdGlvbiBhZGRGZWF0dXJlKHRpbGUsIGZlYXR1cmUsIHRvbGVyYW5jZSwgbm9TaW1wbGlmeSkge1xuXG4gICAgdmFyIGdlb20gPSBmZWF0dXJlLmdlb21ldHJ5LFxuICAgICAgICB0eXBlID0gZmVhdHVyZS50eXBlLFxuICAgICAgICBzaW1wbGlmaWVkID0gW10sXG4gICAgICAgIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlLFxuICAgICAgICBpLCBqLCByaW5nLCBwO1xuXG4gICAgaWYgKHR5cGUgPT09IDEpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdlb20ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNpbXBsaWZpZWQucHVzaChnZW9tW2ldKTtcbiAgICAgICAgICAgIHRpbGUubnVtUG9pbnRzKys7XG4gICAgICAgICAgICB0aWxlLm51bVNpbXBsaWZpZWQrKztcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBzaW1wbGlmeSBhbmQgdHJhbnNmb3JtIHByb2plY3RlZCBjb29yZGluYXRlcyBmb3IgdGlsZSBnZW9tZXRyeVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ2VvbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmluZyA9IGdlb21baV07XG5cbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgdGlueSBwb2x5bGluZXMgJiBwb2x5Z29uc1xuICAgICAgICAgICAgaWYgKCFub1NpbXBsaWZ5ICYmICgodHlwZSA9PT0gMiAmJiByaW5nLmRpc3QgPCB0b2xlcmFuY2UpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlID09PSAzICYmIHJpbmcuYXJlYSA8IHNxVG9sZXJhbmNlKSkpIHtcbiAgICAgICAgICAgICAgICB0aWxlLm51bVBvaW50cyArPSByaW5nLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNpbXBsaWZpZWRSaW5nID0gW107XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCByaW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgcCA9IHJpbmdbal07XG4gICAgICAgICAgICAgICAgLy8ga2VlcCBwb2ludHMgd2l0aCBpbXBvcnRhbmNlID4gdG9sZXJhbmNlXG4gICAgICAgICAgICAgICAgaWYgKG5vU2ltcGxpZnkgfHwgcFsyXSA+IHNxVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbXBsaWZpZWRSaW5nLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbGUubnVtU2ltcGxpZmllZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aWxlLm51bVBvaW50cysrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzaW1wbGlmaWVkLnB1c2goc2ltcGxpZmllZFJpbmcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNpbXBsaWZpZWQubGVuZ3RoKSB7XG4gICAgICAgIHRpbGUuZmVhdHVyZXMucHVzaCh7XG4gICAgICAgICAgICBnZW9tZXRyeTogc2ltcGxpZmllZCxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICB0YWdzOiBmZWF0dXJlLnRhZ3MgfHwgbnVsbFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMudGlsZSA9IHRyYW5zZm9ybVRpbGU7XG5leHBvcnRzLnBvaW50ID0gdHJhbnNmb3JtUG9pbnQ7XG5cbi8vIFRyYW5zZm9ybXMgdGhlIGNvb3JkaW5hdGVzIG9mIGVhY2ggZmVhdHVyZSBpbiB0aGUgZ2l2ZW4gdGlsZSBmcm9tXG4vLyBtZXJjYXRvci1wcm9qZWN0ZWQgc3BhY2UgaW50byAoZXh0ZW50IHggZXh0ZW50KSB0aWxlIHNwYWNlLlxuZnVuY3Rpb24gdHJhbnNmb3JtVGlsZSh0aWxlLCBleHRlbnQpIHtcbiAgICBpZiAodGlsZS50cmFuc2Zvcm1lZCkgcmV0dXJuIHRpbGU7XG5cbiAgICB2YXIgejIgPSB0aWxlLnoyLFxuICAgICAgICB0eCA9IHRpbGUueCxcbiAgICAgICAgdHkgPSB0aWxlLnksXG4gICAgICAgIGksIGosIGs7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGlsZS5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IHRpbGUuZmVhdHVyZXNbaV0sXG4gICAgICAgICAgICBnZW9tID0gZmVhdHVyZS5nZW9tZXRyeSxcbiAgICAgICAgICAgIHR5cGUgPSBmZWF0dXJlLnR5cGU7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnZW9tLmxlbmd0aDsgaisrKSBnZW9tW2pdID0gdHJhbnNmb3JtUG9pbnQoZ2VvbVtqXSwgZXh0ZW50LCB6MiwgdHgsIHR5KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdlb20ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmluZyA9IGdlb21bal07XG4gICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHJpbmcubGVuZ3RoOyBrKyspIHJpbmdba10gPSB0cmFuc2Zvcm1Qb2ludChyaW5nW2tdLCBleHRlbnQsIHoyLCB0eCwgdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGlsZS50cmFuc2Zvcm1lZCA9IHRydWU7XG5cbiAgICByZXR1cm4gdGlsZTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnQocCwgZXh0ZW50LCB6MiwgdHgsIHR5KSB7XG4gICAgdmFyIHggPSBNYXRoLnJvdW5kKGV4dGVudCAqIChwWzBdICogejIgLSB0eCkpLFxuICAgICAgICB5ID0gTWF0aC5yb3VuZChleHRlbnQgKiAocFsxXSAqIHoyIC0gdHkpKTtcbiAgICByZXR1cm4gW3gsIHldO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xpcCA9IHJlcXVpcmUoJy4vY2xpcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXA7XG5cbmZ1bmN0aW9uIHdyYXAoZmVhdHVyZXMsIGJ1ZmZlciwgaW50ZXJzZWN0WCkge1xuICAgIHZhciBtZXJnZWQgPSBmZWF0dXJlcyxcbiAgICAgICAgbGVmdCAgPSBjbGlwKGZlYXR1cmVzLCAxLCAtMSAtIGJ1ZmZlciwgYnVmZmVyLCAgICAgMCwgaW50ZXJzZWN0WCwgLTEsIDIpLCAvLyBsZWZ0IHdvcmxkIGNvcHlcbiAgICAgICAgcmlnaHQgPSBjbGlwKGZlYXR1cmVzLCAxLCAgMSAtIGJ1ZmZlciwgMiArIGJ1ZmZlciwgMCwgaW50ZXJzZWN0WCwgLTEsIDIpOyAvLyByaWdodCB3b3JsZCBjb3B5XG5cbiAgICBpZiAobGVmdCB8fCByaWdodCkge1xuICAgICAgICBtZXJnZWQgPSBjbGlwKGZlYXR1cmVzLCAxLCAtYnVmZmVyLCAxICsgYnVmZmVyLCAwLCBpbnRlcnNlY3RYLCAtMSwgMik7IC8vIGNlbnRlciB3b3JsZCBjb3B5XG5cbiAgICAgICAgaWYgKGxlZnQpIG1lcmdlZCA9IHNoaWZ0RmVhdHVyZUNvb3JkcyhsZWZ0LCAxKS5jb25jYXQobWVyZ2VkKTsgLy8gbWVyZ2UgbGVmdCBpbnRvIGNlbnRlclxuICAgICAgICBpZiAocmlnaHQpIG1lcmdlZCA9IG1lcmdlZC5jb25jYXQoc2hpZnRGZWF0dXJlQ29vcmRzKHJpZ2h0LCAtMSkpOyAvLyBtZXJnZSByaWdodCBpbnRvIGNlbnRlclxuICAgIH1cblxuICAgIHJldHVybiBtZXJnZWQ7XG59XG5cbmZ1bmN0aW9uIHNoaWZ0RmVhdHVyZUNvb3JkcyhmZWF0dXJlcywgb2Zmc2V0KSB7XG4gICAgdmFyIG5ld0ZlYXR1cmVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbaV0sXG4gICAgICAgICAgICB0eXBlID0gZmVhdHVyZS50eXBlO1xuXG4gICAgICAgIHZhciBuZXdHZW9tZXRyeTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgbmV3R2VvbWV0cnkgPSBzaGlmdENvb3JkcyhmZWF0dXJlLmdlb21ldHJ5LCBvZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3R2VvbWV0cnkgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmVhdHVyZS5nZW9tZXRyeS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIG5ld0dlb21ldHJ5LnB1c2goc2hpZnRDb29yZHMoZmVhdHVyZS5nZW9tZXRyeVtqXSwgb2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBuZXdGZWF0dXJlcy5wdXNoKHtcbiAgICAgICAgICAgIGdlb21ldHJ5OiBuZXdHZW9tZXRyeSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICB0YWdzOiBmZWF0dXJlLnRhZ3MsXG4gICAgICAgICAgICBtaW46IFtmZWF0dXJlLm1pblswXSArIG9mZnNldCwgZmVhdHVyZS5taW5bMV1dLFxuICAgICAgICAgICAgbWF4OiBbZmVhdHVyZS5tYXhbMF0gKyBvZmZzZXQsIGZlYXR1cmUubWF4WzFdXVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RmVhdHVyZXM7XG59XG5cbmZ1bmN0aW9uIHNoaWZ0Q29vcmRzKHBvaW50cywgb2Zmc2V0KSB7XG4gICAgdmFyIG5ld1BvaW50cyA9IFtdO1xuICAgIG5ld1BvaW50cy5hcmVhID0gcG9pbnRzLmFyZWE7XG4gICAgbmV3UG9pbnRzLmRpc3QgPSBwb2ludHMuZGlzdDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld1BvaW50cy5wdXNoKFtwb2ludHNbaV1bMF0gKyBvZmZzZXQsIHBvaW50c1tpXVsxXSwgcG9pbnRzW2ldWzJdXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdQb2ludHM7XG59XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgZ2wtbWF0cml4IC0gSGlnaCBwZXJmb3JtYW5jZSBtYXRyaXggYW5kIHZlY3RvciBvcGVyYXRpb25zXG4gKiBAYXV0aG9yIEJyYW5kb24gSm9uZXNcbiAqIEBhdXRob3IgQ29saW4gTWFjS2VuemllIElWXG4gKiBAdmVyc2lvbiAyLjMuMlxuICovXG5cbi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG4vLyBFTkQgSEVBREVSXG5cbmV4cG9ydHMuZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvY29tbW9uLmpzXCIpO1xuZXhwb3J0cy5tYXQyID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L21hdDIuanNcIik7XG5leHBvcnRzLm1hdDJkID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L21hdDJkLmpzXCIpO1xuZXhwb3J0cy5tYXQzID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L21hdDMuanNcIik7XG5leHBvcnRzLm1hdDQgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvbWF0NC5qc1wiKTtcbmV4cG9ydHMucXVhdCA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9xdWF0LmpzXCIpO1xuZXhwb3J0cy52ZWMyID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L3ZlYzIuanNcIik7XG5leHBvcnRzLnZlYzMgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvdmVjMy5qc1wiKTtcbmV4cG9ydHMudmVjNCA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC92ZWM0LmpzXCIpOyIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbi8qKlxuICogQGNsYXNzIENvbW1vbiB1dGlsaXRpZXNcbiAqIEBuYW1lIGdsTWF0cml4XG4gKi9cbnZhciBnbE1hdHJpeCA9IHt9O1xuXG4vLyBDb25maWd1cmF0aW9uIENvbnN0YW50c1xuZ2xNYXRyaXguRVBTSUxPTiA9IDAuMDAwMDAxO1xuZ2xNYXRyaXguQVJSQVlfVFlQRSA9ICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJykgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbmdsTWF0cml4LlJBTkRPTSA9IE1hdGgucmFuZG9tO1xuZ2xNYXRyaXguRU5BQkxFX1NJTUQgPSBmYWxzZTtcblxuLy8gQ2FwYWJpbGl0eSBkZXRlY3Rpb25cbmdsTWF0cml4LlNJTURfQVZBSUxBQkxFID0gKGdsTWF0cml4LkFSUkFZX1RZUEUgPT09IEZsb2F0MzJBcnJheSkgJiYgKCdTSU1EJyBpbiB0aGlzKTtcbmdsTWF0cml4LlVTRV9TSU1EID0gZ2xNYXRyaXguRU5BQkxFX1NJTUQgJiYgZ2xNYXRyaXguU0lNRF9BVkFJTEFCTEU7XG5cbi8qKlxuICogU2V0cyB0aGUgdHlwZSBvZiBhcnJheSB1c2VkIHdoZW4gY3JlYXRpbmcgbmV3IHZlY3RvcnMgYW5kIG1hdHJpY2VzXG4gKlxuICogQHBhcmFtIHtUeXBlfSB0eXBlIEFycmF5IHR5cGUsIHN1Y2ggYXMgRmxvYXQzMkFycmF5IG9yIEFycmF5XG4gKi9cbmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBnbE1hdHJpeC5BUlJBWV9UWVBFID0gdHlwZTtcbn1cblxudmFyIGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG5cbi8qKlxuKiBDb252ZXJ0IERlZ3JlZSBUbyBSYWRpYW5cbipcbiogQHBhcmFtIHtOdW1iZXJ9IEFuZ2xlIGluIERlZ3JlZXNcbiovXG5nbE1hdHJpeC50b1JhZGlhbiA9IGZ1bmN0aW9uKGEpe1xuICAgICByZXR1cm4gYSAqIGRlZ3JlZTtcbn1cblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIG9yIG5vdCB0aGUgYXJndW1lbnRzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSB2YWx1ZSwgd2l0aGluIGFuIGFic29sdXRlXG4gKiBvciByZWxhdGl2ZSB0b2xlcmFuY2Ugb2YgZ2xNYXRyaXguRVBTSUxPTiAoYW4gYWJzb2x1dGUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIHZhbHVlcyBsZXNzIFxuICogdGhhbiBvciBlcXVhbCB0byAxLjAsIGFuZCBhIHJlbGF0aXZlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciBsYXJnZXIgdmFsdWVzKVxuICogXG4gKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgZmlyc3QgbnVtYmVyIHRvIHRlc3QuXG4gKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgc2Vjb25kIG51bWJlciB0byB0ZXN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZ2xNYXRyaXguZXF1YWxzID0gZnVuY3Rpb24oYSwgYikge1xuXHRyZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhKSwgTWF0aC5hYnMoYikpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdsTWF0cml4O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyAyeDIgTWF0cml4XG4gKiBAbmFtZSBtYXQyXG4gKi9cbnZhciBtYXQyID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyXG4gKlxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xubWF0Mi5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5tYXQyLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MiB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdDIgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHJldHVybnMge21hdDJ9IG91dCBBIG5ldyAyeDIgbWF0cml4XG4gKi9cbm1hdDIuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKG0wMCwgbTAxLCBtMTAsIG0xMSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSBtMDA7XG4gICAgb3V0WzFdID0gbTAxO1xuICAgIG91dFsyXSA9IG0xMDtcbiAgICBvdXRbM10gPSBtMTE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0MiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5zZXQgPSBmdW5jdGlvbihvdXQsIG0wMCwgbTAxLCBtMTAsIG0xMSkge1xuICAgIG91dFswXSA9IG0wMDtcbiAgICBvdXRbMV0gPSBtMDE7XG4gICAgb3V0WzJdID0gbTEwO1xuICAgIG91dFszXSA9IG0xMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTEgPSBhWzFdO1xuICAgICAgICBvdXRbMV0gPSBhWzJdO1xuICAgICAgICBvdXRbMl0gPSBhMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzJdO1xuICAgICAgICBvdXRbMl0gPSBhWzFdO1xuICAgICAgICBvdXRbM10gPSBhWzNdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYTAgKiBhMyAtIGEyICogYTE7XG5cbiAgICBpZiAoIWRldCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuICAgIFxuICAgIG91dFswXSA9ICBhMyAqIGRldDtcbiAgICBvdXRbMV0gPSAtYTEgKiBkZXQ7XG4gICAgb3V0WzJdID0gLWEyICogZGV0O1xuICAgIG91dFszXSA9ICBhMCAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gQ2FjaGluZyB0aGlzIHZhbHVlIGlzIG5lc3NlY2FyeSBpZiBvdXQgPT0gYVxuICAgIHZhciBhMCA9IGFbMF07XG4gICAgb3V0WzBdID0gIGFbM107XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgb3V0WzNdID0gIGEwO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDIuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBhWzBdICogYVszXSAtIGFbMl0gKiBhWzFdO1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICAgIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICAgIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICAgIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICAgIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0Mi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQyLm11bCA9IG1hdDIubXVsdGlwbHk7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDIgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuICAgICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgb3V0WzBdID0gYTAgKiAgYyArIGEyICogcztcbiAgICBvdXRbMV0gPSBhMSAqICBjICsgYTMgKiBzO1xuICAgIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gICAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDIgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICoqL1xubWF0Mi5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICAgIG91dFswXSA9IGEwICogdjA7XG4gICAgb3V0WzFdID0gYTEgKiB2MDtcbiAgICBvdXRbMl0gPSBhMiAqIHYxO1xuICAgIG91dFszXSA9IGEzICogdjE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDIucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgbWF0MiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5mcm9tUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgb3V0WzBdID0gYztcbiAgICBvdXRbMV0gPSBzO1xuICAgIG91dFsyXSA9IC1zO1xuICAgIG91dFszXSA9IGM7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0Mi5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IG1hdDIgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmZyb21TY2FsaW5nID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gdlswXTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gdlsxXTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0Mi5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MignICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDIuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSkpXG59O1xuXG4vKipcbiAqIFJldHVybnMgTCwgRCBhbmQgVSBtYXRyaWNlcyAoTG93ZXIgdHJpYW5ndWxhciwgRGlhZ29uYWwgYW5kIFVwcGVyIHRyaWFuZ3VsYXIpIGJ5IGZhY3Rvcml6aW5nIHRoZSBpbnB1dCBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gTCB0aGUgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXggXG4gKiBAcGFyYW0ge21hdDJ9IEQgdGhlIGRpYWdvbmFsIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gVSB0aGUgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXggXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGlucHV0IG1hdHJpeCB0byBmYWN0b3JpemVcbiAqL1xuXG5tYXQyLkxEVSA9IGZ1bmN0aW9uIChMLCBELCBVLCBhKSB7IFxuICAgIExbMl0gPSBhWzJdL2FbMF07IFxuICAgIFVbMF0gPSBhWzBdOyBcbiAgICBVWzFdID0gYVsxXTsgXG4gICAgVVszXSA9IGFbM10gLSBMWzJdICogVVsxXTsgXG4gICAgcmV0dXJuIFtMLCBELCBVXTsgICAgICAgXG59OyBcblxuLyoqXG4gKiBBZGRzIHR3byBtYXQyJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSArIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0Mi5zdWIgPSBtYXQyLnN1YnRyYWN0O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xubWF0Mi5leGFjdEVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM107XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xubWF0Mi5lcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkpO1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5tdWx0aXBseVNjYWxhciA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIG91dFszXSA9IGFbM10gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDIncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIubXVsdGlwbHlTY2FsYXJBbmRBZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSk7XG4gICAgb3V0WzNdID0gYVszXSArIChiWzNdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdDI7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDJ4MyBNYXRyaXhcbiAqIEBuYW1lIG1hdDJkXG4gKiBcbiAqIEBkZXNjcmlwdGlvbiBcbiAqIEEgbWF0MmQgY29udGFpbnMgc2l4IGVsZW1lbnRzIGRlZmluZWQgYXM6XG4gKiA8cHJlPlxuICogW2EsIGMsIHR4LFxuICogIGIsIGQsIHR5XVxuICogPC9wcmU+XG4gKiBUaGlzIGlzIGEgc2hvcnQgZm9ybSBmb3IgdGhlIDN4MyBtYXRyaXg6XG4gKiA8cHJlPlxuICogW2EsIGMsIHR4LFxuICogIGIsIGQsIHR5LFxuICogIDAsIDAsIDFdXG4gKiA8L3ByZT5cbiAqIFRoZSBsYXN0IHJvdyBpcyBpZ25vcmVkIHNvIHRoZSBhcnJheSBpcyBzaG9ydGVyIGFuZCBvcGVyYXRpb25zIGFyZSBmYXN0ZXIuXG4gKi9cbnZhciBtYXQyZCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MmRcbiAqXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xubWF0MmQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MmQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDJkfSBhIG5ldyAyeDMgbWF0cml4XG4gKi9cbm1hdDJkLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MmQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDJkIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdDJkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIENvbXBvbmVudCBBIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgQ29tcG9uZW50IEIgKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gYyBDb21wb25lbnQgQyAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBkIENvbXBvbmVudCBEIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IHR4IENvbXBvbmVudCBUWCAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eSBDb21wb25lbnQgVFkgKGluZGV4IDUpXG4gKiBAcmV0dXJucyB7bWF0MmR9IEEgbmV3IG1hdDJkXG4gKi9cbm1hdDJkLmZyb21WYWx1ZXMgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gICAgb3V0WzBdID0gYTtcbiAgICBvdXRbMV0gPSBiO1xuICAgIG91dFsyXSA9IGM7XG4gICAgb3V0WzNdID0gZDtcbiAgICBvdXRbNF0gPSB0eDtcbiAgICBvdXRbNV0gPSB0eTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQyZCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gYSBDb21wb25lbnQgQSAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIENvbXBvbmVudCBCIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IGMgQ29tcG9uZW50IEMgKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gZCBDb21wb25lbnQgRCAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eCBDb21wb25lbnQgVFggKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gdHkgQ29tcG9uZW50IFRZIChpbmRleCA1KVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuc2V0ID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgICBvdXRbMF0gPSBhO1xuICAgIG91dFsxXSA9IGI7XG4gICAgb3V0WzJdID0gYztcbiAgICBvdXRbM10gPSBkO1xuICAgIG91dFs0XSA9IHR4O1xuICAgIG91dFs1XSA9IHR5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGFhID0gYVswXSwgYWIgPSBhWzFdLCBhYyA9IGFbMl0sIGFkID0gYVszXSxcbiAgICAgICAgYXR4ID0gYVs0XSwgYXR5ID0gYVs1XTtcblxuICAgIHZhciBkZXQgPSBhYSAqIGFkIC0gYWIgKiBhYztcbiAgICBpZighZGV0KXtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IGFkICogZGV0O1xuICAgIG91dFsxXSA9IC1hYiAqIGRldDtcbiAgICBvdXRbMl0gPSAtYWMgKiBkZXQ7XG4gICAgb3V0WzNdID0gYWEgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xuICAgIG91dFs1XSA9IChhYiAqIGF0eCAtIGFhICogYXR5KSAqIGRldDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5tYXQyZC5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsxXSAqIGFbMl07XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDJkJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdLCBiNCA9IGJbNF0sIGI1ID0gYls1XTtcbiAgICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcbiAgICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMTtcbiAgICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcbiAgICBvdXRbNF0gPSBhMCAqIGI0ICsgYTIgKiBiNSArIGE0O1xuICAgIG91dFs1XSA9IGExICogYjQgKyBhMyAqIGI1ICsgYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyZC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQyZC5tdWwgPSBtYXQyZC5tdWx0aXBseTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MmQgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sXG4gICAgICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBhMCAqICBjICsgYTIgKiBzO1xuICAgIG91dFsxXSA9IGExICogIGMgKyBhMyAqIHM7XG4gICAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICAgIG91dFs0XSA9IGE0O1xuICAgIG91dFs1XSA9IGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MmQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICoqL1xubWF0MmQuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTAgKiB2MDtcbiAgICBvdXRbMV0gPSBhMSAqIHYwO1xuICAgIG91dFsyXSA9IGEyICogdjE7XG4gICAgb3V0WzNdID0gYTMgKiB2MTtcbiAgICBvdXRbNF0gPSBhNDtcbiAgICBvdXRbNV0gPSBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHRyYW5zbGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICoqL1xubWF0MmQudHJhbnNsYXRlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sXG4gICAgICAgIHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICAgIG91dFswXSA9IGEwO1xuICAgIG91dFsxXSA9IGExO1xuICAgIG91dFsyXSA9IGEyO1xuICAgIG91dFszXSA9IGEzO1xuICAgIG91dFs0XSA9IGEwICogdjAgKyBhMiAqIHYxICsgYTQ7XG4gICAgb3V0WzVdID0gYTEgKiB2MCArIGEzICogdjEgKyBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDJkLnJvdGF0ZShkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmZyb21Sb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLCBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBjO1xuICAgIG91dFsxXSA9IHM7XG4gICAgb3V0WzJdID0gLXM7XG4gICAgb3V0WzNdID0gYztcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDJkLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmZyb21TY2FsaW5nID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gdlswXTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gdlsxXTtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyZC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmZyb21UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgb3V0WzRdID0gdlswXTtcbiAgICBvdXRbNV0gPSB2WzFdO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQyZC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MmQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzNdICsgJywgJyArIGFbNF0gKyAnLCAnICsgYVs1XSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0MmQuZnJvYiA9IGZ1bmN0aW9uIChhKSB7IFxuICAgIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgMSkpXG59OyBcblxuLyoqXG4gKiBBZGRzIHR3byBtYXQyZCdzXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSArIGJbM107XG4gICAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gICAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICAgIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICAgIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0MmQuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0MmQuc3ViID0gbWF0MmQuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLm11bHRpcGx5U2NhbGFyID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgb3V0WzNdID0gYVszXSAqIGI7XG4gICAgb3V0WzRdID0gYVs0XSAqIGI7XG4gICAgb3V0WzVdID0gYVs1XSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MmQncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5tdWx0aXBseVNjYWxhckFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gICAgb3V0WzRdID0gYVs0XSArIChiWzRdICogc2NhbGUpO1xuICAgIG91dFs1XSA9IGFbNV0gKyAoYls1XSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQyZH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xubWF0MmQuZXhhY3RFcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0MmR9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbm1hdDJkLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV07XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXSwgYjQgPSBiWzRdLCBiNSA9IGJbNV07XG4gICAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0MmQ7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDN4MyBNYXRyaXhcbiAqIEBuYW1lIG1hdDNcbiAqL1xudmFyIG1hdDMgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDNcbiAqXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5tYXQzLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDE7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3BpZXMgdGhlIHVwcGVyLWxlZnQgM3gzIHZhbHVlcyBpbnRvIHRoZSBnaXZlbiBtYXQzLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgM3gzIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhICAgdGhlIHNvdXJjZSA0eDQgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuZnJvbU1hdDQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzRdO1xuICAgIG91dFs0XSA9IGFbNV07XG4gICAgb3V0WzVdID0gYVs2XTtcbiAgICBvdXRbNl0gPSBhWzhdO1xuICAgIG91dFs3XSA9IGFbOV07XG4gICAgb3V0WzhdID0gYVsxMF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcbiAqL1xubWF0My5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdDMgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHJldHVybnMge21hdDN9IEEgbmV3IG1hdDNcbiAqL1xubWF0My5mcm9tVmFsdWVzID0gZnVuY3Rpb24obTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMiwgbTIwLCBtMjEsIG0yMikge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgICBvdXRbMF0gPSBtMDA7XG4gICAgb3V0WzFdID0gbTAxO1xuICAgIG91dFsyXSA9IG0wMjtcbiAgICBvdXRbM10gPSBtMTA7XG4gICAgb3V0WzRdID0gbTExO1xuICAgIG91dFs1XSA9IG0xMjtcbiAgICBvdXRbNl0gPSBtMjA7XG4gICAgb3V0WzddID0gbTIxO1xuICAgIG91dFs4XSA9IG0yMjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLnNldCA9IGZ1bmN0aW9uKG91dCwgbTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMiwgbTIwLCBtMjEsIG0yMikge1xuICAgIG91dFswXSA9IG0wMDtcbiAgICBvdXRbMV0gPSBtMDE7XG4gICAgb3V0WzJdID0gbTAyO1xuICAgIG91dFszXSA9IG0xMDtcbiAgICBvdXRbNF0gPSBtMTE7XG4gICAgb3V0WzVdID0gbTEyO1xuICAgIG91dFs2XSA9IG0yMDtcbiAgICBvdXRbN10gPSBtMjE7XG4gICAgb3V0WzhdID0gbTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDMgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDE7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgIGlmIChvdXQgPT09IGEpIHtcbiAgICAgICAgdmFyIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGExMiA9IGFbNV07XG4gICAgICAgIG91dFsxXSA9IGFbM107XG4gICAgICAgIG91dFsyXSA9IGFbNl07XG4gICAgICAgIG91dFszXSA9IGEwMTtcbiAgICAgICAgb3V0WzVdID0gYVs3XTtcbiAgICAgICAgb3V0WzZdID0gYTAyO1xuICAgICAgICBvdXRbN10gPSBhMTI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVszXTtcbiAgICAgICAgb3V0WzJdID0gYVs2XTtcbiAgICAgICAgb3V0WzNdID0gYVsxXTtcbiAgICAgICAgb3V0WzRdID0gYVs0XTtcbiAgICAgICAgb3V0WzVdID0gYVs3XTtcbiAgICAgICAgb3V0WzZdID0gYVsyXTtcbiAgICAgICAgb3V0WzddID0gYVs1XTtcbiAgICAgICAgb3V0WzhdID0gYVs4XTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICAgICAgYjAxID0gYTIyICogYTExIC0gYTEyICogYTIxLFxuICAgICAgICBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwLFxuICAgICAgICBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjAsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7XG5cbiAgICBpZiAoIWRldCkgeyBcbiAgICAgICAgcmV0dXJuIG51bGw7IFxuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSBiMDEgKiBkZXQ7XG4gICAgb3V0WzFdID0gKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpICogZGV0O1xuICAgIG91dFsyXSA9IChhMTIgKiBhMDEgLSBhMDIgKiBhMTEpICogZGV0O1xuICAgIG91dFszXSA9IGIxMSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTIyICogYTAwIC0gYTAyICogYTIwKSAqIGRldDtcbiAgICBvdXRbNV0gPSAoLWExMiAqIGEwMCArIGEwMiAqIGExMCkgKiBkZXQ7XG4gICAgb3V0WzZdID0gYjIxICogZGV0O1xuICAgIG91dFs3XSA9ICgtYTIxICogYTAwICsgYTAxICogYTIwKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTExICogYTAwIC0gYTAxICogYTEwKSAqIGRldDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGEyMiAtIGExMiAqIGEyMSk7XG4gICAgb3V0WzFdID0gKGEwMiAqIGEyMSAtIGEwMSAqIGEyMik7XG4gICAgb3V0WzJdID0gKGEwMSAqIGExMiAtIGEwMiAqIGExMSk7XG4gICAgb3V0WzNdID0gKGExMiAqIGEyMCAtIGExMCAqIGEyMik7XG4gICAgb3V0WzRdID0gKGEwMCAqIGEyMiAtIGEwMiAqIGEyMCk7XG4gICAgb3V0WzVdID0gKGEwMiAqIGExMCAtIGEwMCAqIGExMik7XG4gICAgb3V0WzZdID0gKGExMCAqIGEyMSAtIGExMSAqIGEyMCk7XG4gICAgb3V0WzddID0gKGEwMSAqIGEyMCAtIGEwMCAqIGEyMSk7XG4gICAgb3V0WzhdID0gKGEwMCAqIGExMSAtIGEwMSAqIGExMCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDMuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gICAgcmV0dXJuIGEwMCAqIChhMjIgKiBhMTEgLSBhMTIgKiBhMjEpICsgYTAxICogKC1hMjIgKiBhMTAgKyBhMTIgKiBhMjApICsgYTAyICogKGEyMSAqIGExMCAtIGExMSAqIGEyMCk7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDMnc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBiMDAgPSBiWzBdLCBiMDEgPSBiWzFdLCBiMDIgPSBiWzJdLFxuICAgICAgICBiMTAgPSBiWzNdLCBiMTEgPSBiWzRdLCBiMTIgPSBiWzVdLFxuICAgICAgICBiMjAgPSBiWzZdLCBiMjEgPSBiWzddLCBiMjIgPSBiWzhdO1xuXG4gICAgb3V0WzBdID0gYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwO1xuICAgIG91dFsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcbiAgICBvdXRbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjI7XG5cbiAgICBvdXRbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XG4gICAgb3V0WzRdID0gYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxO1xuICAgIG91dFs1XSA9IGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMjtcblxuICAgIG91dFs2XSA9IGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMDtcbiAgICBvdXRbN10gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjE7XG4gICAgb3V0WzhdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQzLm11bCA9IG1hdDMubXVsdGlwbHk7XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0MyBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My50cmFuc2xhdGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcbiAgICAgICAgeCA9IHZbMF0sIHkgPSB2WzFdO1xuXG4gICAgb3V0WzBdID0gYTAwO1xuICAgIG91dFsxXSA9IGEwMTtcbiAgICBvdXRbMl0gPSBhMDI7XG5cbiAgICBvdXRbM10gPSBhMTA7XG4gICAgb3V0WzRdID0gYTExO1xuICAgIG91dFs1XSA9IGExMjtcblxuICAgIG91dFs2XSA9IHggKiBhMDAgKyB5ICogYTEwICsgYTIwO1xuICAgIG91dFs3XSA9IHggKiBhMDEgKyB5ICogYTExICsgYTIxO1xuICAgIG91dFs4XSA9IHggKiBhMDIgKyB5ICogYTEyICsgYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQzIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYyAqIGEwMCArIHMgKiBhMTA7XG4gICAgb3V0WzFdID0gYyAqIGEwMSArIHMgKiBhMTE7XG4gICAgb3V0WzJdID0gYyAqIGEwMiArIHMgKiBhMTI7XG5cbiAgICBvdXRbM10gPSBjICogYTEwIC0gcyAqIGEwMDtcbiAgICBvdXRbNF0gPSBjICogYTExIC0gcyAqIGEwMTtcbiAgICBvdXRbNV0gPSBjICogYTEyIC0gcyAqIGEwMjtcblxuICAgIG91dFs2XSA9IGEyMDtcbiAgICBvdXRbN10gPSBhMjE7XG4gICAgb3V0WzhdID0gYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MyBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5tYXQzLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXTtcblxuICAgIG91dFswXSA9IHggKiBhWzBdO1xuICAgIG91dFsxXSA9IHggKiBhWzFdO1xuICAgIG91dFsyXSA9IHggKiBhWzJdO1xuXG4gICAgb3V0WzNdID0geSAqIGFbM107XG4gICAgb3V0WzRdID0geSAqIGFbNF07XG4gICAgb3V0WzVdID0geSAqIGFbNV07XG5cbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmZyb21UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMTtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IHZbMF07XG4gICAgb3V0WzddID0gdlsxXTtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5mcm9tUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSwgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBjO1xuICAgIG91dFsxXSA9IHM7XG4gICAgb3V0WzJdID0gMDtcblxuICAgIG91dFszXSA9IC1zO1xuICAgIG91dFs0XSA9IGM7XG4gICAgb3V0WzVdID0gMDtcblxuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5mcm9tU2NhbGluZyA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IHZbMF07XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuXG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB2WzFdO1xuICAgIG91dFs1XSA9IDA7XG5cbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIGZyb20gYSBtYXQyZCBpbnRvIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY29weVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xubWF0My5mcm9tTWF0MmQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gMDtcblxuICAgIG91dFszXSA9IGFbMl07XG4gICAgb3V0WzRdID0gYVszXTtcbiAgICBvdXRbNV0gPSAwO1xuXG4gICAgb3V0WzZdID0gYVs0XTtcbiAgICBvdXRbN10gPSBhWzVdO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHtxdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4qXG4qIEByZXR1cm5zIHttYXQzfSBvdXRcbiovXG5tYXQzLmZyb21RdWF0ID0gZnVuY3Rpb24gKG91dCwgcSkge1xuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeXggPSB5ICogeDIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB6eCA9IHogKiB4MixcbiAgICAgICAgenkgPSB6ICogeTIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gICAgb3V0WzNdID0geXggLSB3ejtcbiAgICBvdXRbNl0gPSB6eCArIHd5O1xuXG4gICAgb3V0WzFdID0geXggKyB3ejtcbiAgICBvdXRbNF0gPSAxIC0geHggLSB6ejtcbiAgICBvdXRbN10gPSB6eSAtIHd4O1xuXG4gICAgb3V0WzJdID0genggLSB3eTtcbiAgICBvdXRbNV0gPSB6eSArIHd4O1xuICAgIG91dFs4XSA9IDEgLSB4eCAtIHl5O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG5vcm1hbCBtYXRyaXggKHRyYW5zcG9zZSBpbnZlcnNlKSBmcm9tIHRoZSA0eDQgbWF0cml4XG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHttYXQ0fSBhIE1hdDQgdG8gZGVyaXZlIHRoZSBub3JtYWwgbWF0cml4IGZyb21cbipcbiogQHJldHVybnMge21hdDN9IG91dFxuKi9cbm1hdDMubm9ybWFsRnJvbU1hdDQgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFsyXSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuXG4gICAgb3V0WzNdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG5cbiAgICBvdXRbNl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0My5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MygnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICsgYVs4XSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDMuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyBNYXRoLnBvdyhhWzZdLCAyKSArIE1hdGgucG93KGFbN10sIDIpICsgTWF0aC5wb3coYVs4XSwgMikpKVxufTtcblxuLyoqXG4gKiBBZGRzIHR3byBtYXQzJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSArIGJbM107XG4gICAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gICAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gICAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gICAgb3V0WzddID0gYVs3XSArIGJbN107XG4gICAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgICBvdXRbNl0gPSBhWzZdIC0gYls2XTtcbiAgICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDMuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0My5zdWIgPSBtYXQzLnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLm11bHRpcGx5U2NhbGFyID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgb3V0WzNdID0gYVszXSAqIGI7XG4gICAgb3V0WzRdID0gYVs0XSAqIGI7XG4gICAgb3V0WzVdID0gYVs1XSAqIGI7XG4gICAgb3V0WzZdID0gYVs2XSAqIGI7XG4gICAgb3V0WzddID0gYVs3XSAqIGI7XG4gICAgb3V0WzhdID0gYVs4XSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MydzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5tdWx0aXBseVNjYWxhckFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gICAgb3V0WzRdID0gYVs0XSArIChiWzRdICogc2NhbGUpO1xuICAgIG91dFs1XSA9IGFbNV0gKyAoYls1XSAqIHNjYWxlKTtcbiAgICBvdXRbNl0gPSBhWzZdICsgKGJbNl0gKiBzY2FsZSk7XG4gICAgb3V0WzddID0gYVs3XSArIChiWzddICogc2NhbGUpO1xuICAgIG91dFs4XSA9IGFbOF0gKyAoYls4XSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLypcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0M30gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xubWF0My5leGFjdEVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIFxuICAgICAgICAgICBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XSAmJlxuICAgICAgICAgICBhWzZdID09PSBiWzZdICYmIGFbN10gPT09IGJbN10gJiYgYVs4XSA9PT0gYls4XTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQzfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQzLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sIGE2ID0gYVs2XSwgYTcgPSBhWzddLCBhOCA9IGFbOF07XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXSwgYjQgPSBiWzRdLCBiNSA9IGJbNV0sIGI2ID0gYVs2XSwgYjcgPSBiWzddLCBiOCA9IGJbOF07XG4gICAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNiAtIGI2KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhOCAtIGI4KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTgpLCBNYXRoLmFicyhiOCkpKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBtYXQzO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyA0eDQgTWF0cml4XG4gKiBAbmFtZSBtYXQ0XG4gKi9cbnZhciBtYXQ0ID0ge1xuICBzY2FsYXI6IHt9LFxuICBTSU1EOiB7fSxcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQ0XG4gKlxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xubWF0NC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xubWF0NC5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIG91dFs5XSA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0NCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAzIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDMgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDUpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDYpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDgpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDkpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMyBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzAgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMTIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMiBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzMgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTUpXG4gKiBAcmV0dXJucyB7bWF0NH0gQSBuZXcgbWF0NFxuICovXG5tYXQ0LmZyb21WYWx1ZXMgPSBmdW5jdGlvbihtMDAsIG0wMSwgbTAyLCBtMDMsIG0xMCwgbTExLCBtMTIsIG0xMywgbTIwLCBtMjEsIG0yMiwgbTIzLCBtMzAsIG0zMSwgbTMyLCBtMzMpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICAgIG91dFswXSA9IG0wMDtcbiAgICBvdXRbMV0gPSBtMDE7XG4gICAgb3V0WzJdID0gbTAyO1xuICAgIG91dFszXSA9IG0wMztcbiAgICBvdXRbNF0gPSBtMTA7XG4gICAgb3V0WzVdID0gbTExO1xuICAgIG91dFs2XSA9IG0xMjtcbiAgICBvdXRbN10gPSBtMTM7XG4gICAgb3V0WzhdID0gbTIwO1xuICAgIG91dFs5XSA9IG0yMTtcbiAgICBvdXRbMTBdID0gbTIyO1xuICAgIG91dFsxMV0gPSBtMjM7XG4gICAgb3V0WzEyXSA9IG0zMDtcbiAgICBvdXRbMTNdID0gbTMxO1xuICAgIG91dFsxNF0gPSBtMzI7XG4gICAgb3V0WzE1XSA9IG0zMztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQ0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMyBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMyBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAzIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA5KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjMgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMwIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDAgcG9zaXRpb24gKGluZGV4IDEyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMSBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzIgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMzIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDMgcG9zaXRpb24gKGluZGV4IDE1KVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnNldCA9IGZ1bmN0aW9uKG91dCwgbTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gICAgb3V0WzBdID0gbTAwO1xuICAgIG91dFsxXSA9IG0wMTtcbiAgICBvdXRbMl0gPSBtMDI7XG4gICAgb3V0WzNdID0gbTAzO1xuICAgIG91dFs0XSA9IG0xMDtcbiAgICBvdXRbNV0gPSBtMTE7XG4gICAgb3V0WzZdID0gbTEyO1xuICAgIG91dFs3XSA9IG0xMztcbiAgICBvdXRbOF0gPSBtMjA7XG4gICAgb3V0WzldID0gbTIxO1xuICAgIG91dFsxMF0gPSBtMjI7XG4gICAgb3V0WzExXSA9IG0yMztcbiAgICBvdXRbMTJdID0gbTMwO1xuICAgIG91dFsxM10gPSBtMzE7XG4gICAgb3V0WzE0XSA9IG0zMjtcbiAgICBvdXRbMTVdID0gbTMzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5cbi8qKlxuICogU2V0IGEgbWF0NCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQ0IG5vdCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnNjYWxhci50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgICAgIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYTAxO1xuICAgICAgICBvdXRbNl0gPSBhWzldO1xuICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzhdID0gYTAyO1xuICAgICAgICBvdXRbOV0gPSBhMTI7XG4gICAgICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzEyXSA9IGEwMztcbiAgICAgICAgb3V0WzEzXSA9IGExMztcbiAgICAgICAgb3V0WzE0XSA9IGEyMztcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYVsxXTtcbiAgICAgICAgb3V0WzVdID0gYVs1XTtcbiAgICAgICAgb3V0WzZdID0gYVs5XTtcbiAgICAgICAgb3V0WzddID0gYVsxM107XG4gICAgICAgIG91dFs4XSA9IGFbMl07XG4gICAgICAgIG91dFs5XSA9IGFbNl07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTJdID0gYVszXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbN107XG4gICAgICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LlNJTUQudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwLCBhMSwgYTIsIGEzLFxuICAgICAgICB0bXAwMSwgdG1wMjMsXG4gICAgICAgIG91dDAsIG91dDEsIG91dDIsIG91dDM7XG5cbiAgICBhMCA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMCk7XG4gICAgYTEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDQpO1xuICAgIGEyID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA4KTtcbiAgICBhMyA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMTIpO1xuXG4gICAgdG1wMDEgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEwLCBhMSwgMCwgMSwgNCwgNSk7XG4gICAgdG1wMjMgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEyLCBhMywgMCwgMSwgNCwgNSk7XG4gICAgb3V0MCAgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHRtcDAxLCB0bXAyMywgMCwgMiwgNCwgNik7XG4gICAgb3V0MSAgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHRtcDAxLCB0bXAyMywgMSwgMywgNSwgNyk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAwLCAgb3V0MCk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA0LCAgb3V0MSk7XG5cbiAgICB0bXAwMSA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTAsIGExLCAyLCAzLCA2LCA3KTtcbiAgICB0bXAyMyA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTIsIGEzLCAyLCAzLCA2LCA3KTtcbiAgICBvdXQyICA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUodG1wMDEsIHRtcDIzLCAwLCAyLCA0LCA2KTtcbiAgICBvdXQzICA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUodG1wMDEsIHRtcDIzLCAxLCAzLCA1LCA3KTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDgsICBvdXQyKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDEyLCBvdXQzKTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcHNlIGEgbWF0NCB1c2luZyBTSU1EIGlmIGF2YWlsYWJsZSBhbmQgZW5hYmxlZFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC50cmFuc3Bvc2UgPSBnbE1hdHJpeC5VU0VfU0lNRCA/IG1hdDQuU0lNRC50cmFuc3Bvc2UgOiBtYXQ0LnNjYWxhci50cmFuc3Bvc2U7XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDQgbm90IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc2NhbGFyLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgICBpZiAoIWRldCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzNdID0gKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzZdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzldID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTJdID0gKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTVdID0gKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0NCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LlNJTUQuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gIHZhciByb3cwLCByb3cxLCByb3cyLCByb3czLFxuICAgICAgdG1wMSxcbiAgICAgIG1pbm9yMCwgbWlub3IxLCBtaW5vcjIsIG1pbm9yMyxcbiAgICAgIGRldCxcbiAgICAgIGEwID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAwKSxcbiAgICAgIGExID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA0KSxcbiAgICAgIGEyID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA4KSxcbiAgICAgIGEzID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAxMik7XG5cbiAgLy8gQ29tcHV0ZSBtYXRyaXggYWRqdWdhdGVcbiAgdG1wMSA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTAsIGExLCAwLCAxLCA0LCA1KTtcbiAgcm93MSA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTIsIGEzLCAwLCAxLCA0LCA1KTtcbiAgcm93MCA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUodG1wMSwgcm93MSwgMCwgMiwgNCwgNik7XG4gIHJvdzEgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHJvdzEsIHRtcDEsIDEsIDMsIDUsIDcpO1xuICB0bXAxID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMCwgYTEsIDIsIDMsIDYsIDcpO1xuICByb3czID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMiwgYTMsIDIsIDMsIDYsIDcpO1xuICByb3cyID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZSh0bXAxLCByb3czLCAwLCAyLCA0LCA2KTtcbiAgcm93MyA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUocm93MywgdG1wMSwgMSwgMywgNSwgNyk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHJvdzMpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSk7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKSwgbWlub3IwKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKSwgbWlub3IxKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZShtaW5vcjEsIDIsIDMsIDAsIDEpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCByb3cyKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSwgbWlub3IwKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IwLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSkpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpLCBtaW5vcjMpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKG1pbm9yMywgMiwgMywgMCwgMSk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUocm93MSwgMiwgMywgMCwgMSksIHJvdzMpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICByb3cyICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHJvdzIsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpLCBtaW5vcjApO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjAsIFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSk7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSksIG1pbm9yMik7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUobWlub3IyLCAyLCAzLCAwLCAxKTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgcm93MSk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSksIG1pbm9yMik7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSksIG1pbm9yMyk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSksIG1pbm9yMik7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjMsIFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHJvdzMpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IxLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSkpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpLCBtaW5vcjIpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpLCBtaW5vcjEpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IyLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSkpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCByb3cyKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSwgbWlub3IxKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMywgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMSwgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKSwgbWlub3IzKTtcblxuICAvLyBDb21wdXRlIG1hdHJpeCBkZXRlcm1pbmFudFxuICBkZXQgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCBtaW5vcjApO1xuICBkZXQgICA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGRldCwgMiwgMywgMCwgMSksIGRldCk7XG4gIGRldCAgID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoZGV0LCAxLCAwLCAzLCAyKSwgZGV0KTtcbiAgdG1wMSAgPSBTSU1ELkZsb2F0MzJ4NC5yZWNpcHJvY2FsQXBwcm94aW1hdGlvbihkZXQpO1xuICBkZXQgICA9IFNJTUQuRmxvYXQzMng0LnN1YihcbiAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZCh0bXAxLCB0bXAxKSxcbiAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChkZXQsIFNJTUQuRmxvYXQzMng0Lm11bCh0bXAxLCB0bXAxKSkpO1xuICBkZXQgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoZGV0LCAwLCAwLCAwLCAwKTtcbiAgaWYgKCFkZXQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSBtYXRyaXggaW52ZXJzZVxuICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDAsICBTSU1ELkZsb2F0MzJ4NC5tdWwoZGV0LCBtaW5vcjApKTtcbiAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA0LCAgU0lNRC5GbG9hdDMyeDQubXVsKGRldCwgbWlub3IxKSk7XG4gIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgOCwgIFNJTUQuRmxvYXQzMng0Lm11bChkZXQsIG1pbm9yMikpO1xuICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDEyLCBTSU1ELkZsb2F0MzJ4NC5tdWwoZGV0LCBtaW5vcjMpKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0NCB1c2luZyBTSU1EIGlmIGF2YWlsYWJsZSBhbmQgZW5hYmxlZFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5pbnZlcnQgPSBnbE1hdHJpeC5VU0VfU0lNRCA/IG1hdDQuU0lNRC5pbnZlcnQgOiBtYXQ0LnNjYWxhci5pbnZlcnQ7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQ0IG5vdCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnNjYWxhci5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICBvdXRbMF0gID0gIChhMTEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICAgIG91dFsxXSAgPSAtKGEwMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gICAgb3V0WzJdICA9ICAoYTAxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbM10gID0gLShhMDEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs0XSAgPSAtKGExMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gICAgb3V0WzVdICA9ICAoYTAwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgICBvdXRbNl0gID0gLShhMDAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs3XSAgPSAgKGEwMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTEwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzhdICA9ICAoYTEwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpKTtcbiAgICBvdXRbOV0gID0gLShhMDAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkpO1xuICAgIG91dFsxMF0gPSAgKGEwMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gICAgb3V0WzExXSA9IC0oYTAwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgICBvdXRbMTJdID0gLShhMTAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkpO1xuICAgIG91dFsxM10gPSAgKGEwMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSk7XG4gICAgb3V0WzE0XSA9IC0oYTAwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgICBvdXRbMTVdID0gIChhMDAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0NCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LlNJTUQuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICB2YXIgYTAsIGExLCBhMiwgYTM7XG4gIHZhciByb3cwLCByb3cxLCByb3cyLCByb3czO1xuICB2YXIgdG1wMTtcbiAgdmFyIG1pbm9yMCwgbWlub3IxLCBtaW5vcjIsIG1pbm9yMztcblxuICB2YXIgYTAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDApO1xuICB2YXIgYTEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDQpO1xuICB2YXIgYTIgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDgpO1xuICB2YXIgYTMgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDEyKTtcblxuICAvLyBUcmFuc3Bvc2UgdGhlIHNvdXJjZSBtYXRyaXguICBTb3J0IG9mLiAgTm90IGEgdHJ1ZSB0cmFuc3Bvc2Ugb3BlcmF0aW9uXG4gIHRtcDEgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEwLCBhMSwgMCwgMSwgNCwgNSk7XG4gIHJvdzEgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEyLCBhMywgMCwgMSwgNCwgNSk7XG4gIHJvdzAgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHRtcDEsIHJvdzEsIDAsIDIsIDQsIDYpO1xuICByb3cxID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShyb3cxLCB0bXAxLCAxLCAzLCA1LCA3KTtcblxuICB0bXAxID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMCwgYTEsIDIsIDMsIDYsIDcpO1xuICByb3czID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMiwgYTMsIDIsIDMsIDYsIDcpO1xuICByb3cyID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZSh0bXAxLCByb3czLCAwLCAyLCA0LCA2KTtcbiAgcm93MyA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUocm93MywgdG1wMSwgMSwgMywgNSwgNyk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHJvdzMpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSk7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKSwgbWlub3IwKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKSwgbWlub3IxKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZShtaW5vcjEsIDIsIDMsIDAsIDEpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCByb3cyKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSwgbWlub3IwKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IwLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSkpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpLCBtaW5vcjMpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKG1pbm9yMywgMiwgMywgMCwgMSk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUocm93MSwgMiwgMywgMCwgMSksIHJvdzMpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICByb3cyICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHJvdzIsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpLCBtaW5vcjApO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjAsIFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSk7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSksIG1pbm9yMik7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUobWlub3IyLCAyLCAzLCAwLCAxKTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgcm93MSk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSksIG1pbm9yMik7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSksIG1pbm9yMyk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSksIG1pbm9yMik7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjMsIFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHJvdzMpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IxLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSkpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpLCBtaW5vcjIpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpLCBtaW5vcjEpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IyLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSkpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCByb3cyKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSwgbWlub3IxKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMywgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMSwgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKSwgbWlub3IzKTtcblxuICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDAsICBtaW5vcjApO1xuICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDQsICBtaW5vcjEpO1xuICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDgsICBtaW5vcjIpO1xuICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDEyLCBtaW5vcjMpO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDQgdXNpbmcgU0lNRCBpZiBhdmFpbGFibGUgYW5kIGVuYWJsZWRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbiBtYXQ0LmFkam9pbnQgPSBnbE1hdHJpeC5VU0VfU0lNRCA/IG1hdDQuU0lNRC5hZGpvaW50IDogbWF0NC5zY2FsYXIuYWRqb2ludDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0NC5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICByZXR1cm4gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0J3MgZXhwbGljaXRseSB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZCwgbXVzdCBiZSBhIEZsb2F0MzJBcnJheVxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZCwgbXVzdCBiZSBhIEZsb2F0MzJBcnJheVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LlNJTUQubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAwKTtcbiAgICB2YXIgYTEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDQpO1xuICAgIHZhciBhMiA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgOCk7XG4gICAgdmFyIGEzID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAxMik7XG5cbiAgICB2YXIgYjAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGIsIDApO1xuICAgIHZhciBvdXQwID0gU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIwLCAwLCAwLCAwLCAwKSwgYTApLFxuICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjAsIDEsIDEsIDEsIDEpLCBhMSksXG4gICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIwLCAyLCAyLCAyLCAyKSwgYTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjAsIDMsIDMsIDMsIDMpLCBhMykpKSk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAwLCBvdXQwKTtcblxuICAgIHZhciBiMSA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYiwgNCk7XG4gICAgdmFyIG91dDEgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjEsIDAsIDAsIDAsIDApLCBhMCksXG4gICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMSwgMSwgMSwgMSwgMSksIGExKSxcbiAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjEsIDIsIDIsIDIsIDIpLCBhMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMSwgMywgMywgMywgMyksIGEzKSkpKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDQsIG91dDEpO1xuXG4gICAgdmFyIGIyID0gU0lNRC5GbG9hdDMyeDQubG9hZChiLCA4KTtcbiAgICB2YXIgb3V0MiA9IFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMiwgMCwgMCwgMCwgMCksIGEwKSxcbiAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIyLCAxLCAxLCAxLCAxKSwgYTEpLFxuICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjIsIDIsIDIsIDIsIDIpLCBhMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjIsIDMsIDMsIDMsIDMpLCBhMykpKSk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA4LCBvdXQyKTtcblxuICAgIHZhciBiMyA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYiwgMTIpO1xuICAgIHZhciBvdXQzID0gU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIzLCAwLCAwLCAwLCAwKSwgYTApLFxuICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIzLCAxLCAxLCAxLCAxKSwgYTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIzLCAyLCAyLCAyLCAyKSwgYTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIzLCAzLCAzLCAzLCAzKSwgYTMpKSkpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMTIsIG91dDMpO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NCdzIGV4cGxpY2l0bHkgbm90IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc2NhbGFyLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gICAgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG4gICAgdmFyIGIwICA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107XG4gICAgb3V0WzBdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzNdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzRdOyBiMSA9IGJbNV07IGIyID0gYls2XTsgYjMgPSBiWzddO1xuICAgIG91dFs0XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbNV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzZdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFs3XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls4XTsgYjEgPSBiWzldOyBiMiA9IGJbMTBdOyBiMyA9IGJbMTFdO1xuICAgIG91dFs4XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbOV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzEwXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTFdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzEyXTsgYjEgPSBiWzEzXTsgYjIgPSBiWzE0XTsgYjMgPSBiWzE1XTtcbiAgICBvdXRbMTJdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxM10gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzE0XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTVdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDQncyB1c2luZyBTSU1EIGlmIGF2YWlsYWJsZSBhbmQgZW5hYmxlZFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5tdWx0aXBseSA9IGdsTWF0cml4LlVTRV9TSU1EID8gbWF0NC5TSU1ELm11bHRpcGx5IDogbWF0NC5zY2FsYXIubXVsdGlwbHk7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDQubXVsID0gbWF0NC5tdWx0aXBseTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3Igbm90IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnNjYWxhci50cmFuc2xhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl0sXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjM7XG5cbiAgICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMF0gPSBhMDA7IG91dFsxXSA9IGEwMTsgb3V0WzJdID0gYTAyOyBvdXRbM10gPSBhMDM7XG4gICAgICAgIG91dFs0XSA9IGExMDsgb3V0WzVdID0gYTExOyBvdXRbNl0gPSBhMTI7IG91dFs3XSA9IGExMztcbiAgICAgICAgb3V0WzhdID0gYTIwOyBvdXRbOV0gPSBhMjE7IG91dFsxMF0gPSBhMjI7IG91dFsxMV0gPSBhMjM7XG5cbiAgICAgICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhMDIgKiB4ICsgYTEyICogeSArIGEyMiAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3IgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjM30gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuU0lNRC50cmFuc2xhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAwKSxcbiAgICAgICAgYTEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDQpLFxuICAgICAgICBhMiA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgOCksXG4gICAgICAgIGEzID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAxMiksXG4gICAgICAgIHZlYyA9IFNJTUQuRmxvYXQzMng0KHZbMF0sIHZbMV0sIHZbMl0gLCAwKTtcblxuICAgIGlmIChhICE9PSBvdXQpIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTsgb3V0WzFdID0gYVsxXTsgb3V0WzJdID0gYVsyXTsgb3V0WzNdID0gYVszXTtcbiAgICAgICAgb3V0WzRdID0gYVs0XTsgb3V0WzVdID0gYVs1XTsgb3V0WzZdID0gYVs2XTsgb3V0WzddID0gYVs3XTtcbiAgICAgICAgb3V0WzhdID0gYVs4XTsgb3V0WzldID0gYVs5XTsgb3V0WzEwXSA9IGFbMTBdOyBvdXRbMTFdID0gYVsxMV07XG4gICAgfVxuXG4gICAgYTAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwoYTAsIFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodmVjLCAwLCAwLCAwLCAwKSk7XG4gICAgYTEgPSBTSU1ELkZsb2F0MzJ4NC5tdWwoYTEsIFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodmVjLCAxLCAxLCAxLCAxKSk7XG4gICAgYTIgPSBTSU1ELkZsb2F0MzJ4NC5tdWwoYTIsIFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodmVjLCAyLCAyLCAyLCAyKSk7XG5cbiAgICB2YXIgdDAgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoYTAsIFNJTUQuRmxvYXQzMng0LmFkZChhMSwgU0lNRC5GbG9hdDMyeDQuYWRkKGEyLCBhMykpKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDEyLCB0MCk7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGVzIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yIHVzaW5nIFNJTUQgaWYgYXZhaWxhYmxlIGFuZCBlbmFibGVkXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC50cmFuc2xhdGUgPSBnbE1hdHJpeC5VU0VfU0lNRCA/IG1hdDQuU0lNRC50cmFuc2xhdGUgOiBtYXQ0LnNjYWxhci50cmFuc2xhdGU7XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzIG5vdCB1c2luZyB2ZWN0b3JpemF0aW9uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICoqL1xubWF0NC5zY2FsYXIuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdLCB6ID0gdlsyXTtcblxuICAgIG91dFswXSA9IGFbMF0gKiB4O1xuICAgIG91dFsxXSA9IGFbMV0gKiB4O1xuICAgIG91dFsyXSA9IGFbMl0gKiB4O1xuICAgIG91dFszXSA9IGFbM10gKiB4O1xuICAgIG91dFs0XSA9IGFbNF0gKiB5O1xuICAgIG91dFs1XSA9IGFbNV0gKiB5O1xuICAgIG91dFs2XSA9IGFbNl0gKiB5O1xuICAgIG91dFs3XSA9IGFbN10gKiB5O1xuICAgIG91dFs4XSA9IGFbOF0gKiB6O1xuICAgIG91dFs5XSA9IGFbOV0gKiB6O1xuICAgIG91dFsxMF0gPSBhWzEwXSAqIHo7XG4gICAgb3V0WzExXSA9IGFbMTFdICogejtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzIHVzaW5nIHZlY3Rvcml6YXRpb25cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7dmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKiovXG5tYXQ0LlNJTUQuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAsIGExLCBhMjtcbiAgICB2YXIgdmVjID0gU0lNRC5GbG9hdDMyeDQodlswXSwgdlsxXSwgdlsyXSwgMCk7XG5cbiAgICBhMCA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMCk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUoXG4gICAgICAgIG91dCwgMCwgU0lNRC5GbG9hdDMyeDQubXVsKGEwLCBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHZlYywgMCwgMCwgMCwgMCkpKTtcblxuICAgIGExID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA0KTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShcbiAgICAgICAgb3V0LCA0LCBTSU1ELkZsb2F0MzJ4NC5tdWwoYTEsIFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodmVjLCAxLCAxLCAxLCAxKSkpO1xuXG4gICAgYTIgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDgpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKFxuICAgICAgICBvdXQsIDgsIFNJTUQuRmxvYXQzMng0Lm11bChhMiwgU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh2ZWMsIDIsIDIsIDIsIDIpKSk7XG5cbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzIHVzaW5nIFNJTUQgaWYgYXZhaWxhYmxlIGFuZCBlbmFibGVkXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnNjYWxlID0gZ2xNYXRyaXguVVNFX1NJTUQgPyBtYXQ0LlNJTUQuc2NhbGUgOiBtYXQ0LnNjYWxhci5zY2FsZTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0NCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBnaXZlbiBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gICAgdmFyIHggPSBheGlzWzBdLCB5ID0gYXhpc1sxXSwgeiA9IGF4aXNbMl0sXG4gICAgICAgIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopLFxuICAgICAgICBzLCBjLCB0LFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzLFxuICAgICAgICBiMDAsIGIwMSwgYjAyLFxuICAgICAgICBiMTAsIGIxMSwgYjEyLFxuICAgICAgICBiMjAsIGIyMSwgYjIyO1xuXG4gICAgaWYgKE1hdGguYWJzKGxlbikgPCBnbE1hdHJpeC5FUFNJTE9OKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHggKj0gbGVuO1xuICAgIHkgKj0gbGVuO1xuICAgIHogKj0gbGVuO1xuXG4gICAgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgdCA9IDEgLSBjO1xuXG4gICAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcbiAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgIC8vIENvbnN0cnVjdCB0aGUgZWxlbWVudHMgb2YgdGhlIHJvdGF0aW9uIG1hdHJpeFxuICAgIGIwMCA9IHggKiB4ICogdCArIGM7IGIwMSA9IHkgKiB4ICogdCArIHogKiBzOyBiMDIgPSB6ICogeCAqIHQgLSB5ICogcztcbiAgICBiMTAgPSB4ICogeSAqIHQgLSB6ICogczsgYjExID0geSAqIHkgKiB0ICsgYzsgYjEyID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gICAgYjIwID0geCAqIHogKiB0ICsgeSAqIHM7IGIyMSA9IHkgKiB6ICogdCAtIHggKiBzOyBiMjIgPSB6ICogeiAqIHQgKyBjO1xuXG4gICAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XG4gICAgb3V0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyO1xuICAgIG91dFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMjtcbiAgICBvdXRbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XG4gICAgb3V0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyO1xuICAgIG91dFs1XSA9IGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMjtcbiAgICBvdXRbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gICAgb3V0WzddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyO1xuICAgIG91dFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMjtcbiAgICBvdXRbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gICAgb3V0WzEwXSA9IGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMjtcbiAgICBvdXRbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzIG5vdCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zY2FsYXIucm90YXRlWCA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGExMCA9IGFbNF0sXG4gICAgICAgIGExMSA9IGFbNV0sXG4gICAgICAgIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbMF0gID0gYVswXTtcbiAgICAgICAgb3V0WzFdICA9IGFbMV07XG4gICAgICAgIG91dFsyXSAgPSBhWzJdO1xuICAgICAgICBvdXRbM10gID0gYVszXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbNF0gPSBhMTAgKiBjICsgYTIwICogcztcbiAgICBvdXRbNV0gPSBhMTEgKiBjICsgYTIxICogcztcbiAgICBvdXRbNl0gPSBhMTIgKiBjICsgYTIyICogcztcbiAgICBvdXRbN10gPSBhMTMgKiBjICsgYTIzICogcztcbiAgICBvdXRbOF0gPSBhMjAgKiBjIC0gYTEwICogcztcbiAgICBvdXRbOV0gPSBhMjEgKiBjIC0gYTExICogcztcbiAgICBvdXRbMTBdID0gYTIyICogYyAtIGExMiAqIHM7XG4gICAgb3V0WzExXSA9IGEyMyAqIGMgLSBhMTMgKiBzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzIHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LlNJTUQucm90YXRlWCA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gU0lNRC5GbG9hdDMyeDQuc3BsYXQoTWF0aC5zaW4ocmFkKSksXG4gICAgICAgIGMgPSBTSU1ELkZsb2F0MzJ4NC5zcGxhdChNYXRoLmNvcyhyYWQpKTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgb3V0WzBdICA9IGFbMF07XG4gICAgICBvdXRbMV0gID0gYVsxXTtcbiAgICAgIG91dFsyXSAgPSBhWzJdO1xuICAgICAgb3V0WzNdICA9IGFbM107XG4gICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIHZhciBhXzEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDQpO1xuICAgIHZhciBhXzIgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDgpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKGFfMSwgYyksIFNJTUQuRmxvYXQzMng0Lm11bChhXzIsIHMpKSk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA4LFxuICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwoYV8yLCBjKSwgU0lNRC5GbG9hdDMyeDQubXVsKGFfMSwgcykpKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpcyB1c2luZyBTSU1EIGlmIGF2YWlsYWJlIGFuZCBlbmFibGVkXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGVYID0gZ2xNYXRyaXguVVNFX1NJTUQgPyBtYXQ0LlNJTUQucm90YXRlWCA6IG1hdDQuc2NhbGFyLnJvdGF0ZVg7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXMgbm90IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnNjYWxhci5yb3RhdGVZID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTAwID0gYVswXSxcbiAgICAgICAgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXSxcbiAgICAgICAgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICAgIG91dFs0XSAgPSBhWzRdO1xuICAgICAgICBvdXRbNV0gID0gYVs1XTtcbiAgICAgICAgb3V0WzZdICA9IGFbNl07XG4gICAgICAgIG91dFs3XSAgPSBhWzddO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGMgLSBhMjAgKiBzO1xuICAgIG91dFsxXSA9IGEwMSAqIGMgLSBhMjEgKiBzO1xuICAgIG91dFsyXSA9IGEwMiAqIGMgLSBhMjIgKiBzO1xuICAgIG91dFszXSA9IGEwMyAqIGMgLSBhMjMgKiBzO1xuICAgIG91dFs4XSA9IGEwMCAqIHMgKyBhMjAgKiBjO1xuICAgIG91dFs5XSA9IGEwMSAqIHMgKyBhMjEgKiBjO1xuICAgIG91dFsxMF0gPSBhMDIgKiBzICsgYTIyICogYztcbiAgICBvdXRbMTFdID0gYTAzICogcyArIGEyMyAqIGM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXMgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuU0lNRC5yb3RhdGVZID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBTSU1ELkZsb2F0MzJ4NC5zcGxhdChNYXRoLnNpbihyYWQpKSxcbiAgICAgICAgYyA9IFNJTUQuRmxvYXQzMng0LnNwbGF0KE1hdGguY29zKHJhZCkpO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICAgIG91dFs0XSAgPSBhWzRdO1xuICAgICAgICBvdXRbNV0gID0gYVs1XTtcbiAgICAgICAgb3V0WzZdICA9IGFbNl07XG4gICAgICAgIG91dFs3XSAgPSBhWzddO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIHZhciBhXzAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDApO1xuICAgIHZhciBhXzIgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDgpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKGFfMCwgYyksIFNJTUQuRmxvYXQzMng0Lm11bChhXzIsIHMpKSk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA4LFxuICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwoYV8wLCBzKSwgU0lNRC5GbG9hdDMyeDQubXVsKGFfMiwgYykpKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpcyBpZiBTSU1EIGF2YWlsYWJsZSBhbmQgZW5hYmxlZFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbiBtYXQ0LnJvdGF0ZVkgPSBnbE1hdHJpeC5VU0VfU0lNRCA/IG1hdDQuU0lNRC5yb3RhdGVZIDogbWF0NC5zY2FsYXIucm90YXRlWTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpcyBub3QgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc2NhbGFyLnJvdGF0ZVogPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLFxuICAgICAgICBhMTEgPSBhWzVdLFxuICAgICAgICBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgICAgICBvdXRbOF0gID0gYVs4XTtcbiAgICAgICAgb3V0WzldICA9IGFbOV07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTFdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGMgKyBhMTAgKiBzO1xuICAgIG91dFsxXSA9IGEwMSAqIGMgKyBhMTEgKiBzO1xuICAgIG91dFsyXSA9IGEwMiAqIGMgKyBhMTIgKiBzO1xuICAgIG91dFszXSA9IGEwMyAqIGMgKyBhMTMgKiBzO1xuICAgIG91dFs0XSA9IGExMCAqIGMgLSBhMDAgKiBzO1xuICAgIG91dFs1XSA9IGExMSAqIGMgLSBhMDEgKiBzO1xuICAgIG91dFs2XSA9IGExMiAqIGMgLSBhMDIgKiBzO1xuICAgIG91dFs3XSA9IGExMyAqIGMgLSBhMDMgKiBzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzIHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LlNJTUQucm90YXRlWiA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gU0lNRC5GbG9hdDMyeDQuc3BsYXQoTWF0aC5zaW4ocmFkKSksXG4gICAgICAgIGMgPSBTSU1ELkZsb2F0MzJ4NC5zcGxhdChNYXRoLmNvcyhyYWQpKTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzhdICA9IGFbOF07XG4gICAgICAgIG91dFs5XSAgPSBhWzldO1xuICAgICAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICB2YXIgYV8wID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAwKTtcbiAgICB2YXIgYV8xID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA0KTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChhXzAsIGMpLCBTSU1ELkZsb2F0MzJ4NC5tdWwoYV8xLCBzKSkpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKGFfMSwgYyksIFNJTUQuRmxvYXQzMng0Lm11bChhXzAsIHMpKSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXMgaWYgU0lNRCBhdmFpbGFibGUgYW5kIGVuYWJsZWRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG4gbWF0NC5yb3RhdGVaID0gZ2xNYXRyaXguVVNFX1NJTUQgPyBtYXQ0LlNJTUQucm90YXRlWiA6IG1hdDQuc2NhbGFyLnJvdGF0ZVo7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tVHJhbnNsYXRpb24gPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSB2WzBdO1xuICAgIG91dFsxM10gPSB2WzFdO1xuICAgIG91dFsxNF0gPSB2WzJdO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzN9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tU2NhbGluZyA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IHZbMF07XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSB2WzFdO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IHZbMl07XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZSBhcm91bmQgYSBnaXZlbiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZShkZXN0LCBkZXN0LCByYWQsIGF4aXMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21Sb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkLCBheGlzKSB7XG4gICAgdmFyIHggPSBheGlzWzBdLCB5ID0gYXhpc1sxXSwgeiA9IGF4aXNbMl0sXG4gICAgICAgIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopLFxuICAgICAgICBzLCBjLCB0O1xuXG4gICAgaWYgKE1hdGguYWJzKGxlbikgPCBnbE1hdHJpeC5FUFNJTE9OKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHggKj0gbGVuO1xuICAgIHkgKj0gbGVuO1xuICAgIHogKj0gbGVuO1xuXG4gICAgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgdCA9IDEgLSBjO1xuXG4gICAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSB4ICogeCAqIHQgKyBjO1xuICAgIG91dFsxXSA9IHkgKiB4ICogdCArIHogKiBzO1xuICAgIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geCAqIHkgKiB0IC0geiAqIHM7XG4gICAgb3V0WzVdID0geSAqIHkgKiB0ICsgYztcbiAgICBvdXRbNl0gPSB6ICogeSAqIHQgKyB4ICogcztcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzO1xuICAgIG91dFs5XSA9IHkgKiB6ICogdCAtIHggKiBzO1xuICAgIG91dFsxMF0gPSB6ICogeiAqIHQgKyBjO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGVYKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tWFJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSAgPSAxO1xuICAgIG91dFsxXSAgPSAwO1xuICAgIG91dFsyXSAgPSAwO1xuICAgIG91dFszXSAgPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gYztcbiAgICBvdXRbNl0gPSBzO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAtcztcbiAgICBvdXRbMTBdID0gYztcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlWShkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVlSb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gID0gYztcbiAgICBvdXRbMV0gID0gMDtcbiAgICBvdXRbMl0gID0gLXM7XG4gICAgb3V0WzNdICA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSBzO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IGM7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVooZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21aUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdICA9IGM7XG4gICAgb3V0WzFdICA9IHM7XG4gICAgb3V0WzJdICA9IDA7XG4gICAgb3V0WzNdICA9IDA7XG4gICAgb3V0WzRdID0gLXM7XG4gICAgb3V0WzVdID0gYztcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiBhbmQgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIHZhciBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uIChvdXQsIHEsIHYpIHtcbiAgICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgICB4eiA9IHggKiB6MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSAoeXkgKyB6eik7XG4gICAgb3V0WzFdID0geHkgKyB3ejtcbiAgICBvdXRbMl0gPSB4eiAtIHd5O1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geHkgLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICAgIG91dFs2XSA9IHl6ICsgd3g7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4eiArIHd5O1xuICAgIG91dFs5XSA9IHl6IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSAoeHggKyB5eSk7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IgY29tcG9uZW50IG9mIGEgdHJhbnNmb3JtYXRpb25cbiAqICBtYXRyaXguIElmIGEgbWF0cml4IGlzIGJ1aWx0IHdpdGggZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24sXG4gKiAgdGhlIHJldHVybmVkIHZlY3RvciB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3JcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxuICogQHBhcmFtICB7dmVjM30gb3V0IFZlY3RvciB0byByZWNlaXZlIHRyYW5zbGF0aW9uIGNvbXBvbmVudFxuICogQHBhcmFtICB7bWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcbiAqIEByZXR1cm4ge3ZlYzN9IG91dFxuICovXG5tYXQ0LmdldFRyYW5zbGF0aW9uID0gZnVuY3Rpb24gKG91dCwgbWF0KSB7XG4gIG91dFswXSA9IG1hdFsxMl07XG4gIG91dFsxXSA9IG1hdFsxM107XG4gIG91dFsyXSA9IG1hdFsxNF07XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHF1YXRlcm5pb24gcmVwcmVzZW50aW5nIHRoZSByb3RhdGlvbmFsIGNvbXBvbmVudFxuICogIG9mIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoXG4gKiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24sIHRoZSByZXR1cm5lZCBxdWF0ZXJuaW9uIHdpbGwgYmUgdGhlXG4gKiAgc2FtZSBhcyB0aGUgcXVhdGVybmlvbiBvcmlnaW5hbGx5IHN1cHBsaWVkLlxuICogQHBhcmFtIHtxdWF0fSBvdXQgUXVhdGVybmlvbiB0byByZWNlaXZlIHRoZSByb3RhdGlvbiBjb21wb25lbnRcbiAqIEBwYXJhbSB7bWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcbiAqIEByZXR1cm4ge3F1YXR9IG91dFxuICovXG5tYXQ0LmdldFJvdGF0aW9uID0gZnVuY3Rpb24gKG91dCwgbWF0KSB7XG4gIC8vIEFsZ29yaXRobSB0YWtlbiBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtXG4gIHZhciB0cmFjZSA9IG1hdFswXSArIG1hdFs1XSArIG1hdFsxMF07XG4gIHZhciBTID0gMDtcblxuICBpZiAodHJhY2UgPiAwKSB7IFxuICAgIFMgPSBNYXRoLnNxcnQodHJhY2UgKyAxLjApICogMjtcbiAgICBvdXRbM10gPSAwLjI1ICogUztcbiAgICBvdXRbMF0gPSAobWF0WzZdIC0gbWF0WzldKSAvIFM7XG4gICAgb3V0WzFdID0gKG1hdFs4XSAtIG1hdFsyXSkgLyBTOyBcbiAgICBvdXRbMl0gPSAobWF0WzFdIC0gbWF0WzRdKSAvIFM7IFxuICB9IGVsc2UgaWYgKChtYXRbMF0gPiBtYXRbNV0pJihtYXRbMF0gPiBtYXRbMTBdKSkgeyBcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIG1hdFswXSAtIG1hdFs1XSAtIG1hdFsxMF0pICogMjtcbiAgICBvdXRbM10gPSAobWF0WzZdIC0gbWF0WzldKSAvIFM7XG4gICAgb3V0WzBdID0gMC4yNSAqIFM7XG4gICAgb3V0WzFdID0gKG1hdFsxXSArIG1hdFs0XSkgLyBTOyBcbiAgICBvdXRbMl0gPSAobWF0WzhdICsgbWF0WzJdKSAvIFM7IFxuICB9IGVsc2UgaWYgKG1hdFs1XSA+IG1hdFsxMF0pIHsgXG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBtYXRbNV0gLSBtYXRbMF0gLSBtYXRbMTBdKSAqIDI7XG4gICAgb3V0WzNdID0gKG1hdFs4XSAtIG1hdFsyXSkgLyBTO1xuICAgIG91dFswXSA9IChtYXRbMV0gKyBtYXRbNF0pIC8gUzsgXG4gICAgb3V0WzFdID0gMC4yNSAqIFM7XG4gICAgb3V0WzJdID0gKG1hdFs2XSArIG1hdFs5XSkgLyBTOyBcbiAgfSBlbHNlIHsgXG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBtYXRbMTBdIC0gbWF0WzBdIC0gbWF0WzVdKSAqIDI7XG4gICAgb3V0WzNdID0gKG1hdFsxXSAtIG1hdFs0XSkgLyBTO1xuICAgIG91dFswXSA9IChtYXRbOF0gKyBtYXRbMl0pIC8gUztcbiAgICBvdXRbMV0gPSAobWF0WzZdICsgbWF0WzldKSAvIFM7XG4gICAgb3V0WzJdID0gMC4yNSAqIFM7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLCB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kIHZlY3RvciBzY2FsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICB2YXIgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBzY2FsZSlcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gcyBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUgPSBmdW5jdGlvbiAob3V0LCBxLCB2LCBzKSB7XG4gICAgLy8gUXVhdGVybmlvbiBtYXRoXG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB4eSA9IHggKiB5MixcbiAgICAgICAgeHogPSB4ICogejIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB5eiA9IHkgKiB6MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejIsXG4gICAgICAgIHN4ID0gc1swXSxcbiAgICAgICAgc3kgPSBzWzFdLFxuICAgICAgICBzeiA9IHNbMl07XG5cbiAgICBvdXRbMF0gPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgICBvdXRbMV0gPSAoeHkgKyB3eikgKiBzeDtcbiAgICBvdXRbMl0gPSAoeHogLSB3eSkgKiBzeDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9ICh4eSAtIHd6KSAqIHN5O1xuICAgIG91dFs1XSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xuICAgIG91dFs2XSA9ICh5eiArIHd4KSAqIHN5O1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gKHh6ICsgd3kpICogc3o7XG4gICAgb3V0WzldID0gKHl6IC0gd3gpICogc3o7XG4gICAgb3V0WzEwXSA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSB2WzBdO1xuICAgIG91dFsxM10gPSB2WzFdO1xuICAgIG91dFsxNF0gPSB2WzJdO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGUsIHJvdGF0aW5nIGFuZCBzY2FsaW5nIGFyb3VuZCB0aGUgZ2l2ZW4gb3JpZ2luXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIG9yaWdpbik7XG4gKiAgICAgdmFyIHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgbmVnYXRpdmVPcmlnaW4pO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBzIFNjYWxpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IG8gVGhlIG9yaWdpbiB2ZWN0b3IgYXJvdW5kIHdoaWNoIHRvIHNjYWxlIGFuZCByb3RhdGVcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlT3JpZ2luID0gZnVuY3Rpb24gKG91dCwgcSwgdiwgcywgbykge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgeDIgPSB4ICsgeCxcbiAgICAgIHkyID0geSArIHksXG4gICAgICB6MiA9IHogKyB6LFxuXG4gICAgICB4eCA9IHggKiB4MixcbiAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgeHogPSB4ICogejIsXG4gICAgICB5eSA9IHkgKiB5MixcbiAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgenogPSB6ICogejIsXG4gICAgICB3eCA9IHcgKiB4MixcbiAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgd3ogPSB3ICogejIsXG5cbiAgICAgIHN4ID0gc1swXSxcbiAgICAgIHN5ID0gc1sxXSxcbiAgICAgIHN6ID0gc1syXSxcblxuICAgICAgb3ggPSBvWzBdLFxuICAgICAgb3kgPSBvWzFdLFxuICAgICAgb3ogPSBvWzJdO1xuXG4gIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICBvdXRbMV0gPSAoeHkgKyB3eikgKiBzeDtcbiAgb3V0WzJdID0gKHh6IC0gd3kpICogc3g7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9ICh4eSAtIHd6KSAqIHN5O1xuICBvdXRbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9ICh4eiArIHd5KSAqIHN6O1xuICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgb3V0WzEwXSA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF0gKyBveCAtIChvdXRbMF0gKiBveCArIG91dFs0XSAqIG95ICsgb3V0WzhdICogb3opO1xuICBvdXRbMTNdID0gdlsxXSArIG95IC0gKG91dFsxXSAqIG94ICsgb3V0WzVdICogb3kgKyBvdXRbOV0gKiBveik7XG4gIG91dFsxNF0gPSB2WzJdICsgb3ogLSAob3V0WzJdICogb3ggKyBvdXRbNl0gKiBveSArIG91dFsxMF0gKiBveik7XG4gIG91dFsxNV0gPSAxO1xuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgYSA0eDQgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cbiAqXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVF1YXQgPSBmdW5jdGlvbiAob3V0LCBxKSB7XG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB5eCA9IHkgKiB4MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHp4ID0geiAqIHgyLFxuICAgICAgICB6eSA9IHogKiB5MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgICBvdXRbMV0gPSB5eCArIHd6O1xuICAgIG91dFsyXSA9IHp4IC0gd3k7XG4gICAgb3V0WzNdID0gMDtcblxuICAgIG91dFs0XSA9IHl4IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtIHh4IC0geno7XG4gICAgb3V0WzZdID0genkgKyB3eDtcbiAgICBvdXRbN10gPSAwO1xuXG4gICAgb3V0WzhdID0genggKyB3eTtcbiAgICBvdXRbOV0gPSB6eSAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0geHggLSB5eTtcbiAgICBvdXRbMTFdID0gMDtcblxuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgZnJ1c3R1bSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJ1c3R1bSA9IGZ1bmN0aW9uIChvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIHJsID0gMSAvIChyaWdodCAtIGxlZnQpLFxuICAgICAgICB0YiA9IDEgLyAodG9wIC0gYm90dG9tKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IChuZWFyICogMikgKiBybDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IChuZWFyICogMikgKiB0YjtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gKHJpZ2h0ICsgbGVmdCkgKiBybDtcbiAgICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTFdID0gLTE7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IChmYXIgKiBuZWFyICogMikgKiBuZjtcbiAgICBvdXRbMTVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3QgQXNwZWN0IHJhdGlvLiB0eXBpY2FsbHkgdmlld3BvcnQgd2lkdGgvaGVpZ2h0XG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnBlcnNwZWN0aXZlID0gZnVuY3Rpb24gKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgZiA9IDEuMCAvIE1hdGgudGFuKGZvdnkgLyAyKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IGYgLyBhc3BlY3Q7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSBmO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKDIgKiBmYXIgKiBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGZpZWxkIG9mIHZpZXcuXG4gKiBUaGlzIGlzIHByaW1hcmlseSB1c2VmdWwgZm9yIGdlbmVyYXRpbmcgcHJvamVjdGlvbiBtYXRyaWNlcyB0byBiZSB1c2VkXG4gKiB3aXRoIHRoZSBzdGlsbCBleHBlcmllbWVudGFsIFdlYlZSIEFQSS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge09iamVjdH0gZm92IE9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiB1cERlZ3JlZXMsIGRvd25EZWdyZWVzLCBsZWZ0RGVncmVlcywgcmlnaHREZWdyZWVzXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3ID0gZnVuY3Rpb24gKG91dCwgZm92LCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgdXBUYW4gPSBNYXRoLnRhbihmb3YudXBEZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIGRvd25UYW4gPSBNYXRoLnRhbihmb3YuZG93bkRlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgbGVmdFRhbiA9IE1hdGgudGFuKGZvdi5sZWZ0RGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICByaWdodFRhbiA9IE1hdGgudGFuKGZvdi5yaWdodERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgeFNjYWxlID0gMi4wIC8gKGxlZnRUYW4gKyByaWdodFRhbiksXG4gICAgICAgIHlTY2FsZSA9IDIuMCAvICh1cFRhbiArIGRvd25UYW4pO1xuXG4gICAgb3V0WzBdID0geFNjYWxlO1xuICAgIG91dFsxXSA9IDAuMDtcbiAgICBvdXRbMl0gPSAwLjA7XG4gICAgb3V0WzNdID0gMC4wO1xuICAgIG91dFs0XSA9IDAuMDtcbiAgICBvdXRbNV0gPSB5U2NhbGU7XG4gICAgb3V0WzZdID0gMC4wO1xuICAgIG91dFs3XSA9IDAuMDtcbiAgICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgICBvdXRbOV0gPSAoKHVwVGFuIC0gZG93blRhbikgKiB5U2NhbGUgKiAwLjUpO1xuICAgIG91dFsxMF0gPSBmYXIgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzExXSA9IC0xLjA7XG4gICAgb3V0WzEyXSA9IDAuMDtcbiAgICBvdXRbMTNdID0gMC4wO1xuICAgIG91dFsxNF0gPSAoZmFyICogbmVhcikgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzE1XSA9IDAuMDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQub3J0aG8gPSBmdW5jdGlvbiAob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICAgIHZhciBsciA9IDEgLyAobGVmdCAtIHJpZ2h0KSxcbiAgICAgICAgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSAtMiAqIGxyO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gLTIgKiBidDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAyICogbmY7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IChsZWZ0ICsgcmlnaHQpICogbHI7XG4gICAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gICAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGxvb2stYXQgbWF0cml4IHdpdGggdGhlIGdpdmVuIGV5ZSBwb3NpdGlvbiwgZm9jYWwgcG9pbnQsIGFuZCB1cCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHt2ZWMzfSBleWUgUG9zaXRpb24gb2YgdGhlIHZpZXdlclxuICogQHBhcmFtIHt2ZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gKiBAcGFyYW0ge3ZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5sb29rQXQgPSBmdW5jdGlvbiAob3V0LCBleWUsIGNlbnRlciwgdXApIHtcbiAgICB2YXIgeDAsIHgxLCB4MiwgeTAsIHkxLCB5MiwgejAsIHoxLCB6MiwgbGVuLFxuICAgICAgICBleWV4ID0gZXllWzBdLFxuICAgICAgICBleWV5ID0gZXllWzFdLFxuICAgICAgICBleWV6ID0gZXllWzJdLFxuICAgICAgICB1cHggPSB1cFswXSxcbiAgICAgICAgdXB5ID0gdXBbMV0sXG4gICAgICAgIHVweiA9IHVwWzJdLFxuICAgICAgICBjZW50ZXJ4ID0gY2VudGVyWzBdLFxuICAgICAgICBjZW50ZXJ5ID0gY2VudGVyWzFdLFxuICAgICAgICBjZW50ZXJ6ID0gY2VudGVyWzJdO1xuXG4gICAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IGdsTWF0cml4LkVQU0lMT04gJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleSAtIGNlbnRlcnkpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJlxuICAgICAgICBNYXRoLmFicyhleWV6IC0gY2VudGVyeikgPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgICAgIHJldHVybiBtYXQ0LmlkZW50aXR5KG91dCk7XG4gICAgfVxuXG4gICAgejAgPSBleWV4IC0gY2VudGVyeDtcbiAgICB6MSA9IGV5ZXkgLSBjZW50ZXJ5O1xuICAgIHoyID0gZXlleiAtIGNlbnRlcno7XG5cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KHowICogejAgKyB6MSAqIHoxICsgejIgKiB6Mik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG5cbiAgICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyO1xuICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgICBsZW4gPSBNYXRoLnNxcnQoeDAgKiB4MCArIHgxICogeDEgKyB4MiAqIHgyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB4MCA9IDA7XG4gICAgICAgIHgxID0gMDtcbiAgICAgICAgeDIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHgwICo9IGxlbjtcbiAgICAgICAgeDEgKj0gbGVuO1xuICAgICAgICB4MiAqPSBsZW47XG4gICAgfVxuXG4gICAgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgICB5MSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICAgIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG5cbiAgICBsZW4gPSBNYXRoLnNxcnQoeTAgKiB5MCArIHkxICogeTEgKyB5MiAqIHkyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB5MCA9IDA7XG4gICAgICAgIHkxID0gMDtcbiAgICAgICAgeTIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHkwICo9IGxlbjtcbiAgICAgICAgeTEgKj0gbGVuO1xuICAgICAgICB5MiAqPSBsZW47XG4gICAgfVxuXG4gICAgb3V0WzBdID0geDA7XG4gICAgb3V0WzFdID0geTA7XG4gICAgb3V0WzJdID0gejA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4MTtcbiAgICBvdXRbNV0gPSB5MTtcbiAgICBvdXRbNl0gPSB6MTtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHgyO1xuICAgIG91dFs5XSA9IHkyO1xuICAgIG91dFsxMF0gPSB6MjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICAgIG91dFsxM10gPSAtKHkwICogZXlleCArIHkxICogZXlleSArIHkyICogZXlleik7XG4gICAgb3V0WzE0XSA9IC0oejAgKiBleWV4ICsgejEgKiBleWV5ICsgejIgKiBleWV6KTtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0NC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0NCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICBhWzRdICsgJywgJyArIGFbNV0gKyAnLCAnICsgYVs2XSArICcsICcgKyBhWzddICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIGFbOF0gKyAnLCAnICsgYVs5XSArICcsICcgKyBhWzEwXSArICcsICcgKyBhWzExXSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICBhWzEyXSArICcsICcgKyBhWzEzXSArICcsICcgKyBhWzE0XSArICcsICcgKyBhWzE1XSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDQuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyBNYXRoLnBvdyhhWzZdLCAyKSArIE1hdGgucG93KGFbN10sIDIpICsgTWF0aC5wb3coYVs4XSwgMikgKyBNYXRoLnBvdyhhWzldLCAyKSArIE1hdGgucG93KGFbMTBdLCAyKSArIE1hdGgucG93KGFbMTFdLCAyKSArIE1hdGgucG93KGFbMTJdLCAyKSArIE1hdGgucG93KGFbMTNdLCAyKSArIE1hdGgucG93KGFbMTRdLCAyKSArIE1hdGgucG93KGFbMTVdLCAyKSApKVxufTtcblxuLyoqXG4gKiBBZGRzIHR3byBtYXQ0J3NcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSArIGJbM107XG4gICAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gICAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gICAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gICAgb3V0WzddID0gYVs3XSArIGJbN107XG4gICAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gICAgb3V0WzldID0gYVs5XSArIGJbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdICsgYlsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdICsgYlsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdICsgYlsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdICsgYlsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdICsgYlsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdICsgYlsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgICBvdXRbNl0gPSBhWzZdIC0gYls2XTtcbiAgICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgICBvdXRbOV0gPSBhWzldIC0gYls5XTtcbiAgICBvdXRbMTBdID0gYVsxMF0gLSBiWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV0gLSBiWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl0gLSBiWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM10gLSBiWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF0gLSBiWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV0gLSBiWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0NC5zdWIgPSBtYXQ0LnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lm11bHRpcGx5U2NhbGFyID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgb3V0WzNdID0gYVszXSAqIGI7XG4gICAgb3V0WzRdID0gYVs0XSAqIGI7XG4gICAgb3V0WzVdID0gYVs1XSAqIGI7XG4gICAgb3V0WzZdID0gYVs2XSAqIGI7XG4gICAgb3V0WzddID0gYVs3XSAqIGI7XG4gICAgb3V0WzhdID0gYVs4XSAqIGI7XG4gICAgb3V0WzldID0gYVs5XSAqIGI7XG4gICAgb3V0WzEwXSA9IGFbMTBdICogYjtcbiAgICBvdXRbMTFdID0gYVsxMV0gKiBiO1xuICAgIG91dFsxMl0gPSBhWzEyXSAqIGI7XG4gICAgb3V0WzEzXSA9IGFbMTNdICogYjtcbiAgICBvdXRbMTRdID0gYVsxNF0gKiBiO1xuICAgIG91dFsxNV0gPSBhWzE1XSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gbWF0NCdzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5tdWx0aXBseVNjYWxhckFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gICAgb3V0WzRdID0gYVs0XSArIChiWzRdICogc2NhbGUpO1xuICAgIG91dFs1XSA9IGFbNV0gKyAoYls1XSAqIHNjYWxlKTtcbiAgICBvdXRbNl0gPSBhWzZdICsgKGJbNl0gKiBzY2FsZSk7XG4gICAgb3V0WzddID0gYVs3XSArIChiWzddICogc2NhbGUpO1xuICAgIG91dFs4XSA9IGFbOF0gKyAoYls4XSAqIHNjYWxlKTtcbiAgICBvdXRbOV0gPSBhWzldICsgKGJbOV0gKiBzY2FsZSk7XG4gICAgb3V0WzEwXSA9IGFbMTBdICsgKGJbMTBdICogc2NhbGUpO1xuICAgIG91dFsxMV0gPSBhWzExXSArIChiWzExXSAqIHNjYWxlKTtcbiAgICBvdXRbMTJdID0gYVsxMl0gKyAoYlsxMl0gKiBzY2FsZSk7XG4gICAgb3V0WzEzXSA9IGFbMTNdICsgKGJbMTNdICogc2NhbGUpO1xuICAgIG91dFsxNF0gPSBhWzE0XSArIChiWzE0XSAqIHNjYWxlKTtcbiAgICBvdXRbMTVdID0gYVsxNV0gKyAoYlsxNV0gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQ0LmV4YWN0RXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBcbiAgICAgICAgICAgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdICYmIGFbNl0gPT09IGJbNl0gJiYgYVs3XSA9PT0gYls3XSAmJiBcbiAgICAgICAgICAgYVs4XSA9PT0gYls4XSAmJiBhWzldID09PSBiWzldICYmIGFbMTBdID09PSBiWzEwXSAmJiBhWzExXSA9PT0gYlsxMV0gJiZcbiAgICAgICAgICAgYVsxMl0gPT09IGJbMTJdICYmIGFbMTNdID09PSBiWzEzXSAmJiBhWzE0XSA9PT0gYlsxNF0gJiYgYVsxNV0gPT09IGJbMTVdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDR9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbm1hdDQuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYTAgID0gYVswXSwgIGExICA9IGFbMV0sICBhMiAgPSBhWzJdLCAgYTMgID0gYVszXSxcbiAgICAgICAgYTQgID0gYVs0XSwgIGE1ICA9IGFbNV0sICBhNiAgPSBhWzZdLCAgYTcgID0gYVs3XSwgXG4gICAgICAgIGE4ICA9IGFbOF0sICBhOSAgPSBhWzldLCAgYTEwID0gYVsxMF0sIGExMSA9IGFbMTFdLCBcbiAgICAgICAgYTEyID0gYVsxMl0sIGExMyA9IGFbMTNdLCBhMTQgPSBhWzE0XSwgYTE1ID0gYVsxNV07XG5cbiAgICB2YXIgYjAgID0gYlswXSwgIGIxICA9IGJbMV0sICBiMiAgPSBiWzJdLCAgYjMgID0gYlszXSxcbiAgICAgICAgYjQgID0gYls0XSwgIGI1ICA9IGJbNV0sICBiNiAgPSBiWzZdLCAgYjcgID0gYls3XSwgXG4gICAgICAgIGI4ICA9IGJbOF0sICBiOSAgPSBiWzldLCAgYjEwID0gYlsxMF0sIGIxMSA9IGJbMTFdLCBcbiAgICAgICAgYjEyID0gYlsxMl0sIGIxMyA9IGJbMTNdLCBiMTQgPSBiWzE0XSwgYjE1ID0gYlsxNV07XG5cbiAgICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNiksIE1hdGguYWJzKGI2KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE3IC0gYjcpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNyksIE1hdGguYWJzKGI3KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE4IC0gYjgpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOCksIE1hdGguYWJzKGI4KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE5IC0gYjkpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOSksIE1hdGguYWJzKGI5KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExMCAtIGIxMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMCksIE1hdGguYWJzKGIxMCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMTEgLSBiMTEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTEpLCBNYXRoLmFicyhiMTEpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEyIC0gYjEyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEyKSwgTWF0aC5hYnMoYjEyKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExMyAtIGIxMykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMyksIE1hdGguYWJzKGIxMykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMTQgLSBiMTQpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTQpLCBNYXRoLmFicyhiMTQpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTE1IC0gYjE1KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTE1KSwgTWF0aC5hYnMoYjE1KSkpO1xufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gbWF0NDtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcbnZhciBtYXQzID0gcmVxdWlyZShcIi4vbWF0My5qc1wiKTtcbnZhciB2ZWMzID0gcmVxdWlyZShcIi4vdmVjMy5qc1wiKTtcbnZhciB2ZWM0ID0gcmVxdWlyZShcIi4vdmVjNC5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgUXVhdGVybmlvblxuICogQG5hbWUgcXVhdFxuICovXG52YXIgcXVhdCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgcXVhdFxuICpcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKi9cbnF1YXQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0cyBhIHF1YXRlcm5pb24gdG8gcmVwcmVzZW50IHRoZSBzaG9ydGVzdCByb3RhdGlvbiBmcm9tIG9uZVxuICogdmVjdG9yIHRvIGFub3RoZXIuXG4gKlxuICogQm90aCB2ZWN0b3JzIGFyZSBhc3N1bWVkIHRvIGJlIHVuaXQgbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvbi5cbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgaW5pdGlhbCB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgZGVzdGluYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRpb25UbyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdG1wdmVjMyA9IHZlYzMuY3JlYXRlKCk7XG4gICAgdmFyIHhVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygxLDAsMCk7XG4gICAgdmFyIHlVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygwLDEsMCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgICAgIHZhciBkb3QgPSB2ZWMzLmRvdChhLCBiKTtcbiAgICAgICAgaWYgKGRvdCA8IC0wLjk5OTk5OSkge1xuICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCB4VW5pdFZlYzMsIGEpO1xuICAgICAgICAgICAgaWYgKHZlYzMubGVuZ3RoKHRtcHZlYzMpIDwgMC4wMDAwMDEpXG4gICAgICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCB5VW5pdFZlYzMsIGEpO1xuICAgICAgICAgICAgdmVjMy5ub3JtYWxpemUodG1wdmVjMywgdG1wdmVjMyk7XG4gICAgICAgICAgICBxdWF0LnNldEF4aXNBbmdsZShvdXQsIHRtcHZlYzMsIE1hdGguUEkpO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSBlbHNlIGlmIChkb3QgPiAwLjk5OTk5OSkge1xuICAgICAgICAgICAgb3V0WzBdID0gMDtcbiAgICAgICAgICAgIG91dFsxXSA9IDA7XG4gICAgICAgICAgICBvdXRbMl0gPSAwO1xuICAgICAgICAgICAgb3V0WzNdID0gMTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIGEsIGIpO1xuICAgICAgICAgICAgb3V0WzBdID0gdG1wdmVjM1swXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHRtcHZlYzNbMV07XG4gICAgICAgICAgICBvdXRbMl0gPSB0bXB2ZWMzWzJdO1xuICAgICAgICAgICAgb3V0WzNdID0gMSArIGRvdDtcbiAgICAgICAgICAgIHJldHVybiBxdWF0Lm5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzcGVjaWZpZWQgcXVhdGVybmlvbiB3aXRoIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlblxuICogYXhlcy4gRWFjaCBheGlzIGlzIGEgdmVjMyBhbmQgaXMgZXhwZWN0ZWQgdG8gYmUgdW5pdCBsZW5ndGggYW5kXG4gKiBwZXJwZW5kaWN1bGFyIHRvIGFsbCBvdGhlciBzcGVjaWZpZWQgYXhlcy5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IHZpZXcgIHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSB2aWV3aW5nIGRpcmVjdGlvblxuICogQHBhcmFtIHt2ZWMzfSByaWdodCB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJyaWdodFwiIGRpcmVjdGlvblxuICogQHBhcmFtIHt2ZWMzfSB1cCAgICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJ1cFwiIGRpcmVjdGlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnNldEF4ZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1hdHIgPSBtYXQzLmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG91dCwgdmlldywgcmlnaHQsIHVwKSB7XG4gICAgICAgIG1hdHJbMF0gPSByaWdodFswXTtcbiAgICAgICAgbWF0clszXSA9IHJpZ2h0WzFdO1xuICAgICAgICBtYXRyWzZdID0gcmlnaHRbMl07XG5cbiAgICAgICAgbWF0clsxXSA9IHVwWzBdO1xuICAgICAgICBtYXRyWzRdID0gdXBbMV07XG4gICAgICAgIG1hdHJbN10gPSB1cFsyXTtcblxuICAgICAgICBtYXRyWzJdID0gLXZpZXdbMF07XG4gICAgICAgIG1hdHJbNV0gPSAtdmlld1sxXTtcbiAgICAgICAgbWF0cls4XSA9IC12aWV3WzJdO1xuXG4gICAgICAgIHJldHVybiBxdWF0Lm5vcm1hbGl6ZShvdXQsIHF1YXQuZnJvbU1hdDMob3V0LCBtYXRyKSk7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuY2xvbmUgPSB2ZWM0LmNsb25lO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmZyb21WYWx1ZXMgPSB2ZWM0LmZyb21WYWx1ZXM7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHF1YXQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBzb3VyY2UgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuY29weSA9IHZlYzQuY29weTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBxdWF0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zZXQgPSB2ZWM0LnNldDtcblxuLyoqXG4gKiBTZXQgYSBxdWF0IHRvIHRoZSBpZGVudGl0eSBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldHMgYSBxdWF0IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFuZCByb3RhdGlvbiBheGlzLFxuICogdGhlbiByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIGFyb3VuZCB3aGljaCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqKi9cbnF1YXQuc2V0QXhpc0FuZ2xlID0gZnVuY3Rpb24ob3V0LCBheGlzLCByYWQpIHtcbiAgICByYWQgPSByYWQgKiAwLjU7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgIG91dFswXSA9IHMgKiBheGlzWzBdO1xuICAgIG91dFsxXSA9IHMgKiBheGlzWzFdO1xuICAgIG91dFsyXSA9IHMgKiBheGlzWzJdO1xuICAgIG91dFszXSA9IE1hdGguY29zKHJhZCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgcm90YXRpb24gYXhpcyBhbmQgYW5nbGUgZm9yIGEgZ2l2ZW5cbiAqICBxdWF0ZXJuaW9uLiBJZiBhIHF1YXRlcm5pb24gaXMgY3JlYXRlZCB3aXRoXG4gKiAgc2V0QXhpc0FuZ2xlLCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc2FtZVxuICogIHZhbHVlcyBhcyBwcm92aWRpZWQgaW4gdGhlIG9yaWdpbmFsIHBhcmFtZXRlciBsaXN0XG4gKiAgT1IgZnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdmFsdWVzLlxuICogRXhhbXBsZTogVGhlIHF1YXRlcm5pb24gZm9ybWVkIGJ5IGF4aXMgWzAsIDAsIDFdIGFuZFxuICogIGFuZ2xlIC05MCBpcyB0aGUgc2FtZSBhcyB0aGUgcXVhdGVybmlvbiBmb3JtZWQgYnlcbiAqICBbMCwgMCwgMV0gYW5kIDI3MC4gVGhpcyBtZXRob2QgZmF2b3JzIHRoZSBsYXR0ZXIuXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXRfYXhpcyAgVmVjdG9yIHJlY2VpdmluZyB0aGUgYXhpcyBvZiByb3RhdGlvblxuICogQHBhcmFtICB7cXVhdH0gcSAgICAgUXVhdGVybmlvbiB0byBiZSBkZWNvbXBvc2VkXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICBBbmdsZSwgaW4gcmFkaWFucywgb2YgdGhlIHJvdGF0aW9uXG4gKi9cbnF1YXQuZ2V0QXhpc0FuZ2xlID0gZnVuY3Rpb24ob3V0X2F4aXMsIHEpIHtcbiAgICB2YXIgcmFkID0gTWF0aC5hY29zKHFbM10pICogMi4wO1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkIC8gMi4wKTtcbiAgICBpZiAocyAhPSAwLjApIHtcbiAgICAgICAgb3V0X2F4aXNbMF0gPSBxWzBdIC8gcztcbiAgICAgICAgb3V0X2F4aXNbMV0gPSBxWzFdIC8gcztcbiAgICAgICAgb3V0X2F4aXNbMl0gPSBxWzJdIC8gcztcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBzIGlzIHplcm8sIHJldHVybiBhbnkgYXhpcyAobm8gcm90YXRpb24gLSBheGlzIGRvZXMgbm90IG1hdHRlcilcbiAgICAgICAgb3V0X2F4aXNbMF0gPSAxO1xuICAgICAgICBvdXRfYXhpc1sxXSA9IDA7XG4gICAgICAgIG91dF9heGlzWzJdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHJhZDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmFkZCA9IHZlYzQuYWRkO1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdLCBidyA9IGJbM107XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0Lm11bCA9IHF1YXQubXVsdGlwbHk7XG5cbi8qKlxuICogU2NhbGVzIGEgcXVhdCBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zY2FsZSA9IHZlYzQuc2NhbGU7XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVggPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYng7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF6ICogYng7XG4gICAgb3V0WzJdID0gYXogKiBidyAtIGF5ICogYng7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYng7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBZIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVkgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ5ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnk7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF4ICogYnk7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF5ICogYnk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBaIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVogPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ6ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF5ICogYno7XG4gICAgb3V0WzFdID0gYXkgKiBidyAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYno7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF6ICogYno7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgVyBjb21wb25lbnQgb2YgYSBxdWF0IGZyb20gdGhlIFgsIFksIGFuZCBaIGNvbXBvbmVudHMuXG4gKiBBc3N1bWVzIHRoYXQgcXVhdGVybmlvbiBpcyAxIHVuaXQgaW4gbGVuZ3RoLlxuICogQW55IGV4aXN0aW5nIFcgY29tcG9uZW50IHdpbGwgYmUgaWdub3JlZC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBXIGNvbXBvbmVudCBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmNhbGN1bGF0ZVcgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG5cbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSBNYXRoLnNxcnQoTWF0aC5hYnMoMS4wIC0geCAqIHggLSB5ICogeSAtIHogKiB6KSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuZG90ID0gdmVjNC5kb3Q7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubGVycCA9IHZlYzQubGVycDtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5zbGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICAvLyBiZW5jaG1hcmtzOlxuICAgIC8vICAgIGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tc2xlcnAtaW1wbGVtZW50YXRpb25zXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdLCBidyA9IGJbM107XG5cbiAgICB2YXIgICAgICAgIG9tZWdhLCBjb3NvbSwgc2lub20sIHNjYWxlMCwgc2NhbGUxO1xuXG4gICAgLy8gY2FsYyBjb3NpbmVcbiAgICBjb3NvbSA9IGF4ICogYnggKyBheSAqIGJ5ICsgYXogKiBieiArIGF3ICogYnc7XG4gICAgLy8gYWRqdXN0IHNpZ25zIChpZiBuZWNlc3NhcnkpXG4gICAgaWYgKCBjb3NvbSA8IDAuMCApIHtcbiAgICAgICAgY29zb20gPSAtY29zb207XG4gICAgICAgIGJ4ID0gLSBieDtcbiAgICAgICAgYnkgPSAtIGJ5O1xuICAgICAgICBieiA9IC0gYno7XG4gICAgICAgIGJ3ID0gLSBidztcbiAgICB9XG4gICAgLy8gY2FsY3VsYXRlIGNvZWZmaWNpZW50c1xuICAgIGlmICggKDEuMCAtIGNvc29tKSA+IDAuMDAwMDAxICkge1xuICAgICAgICAvLyBzdGFuZGFyZCBjYXNlIChzbGVycClcbiAgICAgICAgb21lZ2EgID0gTWF0aC5hY29zKGNvc29tKTtcbiAgICAgICAgc2lub20gID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgICAgICBzY2FsZTAgPSBNYXRoLnNpbigoMS4wIC0gdCkgKiBvbWVnYSkgLyBzaW5vbTtcbiAgICAgICAgc2NhbGUxID0gTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbm9tO1xuICAgIH0gZWxzZSB7ICAgICAgICBcbiAgICAgICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBxdWF0ZXJuaW9ucyBhcmUgdmVyeSBjbG9zZSBcbiAgICAgICAgLy8gIC4uLiBzbyB3ZSBjYW4gZG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgICBzY2FsZTAgPSAxLjAgLSB0O1xuICAgICAgICBzY2FsZTEgPSB0O1xuICAgIH1cbiAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWVzXG4gICAgb3V0WzBdID0gc2NhbGUwICogYXggKyBzY2FsZTEgKiBieDtcbiAgICBvdXRbMV0gPSBzY2FsZTAgKiBheSArIHNjYWxlMSAqIGJ5O1xuICAgIG91dFsyXSA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XG4gICAgb3V0WzNdID0gc2NhbGUwICogYXcgKyBzY2FsZTEgKiBidztcbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuc3FsZXJwID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlbXAxID0gcXVhdC5jcmVhdGUoKTtcbiAgdmFyIHRlbXAyID0gcXVhdC5jcmVhdGUoKTtcbiAgXG4gIHJldHVybiBmdW5jdGlvbiAob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gICAgcXVhdC5zbGVycCh0ZW1wMSwgYSwgZCwgdCk7XG4gICAgcXVhdC5zbGVycCh0ZW1wMiwgYiwgYywgdCk7XG4gICAgcXVhdC5zbGVycChvdXQsIHRlbXAxLCB0ZW1wMiwgMiAqIHQgKiAoMSAtIHQpKTtcbiAgICBcbiAgICByZXR1cm4gb3V0O1xuICB9O1xufSgpKTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGludmVyc2Ugb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuICAgICAgICBkb3QgPSBhMCphMCArIGExKmExICsgYTIqYTIgKyBhMyphMyxcbiAgICAgICAgaW52RG90ID0gZG90ID8gMS4wL2RvdCA6IDA7XG4gICAgXG4gICAgLy8gVE9ETzogV291bGQgYmUgZmFzdGVyIHRvIHJldHVybiBbMCwwLDAsMF0gaW1tZWRpYXRlbHkgaWYgZG90ID09IDBcblxuICAgIG91dFswXSA9IC1hMCppbnZEb3Q7XG4gICAgb3V0WzFdID0gLWExKmludkRvdDtcbiAgICBvdXRbMl0gPSAtYTIqaW52RG90O1xuICAgIG91dFszXSA9IGEzKmludkRvdDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBjb25qdWdhdGUgb2YgYSBxdWF0XG4gKiBJZiB0aGUgcXVhdGVybmlvbiBpcyBub3JtYWxpemVkLCB0aGlzIGZ1bmN0aW9uIGlzIGZhc3RlciB0aGFuIHF1YXQuaW52ZXJzZSBhbmQgcHJvZHVjZXMgdGhlIHNhbWUgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGNvbmp1Z2F0ZSBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5sZW5ndGggPSB2ZWM0Lmxlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubGVuID0gcXVhdC5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNxdWFyZWRMZW5ndGggPSB2ZWM0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0LnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zcXJMZW4gPSBxdWF0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTm9ybWFsaXplIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5ub3JtYWxpemUgPSB2ZWM0Lm5vcm1hbGl6ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiAzeDMgcm90YXRpb24gbWF0cml4LlxuICpcbiAqIE5PVEU6IFRoZSByZXN1bHRhbnQgcXVhdGVybmlvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28geW91IHNob3VsZCBiZSBzdXJlXG4gKiB0byByZW5vcm1hbGl6ZSB0aGUgcXVhdGVybmlvbiB5b3Vyc2VsZiB3aGVyZSBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge21hdDN9IG0gcm90YXRpb24gbWF0cml4XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5mcm9tTWF0MyA9IGZ1bmN0aW9uKG91dCwgbSkge1xuICAgIC8vIEFsZ29yaXRobSBpbiBLZW4gU2hvZW1ha2UncyBhcnRpY2xlIGluIDE5ODcgU0lHR1JBUEggY291cnNlIG5vdGVzXG4gICAgLy8gYXJ0aWNsZSBcIlF1YXRlcm5pb24gQ2FsY3VsdXMgYW5kIEZhc3QgQW5pbWF0aW9uXCIuXG4gICAgdmFyIGZUcmFjZSA9IG1bMF0gKyBtWzRdICsgbVs4XTtcbiAgICB2YXIgZlJvb3Q7XG5cbiAgICBpZiAoIGZUcmFjZSA+IDAuMCApIHtcbiAgICAgICAgLy8gfHd8ID4gMS8yLCBtYXkgYXMgd2VsbCBjaG9vc2UgdyA+IDEvMlxuICAgICAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxLjApOyAgLy8gMndcbiAgICAgICAgb3V0WzNdID0gMC41ICogZlJvb3Q7XG4gICAgICAgIGZSb290ID0gMC41L2ZSb290OyAgLy8gMS8oNHcpXG4gICAgICAgIG91dFswXSA9IChtWzVdLW1bN10pKmZSb290O1xuICAgICAgICBvdXRbMV0gPSAobVs2XS1tWzJdKSpmUm9vdDtcbiAgICAgICAgb3V0WzJdID0gKG1bMV0tbVszXSkqZlJvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gfHd8IDw9IDEvMlxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGlmICggbVs0XSA+IG1bMF0gKVxuICAgICAgICAgIGkgPSAxO1xuICAgICAgICBpZiAoIG1bOF0gPiBtW2kqMytpXSApXG4gICAgICAgICAgaSA9IDI7XG4gICAgICAgIHZhciBqID0gKGkrMSklMztcbiAgICAgICAgdmFyIGsgPSAoaSsyKSUzO1xuICAgICAgICBcbiAgICAgICAgZlJvb3QgPSBNYXRoLnNxcnQobVtpKjMraV0tbVtqKjMral0tbVtrKjMra10gKyAxLjApO1xuICAgICAgICBvdXRbaV0gPSAwLjUgKiBmUm9vdDtcbiAgICAgICAgZlJvb3QgPSAwLjUgLyBmUm9vdDtcbiAgICAgICAgb3V0WzNdID0gKG1baiozK2tdIC0gbVtrKjMral0pICogZlJvb3Q7XG4gICAgICAgIG91dFtqXSA9IChtW2oqMytpXSArIG1baSozK2pdKSAqIGZSb290O1xuICAgICAgICBvdXRba10gPSAobVtrKjMraV0gKyBtW2kqMytrXSkgKiBmUm9vdDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHF1YXRlbmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnF1YXQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3F1YXQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHF1YXRlcm5pb25zIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgVGhlIGZpcnN0IHF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge3F1YXR9IGIgVGhlIHNlY29uZCBxdWF0ZXJuaW9uLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnF1YXQuZXhhY3RFcXVhbHMgPSB2ZWM0LmV4YWN0RXF1YWxzO1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHF1YXRlcm5pb25zIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7cXVhdH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5xdWF0LmVxdWFscyA9IHZlYzQuZXF1YWxzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHF1YXQ7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDIgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbmFtZSB2ZWMyXG4gKi9cbnZhciB2ZWMyID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxuICpcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHkpIHtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuc3ViID0gdmVjMi5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5tdWwgPSB2ZWMyLm11bHRpcGx5O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuZGl2ID0gdmVjMi5kaXZpZGU7XG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5jZWlsID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmZsb29yID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5yb3VuZCA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zY2FsZUFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMyLmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLmRpc3QgPSB2ZWMyLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMi5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zcXJEaXN0ID0gdmVjMi5zcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjMi5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIubGVuID0gdmVjMi5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjMi5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuc3FyTGVuID0gdmVjMi5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubmVnYXRlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5pbnZlcnNlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5Knk7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzIuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICogTm90ZSB0aGF0IHRoZSBjcm9zcyBwcm9kdWN0IG11c3QgYnkgZGVmaW5pdGlvbiBwcm9kdWNlIGEgM0QgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMyLmNyb3NzID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgdmFyIHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICAgIG91dFswXSA9IG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5sZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnJhbmRvbSA9IGZ1bmN0aW9uIChvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gICAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiBzY2FsZTtcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHNjYWxlO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0MiA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyZH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQyZCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0M1xuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDN9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0MyA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzNdICogeSArIG1bNl07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzRdICogeSArIG1bN107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0NFxuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMCdcbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVsxMl07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bMTNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMyLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVjID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjMi5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAndmVjMignICsgYVswXSArICcsICcgKyBhWzFdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGV4YWN0bHkgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG52ZWMyLmV4YWN0RXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG52ZWMyLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdO1xuICAgIHZhciBiMCA9IGJbMF0sIGIxID0gYlsxXTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB2ZWMyO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyAzIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjM1xuICovXG52YXIgdmVjMyA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzNcbiAqXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbnZlYzMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSwgeikge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnN1YiA9IHZlYzMuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMubXVsID0gdmVjMy5tdWx0aXBseTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmRpdiA9IHZlYzMuZGl2aWRlO1xuXG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuY2VpbCA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICAgIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuZmxvb3IgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICAgIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm1pbiA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5tYXggPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMucm91bmQgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zY2FsZUFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMy5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmRpc3QgPSB2ZWMzLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMy5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl07XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqejtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnNxckRpc3QgPSB2ZWMzLnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWMzLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMubGVuID0gdmVjMy5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjMy5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnNxckxlbiA9IHZlYzMuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuaW52ZXJzZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeSArIHoqejtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgICAgIG91dFsyXSA9IGFbMl0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjMy5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuY3Jvc3MgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXTtcblxuICAgIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl07XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBoZXJtaXRlIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5oZXJtaXRlID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQsXG4gICAgICBmYWN0b3IxID0gZmFjdG9yVGltZXMyICogKDIgKiB0IC0gMykgKyAxLFxuICAgICAgZmFjdG9yMiA9IGZhY3RvclRpbWVzMiAqICh0IC0gMikgKyB0LFxuICAgICAgZmFjdG9yMyA9IGZhY3RvclRpbWVzMiAqICh0IC0gMSksXG4gICAgICBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogKDMgLSAyICogdCk7XG4gIFxuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICBcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBiZXppZXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmJlemllciA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgdmFyIGludmVyc2VGYWN0b3IgPSAxIC0gdCxcbiAgICAgIGludmVyc2VGYWN0b3JUaW1lc1R3byA9IGludmVyc2VGYWN0b3IgKiBpbnZlcnNlRmFjdG9yLFxuICAgICAgZmFjdG9yVGltZXMyID0gdCAqIHQsXG4gICAgICBmYWN0b3IxID0gaW52ZXJzZUZhY3RvclRpbWVzVHdvICogaW52ZXJzZUZhY3RvcixcbiAgICAgIGZhY3RvcjIgPSAzICogdCAqIGludmVyc2VGYWN0b3JUaW1lc1R3byxcbiAgICAgIGZhY3RvcjMgPSAzICogZmFjdG9yVGltZXMyICogaW52ZXJzZUZhY3RvcixcbiAgICAgIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiB0O1xuICBcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMucmFuZG9tID0gZnVuY3Rpb24gKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcblxuICAgIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICAgIHZhciB6ID0gKGdsTWF0cml4LlJBTkRPTSgpICogMi4wKSAtIDEuMDtcbiAgICB2YXIgelNjYWxlID0gTWF0aC5zcXJ0KDEuMC16KnopICogc2NhbGU7XG5cbiAgICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZTtcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZTtcbiAgICBvdXRbMl0gPSB6ICogc2NhbGU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgdyA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XTtcbiAgICB3ID0gdyB8fCAxLjA7XG4gICAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHc7XG4gICAgb3V0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdKSAvIHc7XG4gICAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSkgLyB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIHRoZSAzeDMgbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtTWF0MyA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuICAgIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XTtcbiAgICBvdXRbMV0gPSB4ICogbVsxXSArIHkgKiBtWzRdICsgeiAqIG1bN107XG4gICAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnRyYW5zZm9ybVF1YXQgPSBmdW5jdGlvbihvdXQsIGEsIHEpIHtcbiAgICAvLyBiZW5jaG1hcmtzOiBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9uc1xuXG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHF4ID0gcVswXSwgcXkgPSBxWzFdLCBxeiA9IHFbMl0sIHF3ID0gcVszXSxcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuICAgICAgICBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeSxcbiAgICAgICAgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXG4gICAgICAgIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4LFxuICAgICAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeC1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMucm90YXRlWCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgYyl7XG4gICB2YXIgcCA9IFtdLCByPVtdO1xuXHQgIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblx0ICBwWzBdID0gYVswXSAtIGJbMF07XG5cdCAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcblxuXHQgIC8vcGVyZm9ybSByb3RhdGlvblxuXHQgIHJbMF0gPSBwWzBdO1xuXHQgIHJbMV0gPSBwWzFdKk1hdGguY29zKGMpIC0gcFsyXSpNYXRoLnNpbihjKTtcblx0ICByWzJdID0gcFsxXSpNYXRoLnNpbihjKSArIHBbMl0qTWF0aC5jb3MoYyk7XG5cblx0ICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cdCAgb3V0WzBdID0gclswXSArIGJbMF07XG5cdCAgb3V0WzFdID0gclsxXSArIGJbMV07XG5cdCAgb3V0WzJdID0gclsyXSArIGJbMl07XG5cbiAgXHRyZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yb3RhdGVZID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgXHR2YXIgcCA9IFtdLCByPVtdO1xuICBcdC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgXHRwWzBdID0gYVswXSAtIGJbMF07XG4gIFx0cFsxXSA9IGFbMV0gLSBiWzFdO1xuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcbiAgXG4gIFx0Ly9wZXJmb3JtIHJvdGF0aW9uXG4gIFx0clswXSA9IHBbMl0qTWF0aC5zaW4oYykgKyBwWzBdKk1hdGguY29zKGMpO1xuICBcdHJbMV0gPSBwWzFdO1xuICBcdHJbMl0gPSBwWzJdKk1hdGguY29zKGMpIC0gcFswXSpNYXRoLnNpbihjKTtcbiAgXG4gIFx0Ly90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICBcdG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBcdG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBcdG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICBcbiAgXHRyZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yb3RhdGVaID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgXHR2YXIgcCA9IFtdLCByPVtdO1xuICBcdC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgXHRwWzBdID0gYVswXSAtIGJbMF07XG4gIFx0cFsxXSA9IGFbMV0gLSBiWzFdO1xuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcbiAgXG4gIFx0Ly9wZXJmb3JtIHJvdGF0aW9uXG4gIFx0clswXSA9IHBbMF0qTWF0aC5jb3MoYykgLSBwWzFdKk1hdGguc2luKGMpO1xuICBcdHJbMV0gPSBwWzBdKk1hdGguc2luKGMpICsgcFsxXSpNYXRoLmNvcyhjKTtcbiAgXHRyWzJdID0gcFsyXTtcbiAgXG4gIFx0Ly90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICBcdG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBcdG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBcdG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICBcbiAgXHRyZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjM3MuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMy4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlYyA9IHZlYzMuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSAzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoY291bnQpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07IHZlY1syXSA9IGFbaSsyXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdOyBhW2krMl0gPSB2ZWNbMl07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICovXG52ZWMzLmFuZ2xlID0gZnVuY3Rpb24oYSwgYikge1xuICAgXG4gICAgdmFyIHRlbXBBID0gdmVjMy5mcm9tVmFsdWVzKGFbMF0sIGFbMV0sIGFbMl0pO1xuICAgIHZhciB0ZW1wQiA9IHZlYzMuZnJvbVZhbHVlcyhiWzBdLCBiWzFdLCBiWzJdKTtcbiBcbiAgICB2ZWMzLm5vcm1hbGl6ZSh0ZW1wQSwgdGVtcEEpO1xuICAgIHZlYzMubm9ybWFsaXplKHRlbXBCLCB0ZW1wQik7XG4gXG4gICAgdmFyIGNvc2luZSA9IHZlYzMuZG90KHRlbXBBLCB0ZW1wQik7XG5cbiAgICBpZihjb3NpbmUgPiAxLjApe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5hY29zKGNvc2luZSk7XG4gICAgfSAgICAgXG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMzLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWMzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xudmVjMy5leGFjdEVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG52ZWMzLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl07XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl07XG4gICAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdmVjMztcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgNCBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzRcbiAqL1xudmFyIHZlYzQgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWM0XG4gKlxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xudmVjNC5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xudmVjNC5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSwgeiwgdykge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWM0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5LCB6LCB3KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgb3V0WzNdID0gdztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSArIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5zdWIgPSB2ZWM0LnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gKiBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0Lm11bCA9IHZlYzQubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLyBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5kaXYgPSB2ZWM0LmRpdmlkZTtcblxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmNlaWwgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICAgIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSk7XG4gICAgb3V0WzNdID0gTWF0aC5jZWlsKGFbM10pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5mbG9vciA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICAgIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5mbG9vcihhWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLmZsb29yKGFbM10pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5taW4gPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLm1pbihhWzNdLCBiWzNdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubWF4ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gICAgb3V0WzNdID0gTWF0aC5tYXgoYVszXSwgYlszXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnJvdW5kID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLnJvdW5kKGFbMl0pO1xuICAgIG91dFszXSA9IE1hdGgucm91bmQoYVszXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjNCBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICBvdXRbM10gPSBhWzNdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWM0J3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zY2FsZUFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzQuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl0sXG4gICAgICAgIHcgPSBiWzNdIC0gYVszXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeiArIHcqdyk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LmRpc3QgPSB2ZWM0LmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjNC5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl0sXG4gICAgICAgIHcgPSBiWzNdIC0gYVszXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuc3FyRGlzdCA9IHZlYzQuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzQubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXSxcbiAgICAgICAgdyA9IGFbM107XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnogKyB3KncpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQubGVuID0gdmVjNC5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjNC5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXSxcbiAgICAgICAgdyA9IGFbM107XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqeiArIHcqdztcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5zcXJMZW4gPSB2ZWM0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSAtYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmludmVyc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgb3V0WzNdID0gMS4wIC8gYVszXTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICB2YXIgbGVuID0geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgb3V0WzBdID0geCAqIGxlbjtcbiAgICAgICAgb3V0WzFdID0geSAqIGxlbjtcbiAgICAgICAgb3V0WzJdID0geiAqIGxlbjtcbiAgICAgICAgb3V0WzNdID0gdyAqIGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG52ZWM0LmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXSArIGFbM10gKiBiWzNdO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5sZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXSxcbiAgICAgICAgYXogPSBhWzJdLFxuICAgICAgICBhdyA9IGFbM107XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gICAgb3V0WzNdID0gYXcgKyB0ICogKGJbM10gLSBhdyk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5yYW5kb20gPSBmdW5jdGlvbiAob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuXG4gICAgLy9UT0RPOiBUaGlzIGlzIGEgcHJldHR5IGF3ZnVsIHdheSBvZiBkb2luZyB0aGlzLiBGaW5kIHNvbWV0aGluZyBiZXR0ZXIuXG4gICAgb3V0WzBdID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gICAgb3V0WzFdID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gICAgb3V0WzJdID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gICAgb3V0WzNdID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gICAgdmVjNC5ub3JtYWxpemUob3V0LCBvdXQpO1xuICAgIHZlYzQuc2NhbGUob3V0LCBvdXQsIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBtYXQ0LlxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC50cmFuc2Zvcm1NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sIHcgPSBhWzNdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdICogdztcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSAqIHc7XG4gICAgb3V0WzJdID0gbVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdICogdztcbiAgICBvdXRbM10gPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV0gKiB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnRyYW5zZm9ybVF1YXQgPSBmdW5jdGlvbihvdXQsIGEsIHEpIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdLFxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gICAgICAgIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5LFxuICAgICAgICBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogeixcbiAgICAgICAgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHgsXG4gICAgICAgIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gICAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWM0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWM0LiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjNHMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVjID0gdmVjNC5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTsgdmVjWzJdID0gYVtpKzJdOyB2ZWNbM10gPSBhW2krM107XG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgICAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTsgYVtpKzJdID0gdmVjWzJdOyBhW2krM10gPSB2ZWNbM107XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWM0LnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWM0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjNH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG52ZWM0LmV4YWN0RXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzR9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xudmVjNC5lcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB2ZWM0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyaWRJbmRleDtcblxudmFyIE5VTV9QQVJBTVMgPSAzO1xuXG5mdW5jdGlvbiBHcmlkSW5kZXgoZXh0ZW50LCBuLCBwYWRkaW5nKSB7XG4gICAgdmFyIGNlbGxzID0gdGhpcy5jZWxscyA9IFtdO1xuXG4gICAgaWYgKGV4dGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBleHRlbnQ7XG4gICAgICAgIHZhciBhcnJheSA9IG5ldyBJbnQzMkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgICBleHRlbnQgPSBhcnJheVswXTtcbiAgICAgICAgbiA9IGFycmF5WzFdO1xuICAgICAgICBwYWRkaW5nID0gYXJyYXlbMl07XG5cbiAgICAgICAgdGhpcy5kID0gbiArIDIgKiBwYWRkaW5nO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuZCAqIHRoaXMuZDsgaysrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBhcnJheVtOVU1fUEFSQU1TICsga107XG4gICAgICAgICAgICB2YXIgZW5kID0gYXJyYXlbTlVNX1BBUkFNUyArIGsgKyAxXTtcbiAgICAgICAgICAgIGNlbGxzLnB1c2goc3RhcnQgPT09IGVuZCA/XG4gICAgICAgICAgICAgICAgICAgIG51bGwgOlxuICAgICAgICAgICAgICAgICAgICBhcnJheS5zdWJhcnJheShzdGFydCwgZW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleXNPZmZzZXQgPSBhcnJheVtOVU1fUEFSQU1TICsgY2VsbHMubGVuZ3RoXTtcbiAgICAgICAgdmFyIGJib3hlc09mZnNldCA9IGFycmF5W05VTV9QQVJBTVMgKyBjZWxscy5sZW5ndGggKyAxXTtcbiAgICAgICAgdGhpcy5rZXlzID0gYXJyYXkuc3ViYXJyYXkoa2V5c09mZnNldCwgYmJveGVzT2Zmc2V0KTtcbiAgICAgICAgdGhpcy5iYm94ZXMgPSBhcnJheS5zdWJhcnJheShiYm94ZXNPZmZzZXQpO1xuXG4gICAgICAgIHRoaXMuaW5zZXJ0ID0gdGhpcy5faW5zZXJ0UmVhZG9ubHk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmQgPSBuICsgMiAqIHBhZGRpbmc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kICogdGhpcy5kOyBpKyspIHtcbiAgICAgICAgICAgIGNlbGxzLnB1c2goW10pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2V5cyA9IFtdO1xuICAgICAgICB0aGlzLmJib3hlcyA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMubiA9IG47XG4gICAgdGhpcy5leHRlbnQgPSBleHRlbnQ7XG4gICAgdGhpcy5wYWRkaW5nID0gcGFkZGluZztcbiAgICB0aGlzLnNjYWxlID0gbiAvIGV4dGVudDtcbiAgICB0aGlzLnVpZCA9IDA7XG5cbiAgICB2YXIgcCA9IChwYWRkaW5nIC8gbikgKiBleHRlbnQ7XG4gICAgdGhpcy5taW4gPSAtcDtcbiAgICB0aGlzLm1heCA9IGV4dGVudCArIHA7XG59XG5cblxuR3JpZEluZGV4LnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihrZXksIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdGhpcy5fZm9yRWFjaENlbGwoeDEsIHkxLCB4MiwgeTIsIHRoaXMuX2luc2VydENlbGwsIHRoaXMudWlkKyspO1xuICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgdGhpcy5iYm94ZXMucHVzaCh4MSk7XG4gICAgdGhpcy5iYm94ZXMucHVzaCh5MSk7XG4gICAgdGhpcy5iYm94ZXMucHVzaCh4Mik7XG4gICAgdGhpcy5iYm94ZXMucHVzaCh5Mik7XG59O1xuXG5HcmlkSW5kZXgucHJvdG90eXBlLl9pbnNlcnRSZWFkb25seSA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93ICdDYW5ub3QgaW5zZXJ0IGludG8gYSBHcmlkSW5kZXggY3JlYXRlZCBmcm9tIGFuIEFycmF5QnVmZmVyLic7XG59O1xuXG5HcmlkSW5kZXgucHJvdG90eXBlLl9pbnNlcnRDZWxsID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIGNlbGxJbmRleCwgdWlkKSB7XG4gICAgdGhpcy5jZWxsc1tjZWxsSW5kZXhdLnB1c2godWlkKTtcbn07XG5cbkdyaWRJbmRleC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuICAgIHZhciBtaW4gPSB0aGlzLm1pbjtcbiAgICB2YXIgbWF4ID0gdGhpcy5tYXg7XG4gICAgaWYgKHgxIDw9IG1pbiAmJiB5MSA8PSBtaW4gJiYgbWF4IDw9IHgyICYmIG1heCA8PSB5Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlzLnNsaWNlKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBzZWVuVWlkcyA9IHt9O1xuICAgICAgICB0aGlzLl9mb3JFYWNoQ2VsbCh4MSwgeTEsIHgyLCB5MiwgdGhpcy5fcXVlcnlDZWxsLCByZXN1bHQsIHNlZW5VaWRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuXG5HcmlkSW5kZXgucHJvdG90eXBlLl9xdWVyeUNlbGwgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgY2VsbEluZGV4LCByZXN1bHQsIHNlZW5VaWRzKSB7XG4gICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzW2NlbGxJbmRleF07XG4gICAgaWYgKGNlbGwgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXM7XG4gICAgICAgIHZhciBiYm94ZXMgPSB0aGlzLmJib3hlcztcbiAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCBjZWxsLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICB2YXIgdWlkID0gY2VsbFt1XTtcbiAgICAgICAgICAgIGlmIChzZWVuVWlkc1t1aWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdWlkICogNDtcbiAgICAgICAgICAgICAgICBpZiAoKHgxIDw9IGJib3hlc1tvZmZzZXQgKyAyXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHkxIDw9IGJib3hlc1tvZmZzZXQgKyAzXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHgyID49IGJib3hlc1tvZmZzZXQgKyAwXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHkyID49IGJib3hlc1tvZmZzZXQgKyAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VlblVpZHNbdWlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGtleXNbdWlkXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VlblVpZHNbdWlkXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkdyaWRJbmRleC5wcm90b3R5cGUuX2ZvckVhY2hDZWxsID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIGZuLCBhcmcxLCBhcmcyKSB7XG4gICAgdmFyIGN4MSA9IHRoaXMuX2NvbnZlcnRUb0NlbGxDb29yZCh4MSk7XG4gICAgdmFyIGN5MSA9IHRoaXMuX2NvbnZlcnRUb0NlbGxDb29yZCh5MSk7XG4gICAgdmFyIGN4MiA9IHRoaXMuX2NvbnZlcnRUb0NlbGxDb29yZCh4Mik7XG4gICAgdmFyIGN5MiA9IHRoaXMuX2NvbnZlcnRUb0NlbGxDb29yZCh5Mik7XG4gICAgZm9yICh2YXIgeCA9IGN4MTsgeCA8PSBjeDI7IHgrKykge1xuICAgICAgICBmb3IgKHZhciB5ID0gY3kxOyB5IDw9IGN5MjsgeSsrKSB7XG4gICAgICAgICAgICB2YXIgY2VsbEluZGV4ID0gdGhpcy5kICogeSArIHg7XG4gICAgICAgICAgICBpZiAoZm4uY2FsbCh0aGlzLCB4MSwgeTEsIHgyLCB5MiwgY2VsbEluZGV4LCBhcmcxLCBhcmcyKSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuR3JpZEluZGV4LnByb3RvdHlwZS5fY29udmVydFRvQ2VsbENvb3JkID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLmQgLSAxLCBNYXRoLmZsb29yKHggKiB0aGlzLnNjYWxlKSArIHRoaXMucGFkZGluZykpO1xufTtcblxuR3JpZEluZGV4LnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYXJyYXlCdWZmZXIpIHJldHVybiB0aGlzLmFycmF5QnVmZmVyO1xuXG4gICAgdmFyIGNlbGxzID0gdGhpcy5jZWxscztcblxuICAgIHZhciBtZXRhZGF0YUxlbmd0aCA9IE5VTV9QQVJBTVMgKyB0aGlzLmNlbGxzLmxlbmd0aCArIDEgKyAxO1xuICAgIHZhciB0b3RhbENlbGxMZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b3RhbENlbGxMZW5ndGggKz0gdGhpcy5jZWxsc1tpXS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIGFycmF5ID0gbmV3IEludDMyQXJyYXkobWV0YWRhdGFMZW5ndGggKyB0b3RhbENlbGxMZW5ndGggKyB0aGlzLmtleXMubGVuZ3RoICsgdGhpcy5iYm94ZXMubGVuZ3RoKTtcbiAgICBhcnJheVswXSA9IHRoaXMuZXh0ZW50O1xuICAgIGFycmF5WzFdID0gdGhpcy5uO1xuICAgIGFycmF5WzJdID0gdGhpcy5wYWRkaW5nO1xuXG4gICAgdmFyIG9mZnNldCA9IG1ldGFkYXRhTGVuZ3RoO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgY2VsbHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGNlbGwgPSBjZWxsc1trXTtcbiAgICAgICAgYXJyYXlbTlVNX1BBUkFNUyArIGtdID0gb2Zmc2V0O1xuICAgICAgICBhcnJheS5zZXQoY2VsbCwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IGNlbGwubGVuZ3RoO1xuICAgIH1cblxuICAgIGFycmF5W05VTV9QQVJBTVMgKyBjZWxscy5sZW5ndGhdID0gb2Zmc2V0O1xuICAgIGFycmF5LnNldCh0aGlzLmtleXMsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IHRoaXMua2V5cy5sZW5ndGg7XG5cbiAgICBhcnJheVtOVU1fUEFSQU1TICsgY2VsbHMubGVuZ3RoICsgMV0gPSBvZmZzZXQ7XG4gICAgYXJyYXkuc2V0KHRoaXMuYmJveGVzLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSB0aGlzLmJib3hlcy5sZW5ndGg7XG5cbiAgICByZXR1cm4gYXJyYXkuYnVmZmVyO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24ocGFyYW1ldGVycywgZGVmYXVsdFR5cGUpIHtcbiAgICB2YXIgZnVuO1xuXG4gICAgaWYgKCFpc0Z1bmN0aW9uRGVmaW5pdGlvbihwYXJhbWV0ZXJzKSkge1xuICAgICAgICBmdW4gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHBhcmFtZXRlcnM7IH07XG4gICAgICAgIGZ1bi5pc0ZlYXR1cmVDb25zdGFudCA9IHRydWU7XG4gICAgICAgIGZ1bi5pc1pvb21Db25zdGFudCA9IHRydWU7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQgPSB0eXBlb2YgcGFyYW1ldGVycy5zdG9wc1swXVswXSA9PT0gJ29iamVjdCc7XG4gICAgICAgIHZhciBmZWF0dXJlRGVwZW5kZW50ID0gem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQgfHwgcGFyYW1ldGVycy5wcm9wZXJ0eSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgem9vbURlcGVuZGVudCA9IHpvb21BbmRGZWF0dXJlRGVwZW5kZW50IHx8ICFmZWF0dXJlRGVwZW5kZW50O1xuICAgICAgICB2YXIgdHlwZSA9IHBhcmFtZXRlcnMudHlwZSB8fCBkZWZhdWx0VHlwZSB8fCAnZXhwb25lbnRpYWwnO1xuXG4gICAgICAgIHZhciBpbm5lckZ1bjtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdleHBvbmVudGlhbCcpIHtcbiAgICAgICAgICAgIGlubmVyRnVuID0gZXZhbHVhdGVFeHBvbmVudGlhbEZ1bmN0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpbnRlcnZhbCcpIHtcbiAgICAgICAgICAgIGlubmVyRnVuID0gZXZhbHVhdGVJbnRlcnZhbEZ1bmN0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjYXRlZ29yaWNhbCcpIHtcbiAgICAgICAgICAgIGlubmVyRnVuID0gZXZhbHVhdGVDYXRlZ29yaWNhbEZ1bmN0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGZ1bmN0aW9uIHR5cGUgXCInICsgdHlwZSArICdcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHpvb21BbmRGZWF0dXJlRGVwZW5kZW50KSB7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZUZ1bmN0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIGZlYXR1cmVGdW5jdGlvblN0b3BzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHBhcmFtZXRlcnMuc3RvcHMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcCA9IHBhcmFtZXRlcnMuc3RvcHNbc107XG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVGdW5jdGlvbnNbc3RvcFswXS56b29tXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVGdW5jdGlvbnNbc3RvcFswXS56b29tXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvb206IHN0b3BbMF0uem9vbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHBhcmFtZXRlcnMudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwYXJhbWV0ZXJzLnByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHM6IFtdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZlYXR1cmVGdW5jdGlvbnNbc3RvcFswXS56b29tXS5zdG9wcy5wdXNoKFtzdG9wWzBdLnZhbHVlLCBzdG9wWzFdXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIHogaW4gZmVhdHVyZUZ1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVGdW5jdGlvblN0b3BzLnB1c2goW2ZlYXR1cmVGdW5jdGlvbnNbel0uem9vbSwgY3JlYXRlRnVuY3Rpb24oZmVhdHVyZUZ1bmN0aW9uc1t6XSldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1biA9IGZ1bmN0aW9uKHpvb20sIGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZhbHVhdGVFeHBvbmVudGlhbEZ1bmN0aW9uKHsgc3RvcHM6IGZlYXR1cmVGdW5jdGlvblN0b3BzLCBiYXNlOiBwYXJhbWV0ZXJzLmJhc2UgfSwgem9vbSkoem9vbSwgZmVhdHVyZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZnVuLmlzRmVhdHVyZUNvbnN0YW50ID0gZmFsc2U7XG4gICAgICAgICAgICBmdW4uaXNab29tQ29uc3RhbnQgPSBmYWxzZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHpvb21EZXBlbmRlbnQpIHtcbiAgICAgICAgICAgIGZ1biA9IGZ1bmN0aW9uKHpvb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXJGdW4ocGFyYW1ldGVycywgem9vbSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZnVuLmlzRmVhdHVyZUNvbnN0YW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZ1bi5pc1pvb21Db25zdGFudCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnVuID0gZnVuY3Rpb24oem9vbSwgZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lckZ1bihwYXJhbWV0ZXJzLCBmZWF0dXJlW3BhcmFtZXRlcnMucHJvcGVydHldKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmdW4uaXNGZWF0dXJlQ29uc3RhbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZ1bi5pc1pvb21Db25zdGFudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuO1xufVxuXG5mdW5jdGlvbiBldmFsdWF0ZUNhdGVnb3JpY2FsRnVuY3Rpb24ocGFyYW1ldGVycywgaW5wdXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtZXRlcnMuc3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlucHV0ID09PSBwYXJhbWV0ZXJzLnN0b3BzW2ldWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5zdG9wc1tpXVsxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyYW1ldGVycy5zdG9wc1swXVsxXTtcbn1cblxuZnVuY3Rpb24gZXZhbHVhdGVJbnRlcnZhbEZ1bmN0aW9uKHBhcmFtZXRlcnMsIGlucHV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLnN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbnB1dCA8IHBhcmFtZXRlcnMuc3RvcHNbaV1bMF0pIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1ldGVycy5zdG9wc1tNYXRoLm1heChpIC0gMSwgMCldWzFdO1xufVxuXG5mdW5jdGlvbiBldmFsdWF0ZUV4cG9uZW50aWFsRnVuY3Rpb24ocGFyYW1ldGVycywgaW5wdXQpIHtcbiAgICB2YXIgYmFzZSA9IHBhcmFtZXRlcnMuYmFzZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5iYXNlIDogMTtcblxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoaSA+PSBwYXJhbWV0ZXJzLnN0b3BzLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIGVsc2UgaWYgKGlucHV0IDw9IHBhcmFtZXRlcnMuc3RvcHNbaV1bMF0pIGJyZWFrO1xuICAgICAgICBlbHNlIGkrKztcbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5zdG9wc1tpXVsxXTtcblxuICAgIH0gZWxzZSBpZiAoaSA9PT0gcGFyYW1ldGVycy5zdG9wcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbaSAtIDFdWzFdO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRlKFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBiYXNlLFxuICAgICAgICAgICAgcGFyYW1ldGVycy5zdG9wc1tpIC0gMV1bMF0sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnN0b3BzW2ldWzBdLFxuICAgICAgICAgICAgcGFyYW1ldGVycy5zdG9wc1tpIC0gMV1bMV0sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnN0b3BzW2ldWzFdXG4gICAgICAgICk7XG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKGlucHV0LCBiYXNlLCBpbnB1dExvd2VyLCBpbnB1dFVwcGVyLCBvdXRwdXRMb3dlciwgb3V0cHV0VXBwZXIpIHtcbiAgICBpZiAodHlwZW9mIG91dHB1dExvd2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBldmFsdWF0ZWRMb3dlciA9IG91dHB1dExvd2VyLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBldmFsdWF0ZWRVcHBlciA9IG91dHB1dFVwcGVyLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZShpbnB1dCwgYmFzZSwgaW5wdXRMb3dlciwgaW5wdXRVcHBlciwgZXZhbHVhdGVkTG93ZXIsIGV2YWx1YXRlZFVwcGVyKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG91dHB1dExvd2VyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVBcnJheShpbnB1dCwgYmFzZSwgaW5wdXRMb3dlciwgaW5wdXRVcHBlciwgb3V0cHV0TG93ZXIsIG91dHB1dFVwcGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVOdW1iZXIoaW5wdXQsIGJhc2UsIGlucHV0TG93ZXIsIGlucHV0VXBwZXIsIG91dHB1dExvd2VyLCBvdXRwdXRVcHBlcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZU51bWJlcihpbnB1dCwgYmFzZSwgaW5wdXRMb3dlciwgaW5wdXRVcHBlciwgb3V0cHV0TG93ZXIsIG91dHB1dFVwcGVyKSB7XG4gICAgdmFyIGRpZmZlcmVuY2UgPSAgaW5wdXRVcHBlciAtIGlucHV0TG93ZXI7XG4gICAgdmFyIHByb2dyZXNzID0gaW5wdXQgLSBpbnB1dExvd2VyO1xuXG4gICAgdmFyIHJhdGlvO1xuICAgIGlmIChiYXNlID09PSAxKSB7XG4gICAgICAgIHJhdGlvID0gcHJvZ3Jlc3MgLyBkaWZmZXJlbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJhdGlvID0gKE1hdGgucG93KGJhc2UsIHByb2dyZXNzKSAtIDEpIC8gKE1hdGgucG93KGJhc2UsIGRpZmZlcmVuY2UpIC0gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChvdXRwdXRMb3dlciAqICgxIC0gcmF0aW8pKSArIChvdXRwdXRVcHBlciAqIHJhdGlvKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVBcnJheShpbnB1dCwgYmFzZSwgaW5wdXRMb3dlciwgaW5wdXRVcHBlciwgb3V0cHV0TG93ZXIsIG91dHB1dFVwcGVyKSB7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0cHV0TG93ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0cHV0W2ldID0gaW50ZXJwb2xhdGVOdW1iZXIoaW5wdXQsIGJhc2UsIGlucHV0TG93ZXIsIGlucHV0VXBwZXIsIG91dHB1dExvd2VyW2ldLCBvdXRwdXRVcHBlcltpXSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb25EZWZpbml0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuc3RvcHM7XG59XG5cblxubW9kdWxlLmV4cG9ydHMuaXNGdW5jdGlvbkRlZmluaXRpb24gPSBpc0Z1bmN0aW9uRGVmaW5pdGlvbjtcblxubW9kdWxlLmV4cG9ydHMuaW50ZXJwb2xhdGVkID0gZnVuY3Rpb24ocGFyYW1ldGVycykge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihwYXJhbWV0ZXJzLCAnZXhwb25lbnRpYWwnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzWydwaWVjZXdpc2UtY29uc3RhbnQnXSA9IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24ocGFyYW1ldGVycywgJ2ludGVydmFsJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzU3VwcG9ydGVkO1xufSBlbHNlIGlmICh3aW5kb3cpIHtcbiAgICB3aW5kb3cubWFwYm94Z2wgPSB3aW5kb3cubWFwYm94Z2wgfHwge307XG4gICAgd2luZG93Lm1hcGJveGdsLnN1cHBvcnRlZCA9IGlzU3VwcG9ydGVkO1xufVxuXG4vKipcbiAqIFRlc3Qgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIE1hcGJveCBHTCBKU1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdD1mYWxzZV0gUmV0dXJuIGBmYWxzZWBcbiAqICAgaWYgdGhlIHBlcmZvcm1hbmNlIG9mIE1hcGJveCBHTCBKUyB3b3VsZCBiZSBkcmFtYXRpY2FsbHkgd29yc2UgdGhhblxuICogICBleHBlY3RlZCAoaS5lLiBhIHNvZnR3YXJlIHJlbmRlcmVyIGlzIHdvdWxkIGJlIHVzZWQpXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1N1cHBvcnRlZChvcHRpb25zKSB7XG4gICAgcmV0dXJuICEhKFxuICAgICAgICBpc0Jyb3dzZXIoKSAmJlxuICAgICAgICBpc0FycmF5U3VwcG9ydGVkKCkgJiZcbiAgICAgICAgaXNGdW5jdGlvblN1cHBvcnRlZCgpICYmXG4gICAgICAgIGlzT2JqZWN0U3VwcG9ydGVkKCkgJiZcbiAgICAgICAgaXNKU09OU3VwcG9ydGVkKCkgJiZcbiAgICAgICAgaXNXb3JrZXJTdXBwb3J0ZWQoKSAmJlxuICAgICAgICBpc1dlYkdMU3VwcG9ydGVkQ2FjaGVkKG9wdGlvbnMgJiYgb3B0aW9ucy5mYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0KVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGlzQnJvd3NlcigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbn1cblxuZnVuY3Rpb24gaXNBcnJheVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICBBcnJheS5wcm90b3R5cGUgJiZcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmV2ZXJ5ICYmXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5maWx0ZXIgJiZcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggJiZcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgJiZcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mICYmXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5tYXAgJiZcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnNvbWUgJiZcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnJlZHVjZSAmJlxuICAgICAgICBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb25TdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZSAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZDtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3RTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgT2JqZWN0LmtleXMgJiZcbiAgICAgICAgT2JqZWN0LmNyZWF0ZSAmJlxuICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiZcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgJiZcbiAgICAgICAgT2JqZWN0LmlzU2VhbGVkICYmXG4gICAgICAgIE9iamVjdC5pc0Zyb3plbiAmJlxuICAgICAgICBPYmplY3QuaXNFeHRlbnNpYmxlICYmXG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiZcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzICYmXG4gICAgICAgIE9iamVjdC5zZWFsICYmXG4gICAgICAgIE9iamVjdC5mcmVlemUgJiZcbiAgICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gaXNKU09OU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAnSlNPTicgaW4gd2luZG93ICYmICdwYXJzZScgaW4gSlNPTiAmJiAnc3RyaW5naWZ5JyBpbiBKU09OO1xufVxuXG5mdW5jdGlvbiBpc1dvcmtlclN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gJ1dvcmtlcicgaW4gd2luZG93O1xufVxuXG52YXIgaXNXZWJHTFN1cHBvcnRlZENhY2hlID0ge307XG5mdW5jdGlvbiBpc1dlYkdMU3VwcG9ydGVkQ2FjaGVkKGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQpIHtcblxuICAgIGlmIChpc1dlYkdMU3VwcG9ydGVkQ2FjaGVbZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpc1dlYkdMU3VwcG9ydGVkQ2FjaGVbZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdF0gPSBpc1dlYkdMU3VwcG9ydGVkKGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQpO1xuICAgIH1cblxuICAgIHJldHVybiBpc1dlYkdMU3VwcG9ydGVkQ2FjaGVbZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdF07XG59XG5cbmlzU3VwcG9ydGVkLndlYkdMQ29udGV4dEF0dHJpYnV0ZXMgPSB7XG4gICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICBhbHBoYTogdHJ1ZSxcbiAgICBzdGVuY2lsOiB0cnVlLFxuICAgIGRlcHRoOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1dlYkdMU3VwcG9ydGVkKGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQpIHtcblxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgIHZhciBhdHRyaWJ1dGVzID0gT2JqZWN0LmNyZWF0ZShpc1N1cHBvcnRlZC53ZWJHTENvbnRleHRBdHRyaWJ1dGVzKTtcbiAgICBhdHRyaWJ1dGVzLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQgPSBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0O1xuXG4gICAgaWYgKGNhbnZhcy5wcm9iYWJseVN1cHBvcnRzQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY2FudmFzLnByb2JhYmx5U3VwcG9ydHNDb250ZXh0KCd3ZWJnbCcsIGF0dHJpYnV0ZXMpIHx8XG4gICAgICAgICAgICBjYW52YXMucHJvYmFibHlTdXBwb3J0c0NvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGF0dHJpYnV0ZXMpXG4gICAgICAgICk7XG5cbiAgICB9IGVsc2UgaWYgKGNhbnZhcy5zdXBwb3J0c0NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNhbnZhcy5zdXBwb3J0c0NvbnRleHQoJ3dlYmdsJywgYXR0cmlidXRlcykgfHxcbiAgICAgICAgICAgIGNhbnZhcy5zdXBwb3J0c0NvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGF0dHJpYnV0ZXMpXG4gICAgICAgICk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgYXR0cmlidXRlcykgfHxcbiAgICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBhdHRyaWJ1dGVzKVxuICAgICAgICApO1xuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvcm1hdCA9IHJlcXVpcmUoJ3V0aWwnKS5mb3JtYXQ7XG5cbmZ1bmN0aW9uIFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlIC8qLCBtZXNzYWdlLCAuLi4qLykge1xuICAgIHRoaXMubWVzc2FnZSA9IChcbiAgICAgICAgKGtleSA/IGtleSArICc6ICcgOiAnJykgK1xuICAgICAgICBmb3JtYXQuYXBwbHkoZm9ybWF0LCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKVxuICAgICk7XG5cbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5fX2xpbmVfXykge1xuICAgICAgICB0aGlzLmxpbmUgPSB2YWx1ZS5fX2xpbmVfXztcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVmFsaWRhdGlvbkVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvdXRwdXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaW5wdXQgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGZvciAodmFyIGsgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIG91dHB1dFtrXSA9IGlucHV0W2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFR5cGUodmFsKSB7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWw7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gVHVybiBqc29ubGludC1saW5lcy1wcmltaXRpdmVzIG9iamVjdHMgaW50byBwcmltaXRpdmUgb2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB1bmJ1bmRsZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE51bWJlciB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZyB8fCB2YWx1ZSBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL3ZhbGlkYXRpb25fZXJyb3InKTtcbnZhciBnZXRUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9nZXRfdHlwZScpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXh0ZW5kJyk7XG5cbi8vIE1haW4gcmVjdXJzaXZlIHZhbGlkYXRpb24gZnVuY3Rpb24uIFRyYWNrczpcbi8vXG4vLyAtIGtleTogc3RyaW5nIHJlcHJlc2VudGluZyBsb2NhdGlvbiBvZiB2YWxpZGF0aW9uIGluIHN0eWxlIHRyZWUuIFVzZWQgb25seVxuLy8gICBmb3IgbW9yZSBpbmZvcm1hdGl2ZSBlcnJvciByZXBvcnRpbmcuXG4vLyAtIHZhbHVlOiBjdXJyZW50IHZhbHVlIGZyb20gc3R5bGUgYmVpbmcgZXZhbHVhdGVkLiBNYXkgYmUgYW55dGhpbmcgZnJvbSBhXG4vLyAgIGhpZ2ggbGV2ZWwgb2JqZWN0IHRoYXQgbmVlZHMgdG8gYmUgZGVzY2VuZGVkIGludG8gZGVlcGVyIG9yIGEgc2ltcGxlXG4vLyAgIHNjYWxhciB2YWx1ZS5cbi8vIC0gdmFsdWVTcGVjOiBjdXJyZW50IHNwZWMgYmVpbmcgZXZhbHVhdGVkLiBUcmFja3MgdmFsdWUuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucykge1xuXG4gICAgdmFyIHZhbGlkYXRlRnVuY3Rpb24gPSByZXF1aXJlKCcuL3ZhbGlkYXRlX2Z1bmN0aW9uJyk7XG4gICAgdmFyIHZhbGlkYXRlT2JqZWN0ID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9vYmplY3QnKTtcbiAgICB2YXIgVkFMSURBVE9SUyA9IHtcbiAgICAgICAgJyonOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgJ2FycmF5JzogcmVxdWlyZSgnLi92YWxpZGF0ZV9hcnJheScpLFxuICAgICAgICAnYm9vbGVhbic6IHJlcXVpcmUoJy4vdmFsaWRhdGVfYm9vbGVhbicpLFxuICAgICAgICAnbnVtYmVyJzogcmVxdWlyZSgnLi92YWxpZGF0ZV9udW1iZXInKSxcbiAgICAgICAgJ2NvbG9yJzogcmVxdWlyZSgnLi92YWxpZGF0ZV9jb2xvcicpLFxuICAgICAgICAnY29uc3RhbnRzJzogcmVxdWlyZSgnLi92YWxpZGF0ZV9jb25zdGFudHMnKSxcbiAgICAgICAgJ2VudW0nOiByZXF1aXJlKCcuL3ZhbGlkYXRlX2VudW0nKSxcbiAgICAgICAgJ2ZpbHRlcic6IHJlcXVpcmUoJy4vdmFsaWRhdGVfZmlsdGVyJyksXG4gICAgICAgICdmdW5jdGlvbic6IHJlcXVpcmUoJy4vdmFsaWRhdGVfZnVuY3Rpb24nKSxcbiAgICAgICAgJ2xheWVyJzogcmVxdWlyZSgnLi92YWxpZGF0ZV9sYXllcicpLFxuICAgICAgICAnb2JqZWN0JzogcmVxdWlyZSgnLi92YWxpZGF0ZV9vYmplY3QnKSxcbiAgICAgICAgJ3NvdXJjZSc6IHJlcXVpcmUoJy4vdmFsaWRhdGVfc291cmNlJyksXG4gICAgICAgICdzdHJpbmcnOiByZXF1aXJlKCcuL3ZhbGlkYXRlX3N0cmluZycpXG4gICAgfTtcblxuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIHZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjO1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcblxuICAgIGlmIChnZXRUeXBlKHZhbHVlKSA9PT0gJ3N0cmluZycgJiYgdmFsdWVbMF0gPT09ICdAJykge1xuICAgICAgICBpZiAoc3R5bGVTcGVjLiR2ZXJzaW9uID4gNykge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdjb25zdGFudHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYXMgb2YgdjgnKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEodmFsdWUgaW4gc3R5bGUuY29uc3RhbnRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdjb25zdGFudCBcIiVzXCIgbm90IGZvdW5kJywgdmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zLCB7IHZhbHVlOiBzdHlsZS5jb25zdGFudHNbdmFsdWVdIH0pO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZVNwZWMuZnVuY3Rpb24gJiYgZ2V0VHlwZSh2YWx1ZSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUZ1bmN0aW9uKG9wdGlvbnMpO1xuXG4gICAgfSBlbHNlIGlmICh2YWx1ZVNwZWMudHlwZSAmJiBWQUxJREFUT1JTW3ZhbHVlU3BlYy50eXBlXSkge1xuICAgICAgICByZXR1cm4gVkFMSURBVE9SU1t2YWx1ZVNwZWMudHlwZV0ob3B0aW9ucyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHZhbHVlU3BlYy50eXBlID8gc3R5bGVTcGVjW3ZhbHVlU3BlYy50eXBlXSA6IHZhbHVlU3BlY1xuICAgICAgICB9KSk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdldFR5cGUgPSByZXF1aXJlKCcuLi91dGlsL2dldF90eXBlJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRlJyk7XG52YXIgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlQXJyYXkob3B0aW9ucykge1xuICAgIHZhciBhcnJheSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIGFycmF5U3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjO1xuICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG4gICAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgdmFsaWRhdGVBcnJheUVsZW1lbnQgPSBvcHRpb25zLmFycmF5RWxlbWVudFZhbGlkYXRvciB8fCB2YWxpZGF0ZTtcblxuICAgIGlmIChnZXRUeXBlKGFycmF5KSAhPT0gJ2FycmF5Jykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBhcnJheSwgJ2FycmF5IGV4cGVjdGVkLCAlcyBmb3VuZCcsIGdldFR5cGUoYXJyYXkpKV07XG4gICAgfVxuXG4gICAgaWYgKGFycmF5U3BlYy5sZW5ndGggJiYgYXJyYXkubGVuZ3RoICE9PSBhcnJheVNwZWMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGFycmF5LCAnYXJyYXkgbGVuZ3RoICVkIGV4cGVjdGVkLCBsZW5ndGggJWQgZm91bmQnLCBhcnJheVNwZWMubGVuZ3RoLCBhcnJheS5sZW5ndGgpXTtcbiAgICB9XG5cbiAgICBpZiAoYXJyYXlTcGVjWydtaW4tbGVuZ3RoJ10gJiYgYXJyYXkubGVuZ3RoIDwgYXJyYXlTcGVjWydtaW4tbGVuZ3RoJ10pIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgYXJyYXksICdhcnJheSBsZW5ndGggYXQgbGVhc3QgJWQgZXhwZWN0ZWQsIGxlbmd0aCAlZCBmb3VuZCcsIGFycmF5U3BlY1snbWluLWxlbmd0aCddLCBhcnJheS5sZW5ndGgpXTtcbiAgICB9XG5cbiAgICB2YXIgYXJyYXlFbGVtZW50U3BlYyA9IHtcbiAgICAgICAgXCJ0eXBlXCI6IGFycmF5U3BlYy52YWx1ZVxuICAgIH07XG5cbiAgICBpZiAoc3R5bGVTcGVjLiR2ZXJzaW9uIDwgNykge1xuICAgICAgICBhcnJheUVsZW1lbnRTcGVjLmZ1bmN0aW9uID0gYXJyYXlTcGVjLmZ1bmN0aW9uO1xuICAgIH1cblxuICAgIGlmIChnZXRUeXBlKGFycmF5U3BlYy52YWx1ZSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGFycmF5RWxlbWVudFNwZWMgPSBhcnJheVNwZWMudmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUFycmF5RWxlbWVudCh7XG4gICAgICAgICAgICBhcnJheTogYXJyYXksXG4gICAgICAgICAgICBhcnJheUluZGV4OiBpLFxuICAgICAgICAgICAgdmFsdWU6IGFycmF5W2ldLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBhcnJheUVsZW1lbnRTcGVjLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsXG4gICAgICAgICAgICBrZXk6IGtleSArICdbJyArIGkgKyAnXSdcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdldFR5cGUgPSByZXF1aXJlKCcuLi91dGlsL2dldF90eXBlJyk7XG52YXIgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlQm9vbGVhbihvcHRpb25zKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHR5cGUgPSBnZXRUeXBlKHZhbHVlKTtcblxuICAgIGlmICh0eXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdib29sZWFuIGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xudmFyIGdldFR5cGUgPSByZXF1aXJlKCcuLi91dGlsL2dldF90eXBlJyk7XG52YXIgcGFyc2VDU1NDb2xvciA9IHJlcXVpcmUoJ2Nzc2NvbG9ycGFyc2VyJykucGFyc2VDU1NDb2xvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZUNvbG9yKG9wdGlvbnMpIHtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIgdHlwZSA9IGdldFR5cGUodmFsdWUpO1xuXG4gICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnY29sb3IgZXhwZWN0ZWQsICVzIGZvdW5kJywgdHlwZSldO1xuICAgIH1cblxuICAgIGlmIChwYXJzZUNTU0NvbG9yKHZhbHVlKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2NvbG9yIGV4cGVjdGVkLCBcIiVzXCIgZm91bmQnLCB2YWx1ZSldO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG52YXIgZ2V0VHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0X3R5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZUNvbnN0YW50cyhvcHRpb25zKSB7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciBjb25zdGFudHMgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcblxuICAgIGlmIChzdHlsZVNwZWMuJHZlcnNpb24gPiA3KSB7XG4gICAgICAgIGlmIChjb25zdGFudHMpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGNvbnN0YW50cywgJ2NvbnN0YW50cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2OCcpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0VHlwZShjb25zdGFudHMpO1xuICAgICAgICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGNvbnN0YW50cywgJ29iamVjdCBleHBlY3RlZCwgJXMgZm91bmQnLCB0eXBlKV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgIGZvciAodmFyIGNvbnN0YW50TmFtZSBpbiBjb25zdGFudHMpIHtcbiAgICAgICAgICAgIGlmIChjb25zdGFudE5hbWVbMF0gIT09ICdAJykge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5ICsgJy4nICsgY29uc3RhbnROYW1lLCBjb25zdGFudHNbY29uc3RhbnROYW1lXSwgJ2NvbnN0YW50cyBtdXN0IHN0YXJ0IHdpdGggXCJAXCInKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG52YXIgdW5idW5kbGUgPSByZXF1aXJlKCcuLi91dGlsL3VuYnVuZGxlX2pzb25saW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVFbnVtKG9wdGlvbnMpIHtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIgdmFsdWVTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWM7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuXG4gICAgaWYgKHZhbHVlU3BlYy52YWx1ZXMuaW5kZXhPZih1bmJ1bmRsZSh2YWx1ZSkpID09PSAtMSkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdleHBlY3RlZCBvbmUgb2YgWyVzXSwgJXMgZm91bmQnLCB2YWx1ZVNwZWMudmFsdWVzLmpvaW4oJywgJyksIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xudmFyIHZhbGlkYXRlRW51bSA9IHJlcXVpcmUoJy4vdmFsaWRhdGVfZW51bScpO1xudmFyIGdldFR5cGUgPSByZXF1aXJlKCcuLi91dGlsL2dldF90eXBlJyk7XG52YXIgdW5idW5kbGUgPSByZXF1aXJlKCcuLi91dGlsL3VuYnVuZGxlX2pzb25saW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVGaWx0ZXIob3B0aW9ucykge1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICB2YXIgdHlwZTtcblxuICAgIHZhciBlcnJvcnMgPSBbXTtcblxuICAgIGlmIChnZXRUeXBlKHZhbHVlKSAhPT0gJ2FycmF5Jykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2FycmF5IGV4cGVjdGVkLCAlcyBmb3VuZCcsIGdldFR5cGUodmFsdWUpKV07XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdmaWx0ZXIgYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IDEgZWxlbWVudCcpXTtcbiAgICB9XG5cbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlRW51bSh7XG4gICAgICAgIGtleToga2V5ICsgJ1swXScsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVswXSxcbiAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuZmlsdGVyX29wZXJhdG9yLFxuICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlY1xuICAgIH0pKTtcblxuICAgIHN3aXRjaCAodW5idW5kbGUodmFsdWVbMF0pKSB7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID49IDIgJiYgdmFsdWVbMV0gPT0gJyR0eXBlJykge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ1wiJHR5cGVcIiBjYW5ub3QgYmUgdXNlIHdpdGggb3BlcmF0b3IgXCIlc1wiJywgdmFsdWVbMF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT0gMykge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2ZpbHRlciBhcnJheSBmb3Igb3BlcmF0b3IgXCIlc1wiIG11c3QgaGF2ZSAzIGVsZW1lbnRzJywgdmFsdWVbMF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdpbic6XG4gICAgICAgIGNhc2UgJyFpbic6XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gZ2V0VHlwZSh2YWx1ZVsxXSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5ICsgJ1sxXScsIHZhbHVlWzFdLCAnc3RyaW5nIGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlWzFdWzBdID09PSAnQCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXkgKyAnWzFdJywgdmFsdWVbMV0sICdmaWx0ZXIga2V5IGNhbm5vdCBiZSBhIGNvbnN0YW50JykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gZ2V0VHlwZSh2YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWzFdID09ICckdHlwZScpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUVudW0oe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXkgKyAnWycgKyBpICsgJ10nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuZ2VvbWV0cnlfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlY1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWx1ZVtpXVswXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5ICsgJ1snICsgaSArICddJywgdmFsdWVbaV0sICdmaWx0ZXIgdmFsdWUgY2Fubm90IGJlIGEgY29uc3RhbnQnKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSAnc3RyaW5nJyAmJiB0eXBlICE9PSAnbnVtYmVyJyAmJiB0eXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXkgKyAnWycgKyBpICsgJ10nLCB2YWx1ZVtpXSwgJ3N0cmluZywgbnVtYmVyLCBvciBib29sZWFuIGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhbnknOlxuICAgICAgICBjYXNlICdhbGwnOlxuICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVGaWx0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSArICdbJyArIGkgKyAnXScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWNcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdoYXMnOlxuICAgICAgICBjYXNlICchaGFzJzpcbiAgICAgICAgICAgIHR5cGUgPSBnZXRUeXBlKHZhbHVlWzFdKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdmaWx0ZXIgYXJyYXkgZm9yIFwiJXNcIiBvcGVyYXRvciBtdXN0IGhhdmUgMiBlbGVtZW50cycsIHZhbHVlWzBdKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXkgKyAnWzFdJywgdmFsdWVbMV0sICdzdHJpbmcgZXhwZWN0ZWQsICVzIGZvdW5kJywgdHlwZSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVsxXVswXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXkgKyAnWzFdJywgdmFsdWVbMV0sICdmaWx0ZXIga2V5IGNhbm5vdCBiZSBhIGNvbnN0YW50JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3JzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL3ZhbGlkYXRpb25fZXJyb3InKTtcbnZhciBnZXRUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9nZXRfdHlwZScpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi92YWxpZGF0ZScpO1xudmFyIHZhbGlkYXRlT2JqZWN0ID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9vYmplY3QnKTtcbnZhciB2YWxpZGF0ZUFycmF5ID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9hcnJheScpO1xudmFyIHZhbGlkYXRlTnVtYmVyID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9udW1iZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgb3JpZ2luYWxWYWx1ZVNwZWMgPSBvcHRpb25zLnZhbHVlU3BlYztcbiAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IG9wdGlvbnMudmFsdWU7XG5cbiAgICB2YXIgc3RvcEtleVR5cGU7XG5cbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZSxcbiAgICAgICAgdmFsdWVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYy5mdW5jdGlvbixcbiAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMsXG4gICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7IHN0b3BzOiB2YWxpZGF0ZUZ1bmN0aW9uU3RvcHMgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvblN0b3BzKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuXG4gICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVBcnJheSh7XG4gICAgICAgICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBvcHRpb25zLnZhbHVlU3BlYyxcbiAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYyxcbiAgICAgICAgICAgIGFycmF5RWxlbWVudFZhbGlkYXRvcjogdmFsaWRhdGVGdW5jdGlvblN0b3BcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGlmIChnZXRUeXBlKHZhbHVlKSA9PT0gJ2FycmF5JyAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIHZhbHVlLCAnYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBzdG9wJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uU3RvcChvcHRpb25zKSB7XG4gICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICAgICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuXG4gICAgICAgIGlmIChnZXRUeXBlKHZhbHVlKSAhPT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdhcnJheSBleHBlY3RlZCwgJXMgZm91bmQnLCBnZXRUeXBlKHZhbHVlKSldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdhcnJheSBsZW5ndGggJWQgZXhwZWN0ZWQsIGxlbmd0aCAlZCBmb3VuZCcsIDIsIHZhbHVlLmxlbmd0aCldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHR5cGUgPSBnZXRUeXBlKHZhbHVlWzBdKTtcbiAgICAgICAgaWYgKCFzdG9wS2V5VHlwZSkgc3RvcEtleVR5cGUgPSB0eXBlO1xuICAgICAgICBpZiAodHlwZSAhPT0gc3RvcEtleVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnJXMgc3RvcCBrZXkgdHlwZSBtdXN0IG1hdGNoIHByZXZpb3VzIHN0b3Aga2V5IHR5cGUgJXMnLCB0eXBlLCBzdG9wS2V5VHlwZSldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVbMF0uem9vbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdvYmplY3Qgc3RvcCBrZXkgbXVzdCBoYXZlIHpvb20nKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVbMF0udmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnb2JqZWN0IHN0b3Aga2V5IG11c3QgaGF2ZSB2YWx1ZScpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgIGtleToga2V5ICsgJ1swXScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIHZhbHVlU3BlYzogeyB6b29tOiB7fSB9LFxuICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMsXG4gICAgICAgICAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHsgem9vbTogdmFsaWRhdGVOdW1iZXIsIHZhbHVlOiB2YWxpZGF0ZVZhbHVlIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpc1pvb21GdW5jdGlvbiA9ICFvcmlnaW5hbFZhbHVlLnByb3BlcnR5O1xuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCgoaXNab29tRnVuY3Rpb24gPyB2YWxpZGF0ZU51bWJlciA6IHZhbGlkYXRlVmFsdWUpKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSArICdbMF0nLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHt9LFxuICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGUoe1xuICAgICAgICAgICAga2V5OiBrZXkgKyAnWzFdJyxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVsxXSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogb3JpZ2luYWxWYWx1ZVNwZWMsXG4gICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWNcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGlmIChnZXRUeXBlKHZhbHVlWzBdKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbFZhbHVlU3BlYy5mdW5jdGlvbiA9PT0gJ3BpZWNld2lzZS1jb25zdGFudCcgJiYgdmFsdWVbMF0gJSAxICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXkgKyAnWzBdJywgdmFsdWVbMF0sICd6b29tIGxldmVsIGZvciBwaWVjZXdpc2UtY29uc3RhbnQgZnVuY3Rpb25zIG11c3QgYmUgYW4gaW50ZWdlcicpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVswXSA8IG9wdGlvbnMuYXJyYXlbb3B0aW9ucy5hcnJheUluZGV4IC0gMV1bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXkgKyAnWzBdJywgdmFsdWVbMF0sICdhcnJheSBzdG9wcyBtdXN0IGFwcGVhciBpbiBhc2NlbmRpbmcgb3JkZXInKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVZhbHVlKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgdHlwZSA9IGdldFR5cGUob3B0aW9ucy52YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlICE9PSAnbnVtYmVyJyAmJiB0eXBlICE9PSAnc3RyaW5nJyAmJiB0eXBlICE9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAncHJvcGVydHkgdmFsdWUgbXVzdCBiZSBhIG51bWJlciwgc3RyaW5nIG9yIGFycmF5JykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xudmFyIHZhbGlkYXRlU3RyaW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9zdHJpbmcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG5cbiAgICB2YXIgZXJyb3JzID0gdmFsaWRhdGVTdHJpbmcob3B0aW9ucyk7XG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHJldHVybiBlcnJvcnM7XG5cbiAgICBpZiAodmFsdWUuaW5kZXhPZigne2ZvbnRzdGFja30nKSA9PT0gLTEpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnXCJnbHlwaHNcIiB1cmwgbXVzdCBpbmNsdWRlIGEgXCJ7Zm9udHN0YWNrfVwiIHRva2VuJykpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZS5pbmRleE9mKCd7cmFuZ2V9JykgPT09IC0xKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ1wiZ2x5cGhzXCIgdXJsIG11c3QgaW5jbHVkZSBhIFwie3JhbmdlfVwiIHRva2VuJykpO1xuICAgIH1cblxuICAgIHJldHVybiBlcnJvcnM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xudmFyIHVuYnVuZGxlID0gcmVxdWlyZSgnLi4vdXRpbC91bmJ1bmRsZV9qc29ubGludCcpO1xudmFyIHZhbGlkYXRlT2JqZWN0ID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9vYmplY3QnKTtcbnZhciB2YWxpZGF0ZUZpbHRlciA9IHJlcXVpcmUoJy4vdmFsaWRhdGVfZmlsdGVyJyk7XG52YXIgdmFsaWRhdGVQYWludFByb3BlcnR5ID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9wYWludF9wcm9wZXJ0eScpO1xudmFyIHZhbGlkYXRlTGF5b3V0UHJvcGVydHkgPSByZXF1aXJlKCcuL3ZhbGlkYXRlX2xheW91dF9wcm9wZXJ0eScpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXh0ZW5kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVMYXllcihvcHRpb25zKSB7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuXG4gICAgdmFyIGxheWVyID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG5cbiAgICBpZiAoIWxheWVyLnR5cGUgJiYgIWxheWVyLnJlZikge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIsICdlaXRoZXIgXCJ0eXBlXCIgb3IgXCJyZWZcIiBpcyByZXF1aXJlZCcpKTtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSB1bmJ1bmRsZShsYXllci50eXBlKTtcbiAgICB2YXIgcmVmID0gdW5idW5kbGUobGF5ZXIucmVmKTtcblxuICAgIGlmIChsYXllci5pZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMuYXJyYXlJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJMYXllciA9IHN0eWxlLmxheWVyc1tpXTtcbiAgICAgICAgICAgIGlmICh1bmJ1bmRsZShvdGhlckxheWVyLmlkKSA9PT0gdW5idW5kbGUobGF5ZXIuaWQpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLmlkLCAnZHVwbGljYXRlIGxheWVyIGlkIFwiJXNcIiwgcHJldmlvdXNseSB1c2VkIGF0IGxpbmUgJWQnLCBsYXllci5pZCwgb3RoZXJMYXllci5pZC5fX2xpbmVfXykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCdyZWYnIGluIGxheWVyKSB7XG4gICAgICAgIFsndHlwZScsICdzb3VyY2UnLCAnc291cmNlLWxheWVyJywgJ2ZpbHRlcicsICdsYXlvdXQnXS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICBpZiAocCBpbiBsYXllcikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllcltwXSwgJ1wiJXNcIiBpcyBwcm9oaWJpdGVkIGZvciByZWYgbGF5ZXJzJywgcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcGFyZW50O1xuXG4gICAgICAgIHN0eWxlLmxheWVycy5mb3JFYWNoKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgICAgICBpZiAobGF5ZXIuaWQgPT0gcmVmKSBwYXJlbnQgPSBsYXllcjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllci5yZWYsICdyZWYgbGF5ZXIgXCIlc1wiIG5vdCBmb3VuZCcsIHJlZikpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmVudC5yZWYpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllci5yZWYsICdyZWYgY2Fubm90IHJlZmVyZW5jZSBhbm90aGVyIHJlZiBsYXllcicpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR5cGUgPSB1bmJ1bmRsZShwYXJlbnQudHlwZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdiYWNrZ3JvdW5kJykge1xuICAgICAgICBpZiAoIWxheWVyLnNvdXJjZSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcInNvdXJjZVwiJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHN0eWxlLnNvdXJjZXNbbGF5ZXIuc291cmNlXTtcbiAgICAgICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnNvdXJjZSwgJ3NvdXJjZSBcIiVzXCIgbm90IGZvdW5kJywgbGF5ZXIuc291cmNlKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS50eXBlID09ICd2ZWN0b3InICYmIHR5cGUgPT0gJ3Jhc3RlcicpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIuc291cmNlLCAnbGF5ZXIgXCIlc1wiIHJlcXVpcmVzIGEgcmFzdGVyIHNvdXJjZScsIGxheWVyLmlkKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS50eXBlID09ICdyYXN0ZXInICYmIHR5cGUgIT0gJ3Jhc3RlcicpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIuc291cmNlLCAnbGF5ZXIgXCIlc1wiIHJlcXVpcmVzIGEgdmVjdG9yIHNvdXJjZScsIGxheWVyLmlkKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS50eXBlID09ICd2ZWN0b3InICYmICFsYXllclsnc291cmNlLWxheWVyJ10pIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIsICdsYXllciBcIiVzXCIgbXVzdCBzcGVjaWZ5IGEgXCJzb3VyY2UtbGF5ZXJcIicsIGxheWVyLmlkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiBsYXllcixcbiAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMubGF5ZXIsXG4gICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgZmlsdGVyOiB2YWxpZGF0ZUZpbHRlcixcbiAgICAgICAgICAgIGxheW91dDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiBsYXllcixcbiAgICAgICAgICAgICAgICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyonOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlTGF5b3V0UHJvcGVydHkoZXh0ZW5kKHtsYXllclR5cGU6IHR5cGV9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYWludDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiBsYXllcixcbiAgICAgICAgICAgICAgICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyonOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlUGFpbnRQcm9wZXJ0eShleHRlbmQoe2xheWVyVHlwZTogdHlwZX0sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIGVycm9ycztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vdmFsaWRhdGUnKTtcbnZhciBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVMYXlvdXRQcm9wZXJ0eShvcHRpb25zKSB7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG4gICAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIHByb3BlcnR5S2V5ID0gb3B0aW9ucy5vYmplY3RLZXk7XG4gICAgdmFyIGxheWVyU3BlYyA9IHN0eWxlU3BlY1snbGF5b3V0XycgKyBvcHRpb25zLmxheWVyVHlwZV07XG5cbiAgICBpZiAob3B0aW9ucy52YWx1ZVNwZWMgfHwgbGF5ZXJTcGVjW3Byb3BlcnR5S2V5XSkge1xuICAgICAgICB2YXIgZXJyb3JzID0gW107XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubGF5ZXJUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5S2V5ID09PSAnaWNvbi1pbWFnZScgJiYgc3R5bGUgJiYgIXN0eWxlLnNwcml0ZSkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ3VzZSBvZiBcImljb24taW1hZ2VcIiByZXF1aXJlcyBhIHN0eWxlIFwic3ByaXRlXCIgcHJvcGVydHknKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5S2V5ID09PSAndGV4dC1maWVsZCcgJiYgc3R5bGUgJiYgIXN0eWxlLmdseXBocykge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ3VzZSBvZiBcInRleHQtZmllbGRcIiByZXF1aXJlcyBhIHN0eWxlIFwiZ2x5cGhzXCIgcHJvcGVydHknKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZSh7XG4gICAgICAgICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBvcHRpb25zLnZhbHVlU3BlYyB8fCBsYXllclNwZWNbcHJvcGVydHlLZXldLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgICAgfSkpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICd1bmtub3duIHByb3BlcnR5IFwiJXNcIicsIHByb3BlcnR5S2V5KV07XG4gICAgfVxuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0VHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0X3R5cGUnKTtcbnZhciBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIob3B0aW9ucykge1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciB2YWx1ZVNwZWMgPSBvcHRpb25zLnZhbHVlU3BlYztcbiAgICB2YXIgdHlwZSA9IGdldFR5cGUodmFsdWUpO1xuXG4gICAgaWYgKHR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnbnVtYmVyIGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpXTtcbiAgICB9XG5cbiAgICBpZiAoJ21pbmltdW0nIGluIHZhbHVlU3BlYyAmJiB2YWx1ZSA8IHZhbHVlU3BlYy5taW5pbXVtKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnJXMgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHZhbHVlICVzJywgdmFsdWUsIHZhbHVlU3BlYy5taW5pbXVtKV07XG4gICAgfVxuXG4gICAgaWYgKCdtYXhpbXVtJyBpbiB2YWx1ZVNwZWMgJiYgdmFsdWUgPiB2YWx1ZVNwZWMubWF4aW11bSkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJyVzIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSB2YWx1ZSAlcycsIHZhbHVlLCB2YWx1ZVNwZWMubWF4aW11bSldO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG52YXIgZ2V0VHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0X3R5cGUnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vdmFsaWRhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvcHRpb25zKSB7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciBvYmplY3QgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciB2YWx1ZVNwZWMgPSBvcHRpb25zLnZhbHVlU3BlYztcbiAgICB2YXIgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnMgPSBvcHRpb25zLm9iamVjdEVsZW1lbnRWYWxpZGF0b3JzIHx8IHt9O1xuICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG4gICAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIHZhciBlcnJvcnMgPSBbXTtcblxuICAgIHZhciB0eXBlID0gZ2V0VHlwZShvYmplY3QpO1xuICAgIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBvYmplY3QsICdvYmplY3QgZXhwZWN0ZWQsICVzIGZvdW5kJywgdHlwZSldO1xuICAgIH1cblxuICAgIGZvciAodmFyIG9iamVjdEtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgdmFyIHZhbHVlU3BlY0tleSA9IG9iamVjdEtleS5zcGxpdCgnLicpWzBdOyAvLyB0cmVhdCAncGFpbnQuKicgYXMgJ3BhaW50J1xuICAgICAgICB2YXIgb2JqZWN0RWxlbWVudFNwZWMgPSB2YWx1ZVNwZWMgJiYgKHZhbHVlU3BlY1t2YWx1ZVNwZWNLZXldIHx8IHZhbHVlU3BlY1snKiddKTtcbiAgICAgICAgdmFyIG9iamVjdEVsZW1lbnRWYWxpZGF0b3IgPSBvYmplY3RFbGVtZW50VmFsaWRhdG9yc1t2YWx1ZVNwZWNLZXldIHx8IG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzWycqJ107XG5cbiAgICAgICAgaWYgKG9iamVjdEVsZW1lbnRTcGVjIHx8IG9iamVjdEVsZW1lbnRWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoKG9iamVjdEVsZW1lbnRWYWxpZGF0b3IgfHwgdmFsaWRhdGUpKHtcbiAgICAgICAgICAgICAgICBrZXk6IChrZXkgPyBrZXkgKyAnLicgOiBrZXkpICsgb2JqZWN0S2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBvYmplY3Rbb2JqZWN0S2V5XSxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IG9iamVjdEVsZW1lbnRTcGVjLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlYyxcbiAgICAgICAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICAgICAgICBvYmplY3RLZXk6IG9iamVjdEtleVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIC8vIHRvbGVyYXRlIHJvb3QtbGV2ZWwgZXh0cmEga2V5cyAmIGFyYml0cmFyeSBsYXllciBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgbGF5ZXItc3BlY2lmaWMgbG9naWNcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgIT09ICcnICYmIGtleS5zcGxpdCgnLicpLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIG9iamVjdFtvYmplY3RLZXldLCAndW5rbm93biBwcm9wZXJ0eSBcIiVzXCInLCBvYmplY3RLZXkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFsdWVTcGVjS2V5IGluIHZhbHVlU3BlYykge1xuICAgICAgICBpZiAodmFsdWVTcGVjW3ZhbHVlU3BlY0tleV0ucmVxdWlyZWQgJiYgdmFsdWVTcGVjW3ZhbHVlU3BlY0tleV1bJ2RlZmF1bHQnXSA9PT0gdW5kZWZpbmVkICYmIG9iamVjdFt2YWx1ZVNwZWNLZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBvYmplY3QsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IFwiJXNcIicsIHZhbHVlU3BlY0tleSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVycm9ycztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vdmFsaWRhdGUnKTtcbnZhciBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVQYWludFByb3BlcnR5KG9wdGlvbnMpIHtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIgcHJvcGVydHlLZXkgPSBvcHRpb25zLm9iamVjdEtleTtcbiAgICB2YXIgbGF5ZXJTcGVjID0gc3R5bGVTcGVjWydwYWludF8nICsgb3B0aW9ucy5sYXllclR5cGVdO1xuXG4gICAgdmFyIHRyYW5zaXRpb25NYXRjaCA9IHByb3BlcnR5S2V5Lm1hdGNoKC9eKC4qKS10cmFuc2l0aW9uJC8pO1xuXG4gICAgaWYgKHRyYW5zaXRpb25NYXRjaCAmJiBsYXllclNwZWNbdHJhbnNpdGlvbk1hdGNoWzFdXSAmJiBsYXllclNwZWNbdHJhbnNpdGlvbk1hdGNoWzFdXS50cmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh7XG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLnRyYW5zaXRpb24sXG4gICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICB9KTtcblxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy52YWx1ZVNwZWMgfHwgbGF5ZXJTcGVjW3Byb3BlcnR5S2V5XSkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUoe1xuICAgICAgICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogb3B0aW9ucy52YWx1ZVNwZWMgfHwgbGF5ZXJTcGVjW3Byb3BlcnR5S2V5XSxcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgIH0pO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICd1bmtub3duIHByb3BlcnR5IFwiJXNcIicsIHByb3BlcnR5S2V5KV07XG4gICAgfVxuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xudmFyIHVuYnVuZGxlID0gcmVxdWlyZSgnLi4vdXRpbC91bmJ1bmRsZV9qc29ubGludCcpO1xudmFyIHZhbGlkYXRlT2JqZWN0ID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9vYmplY3QnKTtcbnZhciB2YWxpZGF0ZUVudW0gPSByZXF1aXJlKCcuL3ZhbGlkYXRlX2VudW0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZVNvdXJjZShvcHRpb25zKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG5cbiAgICBpZiAoIXZhbHVlLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdcInR5cGVcIiBpcyByZXF1aXJlZCcpXTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IHVuYnVuZGxlKHZhbHVlLnR5cGUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICd2ZWN0b3InOlxuICAgICAgICBjYXNlICdyYXN0ZXInOlxuICAgICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLnNvdXJjZV90aWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAoJ3VybCcgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChbJ3R5cGUnLCAndXJsJywgJ3RpbGVTaXplJ10uaW5kZXhPZihwcm9wKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5ICsgJy4nICsgcHJvcCwgdmFsdWVbcHJvcF0sICdhIHNvdXJjZSB3aXRoIGEgXCJ1cmxcIiBwcm9wZXJ0eSBtYXkgbm90IGluY2x1ZGUgYSBcIiVzXCIgcHJvcGVydHknLCBwcm9wKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuXG4gICAgICAgIGNhc2UgJ2dlb2pzb24nOlxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuc291cmNlX2dlb2pzb24sXG4gICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5zb3VyY2VfdmlkZW8sXG4gICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5zb3VyY2VfaW1hZ2UsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlRW51bSh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXkgKyAnLnR5cGUnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS50eXBlLFxuICAgICAgICAgICAgICAgIHZhbHVlU3BlYzoge3ZhbHVlczogWyd2ZWN0b3InLCAncmFzdGVyJywgJ2dlb2pzb24nLCAndmlkZW8nLCAnaW1hZ2UnXX0sXG4gICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgICAgICB9KTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0VHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0X3R5cGUnKTtcbnZhciBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcob3B0aW9ucykge1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciB0eXBlID0gZ2V0VHlwZSh2YWx1ZSk7XG5cbiAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdzdHJpbmcgZXhwZWN0ZWQsICVzIGZvdW5kJywgdHlwZSldO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB2YWxpZGF0ZUNvbnN0YW50cyA9IHJlcXVpcmUoJy4vdmFsaWRhdGUvdmFsaWRhdGVfY29uc3RhbnRzJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRlL3ZhbGlkYXRlJyk7XG52YXIgbGF0ZXN0U3R5bGVTcGVjID0gcmVxdWlyZSgnLi4vcmVmZXJlbmNlL2xhdGVzdC5taW4nKTtcbnZhciB2YWxpZGF0ZUdseXBoc1VSTCA9IHJlcXVpcmUoJy4vdmFsaWRhdGUvdmFsaWRhdGVfZ2x5cGhzX3VybCcpO1xuXG4vKipcbiAqIFZhbGlkYXRlIGEgTWFwYm94IEdMIHN0eWxlIGFnYWluc3QgdGhlIHN0eWxlIHNwZWNpZmljYXRpb24uIFRoaXMgZW50cnlwb2ludCxcbiAqIGBtYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGVfc3R5bGUubWluYCwgaXMgZGVzaWduZWQgdG8gcHJvZHVjZSBhc1xuICogc21hbGwgYSBicm93c2VyaWZ5IGJ1bmRsZSBhcyBwb3NzaWJsZSBieSBvbWl0dGluZyB1bm5lY2Vzc2FyeSBmdW5jdGlvbmFsaXR5XG4gKiBhbmQgbGVnYWN5IHN0eWxlIHNwZWNpZmljYXRpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSBUaGUgc3R5bGUgdG8gYmUgdmFsaWRhdGVkLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZVNwZWNdIFRoZSBzdHlsZSBzcGVjaWZpY2F0aW9uIHRvIHZhbGlkYXRlIGFnYWluc3QuXG4gKiAgICAgSWYgb21pdHRlZCwgdGhlIGxhdGVzdCBzdHlsZSBzcGVjIGlzIHVzZWQuXG4gKiBAcmV0dXJucyB7QXJyYXk8VmFsaWRhdGlvbkVycm9yPn1cbiAqIEBleGFtcGxlXG4gKiAgIHZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJ21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZV9zdHlsZS5taW4nKTtcbiAqICAgdmFyIGVycm9ycyA9IHZhbGlkYXRlKHN0eWxlKTtcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTdHlsZU1pbihzdHlsZSwgc3R5bGVTcGVjKSB7XG4gICAgc3R5bGVTcGVjID0gc3R5bGVTcGVjIHx8IGxhdGVzdFN0eWxlU3BlYztcblxuICAgIHZhciBlcnJvcnMgPSBbXTtcblxuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGUoe1xuICAgICAgICBrZXk6ICcnLFxuICAgICAgICB2YWx1ZTogc3R5bGUsXG4gICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLiRyb290LFxuICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlYyxcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgZ2x5cGhzOiB2YWxpZGF0ZUdseXBoc1VSTFxuICAgICAgICB9XG4gICAgfSkpO1xuXG4gICAgaWYgKHN0eWxlU3BlYy4kdmVyc2lvbiA+IDcgJiYgc3R5bGUuY29uc3RhbnRzKSB7XG4gICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVDb25zdGFudHMoe1xuICAgICAgICAgICAga2V5OiAnY29uc3RhbnRzJyxcbiAgICAgICAgICAgIHZhbHVlOiBzdHlsZS5jb25zdGFudHMsXG4gICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvcnRFcnJvcnMoZXJyb3JzKTtcbn1cblxudmFsaWRhdGVTdHlsZU1pbi5zb3VyY2UgPSB3cmFwQ2xlYW5FcnJvcnMocmVxdWlyZSgnLi92YWxpZGF0ZS92YWxpZGF0ZV9zb3VyY2UnKSk7XG52YWxpZGF0ZVN0eWxlTWluLmxheWVyID0gd3JhcENsZWFuRXJyb3JzKHJlcXVpcmUoJy4vdmFsaWRhdGUvdmFsaWRhdGVfbGF5ZXInKSk7XG52YWxpZGF0ZVN0eWxlTWluLmZpbHRlciA9IHdyYXBDbGVhbkVycm9ycyhyZXF1aXJlKCcuL3ZhbGlkYXRlL3ZhbGlkYXRlX2ZpbHRlcicpKTtcbnZhbGlkYXRlU3R5bGVNaW4ucGFpbnRQcm9wZXJ0eSA9IHdyYXBDbGVhbkVycm9ycyhyZXF1aXJlKCcuL3ZhbGlkYXRlL3ZhbGlkYXRlX3BhaW50X3Byb3BlcnR5JykpO1xudmFsaWRhdGVTdHlsZU1pbi5sYXlvdXRQcm9wZXJ0eSA9IHdyYXBDbGVhbkVycm9ycyhyZXF1aXJlKCcuL3ZhbGlkYXRlL3ZhbGlkYXRlX2xheW91dF9wcm9wZXJ0eScpKTtcblxuZnVuY3Rpb24gc29ydEVycm9ycyhlcnJvcnMpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KGVycm9ycykuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5saW5lIC0gYi5saW5lO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB3cmFwQ2xlYW5FcnJvcnMoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzb3J0RXJyb3JzKGlubmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRhdGVTdHlsZU1pbjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi92OC5qc29uJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vdjgubWluLmpzb24nKTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkdmVyc2lvblwiOiA4LFxuICBcIiRyb290XCI6IHtcbiAgICBcInZlcnNpb25cIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogWzhdLFxuICAgICAgXCJkb2NcIjogXCJTdHlsZXNoZWV0IHZlcnNpb24gbnVtYmVyLiBNdXN0IGJlIDguXCIsXG4gICAgICBcImV4YW1wbGVcIjogOFxuICAgIH0sXG4gICAgXCJuYW1lXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJBIGh1bWFuLXJlYWRhYmxlIG5hbWUgZm9yIHRoZSBzdHlsZS5cIixcbiAgICAgIFwiZXhhbXBsZVwiOiBcIkJyaWdodFwiXG4gICAgfSxcbiAgICBcIm1ldGFkYXRhXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIipcIixcbiAgICAgIFwiZG9jXCI6IFwiQXJiaXRyYXJ5IHByb3BlcnRpZXMgdXNlZnVsIHRvIHRyYWNrIHdpdGggdGhlIHN0eWxlc2hlZXQsIGJ1dCBkbyBub3QgaW5mbHVlbmNlIHJlbmRlcmluZy4gUHJvcGVydGllcyBzaG91bGQgYmUgcHJlZml4ZWQgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSAnbWFwYm94OicuXCJcbiAgICB9LFxuICAgIFwiY2VudGVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIkRlZmF1bHQgbWFwIGNlbnRlciBpbiBsb25naXR1ZGUgYW5kIGxhdGl0dWRlLiAgVGhlIHN0eWxlIGNlbnRlciB3aWxsIGJlIHVzZWQgb25seSBpZiB0aGUgbWFwIGhhcyBub3QgYmVlbiBwb3NpdGlvbmVkIGJ5IG90aGVyIG1lYW5zIChlLmcuIG1hcCBvcHRpb25zIG9yIHVzZXIgaW50ZXJhY3Rpb24pLlwiLFxuICAgICAgXCJleGFtcGxlXCI6IFstNzMuOTc0OSwgNDAuNzczNl1cbiAgICB9LFxuICAgIFwiem9vbVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiRGVmYXVsdCB6b29tIGxldmVsLiAgVGhlIHN0eWxlIHpvb20gd2lsbCBiZSB1c2VkIG9ubHkgaWYgdGhlIG1hcCBoYXMgbm90IGJlZW4gcG9zaXRpb25lZCBieSBvdGhlciBtZWFucyAoZS5nLiBtYXAgb3B0aW9ucyBvciB1c2VyIGludGVyYWN0aW9uKS5cIixcbiAgICAgIFwiZXhhbXBsZVwiOiAxMi41XG4gICAgfSxcbiAgICBcImJlYXJpbmdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwicGVyaW9kXCI6IDM2MCxcbiAgICAgIFwidW5pdHNcIjogXCJkZWdyZWVzXCIsXG4gICAgICBcImRvY1wiOiBcIkRlZmF1bHQgYmVhcmluZywgaW4gZGVncmVlcy4gIFRoZSBzdHlsZSBiZWFyaW5nIHdpbGwgYmUgdXNlZCBvbmx5IGlmIHRoZSBtYXAgaGFzIG5vdCBiZWVuIHBvc2l0aW9uZWQgYnkgb3RoZXIgbWVhbnMgKGUuZy4gbWFwIG9wdGlvbnMgb3IgdXNlciBpbnRlcmFjdGlvbikuXCIsXG4gICAgICBcImV4YW1wbGVcIjogMjlcbiAgICB9LFxuICAgIFwicGl0Y2hcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwidW5pdHNcIjogXCJkZWdyZWVzXCIsXG4gICAgICBcImRvY1wiOiBcIkRlZmF1bHQgcGl0Y2gsIGluIGRlZ3JlZXMuIFplcm8gaXMgcGVycGVuZGljdWxhciB0byB0aGUgc3VyZmFjZS4gIFRoZSBzdHlsZSBwaXRjaCB3aWxsIGJlIHVzZWQgb25seSBpZiB0aGUgbWFwIGhhcyBub3QgYmVlbiBwb3NpdGlvbmVkIGJ5IG90aGVyIG1lYW5zIChlLmcuIG1hcCBvcHRpb25zIG9yIHVzZXIgaW50ZXJhY3Rpb24pLlwiLFxuICAgICAgXCJleGFtcGxlXCI6IDUwXG4gICAgfSxcbiAgICBcInNvdXJjZXNcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwic291cmNlc1wiLFxuICAgICAgXCJkb2NcIjogXCJEYXRhIHNvdXJjZSBzcGVjaWZpY2F0aW9ucy5cIixcbiAgICAgIFwiZXhhbXBsZVwiOiB7XG4gICAgICAgIFwibWFwYm94LXN0cmVldHNcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInZlY3RvclwiLFxuICAgICAgICAgIFwidXJsXCI6IFwibWFwYm94Oi8vbWFwYm94Lm1hcGJveC1zdHJlZXRzLXY2XCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJzcHJpdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIkEgYmFzZSBVUkwgZm9yIHJldHJpZXZpbmcgdGhlIHNwcml0ZSBpbWFnZSBhbmQgbWV0YWRhdGEuIFRoZSBleHRlbnNpb25zIGAucG5nYCwgYC5qc29uYCBhbmQgc2NhbGUgZmFjdG9yIGBAMngucG5nYCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYXBwZW5kZWQuIFRoaXMgcHJvcGVydHkgaXMgcmVxdWlyZWQgaWYgYW55IGxheWVyIHVzZXMgdGhlICdzcHJpdGUtaW1hZ2UnIGxheW91dCBwcm9wZXJ0eS5cIixcbiAgICAgIFwiZXhhbXBsZVwiOiBcIm1hcGJveDovL3Nwcml0ZXMvbWFwYm94L2JyaWdodC12OFwiXG4gICAgfSxcbiAgICBcImdseXBoc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBVUkwgdGVtcGxhdGUgZm9yIGxvYWRpbmcgc2lnbmVkLWRpc3RhbmNlLWZpZWxkIGdseXBoIHNldHMgaW4gUEJGIGZvcm1hdC4gVGhlIFVSTCBtdXN0IGluY2x1ZGUgYHtmb250c3RhY2t9YCBhbmQgYHtyYW5nZX1gIHRva2Vucy4gVGhpcyBwcm9wZXJ0eSBpcyByZXF1aXJlZCBpZiBhbnkgbGF5ZXIgdXNlcyB0aGUgJ3RleHQtZmllbGQnIGxheW91dCBwcm9wZXJ0eS5cIixcbiAgICAgIFwiZXhhbXBsZVwiOiBcIm1hcGJveDovL2ZvbnRzL21hcGJveC97Zm9udHN0YWNrfS97cmFuZ2V9LnBiZlwiXG4gICAgfSxcbiAgICBcInRyYW5zaXRpb25cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwidHJhbnNpdGlvblwiLFxuICAgICAgXCJkb2NcIjogXCJBIGdsb2JhbCB0cmFuc2l0aW9uIGRlZmluaXRpb24gdG8gdXNlIGFzIGEgZGVmYXVsdCBhY3Jvc3MgcHJvcGVydGllcy5cIixcbiAgICAgIFwiZXhhbXBsZVwiOiB7XG4gICAgICAgIFwiZHVyYXRpb25cIjogMzAwLFxuICAgICAgICBcImRlbGF5XCI6IDBcbiAgICAgIH1cbiAgICB9LFxuICAgIFwibGF5ZXJzXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibGF5ZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiTGF5ZXJzIHdpbGwgYmUgZHJhd24gaW4gdGhlIG9yZGVyIG9mIHRoaXMgYXJyYXkuXCIsXG4gICAgICBcImV4YW1wbGVcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJpZFwiOiBcIndhdGVyXCIsXG4gICAgICAgICAgXCJzb3VyY2VcIjogXCJtYXBib3gtc3RyZWV0c1wiLFxuICAgICAgICAgIFwic291cmNlLWxheWVyXCI6IFwid2F0ZXJcIixcbiAgICAgICAgICBcInR5cGVcIjogXCJmaWxsXCIsXG4gICAgICAgICAgXCJwYWludFwiOiB7XG4gICAgICAgICAgICBcImZpbGwtY29sb3JcIjogXCIjMDBmZmZmXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG4gIH0sXG4gIFwic291cmNlc1wiOiB7XG4gICAgXCIqXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInNvdXJjZVwiLFxuICAgICAgXCJkb2NcIjogXCJTcGVjaWZpY2F0aW9uIG9mIGEgZGF0YSBzb3VyY2UuIEZvciB2ZWN0b3IgYW5kIHJhc3RlciBzb3VyY2VzLCBlaXRoZXIgVGlsZUpTT04gb3IgYSBVUkwgdG8gYSBUaWxlSlNPTiBtdXN0IGJlIHByb3ZpZGVkLiBGb3IgR2VvSlNPTiBhbmQgdmlkZW8gc291cmNlcywgYSBVUkwgbXVzdCBiZSBwcm92aWRlZC5cIlxuICAgIH1cbiAgfSxcbiAgXCJzb3VyY2VcIjogW1xuICAgIFwic291cmNlX3RpbGVcIixcbiAgICBcInNvdXJjZV9nZW9qc29uXCIsXG4gICAgXCJzb3VyY2VfdmlkZW9cIixcbiAgICBcInNvdXJjZV9pbWFnZVwiXG4gIF0sXG4gIFwic291cmNlX3RpbGVcIjoge1xuICAgIFwidHlwZVwiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwidmVjdG9yXCIsXG4gICAgICAgIFwicmFzdGVyXCJcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIlRoZSBkYXRhIHR5cGUgb2YgdGhlIHRpbGUgc291cmNlLlwiXG4gICAgfSxcbiAgICBcInVybFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBVUkwgdG8gYSBUaWxlSlNPTiByZXNvdXJjZS4gU3VwcG9ydGVkIHByb3RvY29scyBhcmUgYGh0dHA6YCwgYGh0dHBzOmAsIGFuZCBgbWFwYm94Oi8vPG1hcGlkPmAuXCJcbiAgICB9LFxuICAgIFwidGlsZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiQW4gYXJyYXkgb2Ygb25lIG9yIG1vcmUgdGlsZSBzb3VyY2UgVVJMcywgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuXCJcbiAgICB9LFxuICAgIFwibWluem9vbVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJkb2NcIjogXCJNaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLlwiXG4gICAgfSxcbiAgICBcIm1heHpvb21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMjIsXG4gICAgICBcImRvY1wiOiBcIk1heGltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIERhdGEgZnJvbSB0aWxlcyBhdCB0aGUgbWF4em9vbSBhcmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhlIG1hcCBhdCBoaWdoZXIgem9vbSBsZXZlbHMuXCJcbiAgICB9LFxuICAgIFwidGlsZVNpemVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogNTEyLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgbWluaW11bSB2aXN1YWwgc2l6ZSB0byBkaXNwbGF5IHRpbGVzIGZvciB0aGlzIGxheWVyLiBPbmx5IGNvbmZpZ3VyYWJsZSBmb3IgcmFzdGVyIGxheWVycy5cIlxuICAgIH0sXG4gICAgXCIqXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIipcIixcbiAgICAgIFwiZG9jXCI6IFwiT3RoZXIga2V5cyB0byBjb25maWd1cmUgdGhlIGRhdGEgc291cmNlLlwiXG4gICAgfVxuICB9LFxuICBcInNvdXJjZV9nZW9qc29uXCI6IHtcbiAgICBcInR5cGVcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcImdlb2pzb25cIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRhdGEgdHlwZSBvZiB0aGUgR2VvSlNPTiBzb3VyY2UuXCJcbiAgICB9LFxuICAgIFwiZGF0YVwiOiB7XG4gICAgICBcInR5cGVcIjogXCIqXCIsXG4gICAgICBcImRvY1wiOiBcIkEgVVJMIHRvIGEgR2VvSlNPTiBmaWxlLCBvciBpbmxpbmUgR2VvSlNPTi5cIlxuICAgIH0sXG4gICAgXCJtYXh6b29tXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDE0LFxuICAgICAgXCJkb2NcIjogXCJNYXhpbXVtIHpvb20gbGV2ZWwgYXQgd2hpY2ggdG8gY3JlYXRlIHZlY3RvciB0aWxlcyAoaGlnaGVyIG1lYW5zIGdyZWF0ZXIgZGV0YWlsIGF0IGhpZ2ggem9vbSBsZXZlbHMpLlwiXG4gICAgfSxcbiAgICBcImJ1ZmZlclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiA2NCxcbiAgICAgIFwiZG9jXCI6IFwiVGlsZSBidWZmZXIgc2l6ZSBvbiBlYWNoIHNpZGUgKGhpZ2hlciBtZWFucyBmZXdlciByZW5kZXJpbmcgYXJ0aWZhY3RzIG5lYXIgdGlsZSBlZGdlcyBidXQgc2xvd2VyIHBlcmZvcm1hbmNlKS5cIlxuICAgIH0sXG4gICAgXCJ0b2xlcmFuY2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMyxcbiAgICAgIFwiZG9jXCI6IFwiRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uIHRvbGVyYW5jZSAoaGlnaGVyIG1lYW5zIHNpbXBsZXIgZ2VvbWV0cmllcyBhbmQgZmFzdGVyIHBlcmZvcm1hbmNlKS5cIlxuICAgIH0sXG4gICAgXCJjbHVzdGVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdGhlIGRhdGEgaXMgYSBjb2xsZWN0aW9uIG9mIHBvaW50IGZlYXR1cmVzLCBzZXR0aW5nIHRoaXMgdG8gdHJ1ZSBjbHVzdGVycyB0aGUgcG9pbnRzIGJ5IHJhZGl1cyBpbnRvIGdyb3Vwcy5cIlxuICAgIH0sXG4gICAgXCJjbHVzdGVyUmFkaXVzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDQwMCxcbiAgICAgIFwiZG9jXCI6IFwiUmFkaXVzIG9mIGVhY2ggY2x1c3RlciB3aGVuIGNsdXN0ZXJpbmcgcG9pbnRzLCByZWxhdGl2ZSB0byA0MDk2IHRpbGUuXCJcbiAgICB9LFxuICAgIFwiY2x1c3Rlck1heFpvb21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIk1heCB6b29tIHRvIGNsdXN0ZXIgcG9pbnRzIG9uLiBEZWZhdWx0cyB0byBvbmUgem9vbSBsZXNzIHRoYW4gbWF4em9vbSAoc28gdGhhdCBsYXN0IHpvb20gZmVhdHVyZXMgYXJlIG5vdCBjbHVzdGVyZWQpLlwiXG4gICAgfVxuICB9LFxuICBcInNvdXJjZV92aWRlb1wiOiB7XG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJ2aWRlb1wiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGF0YSB0eXBlIG9mIHRoZSB2aWRlbyBzb3VyY2UuXCJcbiAgICB9LFxuICAgIFwidXJsc1wiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJVUkxzIHRvIHZpZGVvIGNvbnRlbnQgaW4gb3JkZXIgb2YgcHJlZmVycmVkIGZvcm1hdC5cIlxuICAgIH0sXG4gICAgXCJjb29yZGluYXRlc1wiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIkNvcm5lcnMgb2YgdmlkZW8gc3BlY2lmaWVkIGluIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcGFpcnMuXCIsXG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJsZW5ndGhcIjogNCxcbiAgICAgIFwidmFsdWVcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZG9jXCI6IFwiQSBzaW5nbGUgbG9uZ2l0dWRlLCBsYXRpdHVkZSBwYWlyLlwiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcInNvdXJjZV9pbWFnZVwiOiB7XG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJpbWFnZVwiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGF0YSB0eXBlIG9mIHRoZSBpbWFnZSBzb3VyY2UuXCJcbiAgICB9LFxuICAgIFwidXJsXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJVUkwgdGhhdCBwb2ludHMgdG8gYW4gaW1hZ2VcIlxuICAgIH0sXG4gICAgXCJjb29yZGluYXRlc1wiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIkNvcm5lcnMgb2YgaW1hZ2Ugc3BlY2lmaWVkIGluIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcGFpcnMuXCIsXG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJsZW5ndGhcIjogNCxcbiAgICAgIFwidmFsdWVcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZG9jXCI6IFwiQSBzaW5nbGUgbG9uZ2l0dWRlLCBsYXRpdHVkZSBwYWlyLlwiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcImxheWVyXCI6IHtcbiAgICBcImlkXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJVbmlxdWUgbGF5ZXIgbmFtZS5cIixcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJmaWxsXCIsXG4gICAgICAgIFwibGluZVwiLFxuICAgICAgICBcInN5bWJvbFwiLFxuICAgICAgICBcImNpcmNsZVwiLFxuICAgICAgICBcInJhc3RlclwiLFxuICAgICAgICBcImJhY2tncm91bmRcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiUmVuZGVyaW5nIHR5cGUgb2YgdGhpcyBsYXllci5cIlxuICAgIH0sXG4gICAgXCJtZXRhZGF0YVwiOiB7XG4gICAgICBcInR5cGVcIjogXCIqXCIsXG4gICAgICBcImRvY1wiOiBcIkFyYml0cmFyeSBwcm9wZXJ0aWVzIHVzZWZ1bCB0byB0cmFjayB3aXRoIHRoZSBsYXllciwgYnV0IGRvIG5vdCBpbmZsdWVuY2UgcmVuZGVyaW5nLiBQcm9wZXJ0aWVzIHNob3VsZCBiZSBwcmVmaXhlZCB0byBhdm9pZCBjb2xsaXNpb25zLCBsaWtlICdtYXBib3g6Jy5cIlxuICAgIH0sXG4gICAgXCJyZWZcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIlJlZmVyZW5jZXMgYW5vdGhlciBsYXllciB0byBjb3B5IGB0eXBlYCwgYHNvdXJjZWAsIGBzb3VyY2UtbGF5ZXJgLCBgbWluem9vbWAsIGBtYXh6b29tYCwgYGZpbHRlcmAsIGFuZCBgbGF5b3V0YCBwcm9wZXJ0aWVzIGZyb20uIFRoaXMgYWxsb3dzIHRoZSBsYXllcnMgdG8gc2hhcmUgcHJvY2Vzc2luZyBhbmQgYmUgbW9yZSBlZmZpY2llbnQuXCJcbiAgICB9LFxuICAgIFwic291cmNlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJOYW1lIG9mIGEgc291cmNlIGRlc2NyaXB0aW9uIHRvIGJlIHVzZWQgZm9yIHRoaXMgbGF5ZXIuXCJcbiAgICB9LFxuICAgIFwic291cmNlLWxheWVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJMYXllciB0byB1c2UgZnJvbSBhIHZlY3RvciB0aWxlIHNvdXJjZS4gUmVxdWlyZWQgaWYgdGhlIHNvdXJjZSBzdXBwb3J0cyBtdWx0aXBsZSBsYXllcnMuXCJcbiAgICB9LFxuICAgIFwibWluem9vbVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDIyLFxuICAgICAgXCJkb2NcIjogXCJUaGUgbWluaW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBsYXllciBnZXRzIHBhcnNlZCBhbmQgYXBwZWFycyBvbi5cIlxuICAgIH0sXG4gICAgXCJtYXh6b29tXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMjIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIGxheWVyIGdldHMgcGFyc2VkIGFuZCBhcHBlYXJzIG9uLlwiXG4gICAgfSxcbiAgICBcImludGVyYWN0aXZlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZG9jXCI6IFwiRW5hYmxlIHF1ZXJ5aW5nIG9mIGZlYXR1cmUgZGF0YSBmcm9tIHRoaXMgbGF5ZXIgZm9yIGludGVyYWN0aXZpdHkuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwiZmlsdGVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImZpbHRlclwiLFxuICAgICAgXCJkb2NcIjogXCJBIGV4cHJlc3Npb24gc3BlY2lmeWluZyBjb25kaXRpb25zIG9uIHNvdXJjZSBmZWF0dXJlcy4gT25seSBmZWF0dXJlcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIgYXJlIGRpc3BsYXllZC5cIlxuICAgIH0sXG4gICAgXCJsYXlvdXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGF5b3V0XCIsXG4gICAgICBcImRvY1wiOiBcIkxheW91dCBwcm9wZXJ0aWVzIGZvciB0aGUgbGF5ZXIuXCJcbiAgICB9LFxuICAgIFwicGFpbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwicGFpbnRcIixcbiAgICAgIFwiZG9jXCI6IFwiRGVmYXVsdCBwYWludCBwcm9wZXJ0aWVzIGZvciB0aGlzIGxheWVyLlwiXG4gICAgfSxcbiAgICBcInBhaW50LipcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwicGFpbnRcIixcbiAgICAgIFwiZG9jXCI6IFwiQ2xhc3Mtc3BlY2lmaWMgcGFpbnQgcHJvcGVydGllcyBmb3IgdGhpcyBsYXllci4gVGhlIGNsYXNzIG5hbWUgaXMgdGhlIHBhcnQgYWZ0ZXIgdGhlIGZpcnN0IGRvdC5cIlxuICAgIH1cbiAgfSxcbiAgXCJsYXlvdXRcIjogW1xuICAgIFwibGF5b3V0X2ZpbGxcIixcbiAgICBcImxheW91dF9saW5lXCIsXG4gICAgXCJsYXlvdXRfY2lyY2xlXCIsXG4gICAgXCJsYXlvdXRfc3ltYm9sXCIsXG4gICAgXCJsYXlvdXRfcmFzdGVyXCIsXG4gICAgXCJsYXlvdXRfYmFja2dyb3VuZFwiXG4gIF0sXG4gIFwibGF5b3V0X2JhY2tncm91bmRcIjoge1xuICAgIFwidmlzaWJpbGl0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwidmlzaWJsZVwiLFxuICAgICAgICBcIm5vbmVcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgdGhpcyBsYXllci4gYG5vbmVgIGhpZGVzIHRoaXMgbGF5ZXIuXCJcbiAgICB9XG4gIH0sXG4gIFwibGF5b3V0X2ZpbGxcIjoge1xuICAgIFwidmlzaWJpbGl0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwidmlzaWJsZVwiLFxuICAgICAgICBcIm5vbmVcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgdGhpcyBsYXllci4gYG5vbmVgIGhpZGVzIHRoaXMgbGF5ZXIuXCJcbiAgICB9XG4gIH0sXG4gIFwibGF5b3V0X2NpcmNsZVwiOiB7XG4gICAgXCJ2aXNpYmlsaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJ2aXNpYmxlXCIsXG4gICAgICAgIFwibm9uZVwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiB0aGlzIGxheWVyLiBgbm9uZWAgaGlkZXMgdGhpcyBsYXllci5cIlxuICAgIH1cbiAgfSxcbiAgXCJsYXlvdXRfbGluZVwiOiB7XG4gICAgXCJsaW5lLWNhcFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwiYnV0dFwiLFxuICAgICAgICBcInJvdW5kXCIsXG4gICAgICAgIFwic3F1YXJlXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJidXR0XCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBkaXNwbGF5IG9mIGxpbmUgZW5kaW5ncy5cIlxuICAgIH0sXG4gICAgXCJsaW5lLWpvaW5cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcImJldmVsXCIsXG4gICAgICAgIFwicm91bmRcIixcbiAgICAgICAgXCJtaXRlclwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibWl0ZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgbGluZXMgd2hlbiBqb2luaW5nLlwiXG4gICAgfSxcbiAgICBcImxpbmUtbWl0ZXItbGltaXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiVXNlZCB0byBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgbWl0ZXIgam9pbnMgdG8gYmV2ZWwgam9pbnMgZm9yIHNoYXJwIGFuZ2xlcy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJsaW5lLWpvaW5cIjogXCJtaXRlclwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwibGluZS1yb3VuZC1saW1pdFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLjA1LFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJVc2VkIHRvIGF1dG9tYXRpY2FsbHkgY29udmVydCByb3VuZCBqb2lucyB0byBtaXRlciBqb2lucyBmb3Igc2hhbGxvdyBhbmdsZXMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwibGluZS1qb2luXCI6IFwicm91bmRcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcInZpc2liaWxpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcInZpc2libGVcIixcbiAgICAgICAgXCJub25lXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBkaXNwbGF5IG9mIHRoaXMgbGF5ZXIuIGBub25lYCBoaWRlcyB0aGlzIGxheWVyLlwiXG4gICAgfVxuICB9LFxuICBcImxheW91dF9zeW1ib2xcIjoge1xuICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgICAgXCJwb2ludFwiLFxuICAgICAgICAgIFwibGluZVwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwicG9pbnRcIixcbiAgICAgIFwiZG9jXCI6IFwiTGFiZWwgcGxhY2VtZW50IHJlbGF0aXZlIHRvIGl0cyBnZW9tZXRyeS4gYGxpbmVgIGNhbiBvbmx5IGJlIHVzZWQgb24gTGluZVN0cmluZ3MgYW5kIFBvbHlnb25zLlwiXG4gICAgfSxcbiAgICBcInN5bWJvbC1zcGFjaW5nXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDI1MCxcbiAgICAgIFwibWluaW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJEaXN0YW5jZSBiZXR3ZWVuIHR3byBzeW1ib2wgYW5jaG9ycy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFwibGluZVwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwic3ltYm9sLWF2b2lkLWVkZ2VzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIHN5bWJvbHMgd2lsbCBub3QgY3Jvc3MgdGlsZSBlZGdlcyB0byBhdm9pZCBtdXR1YWwgY29sbGlzaW9ucy4gUmVjb21tZW5kZWQgaW4gbGF5ZXJzIHRoYXQgZG9uJ3QgaGF2ZSBlbm91Z2ggcGFkZGluZyBpbiB0aGUgdmVjdG9yIHRpbGUgdG8gcHJldmVudCBjb2xsaXNpb25zLCBvciBpZiBpdCBpcyBhIHBvaW50IHN5bWJvbCBsYXllciBwbGFjZWQgYWZ0ZXIgYSBsaW5lIHN5bWJvbCBsYXllci5cIlxuICAgIH0sXG4gICAgXCJpY29uLWFsbG93LW92ZXJsYXBcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgaWNvbiB3aWxsIGJlIHZpc2libGUgZXZlbiBpZiBpdCBjb2xsaWRlcyB3aXRoIG90aGVyIHByZXZpb3VzbHkgZHJhd24gc3ltYm9scy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLWlnbm9yZS1wbGFjZW1lbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCBvdGhlciBzeW1ib2xzIGNhbiBiZSB2aXNpYmxlIGV2ZW4gaWYgdGhleSBjb2xsaWRlIHdpdGggdGhlIGljb24uXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1vcHRpb25hbFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRleHQgd2lsbCBkaXNwbGF5IHdpdGhvdXQgdGhlaXIgY29ycmVzcG9uZGluZyBpY29ucyB3aGVuIHRoZSBpY29uIGNvbGxpZGVzIHdpdGggb3RoZXIgc3ltYm9scyBhbmQgdGhlIHRleHQgZG9lcyBub3QuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCIsXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24tcm90YXRpb24tYWxpZ25tZW50XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJtYXBcIixcbiAgICAgICAgXCJ2aWV3cG9ydFwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwidmlld3BvcnRcIixcbiAgICAgIFwiZG9jXCI6IFwiT3JpZW50YXRpb24gb2YgaWNvbiB3aGVuIG1hcCBpcyByb3RhdGVkLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24tc2l6ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIlNjYWxlIGZhY3RvciBmb3IgaWNvbi4gMSBpcyBvcmlnaW5hbCBzaXplLCAzIHRyaXBsZXMgdGhlIHNpemUuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1pbWFnZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBzdHJpbmcgd2l0aCB7dG9rZW5zfSByZXBsYWNlZCwgcmVmZXJlbmNpbmcgdGhlIGRhdGEgcHJvcGVydHkgdG8gcHVsbCBmcm9tLlwiLFxuICAgICAgXCJ0b2tlbnNcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJpY29uLXJvdGF0ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJwZXJpb2RcIjogMzYwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ1bml0c1wiOiBcImRlZ3JlZXNcIixcbiAgICAgIFwiZG9jXCI6IFwiUm90YXRlcyB0aGUgaWNvbiBjbG9ja3dpc2UuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1wYWRkaW5nXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDIsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiU2l6ZSBvZiB0aGUgYWRkaXRpb25hbCBhcmVhIGFyb3VuZCB0aGUgaWNvbiBib3VuZGluZyBib3ggdXNlZCBmb3IgZGV0ZWN0aW5nIHN5bWJvbCBjb2xsaXNpb25zLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24ta2VlcC11cHJpZ2h0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIGljb24gbWF5IGJlIGZsaXBwZWQgdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHJlbmRlcmVkIHVwc2lkZS1kb3duLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiLFxuICAgICAgICB7XG4gICAgICAgICAgXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiOiBcIm1hcFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogXCJsaW5lXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLW9mZnNldFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJsZW5ndGhcIjogMixcbiAgICAgIFwiZGVmYXVsdFwiOiBbXG4gICAgICAgIDAsXG4gICAgICAgIDBcbiAgICAgIF0sXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIk9mZnNldCBkaXN0YW5jZSBvZiBpY29uIGZyb20gaXRzIGFuY2hvci4gUG9zaXRpdmUgdmFsdWVzIGluZGljYXRlIHJpZ2h0IGFuZCBkb3duLCB3aGlsZSBuZWdhdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aWV3cG9ydFwiLFxuICAgICAgXCJkb2NcIjogXCJPcmllbnRhdGlvbiBvZiB0ZXh0IHdoZW4gbWFwIGlzIHJvdGF0ZWQuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1maWVsZFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIlwiLFxuICAgICAgXCJ0b2tlbnNcIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiVmFsdWUgdG8gdXNlIGZvciBhIHRleHQgbGFiZWwuIEZlYXR1cmUgcHJvcGVydGllcyBhcmUgc3BlY2lmaWVkIHVzaW5nIHRva2VucyBsaWtlIHtmaWVsZF9uYW1lfS5cIlxuICAgIH0sXG4gICAgXCJ0ZXh0LWZvbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBbXCJPcGVuIFNhbnMgUmVndWxhclwiLCBcIkFyaWFsIFVuaWNvZGUgTVMgUmVndWxhclwiXSxcbiAgICAgIFwiZG9jXCI6IFwiRm9udCBzdGFjayB0byB1c2UgZm9yIGRpc3BsYXlpbmcgdGV4dC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LXNpemVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMTYsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiRm9udCBzaXplLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtbWF4LXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwiZW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1heGltdW0gbGluZSB3aWR0aCBmb3IgdGV4dCB3cmFwcGluZy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWxpbmUtaGVpZ2h0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEuMixcbiAgICAgIFwidW5pdHNcIjogXCJlbVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJUZXh0IGxlYWRpbmcgdmFsdWUgZm9yIG11bHRpLWxpbmUgdGV4dC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWxldHRlci1zcGFjaW5nXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwiZW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiVGV4dCB0cmFja2luZyBhbW91bnQuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1qdXN0aWZ5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJsZWZ0XCIsXG4gICAgICAgIFwiY2VudGVyXCIsXG4gICAgICAgIFwicmlnaHRcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcImNlbnRlclwiLFxuICAgICAgXCJkb2NcIjogXCJUZXh0IGp1c3RpZmljYXRpb24gb3B0aW9ucy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwiY2VudGVyXCIsXG4gICAgICAgIFwibGVmdFwiLFxuICAgICAgICBcInJpZ2h0XCIsXG4gICAgICAgIFwidG9wXCIsXG4gICAgICAgIFwiYm90dG9tXCIsXG4gICAgICAgIFwidG9wLWxlZnRcIixcbiAgICAgICAgXCJ0b3AtcmlnaHRcIixcbiAgICAgICAgXCJib3R0b20tbGVmdFwiLFxuICAgICAgICBcImJvdHRvbS1yaWdodFwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiY2VudGVyXCIsXG4gICAgICBcImRvY1wiOiBcIlBhcnQgb2YgdGhlIHRleHQgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LW1heC1hbmdsZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiA0NSxcbiAgICAgIFwidW5pdHNcIjogXCJkZWdyZWVzXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIk1heGltdW0gYW5nbGUgY2hhbmdlIGJldHdlZW4gYWRqYWNlbnQgY2hhcmFjdGVycy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIixcbiAgICAgICAge1xuICAgICAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBcImxpbmVcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtcm90YXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcInBlcmlvZFwiOiAzNjAsXG4gICAgICBcInVuaXRzXCI6IFwiZGVncmVlc1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJSb3RhdGVzIHRoZSB0ZXh0IGNsb2Nrd2lzZS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LXBhZGRpbmdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJTaXplIG9mIHRoZSBhZGRpdGlvbmFsIGFyZWEgYXJvdW5kIHRoZSB0ZXh0IGJvdW5kaW5nIGJveCB1c2VkIGZvciBkZXRlY3Rpbmcgc3ltYm9sIGNvbGxpc2lvbnMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1rZWVwLXVwcmlnaHRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSB0ZXh0IG1heSBiZSBmbGlwcGVkIHZlcnRpY2FsbHkgdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHJlbmRlcmVkIHVwc2lkZS1kb3duLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiLFxuICAgICAgICB7XG4gICAgICAgICAgXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiOiBcIm1hcFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogXCJsaW5lXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LXRyYW5zZm9ybVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibm9uZVwiLFxuICAgICAgICBcInVwcGVyY2FzZVwiLFxuICAgICAgICBcImxvd2VyY2FzZVwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibm9uZVwiLFxuICAgICAgXCJkb2NcIjogXCJTcGVjaWZpZXMgaG93IHRvIGNhcGl0YWxpemUgdGV4dCwgc2ltaWxhciB0byB0aGUgQ1NTIGB0ZXh0LXRyYW5zZm9ybWAgcHJvcGVydHkuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1vZmZzZXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwiZG9jXCI6IFwiT2Zmc2V0IGRpc3RhbmNlIG9mIHRleHQgZnJvbSBpdHMgYW5jaG9yLiBQb3NpdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgcmlnaHQgYW5kIGRvd24sIHdoaWxlIG5lZ2F0aXZlIHZhbHVlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cC5cIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwidW5pdHNcIjogXCJlbXNcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtYWxsb3ctb3ZlcmxhcFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSB0ZXh0IHdpbGwgYmUgdmlzaWJsZSBldmVuIGlmIGl0IGNvbGxpZGVzIHdpdGggb3RoZXIgcHJldmlvdXNseSBkcmF3biBzeW1ib2xzLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtaWdub3JlLXBsYWNlbWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIG90aGVyIHN5bWJvbHMgY2FuIGJlIHZpc2libGUgZXZlbiBpZiB0aGV5IGNvbGxpZGUgd2l0aCB0aGUgdGV4dC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LW9wdGlvbmFsXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgaWNvbnMgd2lsbCBkaXNwbGF5IHdpdGhvdXQgdGhlaXIgY29ycmVzcG9uZGluZyB0ZXh0IHdoZW4gdGhlIHRleHQgY29sbGlkZXMgd2l0aCBvdGhlciBzeW1ib2xzIGFuZCB0aGUgaWNvbiBkb2VzIG5vdC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIixcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidmlzaWJpbGl0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwidmlzaWJsZVwiLFxuICAgICAgICBcIm5vbmVcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgdGhpcyBsYXllci4gYG5vbmVgIGhpZGVzIHRoaXMgbGF5ZXIuXCJcbiAgICB9XG4gIH0sXG4gIFwibGF5b3V0X3Jhc3RlclwiOiB7XG4gICAgXCJ2aXNpYmlsaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJ2aXNpYmxlXCIsXG4gICAgICAgIFwibm9uZVwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiB0aGlzIGxheWVyLiBgbm9uZWAgaGlkZXMgdGhpcyBsYXllci5cIlxuICAgIH1cbiAgfSxcbiAgXCJmaWx0ZXJcIjoge1xuICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgXCJ2YWx1ZVwiOiBcIipcIixcbiAgICBcImRvY1wiOiBcIkEgZmlsdGVyIHNlbGVjdHMgc3BlY2lmaWMgZmVhdHVyZXMgZnJvbSBhIGxheWVyLlwiXG4gIH0sXG4gIFwiZmlsdGVyX29wZXJhdG9yXCI6IHtcbiAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgXCI9PVwiLFxuICAgICAgXCIhPVwiLFxuICAgICAgXCI+XCIsXG4gICAgICBcIj49XCIsXG4gICAgICBcIjxcIixcbiAgICAgIFwiPD1cIixcbiAgICAgIFwiaW5cIixcbiAgICAgIFwiIWluXCIsXG4gICAgICBcImFsbFwiLFxuICAgICAgXCJhbnlcIixcbiAgICAgIFwibm9uZVwiLFxuICAgICAgXCJoYXNcIixcbiAgICAgIFwiIWhhc1wiXG4gICAgXSxcbiAgICBcImRvY1wiOiBcIlRoZSBmaWx0ZXIgb3BlcmF0b3IuXCJcbiAgfSxcbiAgXCJnZW9tZXRyeV90eXBlXCI6IHtcbiAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgXCJQb2ludFwiLFxuICAgICAgXCJMaW5lU3RyaW5nXCIsXG4gICAgICBcIlBvbHlnb25cIlxuICAgIF0sXG4gICAgXCJkb2NcIjogXCJUaGUgZ2VvbWV0cnkgdHlwZSBmb3IgdGhlIGZpbHRlciB0byBzZWxlY3QuXCJcbiAgfSxcbiAgXCJjb2xvcl9vcGVyYXRpb25cIjoge1xuICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICBcInZhbHVlc1wiOiBbXG4gICAgICBcImxpZ2h0ZW5cIixcbiAgICAgIFwic2F0dXJhdGVcIixcbiAgICAgIFwic3BpblwiLFxuICAgICAgXCJmYWRlXCIsXG4gICAgICBcIm1peFwiXG4gICAgXSxcbiAgICBcImRvY1wiOiBcIkEgY29sb3Igb3BlcmF0aW9uIHRvIGFwcGx5LlwiXG4gIH0sXG4gIFwiZnVuY3Rpb25cIjoge1xuICAgIFwic3RvcHNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiQW4gYXJyYXkgb2Ygc3RvcHMuXCIsXG4gICAgICBcInZhbHVlXCI6IFwiZnVuY3Rpb25fc3RvcFwiXG4gICAgfSxcbiAgICBcImJhc2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZXhwb25lbnRpYWwgYmFzZSBvZiB0aGUgaW50ZXJwb2xhdGlvbiBjdXJ2ZS4gSXQgY29udHJvbHMgdGhlIHJhdGUgYXQgd2hpY2ggdGhlIHJlc3VsdCBpbmNyZWFzZXMuIEhpZ2hlciB2YWx1ZXMgbWFrZSB0aGUgcmVzdWx0IGluY3JlYXNlIG1vcmUgdG93YXJkcyB0aGUgaGlnaCBlbmQgb2YgdGhlIHJhbmdlLiBXaXRoIGAxYCB0aGUgc3RvcHMgYXJlIGludGVycG9sYXRlZCBsaW5lYXJseS5cIlxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG5hbWUgb2YgYSBnbG9iYWwgcHJvcGVydHkgb3IgZmVhdHVyZSBwcm9wZXJ0eSB0byB1c2UgYXMgdGhlIGZ1bmN0aW9uIGlucHV0LlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiJHpvb21cIlxuICAgIH0sXG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgICBcImV4cG9uZW50aWFsXCIsXG4gICAgICAgICAgXCJpbnRlcnZhbFwiLFxuICAgICAgICAgIFwiY2F0ZWdvcmljYWxcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGludGVycG9sYXRpb24gc3RyYXRlZ3kgdG8gdXNlIGluIGZ1bmN0aW9uIGV2YWx1YXRpb24uXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJleHBvbmVudGlhbFwiXG4gICAgfVxuICB9LFxuICBcImZ1bmN0aW9uX3N0b3BcIjoge1xuICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgXCJtYXhpbXVtXCI6IDIyLFxuICAgIFwidmFsdWVcIjogW1xuICAgICAgXCJudW1iZXJcIixcbiAgICAgIFwiY29sb3JcIlxuICAgIF0sXG4gICAgXCJsZW5ndGhcIjogMixcbiAgICBcImRvY1wiOiBcIlpvb20gbGV2ZWwgYW5kIHZhbHVlIHBhaXIuXCJcbiAgfSxcbiAgXCJwYWludFwiOiBbXG4gICAgXCJwYWludF9maWxsXCIsXG4gICAgXCJwYWludF9saW5lXCIsXG4gICAgXCJwYWludF9jaXJjbGVcIixcbiAgICBcInBhaW50X3N5bWJvbFwiLFxuICAgIFwicGFpbnRfcmFzdGVyXCIsXG4gICAgXCJwYWludF9iYWNrZ3JvdW5kXCJcbiAgXSxcbiAgXCJwYWludF9maWxsXCI6IHtcbiAgICBcImZpbGwtYW50aWFsaWFzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJXaGV0aGVyIG9yIG5vdCB0aGUgZmlsbCBzaG91bGQgYmUgYW50aWFsaWFzZWQuXCJcbiAgICB9LFxuICAgIFwiZmlsbC1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBnaXZlbiB0byB0aGUgZmlsbCBjb2xvci5cIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcImZpbGwtY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBmaWxsLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiIVwiOiBcImZpbGwtcGF0dGVyblwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwiZmlsbC1vdXRsaW5lLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBvdXRsaW5lIGNvbG9yIG9mIHRoZSBmaWxsLiBNYXRjaGVzIHRoZSB2YWx1ZSBvZiBgZmlsbC1jb2xvcmAgaWYgdW5zcGVjaWZpZWQuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCIhXCI6IFwiZmlsbC1wYXR0ZXJuXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwiZmlsbC1hbnRpYWxpYXNcIjogdHJ1ZVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImZpbGwtdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiXG4gICAgfSxcbiAgICBcImZpbGwtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibWFwXCIsXG4gICAgICAgIFwidmlld3BvcnRcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB3aGV0aGVyIHRoZSB0cmFuc2xhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgbWFwIChub3J0aCkgb3Igdmlld3BvcnQgKHNjcmVlbilcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiZmlsbC10cmFuc2xhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJmaWxsLXBhdHRlcm5cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGltYWdlIGZpbGxzLiBGb3Igc2VhbWxlc3MgcGF0dGVybnMsIGltYWdlIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS5cIlxuICAgIH1cbiAgfSxcbiAgXCJwYWludF9saW5lXCI6IHtcbiAgICBcImxpbmUtb3BhY2l0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGxpbmUgd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcImxpbmUtY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIHdpdGggd2hpY2ggdGhlIGxpbmUgd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcIiFcIjogXCJsaW5lLXBhdHRlcm5cIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImxpbmUtdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiXG4gICAgfSxcbiAgICBcImxpbmUtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibWFwXCIsXG4gICAgICAgIFwidmlld3BvcnRcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB3aGV0aGVyIHRoZSB0cmFuc2xhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgbWFwIChub3J0aCkgb3Igdmlld3BvcnQgKHNjcmVlbilcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwibGluZS10cmFuc2xhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJsaW5lLXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJTdHJva2UgdGhpY2tuZXNzLlwiXG4gICAgfSxcbiAgICBcImxpbmUtZ2FwLXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZG9jXCI6IFwiRHJhd3MgYSBsaW5lIGNhc2luZyBvdXRzaWRlIG9mIGEgbGluZSdzIGFjdHVhbCBwYXRoLiBWYWx1ZSBpbmRpY2F0ZXMgdGhlIHdpZHRoIG9mIHRoZSBpbm5lciBnYXAuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIlxuICAgIH0sXG4gICAgXCJsaW5lLW9mZnNldFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJkb2NcIjogXCJUaGUgbGluZSdzIG9mZnNldCBwZXJwZW5kaWN1bGFyIHRvIGl0cyBkaXJlY3Rpb24uIFZhbHVlcyBtYXkgYmUgcG9zaXRpdmUgb3IgbmVnYXRpdmUsIHdoZXJlIHBvc2l0aXZlIGluZGljYXRlcyBcXFwicmlnaHR3YXJkc1xcXCIgKGlmIHlvdSB3ZXJlIG1vdmluZyBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBsaW5lKSBhbmQgbmVnYXRpdmUgaW5kaWNhdGVzIFxcXCJsZWZ0d2FyZHMuXFxcIlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCJcbiAgICB9LFxuICAgIFwibGluZS1ibHVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJCbHVyIGFwcGxpZWQgdG8gdGhlIGxpbmUsIGluIHBpeGVscy5cIlxuICAgIH0sXG4gICAgXCJsaW5lLWRhc2hhcnJheVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkb2NcIjogXCJTcGVjaWZpZXMgdGhlIGxlbmd0aHMgb2YgdGhlIGFsdGVybmF0aW5nIGRhc2hlcyBhbmQgZ2FwcyB0aGF0IGZvcm0gdGhlIGRhc2ggcGF0dGVybi4gVGhlIGxlbmd0aHMgYXJlIGxhdGVyIHNjYWxlZCBieSB0aGUgbGluZSB3aWR0aC4gVG8gY29udmVydCBhIGRhc2ggbGVuZ3RoIHRvIHBpeGVscywgbXVsdGlwbHkgdGhlIGxlbmd0aCBieSB0aGUgY3VycmVudCBsaW5lIHdpZHRoLlwiLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJsaW5lIHdpZHRoc1wiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcIiFcIjogXCJsaW5lLXBhdHRlcm5cIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImxpbmUtcGF0dGVyblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgaW1hZ2UgbGluZXMuIEZvciBzZWFtbGVzcyBwYXR0ZXJucywgaW1hZ2Ugd2lkdGggbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS5cIlxuICAgIH1cbiAgfSxcbiAgXCJwYWludF9jaXJjbGVcIjoge1xuICAgIFwiY2lyY2xlLXJhZGl1c1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiA1LFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiQ2lyY2xlIHJhZGl1cy5cIlxuICAgIH0sXG4gICAgXCJjaXJjbGUtY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBjaXJjbGUuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJjaXJjbGUtYmx1clwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJkb2NcIjogXCJBbW91bnQgdG8gYmx1ciB0aGUgY2lyY2xlLiAxIGJsdXJzIHRoZSBjaXJjbGUgc3VjaCB0aGF0IG9ubHkgdGhlIGNlbnRlcnBvaW50IGlzIGZ1bGwgb3BhY2l0eS5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcImNpcmNsZS1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgY2lyY2xlIHdpbGwgYmUgZHJhd24uXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJjaXJjbGUtdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFswLCAwXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiXG4gICAgfSxcbiAgICBcImNpcmNsZS10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJtYXBcIixcbiAgICAgICAgXCJ2aWV3cG9ydFwiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJDb250cm9sIHdoZXRoZXIgdGhlIHRyYW5zbGF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBtYXAgKG5vcnRoKSBvciB2aWV3cG9ydCAoc2NyZWVuKVwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibWFwXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJjaXJjbGUtdHJhbnNsYXRlXCJcbiAgICAgIF1cbiAgICB9XG4gIH0sXG4gIFwicGFpbnRfc3ltYm9sXCI6IHtcbiAgICBcImljb24tb3BhY2l0eVwiOiB7XG4gICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBpY29uIHdpbGwgYmUgZHJhd24uXCIsXG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24tY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIGljb24uIFRoaXMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHNkZiBpY29ucy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLWhhbG8tY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIGljb24ncyBoYWxvLiBJY29uIGhhbG9zIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBzZGYgaWNvbnMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1oYWxvLXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJEaXN0YW5jZSBvZiBoYWxvIHRvIHRoZSBpY29uIG91dGxpbmUuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1oYWxvLWJsdXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkZhZGUgb3V0IHRoZSBoYWxvIHRvd2FyZHMgdGhlIG91dHNpZGUuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi10cmFuc2xhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkRpc3RhbmNlIHRoYXQgdGhlIGljb24ncyBhbmNob3IgaXMgbW92ZWQgZnJvbSBpdHMgb3JpZ2luYWwgcGxhY2VtZW50LiBQb3NpdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgcmlnaHQgYW5kIGRvd24sIHdoaWxlIG5lZ2F0aXZlIHZhbHVlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIkNvbnRyb2wgd2hldGhlciB0aGUgdHJhbnNsYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG1hcCAobm9ydGgpIG9yIHZpZXdwb3J0IChzY3JlZW4pLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibWFwXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCIsXG4gICAgICAgIFwiaWNvbi10cmFuc2xhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LW9wYWNpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSB0ZXh0IHdpbGwgYmUgZHJhd24uXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciB3aXRoIHdoaWNoIHRoZSB0ZXh0IHdpbGwgYmUgZHJhd24uXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWhhbG8tY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIHRleHQncyBoYWxvLCB3aGljaCBoZWxwcyBpdCBzdGFuZCBvdXQgZnJvbSBiYWNrZ3JvdW5kcy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWhhbG8td2lkdGhcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkRpc3RhbmNlIG9mIGhhbG8gdG8gdGhlIGZvbnQgb3V0bGluZS4gTWF4IHRleHQgaGFsbyB3aWR0aCBpcyAxLzQgb2YgdGhlIGZvbnQtc2l6ZS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWhhbG8tYmx1clwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGhhbG8ncyBmYWRlb3V0IGRpc3RhbmNlIHRvd2FyZHMgdGhlIG91dHNpZGUuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC10cmFuc2xhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkRpc3RhbmNlIHRoYXQgdGhlIHRleHQncyBhbmNob3IgaXMgbW92ZWQgZnJvbSBpdHMgb3JpZ2luYWwgcGxhY2VtZW50LiBQb3NpdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgcmlnaHQgYW5kIGRvd24sIHdoaWxlIG5lZ2F0aXZlIHZhbHVlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIkNvbnRyb2wgd2hldGhlciB0aGUgdHJhbnNsYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG1hcCAobm9ydGgpIG9yIHZpZXdwb3J0IChzY3JlZW4pLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibWFwXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCIsXG4gICAgICAgIFwidGV4dC10cmFuc2xhdGVcIlxuICAgICAgXVxuICAgIH1cbiAgfSxcbiAgXCJwYWludF9yYXN0ZXJcIjoge1xuICAgIFwicmFzdGVyLW9wYWNpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBpbWFnZSB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwicmFzdGVyLWh1ZS1yb3RhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwicGVyaW9kXCI6IDM2MCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcImRlZ3JlZXNcIixcbiAgICAgIFwiZG9jXCI6IFwiUm90YXRlcyBodWVzIGFyb3VuZCB0aGUgY29sb3Igd2hlZWwuXCJcbiAgICB9LFxuICAgIFwicmFzdGVyLWJyaWdodG5lc3MtbWluXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIGJyaWdodG5lc3Mgb2YgdGhlIGltYWdlLiBUaGUgdmFsdWUgaXMgdGhlIG1pbmltdW0gYnJpZ2h0bmVzcy5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcInJhc3Rlci1icmlnaHRuZXNzLW1heFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBicmlnaHRuZXNzIG9mIHRoZSBpbWFnZS4gVGhlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIGJyaWdodG5lc3MuXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJyYXN0ZXItc2F0dXJhdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBzYXR1cmF0aW9uIG9mIHRoZSBpbWFnZS5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IC0xLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJyYXN0ZXItY29udHJhc3RcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgY29udHJhc3Qgb2YgdGhlIGltYWdlLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogLTEsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcInJhc3Rlci1mYWRlLWR1cmF0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDMwMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICBcImRvY1wiOiBcIkZhZGUgZHVyYXRpb24gd2hlbiBhIG5ldyB0aWxlIGlzIGFkZGVkLlwiXG4gICAgfVxuICB9LFxuICBcInBhaW50X2JhY2tncm91bmRcIjoge1xuICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igd2l0aCB3aGljaCB0aGUgYmFja2dyb3VuZCB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiIVwiOiBcImJhY2tncm91bmQtcGF0dGVyblwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwiYmFja2dyb3VuZC1wYXR0ZXJuXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBhbiBpbWFnZSBiYWNrZ3JvdW5kLiBGb3Igc2VhbWxlc3MgcGF0dGVybnMsIGltYWdlIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS5cIlxuICAgIH0sXG4gICAgXCJiYWNrZ3JvdW5kLW9wYWNpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBiYWNrZ3JvdW5kIHdpbGwgYmUgZHJhd24uXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgXCJ0cmFuc2l0aW9uXCI6IHtcbiAgICBcImR1cmF0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDMwMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJ1bml0c1wiOiBcIm1pbGxpc2Vjb25kc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaW1lIGFsbG90dGVkIGZvciB0cmFuc2l0aW9ucyB0byBjb21wbGV0ZS5cIlxuICAgIH0sXG4gICAgXCJkZWxheVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICBcImRvY1wiOiBcIkxlbmd0aCBvZiB0aW1lIGJlZm9yZSBhIHRyYW5zaXRpb24gYmVnaW5zLlwiXG4gICAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XCIkdmVyc2lvblwiOjgsXCIkcm9vdFwiOntcInZlcnNpb25cIjp7XCJyZXF1aXJlZFwiOnRydWUsXCJ0eXBlXCI6XCJlbnVtXCIsXCJ2YWx1ZXNcIjpbOF19LFwibmFtZVwiOntcInR5cGVcIjpcInN0cmluZ1wifSxcIm1ldGFkYXRhXCI6e1widHlwZVwiOlwiKlwifSxcImNlbnRlclwiOntcInR5cGVcIjpcImFycmF5XCIsXCJ2YWx1ZVwiOlwibnVtYmVyXCJ9LFwiem9vbVwiOntcInR5cGVcIjpcIm51bWJlclwifSxcImJlYXJpbmdcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwicGVyaW9kXCI6MzYwLFwidW5pdHNcIjpcImRlZ3JlZXNcIn0sXCJwaXRjaFwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjAsXCJ1bml0c1wiOlwiZGVncmVlc1wifSxcInNvdXJjZXNcIjp7XCJyZXF1aXJlZFwiOnRydWUsXCJ0eXBlXCI6XCJzb3VyY2VzXCJ9LFwic3ByaXRlXCI6e1widHlwZVwiOlwic3RyaW5nXCJ9LFwiZ2x5cGhzXCI6e1widHlwZVwiOlwic3RyaW5nXCJ9LFwidHJhbnNpdGlvblwiOntcInR5cGVcIjpcInRyYW5zaXRpb25cIn0sXCJsYXllcnNcIjp7XCJyZXF1aXJlZFwiOnRydWUsXCJ0eXBlXCI6XCJhcnJheVwiLFwidmFsdWVcIjpcImxheWVyXCJ9fSxcInNvdXJjZXNcIjp7XCIqXCI6e1widHlwZVwiOlwic291cmNlXCJ9fSxcInNvdXJjZVwiOltcInNvdXJjZV90aWxlXCIsXCJzb3VyY2VfZ2VvanNvblwiLFwic291cmNlX3ZpZGVvXCIsXCJzb3VyY2VfaW1hZ2VcIl0sXCJzb3VyY2VfdGlsZVwiOntcInR5cGVcIjp7XCJyZXF1aXJlZFwiOnRydWUsXCJ0eXBlXCI6XCJlbnVtXCIsXCJ2YWx1ZXNcIjpbXCJ2ZWN0b3JcIixcInJhc3RlclwiXX0sXCJ1cmxcIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIn0sXCJ0aWxlc1wiOntcInR5cGVcIjpcImFycmF5XCIsXCJ2YWx1ZVwiOlwic3RyaW5nXCJ9LFwibWluem9vbVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjB9LFwibWF4em9vbVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjIyfSxcInRpbGVTaXplXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6NTEyLFwidW5pdHNcIjpcInBpeGVsc1wifSxcIipcIjp7XCJ0eXBlXCI6XCIqXCJ9fSxcInNvdXJjZV9nZW9qc29uXCI6e1widHlwZVwiOntcInJlcXVpcmVkXCI6dHJ1ZSxcInR5cGVcIjpcImVudW1cIixcInZhbHVlc1wiOltcImdlb2pzb25cIl19LFwiZGF0YVwiOntcInR5cGVcIjpcIipcIn0sXCJtYXh6b29tXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MTR9LFwiYnVmZmVyXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6NjR9LFwidG9sZXJhbmNlXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6M30sXCJjbHVzdGVyXCI6e1widHlwZVwiOlwiYm9vbGVhblwiLFwiZGVmYXVsdFwiOmZhbHNlfSxcImNsdXN0ZXJSYWRpdXNcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjo0MDB9LFwiY2x1c3Rlck1heFpvb21cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIn19LFwic291cmNlX3ZpZGVvXCI6e1widHlwZVwiOntcInJlcXVpcmVkXCI6dHJ1ZSxcInR5cGVcIjpcImVudW1cIixcInZhbHVlc1wiOltcInZpZGVvXCJdfSxcInVybHNcIjp7XCJyZXF1aXJlZFwiOnRydWUsXCJ0eXBlXCI6XCJhcnJheVwiLFwidmFsdWVcIjpcInN0cmluZ1wifSxcImNvb3JkaW5hdGVzXCI6e1wicmVxdWlyZWRcIjp0cnVlLFwidHlwZVwiOlwiYXJyYXlcIixcImxlbmd0aFwiOjQsXCJ2YWx1ZVwiOntcInR5cGVcIjpcImFycmF5XCIsXCJsZW5ndGhcIjoyLFwidmFsdWVcIjpcIm51bWJlclwifX19LFwic291cmNlX2ltYWdlXCI6e1widHlwZVwiOntcInJlcXVpcmVkXCI6dHJ1ZSxcInR5cGVcIjpcImVudW1cIixcInZhbHVlc1wiOltcImltYWdlXCJdfSxcInVybFwiOntcInJlcXVpcmVkXCI6dHJ1ZSxcInR5cGVcIjpcInN0cmluZ1wifSxcImNvb3JkaW5hdGVzXCI6e1wicmVxdWlyZWRcIjp0cnVlLFwidHlwZVwiOlwiYXJyYXlcIixcImxlbmd0aFwiOjQsXCJ2YWx1ZVwiOntcInR5cGVcIjpcImFycmF5XCIsXCJsZW5ndGhcIjoyLFwidmFsdWVcIjpcIm51bWJlclwifX19LFwibGF5ZXJcIjp7XCJpZFwiOntcInR5cGVcIjpcInN0cmluZ1wiLFwicmVxdWlyZWRcIjp0cnVlfSxcInR5cGVcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJ2YWx1ZXNcIjpbXCJmaWxsXCIsXCJsaW5lXCIsXCJzeW1ib2xcIixcImNpcmNsZVwiLFwicmFzdGVyXCIsXCJiYWNrZ3JvdW5kXCJdfSxcIm1ldGFkYXRhXCI6e1widHlwZVwiOlwiKlwifSxcInJlZlwiOntcInR5cGVcIjpcInN0cmluZ1wifSxcInNvdXJjZVwiOntcInR5cGVcIjpcInN0cmluZ1wifSxcInNvdXJjZS1sYXllclwiOntcInR5cGVcIjpcInN0cmluZ1wifSxcIm1pbnpvb21cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcIm1pbmltdW1cIjowLFwibWF4aW11bVwiOjIyfSxcIm1heHpvb21cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcIm1pbmltdW1cIjowLFwibWF4aW11bVwiOjIyfSxcImludGVyYWN0aXZlXCI6e1widHlwZVwiOlwiYm9vbGVhblwiLFwiZGVmYXVsdFwiOmZhbHNlfSxcImZpbHRlclwiOntcInR5cGVcIjpcImZpbHRlclwifSxcImxheW91dFwiOntcInR5cGVcIjpcImxheW91dFwifSxcInBhaW50XCI6e1widHlwZVwiOlwicGFpbnRcIn0sXCJwYWludC4qXCI6e1widHlwZVwiOlwicGFpbnRcIn19LFwibGF5b3V0XCI6W1wibGF5b3V0X2ZpbGxcIixcImxheW91dF9saW5lXCIsXCJsYXlvdXRfY2lyY2xlXCIsXCJsYXlvdXRfc3ltYm9sXCIsXCJsYXlvdXRfcmFzdGVyXCIsXCJsYXlvdXRfYmFja2dyb3VuZFwiXSxcImxheW91dF9iYWNrZ3JvdW5kXCI6e1widmlzaWJpbGl0eVwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcInZpc2libGVcIixcIm5vbmVcIl0sXCJkZWZhdWx0XCI6XCJ2aXNpYmxlXCJ9fSxcImxheW91dF9maWxsXCI6e1widmlzaWJpbGl0eVwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcInZpc2libGVcIixcIm5vbmVcIl0sXCJkZWZhdWx0XCI6XCJ2aXNpYmxlXCJ9fSxcImxheW91dF9jaXJjbGVcIjp7XCJ2aXNpYmlsaXR5XCI6e1widHlwZVwiOlwiZW51bVwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwidmFsdWVzXCI6W1widmlzaWJsZVwiLFwibm9uZVwiXSxcImRlZmF1bHRcIjpcInZpc2libGVcIn19LFwibGF5b3V0X2xpbmVcIjp7XCJsaW5lLWNhcFwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcImJ1dHRcIixcInJvdW5kXCIsXCJzcXVhcmVcIl0sXCJkZWZhdWx0XCI6XCJidXR0XCJ9LFwibGluZS1qb2luXCI6e1widHlwZVwiOlwiZW51bVwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwidmFsdWVzXCI6W1wiYmV2ZWxcIixcInJvdW5kXCIsXCJtaXRlclwiXSxcImRlZmF1bHRcIjpcIm1pdGVyXCJ9LFwibGluZS1taXRlci1saW1pdFwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJyZXF1aXJlc1wiOlt7XCJsaW5lLWpvaW5cIjpcIm1pdGVyXCJ9XX0sXCJsaW5lLXJvdW5kLWxpbWl0XCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MS4wNSxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInJlcXVpcmVzXCI6W3tcImxpbmUtam9pblwiOlwicm91bmRcIn1dfSxcInZpc2liaWxpdHlcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ2YWx1ZXNcIjpbXCJ2aXNpYmxlXCIsXCJub25lXCJdLFwiZGVmYXVsdFwiOlwidmlzaWJsZVwifX0sXCJsYXlvdXRfc3ltYm9sXCI6e1wic3ltYm9sLXBsYWNlbWVudFwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcInBvaW50XCIsXCJsaW5lXCJdLFwiZGVmYXVsdFwiOlwicG9pbnRcIn0sXCJzeW1ib2wtc3BhY2luZ1wiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjI1MCxcIm1pbmltdW1cIjoxLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidW5pdHNcIjpcInBpeGVsc1wiLFwicmVxdWlyZXNcIjpbe1wic3ltYm9sLXBsYWNlbWVudFwiOlwibGluZVwifV19LFwic3ltYm9sLWF2b2lkLWVkZ2VzXCI6e1widHlwZVwiOlwiYm9vbGVhblwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiZGVmYXVsdFwiOmZhbHNlfSxcImljb24tYWxsb3ctb3ZlcmxhcFwiOntcInR5cGVcIjpcImJvb2xlYW5cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcImRlZmF1bHRcIjpmYWxzZSxcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiXX0sXCJpY29uLWlnbm9yZS1wbGFjZW1lbnRcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJkZWZhdWx0XCI6ZmFsc2UsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIl19LFwiaWNvbi1vcHRpb25hbFwiOntcInR5cGVcIjpcImJvb2xlYW5cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcImRlZmF1bHRcIjpmYWxzZSxcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiLFwidGV4dC1maWVsZFwiXX0sXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcIm1hcFwiLFwidmlld3BvcnRcIl0sXCJkZWZhdWx0XCI6XCJ2aWV3cG9ydFwiLFwicmVxdWlyZXNcIjpbXCJpY29uLWltYWdlXCJdfSxcImljb24tc2l6ZVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjEsXCJtaW5pbXVtXCI6MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiXX0sXCJpY29uLWltYWdlXCI6e1widHlwZVwiOlwic3RyaW5nXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ0b2tlbnNcIjp0cnVlfSxcImljb24tcm90YXRlXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcInBlcmlvZFwiOjM2MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInVuaXRzXCI6XCJkZWdyZWVzXCIsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIl19LFwiaWNvbi1wYWRkaW5nXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MixcIm1pbmltdW1cIjowLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidW5pdHNcIjpcInBpeGVsc1wiLFwicmVxdWlyZXNcIjpbXCJpY29uLWltYWdlXCJdfSxcImljb24ta2VlcC11cHJpZ2h0XCI6e1widHlwZVwiOlwiYm9vbGVhblwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiZGVmYXVsdFwiOmZhbHNlLFwicmVxdWlyZXNcIjpbXCJpY29uLWltYWdlXCIse1wiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIjpcIm1hcFwifSx7XCJzeW1ib2wtcGxhY2VtZW50XCI6XCJsaW5lXCJ9XX0sXCJpY29uLW9mZnNldFwiOntcInR5cGVcIjpcImFycmF5XCIsXCJ2YWx1ZVwiOlwibnVtYmVyXCIsXCJsZW5ndGhcIjoyLFwiZGVmYXVsdFwiOlswLDBdLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwicmVxdWlyZXNcIjpbXCJpY29uLWltYWdlXCJdfSxcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCI6e1widHlwZVwiOlwiZW51bVwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwidmFsdWVzXCI6W1wibWFwXCIsXCJ2aWV3cG9ydFwiXSxcImRlZmF1bHRcIjpcInZpZXdwb3J0XCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC1maWVsZFwiOntcInR5cGVcIjpcInN0cmluZ1wiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiZGVmYXVsdFwiOlwiXCIsXCJ0b2tlbnNcIjp0cnVlfSxcInRleHQtZm9udFwiOntcInR5cGVcIjpcImFycmF5XCIsXCJ2YWx1ZVwiOlwic3RyaW5nXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJkZWZhdWx0XCI6W1wiT3BlbiBTYW5zIFJlZ3VsYXJcIixcIkFyaWFsIFVuaWNvZGUgTVMgUmVndWxhclwiXSxcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXX0sXCJ0ZXh0LXNpemVcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjoxNixcIm1pbmltdW1cIjowLFwidW5pdHNcIjpcInBpeGVsc1wiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdfSxcInRleHQtbWF4LXdpZHRoXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MTAsXCJtaW5pbXVtXCI6MCxcInVuaXRzXCI6XCJlbVwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdfSxcInRleHQtbGluZS1oZWlnaHRcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjoxLjIsXCJ1bml0c1wiOlwiZW1cIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXX0sXCJ0ZXh0LWxldHRlci1zcGFjaW5nXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcInVuaXRzXCI6XCJlbVwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdfSxcInRleHQtanVzdGlmeVwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcImxlZnRcIixcImNlbnRlclwiLFwicmlnaHRcIl0sXCJkZWZhdWx0XCI6XCJjZW50ZXJcIixcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXX0sXCJ0ZXh0LWFuY2hvclwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcImNlbnRlclwiLFwibGVmdFwiLFwicmlnaHRcIixcInRvcFwiLFwiYm90dG9tXCIsXCJ0b3AtbGVmdFwiLFwidG9wLXJpZ2h0XCIsXCJib3R0b20tbGVmdFwiLFwiYm90dG9tLXJpZ2h0XCJdLFwiZGVmYXVsdFwiOlwiY2VudGVyXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC1tYXgtYW5nbGVcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjo0NSxcInVuaXRzXCI6XCJkZWdyZWVzXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIix7XCJzeW1ib2wtcGxhY2VtZW50XCI6XCJsaW5lXCJ9XX0sXCJ0ZXh0LXJvdGF0ZVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjAsXCJwZXJpb2RcIjozNjAsXCJ1bml0c1wiOlwiZGVncmVlc1wiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdfSxcInRleHQtcGFkZGluZ1wiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjIsXCJtaW5pbXVtXCI6MCxcInVuaXRzXCI6XCJwaXhlbHNcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXX0sXCJ0ZXh0LWtlZXAtdXByaWdodFwiOntcInR5cGVcIjpcImJvb2xlYW5cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcImRlZmF1bHRcIjp0cnVlLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCIse1widGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIjpcIm1hcFwifSx7XCJzeW1ib2wtcGxhY2VtZW50XCI6XCJsaW5lXCJ9XX0sXCJ0ZXh0LXRyYW5zZm9ybVwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcIm5vbmVcIixcInVwcGVyY2FzZVwiLFwibG93ZXJjYXNlXCJdLFwiZGVmYXVsdFwiOlwibm9uZVwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdfSxcInRleHQtb2Zmc2V0XCI6e1widHlwZVwiOlwiYXJyYXlcIixcInZhbHVlXCI6XCJudW1iZXJcIixcInVuaXRzXCI6XCJlbXNcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcImxlbmd0aFwiOjIsXCJkZWZhdWx0XCI6WzAsMF0sXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC1hbGxvdy1vdmVybGFwXCI6e1widHlwZVwiOlwiYm9vbGVhblwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiZGVmYXVsdFwiOmZhbHNlLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdfSxcInRleHQtaWdub3JlLXBsYWNlbWVudFwiOntcInR5cGVcIjpcImJvb2xlYW5cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcImRlZmF1bHRcIjpmYWxzZSxcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXX0sXCJ0ZXh0LW9wdGlvbmFsXCI6e1widHlwZVwiOlwiYm9vbGVhblwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiZGVmYXVsdFwiOmZhbHNlLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCIsXCJpY29uLWltYWdlXCJdfSxcInZpc2liaWxpdHlcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ2YWx1ZXNcIjpbXCJ2aXNpYmxlXCIsXCJub25lXCJdLFwiZGVmYXVsdFwiOlwidmlzaWJsZVwifX0sXCJsYXlvdXRfcmFzdGVyXCI6e1widmlzaWJpbGl0eVwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcInZpc2libGVcIixcIm5vbmVcIl0sXCJkZWZhdWx0XCI6XCJ2aXNpYmxlXCJ9fSxcImZpbHRlclwiOntcInR5cGVcIjpcImFycmF5XCIsXCJ2YWx1ZVwiOlwiKlwifSxcImZpbHRlcl9vcGVyYXRvclwiOntcInR5cGVcIjpcImVudW1cIixcInZhbHVlc1wiOltcIj09XCIsXCIhPVwiLFwiPlwiLFwiPj1cIixcIjxcIixcIjw9XCIsXCJpblwiLFwiIWluXCIsXCJhbGxcIixcImFueVwiLFwibm9uZVwiLFwiaGFzXCIsXCIhaGFzXCJdfSxcImdlb21ldHJ5X3R5cGVcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJ2YWx1ZXNcIjpbXCJQb2ludFwiLFwiTGluZVN0cmluZ1wiLFwiUG9seWdvblwiXX0sXCJjb2xvcl9vcGVyYXRpb25cIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJ2YWx1ZXNcIjpbXCJsaWdodGVuXCIsXCJzYXR1cmF0ZVwiLFwic3BpblwiLFwiZmFkZVwiLFwibWl4XCJdfSxcImZ1bmN0aW9uXCI6e1wic3RvcHNcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwicmVxdWlyZWRcIjp0cnVlLFwidmFsdWVcIjpcImZ1bmN0aW9uX3N0b3BcIn0sXCJiYXNlXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MSxcIm1pbmltdW1cIjowfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwic3RyaW5nXCIsXCJkZWZhdWx0XCI6XCIkem9vbVwifSxcInR5cGVcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJ2YWx1ZXNcIjpbXCJleHBvbmVudGlhbFwiLFwiaW50ZXJ2YWxcIixcImNhdGVnb3JpY2FsXCJdLFwiZGVmYXVsdFwiOlwiZXhwb25lbnRpYWxcIn19LFwiZnVuY3Rpb25fc3RvcFwiOntcInR5cGVcIjpcImFycmF5XCIsXCJtaW5pbXVtXCI6MCxcIm1heGltdW1cIjoyMixcInZhbHVlXCI6W1wibnVtYmVyXCIsXCJjb2xvclwiXSxcImxlbmd0aFwiOjJ9LFwicGFpbnRcIjpbXCJwYWludF9maWxsXCIsXCJwYWludF9saW5lXCIsXCJwYWludF9jaXJjbGVcIixcInBhaW50X3N5bWJvbFwiLFwicGFpbnRfcmFzdGVyXCIsXCJwYWludF9iYWNrZ3JvdW5kXCJdLFwicGFpbnRfZmlsbFwiOntcImZpbGwtYW50aWFsaWFzXCI6e1widHlwZVwiOlwiYm9vbGVhblwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiZGVmYXVsdFwiOnRydWV9LFwiZmlsbC1vcGFjaXR5XCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJkZWZhdWx0XCI6MSxcIm1pbmltdW1cIjowLFwibWF4aW11bVwiOjEsXCJ0cmFuc2l0aW9uXCI6dHJ1ZX0sXCJmaWxsLWNvbG9yXCI6e1widHlwZVwiOlwiY29sb3JcIixcImRlZmF1bHRcIjpcIiMwMDAwMDBcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwicmVxdWlyZXNcIjpbe1wiIVwiOlwiZmlsbC1wYXR0ZXJuXCJ9XX0sXCJmaWxsLW91dGxpbmUtY29sb3JcIjp7XCJ0eXBlXCI6XCJjb2xvclwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJyZXF1aXJlc1wiOlt7XCIhXCI6XCJmaWxsLXBhdHRlcm5cIn0se1wiZmlsbC1hbnRpYWxpYXNcIjp0cnVlfV19LFwiZmlsbC10cmFuc2xhdGVcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwidmFsdWVcIjpcIm51bWJlclwiLFwibGVuZ3RoXCI6MixcImRlZmF1bHRcIjpbMCwwXSxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wifSxcImZpbGwtdHJhbnNsYXRlLWFuY2hvclwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcIm1hcFwiLFwidmlld3BvcnRcIl0sXCJkZWZhdWx0XCI6XCJtYXBcIixcInJlcXVpcmVzXCI6W1wiZmlsbC10cmFuc2xhdGVcIl19LFwiZmlsbC1wYXR0ZXJuXCI6e1widHlwZVwiOlwic3RyaW5nXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZX19LFwicGFpbnRfbGluZVwiOntcImxpbmUtb3BhY2l0eVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiZGVmYXVsdFwiOjEsXCJtaW5pbXVtXCI6MCxcIm1heGltdW1cIjoxLFwidHJhbnNpdGlvblwiOnRydWV9LFwibGluZS1jb2xvclwiOntcInR5cGVcIjpcImNvbG9yXCIsXCJkZWZhdWx0XCI6XCIjMDAwMDAwXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInJlcXVpcmVzXCI6W3tcIiFcIjpcImxpbmUtcGF0dGVyblwifV19LFwibGluZS10cmFuc2xhdGVcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwidmFsdWVcIjpcIm51bWJlclwiLFwibGVuZ3RoXCI6MixcImRlZmF1bHRcIjpbMCwwXSxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wifSxcImxpbmUtdHJhbnNsYXRlLWFuY2hvclwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcIm1hcFwiLFwidmlld3BvcnRcIl0sXCJkZWZhdWx0XCI6XCJtYXBcIixcInJlcXVpcmVzXCI6W1wibGluZS10cmFuc2xhdGVcIl19LFwibGluZS13aWR0aFwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjEsXCJtaW5pbXVtXCI6MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wifSxcImxpbmUtZ2FwLXdpZHRoXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcIm1pbmltdW1cIjowLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCJ9LFwibGluZS1vZmZzZXRcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCJ9LFwibGluZS1ibHVyXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcIm1pbmltdW1cIjowLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCJ9LFwibGluZS1kYXNoYXJyYXlcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwidmFsdWVcIjpcIm51bWJlclwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwibWluaW11bVwiOjAsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInVuaXRzXCI6XCJsaW5lIHdpZHRoc1wiLFwicmVxdWlyZXNcIjpbe1wiIVwiOlwibGluZS1wYXR0ZXJuXCJ9XX0sXCJsaW5lLXBhdHRlcm5cIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInRyYW5zaXRpb25cIjp0cnVlfX0sXCJwYWludF9jaXJjbGVcIjp7XCJjaXJjbGUtcmFkaXVzXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6NSxcIm1pbmltdW1cIjowLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCJ9LFwiY2lyY2xlLWNvbG9yXCI6e1widHlwZVwiOlwiY29sb3JcIixcImRlZmF1bHRcIjpcIiMwMDAwMDBcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlfSxcImNpcmNsZS1ibHVyXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlfSxcImNpcmNsZS1vcGFjaXR5XCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MSxcIm1pbmltdW1cIjowLFwibWF4aW11bVwiOjEsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZX0sXCJjaXJjbGUtdHJhbnNsYXRlXCI6e1widHlwZVwiOlwiYXJyYXlcIixcInZhbHVlXCI6XCJudW1iZXJcIixcImxlbmd0aFwiOjIsXCJkZWZhdWx0XCI6WzAsMF0sXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInVuaXRzXCI6XCJwaXhlbHNcIn0sXCJjaXJjbGUtdHJhbnNsYXRlLWFuY2hvclwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcIm1hcFwiLFwidmlld3BvcnRcIl0sXCJkZWZhdWx0XCI6XCJtYXBcIixcInJlcXVpcmVzXCI6W1wiY2lyY2xlLXRyYW5zbGF0ZVwiXX19LFwicGFpbnRfc3ltYm9sXCI6e1wiaWNvbi1vcGFjaXR5XCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MSxcIm1pbmltdW1cIjowLFwibWF4aW11bVwiOjEsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiXX0sXCJpY29uLWNvbG9yXCI6e1widHlwZVwiOlwiY29sb3JcIixcImRlZmF1bHRcIjpcIiMwMDAwMDBcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwicmVxdWlyZXNcIjpbXCJpY29uLWltYWdlXCJdfSxcImljb24taGFsby1jb2xvclwiOntcInR5cGVcIjpcImNvbG9yXCIsXCJkZWZhdWx0XCI6XCJyZ2JhKDAsIDAsIDAsIDApXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiXX0sXCJpY29uLWhhbG8td2lkdGhcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwibWluaW11bVwiOjAsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInVuaXRzXCI6XCJwaXhlbHNcIixcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiXX0sXCJpY29uLWhhbG8tYmx1clwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjAsXCJtaW5pbXVtXCI6MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wiLFwicmVxdWlyZXNcIjpbXCJpY29uLWltYWdlXCJdfSxcImljb24tdHJhbnNsYXRlXCI6e1widHlwZVwiOlwiYXJyYXlcIixcInZhbHVlXCI6XCJudW1iZXJcIixcImxlbmd0aFwiOjIsXCJkZWZhdWx0XCI6WzAsMF0sXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInVuaXRzXCI6XCJwaXhlbHNcIixcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiXX0sXCJpY29uLXRyYW5zbGF0ZS1hbmNob3JcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ2YWx1ZXNcIjpbXCJtYXBcIixcInZpZXdwb3J0XCJdLFwiZGVmYXVsdFwiOlwibWFwXCIsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIixcImljb24tdHJhbnNsYXRlXCJdfSxcInRleHQtb3BhY2l0eVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjEsXCJtaW5pbXVtXCI6MCxcIm1heGltdW1cIjoxLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC1jb2xvclwiOntcInR5cGVcIjpcImNvbG9yXCIsXCJkZWZhdWx0XCI6XCIjMDAwMDAwXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXX0sXCJ0ZXh0LWhhbG8tY29sb3JcIjp7XCJ0eXBlXCI6XCJjb2xvclwiLFwiZGVmYXVsdFwiOlwicmdiYSgwLCAwLCAwLCAwKVwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC1oYWxvLXdpZHRoXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcIm1pbmltdW1cIjowLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC1oYWxvLWJsdXJcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwibWluaW11bVwiOjAsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInVuaXRzXCI6XCJwaXhlbHNcIixcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXX0sXCJ0ZXh0LXRyYW5zbGF0ZVwiOntcInR5cGVcIjpcImFycmF5XCIsXCJ2YWx1ZVwiOlwibnVtYmVyXCIsXCJsZW5ndGhcIjoyLFwiZGVmYXVsdFwiOlswLDBdLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC10cmFuc2xhdGUtYW5jaG9yXCI6e1widHlwZVwiOlwiZW51bVwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwidmFsdWVzXCI6W1wibWFwXCIsXCJ2aWV3cG9ydFwiXSxcImRlZmF1bHRcIjpcIm1hcFwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCIsXCJ0ZXh0LXRyYW5zbGF0ZVwiXX19LFwicGFpbnRfcmFzdGVyXCI6e1wicmFzdGVyLW9wYWNpdHlcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjoxLFwibWluaW11bVwiOjAsXCJtYXhpbXVtXCI6MSxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlfSxcInJhc3Rlci1odWUtcm90YXRlXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcInBlcmlvZFwiOjM2MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcImRlZ3JlZXNcIn0sXCJyYXN0ZXItYnJpZ2h0bmVzcy1taW5cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcImRlZmF1bHRcIjowLFwibWluaW11bVwiOjAsXCJtYXhpbXVtXCI6MSxcInRyYW5zaXRpb25cIjp0cnVlfSxcInJhc3Rlci1icmlnaHRuZXNzLW1heFwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiZGVmYXVsdFwiOjEsXCJtaW5pbXVtXCI6MCxcIm1heGltdW1cIjoxLFwidHJhbnNpdGlvblwiOnRydWV9LFwicmFzdGVyLXNhdHVyYXRpb25cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwibWluaW11bVwiOi0xLFwibWF4aW11bVwiOjEsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZX0sXCJyYXN0ZXItY29udHJhc3RcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwibWluaW11bVwiOi0xLFwibWF4aW11bVwiOjEsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZX0sXCJyYXN0ZXItZmFkZS1kdXJhdGlvblwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjMwMCxcIm1pbmltdW1cIjowLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwibWlsbGlzZWNvbmRzXCJ9fSxcInBhaW50X2JhY2tncm91bmRcIjp7XCJiYWNrZ3JvdW5kLWNvbG9yXCI6e1widHlwZVwiOlwiY29sb3JcIixcImRlZmF1bHRcIjpcIiMwMDAwMDBcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwicmVxdWlyZXNcIjpbe1wiIVwiOlwiYmFja2dyb3VuZC1wYXR0ZXJuXCJ9XX0sXCJiYWNrZ3JvdW5kLXBhdHRlcm5cIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInRyYW5zaXRpb25cIjp0cnVlfSxcImJhY2tncm91bmQtb3BhY2l0eVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjEsXCJtaW5pbXVtXCI6MCxcIm1heGltdW1cIjoxLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWV9fSxcInRyYW5zaXRpb25cIjp7XCJkdXJhdGlvblwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjMwMCxcIm1pbmltdW1cIjowLFwidW5pdHNcIjpcIm1pbGxpc2Vjb25kc1wifSxcImRlbGF5XCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcIm1pbmltdW1cIjowLFwidW5pdHNcIjpcIm1pbGxpc2Vjb25kc1wifX19IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBsaWdodHdlaWdodCBCdWZmZXIgc2hpbSBmb3IgcGJmIGJyb3dzZXIgYnVpbGRcbi8vIGJhc2VkIG9uIGNvZGUgZnJvbSBnaXRodWIuY29tL2Zlcm9zcy9idWZmZXIgKE1JVC1saWNlbnNlZClcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXI7XG5cbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpO1xuXG52YXIgQnVmZmVyTWV0aG9kcztcblxuZnVuY3Rpb24gQnVmZmVyKGxlbmd0aCkge1xuICAgIHZhciBhcnI7XG4gICAgaWYgKGxlbmd0aCAmJiBsZW5ndGgubGVuZ3RoKSB7XG4gICAgICAgIGFyciA9IGxlbmd0aDtcbiAgICAgICAgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCB8fCAwKTtcbiAgICBpZiAoYXJyKSBidWYuc2V0KGFycik7XG5cbiAgICBidWYucmVhZFVJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy5yZWFkVUludDMyTEU7XG4gICAgYnVmLndyaXRlVUludDMyTEUgPSBCdWZmZXJNZXRob2RzLndyaXRlVUludDMyTEU7XG4gICAgYnVmLnJlYWRJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy5yZWFkSW50MzJMRTtcbiAgICBidWYud3JpdGVJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy53cml0ZUludDMyTEU7XG4gICAgYnVmLnJlYWRGbG9hdExFID0gQnVmZmVyTWV0aG9kcy5yZWFkRmxvYXRMRTtcbiAgICBidWYud3JpdGVGbG9hdExFID0gQnVmZmVyTWV0aG9kcy53cml0ZUZsb2F0TEU7XG4gICAgYnVmLnJlYWREb3VibGVMRSA9IEJ1ZmZlck1ldGhvZHMucmVhZERvdWJsZUxFO1xuICAgIGJ1Zi53cml0ZURvdWJsZUxFID0gQnVmZmVyTWV0aG9kcy53cml0ZURvdWJsZUxFO1xuICAgIGJ1Zi50b1N0cmluZyA9IEJ1ZmZlck1ldGhvZHMudG9TdHJpbmc7XG4gICAgYnVmLndyaXRlID0gQnVmZmVyTWV0aG9kcy53cml0ZTtcbiAgICBidWYuc2xpY2UgPSBCdWZmZXJNZXRob2RzLnNsaWNlO1xuICAgIGJ1Zi5jb3B5ID0gQnVmZmVyTWV0aG9kcy5jb3B5O1xuXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWU7XG4gICAgcmV0dXJuIGJ1Zjtcbn1cblxudmFyIGxhc3RTdHIsIGxhc3RTdHJFbmNvZGVkO1xuXG5CdWZmZXJNZXRob2RzID0ge1xuICAgIHJlYWRVSW50MzJMRTogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXNbcG9zXSkgfFxuICAgICAgICAgICAgKHRoaXNbcG9zICsgMV0gPDwgOCkgfFxuICAgICAgICAgICAgKHRoaXNbcG9zICsgMl0gPDwgMTYpKSArXG4gICAgICAgICAgICAodGhpc1twb3MgKyAzXSAqIDB4MTAwMDAwMCk7XG4gICAgfSxcblxuICAgIHdyaXRlVUludDMyTEU6IGZ1bmN0aW9uKHZhbCwgcG9zKSB7XG4gICAgICAgIHRoaXNbcG9zXSA9IHZhbDtcbiAgICAgICAgdGhpc1twb3MgKyAxXSA9ICh2YWwgPj4+IDgpO1xuICAgICAgICB0aGlzW3BvcyArIDJdID0gKHZhbCA+Pj4gMTYpO1xuICAgICAgICB0aGlzW3BvcyArIDNdID0gKHZhbCA+Pj4gMjQpO1xuICAgIH0sXG5cbiAgICByZWFkSW50MzJMRTogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXNbcG9zXSkgfFxuICAgICAgICAgICAgKHRoaXNbcG9zICsgMV0gPDwgOCkgfFxuICAgICAgICAgICAgKHRoaXNbcG9zICsgMl0gPDwgMTYpKSArXG4gICAgICAgICAgICAodGhpc1twb3MgKyAzXSA8PCAyNCk7XG4gICAgfSxcblxuICAgIHJlYWRGbG9hdExFOiAgZnVuY3Rpb24ocG9zKSB7IHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgcG9zLCB0cnVlLCAyMywgNCk7IH0sXG4gICAgcmVhZERvdWJsZUxFOiBmdW5jdGlvbihwb3MpIHsgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBwb3MsIHRydWUsIDUyLCA4KTsgfSxcblxuICAgIHdyaXRlRmxvYXRMRTogIGZ1bmN0aW9uKHZhbCwgcG9zKSB7IHJldHVybiBpZWVlNzU0LndyaXRlKHRoaXMsIHZhbCwgcG9zLCB0cnVlLCAyMywgNCk7IH0sXG4gICAgd3JpdGVEb3VibGVMRTogZnVuY3Rpb24odmFsLCBwb3MpIHsgcmV0dXJuIGllZWU3NTQud3JpdGUodGhpcywgdmFsLCBwb3MsIHRydWUsIDUyLCA4KTsgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgc3RyID0gJycsXG4gICAgICAgICAgICB0bXAgPSAnJztcblxuICAgICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgICAgIGVuZCA9IE1hdGgubWluKHRoaXMubGVuZ3RoLCBlbmQgfHwgdGhpcy5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSB0aGlzW2ldO1xuICAgICAgICAgICAgaWYgKGNoIDw9IDB4N0YpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gZGVjb2RlVVJJQ29tcG9uZW50KHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgICAgICAgICB0bXAgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG1wICs9ICclJyArIGNoLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciArPSBkZWNvZGVVUklDb21wb25lbnQodG1wKTtcblxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cbiAgICB3cml0ZTogZnVuY3Rpb24oc3RyLCBwb3MpIHtcbiAgICAgICAgdmFyIGJ5dGVzID0gc3RyID09PSBsYXN0U3RyID8gbGFzdFN0ckVuY29kZWQgOiBlbmNvZGVTdHJpbmcoc3RyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpc1twb3MgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNsaWNlOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpO1xuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbihidWYsIHBvcykge1xuICAgICAgICBwb3MgPSBwb3MgfHwgMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBidWZbcG9zICsgaV0gPSB0aGlzW2ldO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuQnVmZmVyTWV0aG9kcy53cml0ZUludDMyTEUgPSBCdWZmZXJNZXRob2RzLndyaXRlVUludDMyTEU7XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgbGFzdFN0ciA9IHN0cjtcbiAgICBsYXN0U3RyRW5jb2RlZCA9IGVuY29kZVN0cmluZyhzdHIpO1xuICAgIHJldHVybiBsYXN0U3RyRW5jb2RlZC5sZW5ndGg7XG59O1xuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbihidWYpIHtcbiAgICByZXR1cm4gISEoYnVmICYmIGJ1Zi5faXNCdWZmZXIpO1xufTtcblxuZnVuY3Rpb24gZW5jb2RlU3RyaW5nKHN0cikge1xuICAgIHZhciBsZW5ndGggPSBzdHIubGVuZ3RoLFxuICAgICAgICBieXRlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGMsIGxlYWQ7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7IC8vIGNvZGUgcG9pbnRcblxuICAgICAgICBpZiAoYyA+IDB4RDdGRiAmJiBjIDwgMHhFMDAwKSB7XG5cbiAgICAgICAgICAgIGlmIChsZWFkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPCAweERDMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICAgICAgICAgICAgbGVhZCA9IGM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGxlYWQgLSAweEQ4MDAgPDwgMTAgfCBjIC0gMHhEQzAwIHwgMHgxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgbGVhZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjID4gMHhEQkZGIHx8IChpICsgMSA9PT0gbGVuZ3RoKSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICAgICAgICBlbHNlIGxlYWQgPSBjO1xuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChsZWFkKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgICAgbGVhZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4ODApIGJ5dGVzLnB1c2goYyk7XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkgYnl0ZXMucHVzaChjID4+IDB4NiB8IDB4QzAsIGMgJiAweDNGIHwgMHg4MCk7XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDEwMDAwKSBieXRlcy5wdXNoKGMgPj4gMHhDIHwgMHhFMCwgYyA+PiAweDYgJiAweDNGIHwgMHg4MCwgYyAmIDB4M0YgfCAweDgwKTtcbiAgICAgICAgZWxzZSBieXRlcy5wdXNoKGMgPj4gMHgxMiB8IDB4RjAsIGMgPj4gMHhDICYgMHgzRiB8IDB4ODAsIGMgPj4gMHg2ICYgMHgzRiB8IDB4ODAsIGMgJiAweDNGIHwgMHg4MCk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYmY7XG5cbnZhciBCdWZmZXIgPSBnbG9iYWwuQnVmZmVyIHx8IHJlcXVpcmUoJy4vYnVmZmVyJyk7XG5cbmZ1bmN0aW9uIFBiZihidWYpIHtcbiAgICB0aGlzLmJ1ZiA9ICFCdWZmZXIuaXNCdWZmZXIoYnVmKSA/IG5ldyBCdWZmZXIoYnVmIHx8IDApIDogYnVmO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMuYnVmLmxlbmd0aDtcbn1cblxuUGJmLlZhcmludCAgPSAwOyAvLyB2YXJpbnQ6IGludDMyLCBpbnQ2NCwgdWludDMyLCB1aW50NjQsIHNpbnQzMiwgc2ludDY0LCBib29sLCBlbnVtXG5QYmYuRml4ZWQ2NCA9IDE7IC8vIDY0LWJpdDogZG91YmxlLCBmaXhlZDY0LCBzZml4ZWQ2NFxuUGJmLkJ5dGVzICAgPSAyOyAvLyBsZW5ndGgtZGVsaW1pdGVkOiBzdHJpbmcsIGJ5dGVzLCBlbWJlZGRlZCBtZXNzYWdlcywgcGFja2VkIHJlcGVhdGVkIGZpZWxkc1xuUGJmLkZpeGVkMzIgPSA1OyAvLyAzMi1iaXQ6IGZsb2F0LCBmaXhlZDMyLCBzZml4ZWQzMlxuXG52YXIgU0hJRlRfTEVGVF8zMiA9ICgxIDw8IDE2KSAqICgxIDw8IDE2KSxcbiAgICBTSElGVF9SSUdIVF8zMiA9IDEgLyBTSElGVF9MRUZUXzMyLFxuICAgIFBPV18yXzYzID0gTWF0aC5wb3coMiwgNjMpO1xuXG5QYmYucHJvdG90eXBlID0ge1xuXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYnVmID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLy8gPT09IFJFQURJTkcgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIHJlYWRGaWVsZHM6IGZ1bmN0aW9uKHJlYWRGaWVsZCwgcmVzdWx0LCBlbmQpIHtcbiAgICAgICAgZW5kID0gZW5kIHx8IHRoaXMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMucmVhZFZhcmludCgpLFxuICAgICAgICAgICAgICAgIHRhZyA9IHZhbCA+PiAzLFxuICAgICAgICAgICAgICAgIHN0YXJ0UG9zID0gdGhpcy5wb3M7XG5cbiAgICAgICAgICAgIHJlYWRGaWVsZCh0YWcsIHJlc3VsdCwgdGhpcyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gc3RhcnRQb3MpIHRoaXMuc2tpcCh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHJlYWRNZXNzYWdlOiBmdW5jdGlvbihyZWFkRmllbGQsIHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkRmllbGRzKHJlYWRGaWVsZCwgcmVzdWx0LCB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zKTtcbiAgICB9LFxuXG4gICAgcmVhZEZpeGVkMzI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgcmVhZFNGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRJbnQzMkxFKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgLy8gNjQtYml0IGludCBoYW5kbGluZyBpcyBiYXNlZCBvbiBnaXRodWIuY29tL2Rwdy9ub2RlLWJ1ZmZlci1tb3JlLWludHMgKE1JVC1saWNlbnNlZClcblxuICAgIHJlYWRGaXhlZDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcykgKyB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MgKyA0KSAqIFNISUZUX0xFRlRfMzI7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRTRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MpICsgdGhpcy5idWYucmVhZEludDMyTEUodGhpcy5wb3MgKyA0KSAqIFNISUZUX0xFRlRfMzI7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRGbG9hdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkRmxvYXRMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWREb3VibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZERvdWJsZUxFKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgcmVhZFZhcmludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBidWYgPSB0aGlzLmJ1ZixcbiAgICAgICAgICAgIHZhbCwgYjtcblxuICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgID0gIGIgJiAweDdmOyAgICAgICAgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgfD0gKGIgJiAweDdmKSA8PCA3OyAgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgfD0gKGIgJiAweDdmKSA8PCAxNDsgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgfD0gKGIgJiAweDdmKSA8PCAyMTsgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuXG4gICAgICAgIHJldHVybiByZWFkVmFyaW50UmVtYWluZGVyKHZhbCwgdGhpcyk7XG4gICAgfSxcblxuICAgIHJlYWRWYXJpbnQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zLFxuICAgICAgICAgICAgdmFsID0gdGhpcy5yZWFkVmFyaW50KCk7XG5cbiAgICAgICAgaWYgKHZhbCA8IFBPV18yXzYzKSByZXR1cm4gdmFsO1xuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcyAtIDI7XG4gICAgICAgIHdoaWxlICh0aGlzLmJ1Zltwb3NdID09PSAweGZmKSBwb3MtLTtcbiAgICAgICAgaWYgKHBvcyA8IHN0YXJ0UG9zKSBwb3MgPSBzdGFydFBvcztcblxuICAgICAgICB2YWwgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvcyAtIHN0YXJ0UG9zICsgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYiA9IH50aGlzLmJ1ZltzdGFydFBvcyArIGldICYgMHg3ZjtcbiAgICAgICAgICAgIHZhbCArPSBpIDwgNCA/IGIgPDwgaSAqIDcgOiBiICogTWF0aC5wb3coMiwgaSAqIDcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC12YWwgLSAxO1xuICAgIH0sXG5cbiAgICByZWFkU1ZhcmludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBudW0gPSB0aGlzLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgcmV0dXJuIG51bSAlIDIgPT09IDEgPyAobnVtICsgMSkgLyAtMiA6IG51bSAvIDI7IC8vIHppZ3phZyBlbmNvZGluZ1xuICAgIH0sXG5cbiAgICByZWFkQm9vbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMucmVhZFZhcmludCgpKTtcbiAgICB9LFxuXG4gICAgcmVhZFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgc3RyID0gdGhpcy5idWYudG9TdHJpbmcoJ3V0ZjgnLCB0aGlzLnBvcywgZW5kKTtcbiAgICAgICAgdGhpcy5wb3MgPSBlbmQ7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuICAgIHJlYWRCeXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgYnVmZmVyID0gdGhpcy5idWYuc2xpY2UodGhpcy5wb3MsIGVuZCk7XG4gICAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH0sXG5cbiAgICAvLyB2ZXJib3NlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOyBkb2Vzbid0IGFmZmVjdCBnemlwcGVkIHNpemVcblxuICAgIHJlYWRQYWNrZWRWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkVmFyaW50KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU1ZhcmludCgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRCb29sZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEJvb2xlYW4oKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRmxvYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkRmxvYXQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRG91YmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZERvdWJsZSgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkU0ZpeGVkMzI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU0ZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZFNGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG5cbiAgICBza2lwOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB2YWwgJiAweDc7XG4gICAgICAgIGlmICh0eXBlID09PSBQYmYuVmFyaW50KSB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gPiAweDdmKSB7fVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBQYmYuQnl0ZXMpIHRoaXMucG9zID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcztcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gUGJmLkZpeGVkMzIpIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFBiZi5GaXhlZDY0KSB0aGlzLnBvcyArPSA4O1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCB0eXBlOiAnICsgdHlwZSk7XG4gICAgfSxcblxuICAgIC8vID09PSBXUklUSU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICB3cml0ZVRhZzogZnVuY3Rpb24odGFnLCB0eXBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoKHRhZyA8PCAzKSB8IHR5cGUpO1xuICAgIH0sXG5cbiAgICByZWFsbG9jOiBmdW5jdGlvbihtaW4pIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDE2O1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGggPCB0aGlzLnBvcyArIG1pbikgbGVuZ3RoICo9IDI7XG5cbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmJ1Zi5jb3B5KGJ1Zik7XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgd3JpdGVGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZVVJbnQzMkxFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZVNGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUodmFsLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgfSxcblxuICAgIHdyaXRlRml4ZWQ2NDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVJbnQzMkxFKHZhbCAmIC0xLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlVUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIHRoaXMucG9zICsgNCk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlU0ZpeGVkNjQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoOCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIHRoaXMucG9zICsgNCk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlVmFyaW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFsID0gK3ZhbDtcblxuICAgICAgICBpZiAodmFsID4gMHhmZmZmZmZmKSB7XG4gICAgICAgICAgICB3cml0ZUJpZ1ZhcmludCh2YWwsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuXG4gICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gICAgICAgICAgIHZhbCAmIDB4N2YgIHwgKHZhbCA+IDB4N2YgPyAweDgwIDogMCk7IGlmICh2YWwgPD0gMHg3ZikgcmV0dXJuO1xuICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+Pj0gNykgJiAweDdmKSB8ICh2YWwgPiAweDdmID8gMHg4MCA6IDApOyBpZiAodmFsIDw9IDB4N2YpIHJldHVybjtcbiAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj49IDcpICYgMHg3ZikgfCAodmFsID4gMHg3ZiA/IDB4ODAgOiAwKTsgaWYgKHZhbCA8PSAweDdmKSByZXR1cm47XG4gICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gICAodmFsID4+PiA3KSAmIDB4N2Y7XG4gICAgfSxcblxuICAgIHdyaXRlU1ZhcmludDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQodmFsIDwgMCA/IC12YWwgKiAyIC0gMSA6IHZhbCAqIDIpO1xuICAgIH0sXG5cbiAgICB3cml0ZUJvb2xlYW46IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KEJvb2xlYW4odmFsKSk7XG4gICAgfSxcblxuICAgIHdyaXRlU3RyaW5nOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgICAgIHZhciBieXRlcyA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN0cik7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoYnl0ZXMpO1xuICAgICAgICB0aGlzLnJlYWxsb2MoYnl0ZXMpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZShzdHIsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gYnl0ZXM7XG4gICAgfSxcblxuICAgIHdyaXRlRmxvYXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlRmxvYXRMRSh2YWwsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICB9LFxuXG4gICAgd3JpdGVEb3VibGU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoOCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlRG91YmxlTEUodmFsLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlQnl0ZXM6IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICB2YXIgbGVuID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChsZW4pO1xuICAgICAgICB0aGlzLnJlYWxsb2MobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgdGhpcy5idWZbdGhpcy5wb3MrK10gPSBidWZmZXJbaV07XG4gICAgfSxcblxuICAgIHdyaXRlUmF3TWVzc2FnZTogZnVuY3Rpb24oZm4sIG9iaikge1xuICAgICAgICB0aGlzLnBvcysrOyAvLyByZXNlcnZlIDEgYnl0ZSBmb3Igc2hvcnQgbWVzc2FnZSBsZW5ndGhcblxuICAgICAgICAvLyB3cml0ZSB0aGUgbWVzc2FnZSBkaXJlY3RseSB0byB0aGUgYnVmZmVyIGFuZCBzZWUgaG93IG11Y2ggd2FzIHdyaXR0ZW5cbiAgICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5wb3M7XG4gICAgICAgIGZuKG9iaiwgdGhpcyk7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLnBvcyAtIHN0YXJ0UG9zO1xuXG4gICAgICAgIGlmIChsZW4gPj0gMHg4MCkgcmVhbGxvY0ZvclJhd01lc3NhZ2Uoc3RhcnRQb3MsIGxlbiwgdGhpcyk7XG5cbiAgICAgICAgLy8gZmluYWxseSwgd3JpdGUgdGhlIG1lc3NhZ2UgbGVuZ3RoIGluIHRoZSByZXNlcnZlZCBwbGFjZSBhbmQgcmVzdG9yZSB0aGUgcG9zaXRpb25cbiAgICAgICAgdGhpcy5wb3MgPSBzdGFydFBvcyAtIDE7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQobGVuKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gbGVuO1xuICAgIH0sXG5cbiAgICB3cml0ZU1lc3NhZ2U6IGZ1bmN0aW9uKHRhZywgZm4sIG9iaikge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkJ5dGVzKTtcbiAgICAgICAgdGhpcy53cml0ZVJhd01lc3NhZ2UoZm4sIG9iaik7XG4gICAgfSxcblxuICAgIHdyaXRlUGFja2VkVmFyaW50OiAgIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRWYXJpbnQsIGFycik7ICAgfSxcbiAgICB3cml0ZVBhY2tlZFNWYXJpbnQ6ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkU1ZhcmludCwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRCb29sZWFuOiAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEJvb2xlYW4sIGFycik7ICB9LFxuICAgIHdyaXRlUGFja2VkRmxvYXQ6ICAgIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRGbG9hdCwgYXJyKTsgICAgfSxcbiAgICB3cml0ZVBhY2tlZERvdWJsZTogICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRG91YmxlLCBhcnIpOyAgIH0sXG4gICAgd3JpdGVQYWNrZWRGaXhlZDMyOiAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEZpeGVkMzIsIGFycik7ICB9LFxuICAgIHdyaXRlUGFja2VkU0ZpeGVkMzI6IGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRTRml4ZWQzMiwgYXJyKTsgfSxcbiAgICB3cml0ZVBhY2tlZEZpeGVkNjQ6ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRml4ZWQ2NCwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRTRml4ZWQ2NDogZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFNGaXhlZDY0LCBhcnIpOyB9LFxuXG4gICAgd3JpdGVCeXRlc0ZpZWxkOiBmdW5jdGlvbih0YWcsIGJ1ZmZlcikge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkJ5dGVzKTtcbiAgICAgICAgdGhpcy53cml0ZUJ5dGVzKGJ1ZmZlcik7XG4gICAgfSxcbiAgICB3cml0ZUZpeGVkMzJGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDMyKTtcbiAgICAgICAgdGhpcy53cml0ZUZpeGVkMzIodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU0ZpeGVkMzJGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDMyKTtcbiAgICAgICAgdGhpcy53cml0ZVNGaXhlZDMyKHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZUZpeGVkNjRGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDY0KTtcbiAgICAgICAgdGhpcy53cml0ZUZpeGVkNjQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU0ZpeGVkNjRGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDY0KTtcbiAgICAgICAgdGhpcy53cml0ZVNGaXhlZDY0KHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZVZhcmludEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLlZhcmludCk7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU1ZhcmludEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLlZhcmludCk7XG4gICAgICAgIHRoaXMud3JpdGVTVmFyaW50KHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZVN0cmluZ0ZpZWxkOiBmdW5jdGlvbih0YWcsIHN0cikge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkJ5dGVzKTtcbiAgICAgICAgdGhpcy53cml0ZVN0cmluZyhzdHIpO1xuICAgIH0sXG4gICAgd3JpdGVGbG9hdEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlRmxvYXQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlRG91YmxlRmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQ2NCk7XG4gICAgICAgIHRoaXMud3JpdGVEb3VibGUodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlQm9vbGVhbkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50RmllbGQodGFnLCBCb29sZWFuKHZhbCkpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHJlYWRWYXJpbnRSZW1haW5kZXIodmFsLCBwYmYpIHtcbiAgICB2YXIgYnVmID0gcGJmLmJ1ZiwgYjtcblxuICAgIGIgPSBidWZbcGJmLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDEwMDAwMDAwOyAgICAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICBiID0gYnVmW3BiZi5wb3MrK107IHZhbCArPSAoYiAmIDB4N2YpICogMHg4MDAwMDAwMDA7ICAgICAgICBpZiAoYiA8IDB4ODApIHJldHVybiB2YWw7XG4gICAgYiA9IGJ1ZltwYmYucG9zKytdOyB2YWwgKz0gKGIgJiAweDdmKSAqIDB4NDAwMDAwMDAwMDA7ICAgICAgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuICAgIGIgPSBidWZbcGJmLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDIwMDAwMDAwMDAwMDA7ICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICBiID0gYnVmW3BiZi5wb3MrK107IHZhbCArPSAoYiAmIDB4N2YpICogMHgxMDAwMDAwMDAwMDAwMDA7ICBpZiAoYiA8IDB4ODApIHJldHVybiB2YWw7XG4gICAgYiA9IGJ1ZltwYmYucG9zKytdOyB2YWwgKz0gKGIgJiAweDdmKSAqIDB4ODAwMDAwMDAwMDAwMDAwMDsgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YXJpbnQgbm90IG1vcmUgdGhhbiAxMCBieXRlcycpO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJpZ1ZhcmludCh2YWwsIHBiZikge1xuICAgIHBiZi5yZWFsbG9jKDEwKTtcblxuICAgIHZhciBtYXhQb3MgPSBwYmYucG9zICsgMTA7XG5cbiAgICB3aGlsZSAodmFsID49IDEpIHtcbiAgICAgICAgaWYgKHBiZi5wb3MgPj0gbWF4UG9zKSB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIHZhcmludCBkb2VzblxcJ3QgZml0IGludG8gMTAgYnl0ZXMnKTtcbiAgICAgICAgdmFyIGIgPSB2YWwgJiAweGZmO1xuICAgICAgICBwYmYuYnVmW3BiZi5wb3MrK10gPSBiIHwgKHZhbCA+PSAweDgwID8gMHg4MCA6IDApO1xuICAgICAgICB2YWwgLz0gMHg4MDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlYWxsb2NGb3JSYXdNZXNzYWdlKHN0YXJ0UG9zLCBsZW4sIHBiZikge1xuICAgIHZhciBleHRyYUxlbiA9XG4gICAgICAgIGxlbiA8PSAweDNmZmYgPyAxIDpcbiAgICAgICAgbGVuIDw9IDB4MWZmZmZmID8gMiA6XG4gICAgICAgIGxlbiA8PSAweGZmZmZmZmYgPyAzIDogTWF0aC5jZWlsKE1hdGgubG9nKGxlbikgLyAoTWF0aC5MTjIgKiA3KSk7XG5cbiAgICAvLyBpZiAxIGJ5dGUgaXNuJ3QgZW5vdWdoIGZvciBlbmNvZGluZyBtZXNzYWdlIGxlbmd0aCwgc2hpZnQgdGhlIGRhdGEgdG8gdGhlIHJpZ2h0XG4gICAgcGJmLnJlYWxsb2MoZXh0cmFMZW4pO1xuICAgIGZvciAodmFyIGkgPSBwYmYucG9zIC0gMTsgaSA+PSBzdGFydFBvczsgaS0tKSBwYmYuYnVmW2kgKyBleHRyYUxlbl0gPSBwYmYuYnVmW2ldO1xufVxuXG5mdW5jdGlvbiB3cml0ZVBhY2tlZFZhcmludChhcnIsIHBiZikgICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVWYXJpbnQoYXJyW2ldKTsgICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZFNWYXJpbnQoYXJyLCBwYmYpICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVTVmFyaW50KGFycltpXSk7ICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZEZsb2F0KGFyciwgcGJmKSAgICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVGbG9hdChhcnJbaV0pOyAgICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZERvdWJsZShhcnIsIHBiZikgICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVEb3VibGUoYXJyW2ldKTsgICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZEJvb2xlYW4oYXJyLCBwYmYpICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVCb29sZWFuKGFycltpXSk7ICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZEZpeGVkMzIoYXJyLCBwYmYpICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVGaXhlZDMyKGFycltpXSk7ICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZFNGaXhlZDMyKGFyciwgcGJmKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVTRml4ZWQzMihhcnJbaV0pOyB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZEZpeGVkNjQoYXJyLCBwYmYpICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVGaXhlZDY0KGFycltpXSk7ICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZFNGaXhlZDY0KGFyciwgcGJmKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVTRml4ZWQ2NChhcnJbaV0pOyB9XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxuZnVuY3Rpb24gUG9pbnQoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbn1cblxuUG9pbnQucHJvdG90eXBlID0ge1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7IH0sXG5cbiAgICBhZGQ6ICAgICBmdW5jdGlvbihwKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX2FkZChwKTsgICAgIH0sXG4gICAgc3ViOiAgICAgZnVuY3Rpb24ocCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWIocCk7ICAgICB9LFxuICAgIG11bHQ6ICAgIGZ1bmN0aW9uKGspIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fbXVsdChrKTsgICAgfSxcbiAgICBkaXY6ICAgICBmdW5jdGlvbihrKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX2RpdihrKTsgICAgIH0sXG4gICAgcm90YXRlOiAgZnVuY3Rpb24oYSkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3RhdGUoYSk7ICB9LFxuICAgIG1hdE11bHQ6IGZ1bmN0aW9uKG0pIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fbWF0TXVsdChtKTsgfSxcbiAgICB1bml0OiAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fdW5pdCgpOyB9LFxuICAgIHBlcnA6ICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9wZXJwKCk7IH0sXG4gICAgcm91bmQ6ICAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3JvdW5kKCk7IH0sXG5cbiAgICBtYWc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSBwLnggJiZcbiAgICAgICAgICAgICAgIHRoaXMueSA9PT0gcC55O1xuICAgIH0sXG5cbiAgICBkaXN0OiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0U3FyKHApKTtcbiAgICB9LFxuXG4gICAgZGlzdFNxcjogZnVuY3Rpb24ocCkge1xuICAgICAgICB2YXIgZHggPSBwLnggLSB0aGlzLngsXG4gICAgICAgICAgICBkeSA9IHAueSAtIHRoaXMueTtcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuICAgIH0sXG5cbiAgICBhbmdsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcbiAgICB9LFxuXG4gICAgYW5nbGVUbzogZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnkgLSBiLnksIHRoaXMueCAtIGIueCk7XG4gICAgfSxcblxuICAgIGFuZ2xlV2l0aDogZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmdsZVdpdGhTZXAoYi54LCBiLnkpO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIHRoZSBhbmdsZSBvZiB0aGUgdHdvIHZlY3RvcnMsIHNvbHZpbmcgdGhlIGZvcm11bGEgZm9yIHRoZSBjcm9zcyBwcm9kdWN0IGEgeCBiID0gfGF8fGJ8c2luKM64KSBmb3IgzrguXG4gICAgYW5nbGVXaXRoU2VwOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKFxuICAgICAgICAgICAgdGhpcy54ICogeSAtIHRoaXMueSAqIHgsXG4gICAgICAgICAgICB0aGlzLnggKiB4ICsgdGhpcy55ICogeSk7XG4gICAgfSxcblxuICAgIF9tYXRNdWx0OiBmdW5jdGlvbihtKSB7XG4gICAgICAgIHZhciB4ID0gbVswXSAqIHRoaXMueCArIG1bMV0gKiB0aGlzLnksXG4gICAgICAgICAgICB5ID0gbVsyXSAqIHRoaXMueCArIG1bM10gKiB0aGlzLnk7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfYWRkOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHRoaXMueCArPSBwLng7XG4gICAgICAgIHRoaXMueSArPSBwLnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfc3ViOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHRoaXMueCAtPSBwLng7XG4gICAgICAgIHRoaXMueSAtPSBwLnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfbXVsdDogZnVuY3Rpb24oaykge1xuICAgICAgICB0aGlzLnggKj0gaztcbiAgICAgICAgdGhpcy55ICo9IGs7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfZGl2OiBmdW5jdGlvbihrKSB7XG4gICAgICAgIHRoaXMueCAvPSBrO1xuICAgICAgICB0aGlzLnkgLz0gaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF91bml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fZGl2KHRoaXMubWFnKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3BlcnA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgeSA9IHRoaXMueTtcbiAgICAgICAgdGhpcy55ID0gdGhpcy54O1xuICAgICAgICB0aGlzLnggPSAteTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9yb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICB4ID0gY29zICogdGhpcy54IC0gc2luICogdGhpcy55LFxuICAgICAgICAgICAgeSA9IHNpbiAqIHRoaXMueCArIGNvcyAqIHRoaXMueTtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9yb3VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcbiAgICAgICAgdGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RzIFBvaW50IGZyb20gYW4gYXJyYXkgaWYgbmVjZXNzYXJ5XG5Qb2ludC5jb252ZXJ0ID0gZnVuY3Rpb24gKGEpIHtcbiAgICBpZiAoYSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KGFbMF0sIGFbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBTaW1vbiBMeWRlbGxcclxuLy8gWDExICjigJxNSVTigJ0pIExpY2Vuc2VkLiAoU2VlIExJQ0VOU0UuKVxyXG5cclxudm9pZCAoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKGZhY3RvcnkpXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KClcclxuICB9IGVsc2Uge1xyXG4gICAgcm9vdC5yZXNvbHZlVXJsID0gZmFjdG9yeSgpXHJcbiAgfVxyXG59KHRoaXMsIGZ1bmN0aW9uKCkge1xyXG5cclxuICBmdW5jdGlvbiByZXNvbHZlVXJsKC8qIC4uLnVybHMgKi8pIHtcclxuICAgIHZhciBudW1VcmxzID0gYXJndW1lbnRzLmxlbmd0aFxyXG5cclxuICAgIGlmIChudW1VcmxzID09PSAwKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInJlc29sdmVVcmwgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50OyBnb3Qgbm9uZS5cIilcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYmFzZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiYXNlXCIpXHJcbiAgICBiYXNlLmhyZWYgPSBhcmd1bWVudHNbMF1cclxuXHJcbiAgICBpZiAobnVtVXJscyA9PT0gMSkge1xyXG4gICAgICByZXR1cm4gYmFzZS5ocmVmXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF1cclxuICAgIGhlYWQuaW5zZXJ0QmVmb3JlKGJhc2UsIGhlYWQuZmlyc3RDaGlsZClcclxuXHJcbiAgICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpXHJcbiAgICB2YXIgcmVzb2x2ZWRcclxuXHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgbnVtVXJsczsgaW5kZXgrKykge1xyXG4gICAgICBhLmhyZWYgPSBhcmd1bWVudHNbaW5kZXhdXHJcbiAgICAgIHJlc29sdmVkID0gYS5ocmVmXHJcbiAgICAgIGJhc2UuaHJlZiA9IHJlc29sdmVkXHJcbiAgICB9XHJcblxyXG4gICAgaGVhZC5yZW1vdmVDaGlsZChiYXNlKVxyXG5cclxuICAgIHJldHVybiByZXNvbHZlZFxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc29sdmVVcmxcclxuXHJcbn0pKTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNoZWxmUGFjaztcblxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBTaGVsZlBhY2sgYmluIGFsbG9jYXRvci5cbiAqXG4gKiBVc2VzIHRoZSBTaGVsZiBCZXN0IEhlaWdodCBGaXQgYWxnb3JpdGhtIGZyb21cbiAqIGh0dHA6Ly9jbGIuZGVtb24uZmkvZmlsZXMvUmVjdGFuZ2xlQmluUGFjay5wZGZcbiAqXG4gKiBAY2xhc3MgIFNoZWxmUGFja1xuICogQHBhcmFtICB7bnVtYmVyfSAgW3c9NjRdICBJbml0aWFsIHdpZHRoIG9mIHRoZSBzcHJpdGVcbiAqIEBwYXJhbSAge251bWJlcn0gIFtoPTY0XSAgSW5pdGlhbCB3aWR0aCBvZiB0aGUgc3ByaXRlXG4gKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9uc11cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLmF1dG9SZXNpemU9ZmFsc2VdICBJZiBgdHJ1ZWAsIHRoZSBzcHJpdGUgd2lsbCBhdXRvbWF0aWNhbGx5IGdyb3dcbiAqIEBleGFtcGxlXG4gKiB2YXIgc3ByaXRlID0gbmV3IFNoZWxmUGFjayg2NCwgNjQsIHsgYXV0b1Jlc2l6ZTogZmFsc2UgfSk7XG4gKi9cbmZ1bmN0aW9uIFNoZWxmUGFjayh3LCBoLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy53ID0gdyB8fCA2NDtcbiAgICB0aGlzLmggPSBoIHx8IDY0O1xuICAgIHRoaXMuYXV0b1Jlc2l6ZSA9ICEhb3B0aW9ucy5hdXRvUmVzaXplO1xuICAgIHRoaXMuc2hlbHZlcyA9IFtdO1xuICAgIHRoaXMuc3RhdHMgPSB7fTtcbiAgICB0aGlzLmNvdW50ID0gZnVuY3Rpb24oaCkge1xuICAgICAgICB0aGlzLnN0YXRzW2hdID0gKHRoaXMuc3RhdHNbaF0gfCAwKSArIDE7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBCYXRjaCBwYWNrIG11bHRpcGxlIGJpbnMgaW50byB0aGUgc3ByaXRlLlxuICpcbiAqIEBwYXJhbSAgIHtBcnJheX0gICBiaW5zIEFycmF5IG9mIHJlcXVlc3RlZCBiaW5zIC0gZWFjaCBvYmplY3Qgc2hvdWxkIGhhdmUgYHdpZHRoYCwgYGhlaWdodGAgKG9yIGB3YCwgYGhgKSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gICB7T2JqZWN0fSAgW29wdGlvbnNdXG4gKiBAcGFyYW0gICB7Ym9vbGVhbn0gW29wdGlvbnMuaW5QbGFjZT1mYWxzZV0gSWYgYHRydWVgLCB0aGUgc3VwcGxpZWQgYmluIG9iamVjdHMgd2lsbCBiZSB1cGRhdGVkIGlucGxhY2Ugd2l0aCBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7QXJyYXl9ICAgQXJyYXkgb2YgYWxsb2NhdGVkIGJpbnMgLSBlYWNoIGJpbiBpcyBhbiBvYmplY3Qgd2l0aCBgeGAsIGB5YCwgYHdgLCBgaGAgcHJvcGVydGllc1xuICogQGV4YW1wbGVcbiAqIHZhciBiaW5zID0gW1xuICogICAgIHsgaWQ6ICdhJywgd2lkdGg6IDEyLCBoZWlnaHQ6IDEyIH0sXG4gKiAgICAgeyBpZDogJ2InLCB3aWR0aDogMTIsIGhlaWdodDogMTYgfSxcbiAqICAgICB7IGlkOiAnYycsIHdpZHRoOiAxMiwgaGVpZ2h0OiAyNCB9XG4gKiBdO1xuICogdmFyIHJlc3VsdHMgPSBzcHJpdGUucGFjayhiaW5zLCB7IGluUGxhY2U6IGZhbHNlIH0pO1xuICovXG5TaGVsZlBhY2sucHJvdG90eXBlLnBhY2sgPSBmdW5jdGlvbihiaW5zLCBvcHRpb25zKSB7XG4gICAgYmlucyA9IFtdLmNvbmNhdChiaW5zKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciByZXN1bHRzID0gW10sXG4gICAgICAgIHcsIGgsIGFsbG9jYXRpb247XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdyA9IGJpbnNbaV0udyB8fCBiaW5zW2ldLndpZHRoO1xuICAgICAgICBoID0gYmluc1tpXS5oIHx8IGJpbnNbaV0uaGVpZ2h0O1xuICAgICAgICBpZiAodyAmJiBoKSB7XG4gICAgICAgICAgICBhbGxvY2F0aW9uID0gdGhpcy5wYWNrT25lKHcsIGgpO1xuICAgICAgICAgICAgaWYgKCFhbGxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pblBsYWNlKSB7XG4gICAgICAgICAgICAgICAgYmluc1tpXS54ID0gYWxsb2NhdGlvbi54O1xuICAgICAgICAgICAgICAgIGJpbnNbaV0ueSA9IGFsbG9jYXRpb24ueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChhbGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBQYWNrIGEgc2luZ2xlIGJpbiBpbnRvIHRoZSBzcHJpdGUuXG4gKlxuICogQHBhcmFtICAge251bWJlcn0gIHcgICBXaWR0aCBvZiB0aGUgYmluIHRvIGFsbG9jYXRlXG4gKiBAcGFyYW0gICB7bnVtYmVyfSAgaCAgIEhlaWdodCBvZiB0aGUgYmluIHRvIGFsbG9jYXRlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAgQWxsb2NhdGVkIGJpbiBvYmplY3Qgd2l0aCBgeGAsIGB5YCwgYHdgLCBgaGAgcHJvcGVydGllcywgb3IgYG51bGxgIGlmIGFsbG9jYXRpb24gZmFpbGVkXG4gKiBAZXhhbXBsZVxuICogdmFyIHJlc3VsdHMgPSBzcHJpdGUucGFja09uZSgxMiwgMTYpO1xuICovXG5TaGVsZlBhY2sucHJvdG90eXBlLnBhY2tPbmUgPSBmdW5jdGlvbih3LCBoKSB7XG4gICAgdmFyIHkgPSAwLFxuICAgICAgICBiZXN0ID0geyBzaGVsZjogLTEsIHdhc3RlOiBJbmZpbml0eSB9LFxuICAgICAgICBzaGVsZiwgd2FzdGU7XG5cbiAgICAvLyBmaW5kIHRoZSBiZXN0IHNoZWxmXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNoZWx2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2hlbGYgPSB0aGlzLnNoZWx2ZXNbaV07XG4gICAgICAgIHkgKz0gc2hlbGYuaDtcblxuICAgICAgICAvLyBleGFjdGx5IHRoZSByaWdodCBoZWlnaHQgd2l0aCB3aWR0aCB0byBzcGFyZSwgcGFjayBpdC4uXG4gICAgICAgIGlmIChoID09PSBzaGVsZi5oICYmIHcgPD0gc2hlbGYuZnJlZSkge1xuICAgICAgICAgICAgdGhpcy5jb3VudChoKTtcbiAgICAgICAgICAgIHJldHVybiBzaGVsZi5hbGxvYyh3LCBoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3QgZW5vdWdoIGhlaWdodCBvciB3aWR0aCwgc2tpcCBpdC4uXG4gICAgICAgIGlmIChoID4gc2hlbGYuaCB8fCB3ID4gc2hlbGYuZnJlZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWF5YmUgZW5vdWdoIGhlaWdodCBvciB3aWR0aCwgbWluaW1pemUgd2FzdGUuLlxuICAgICAgICBpZiAoaCA8IHNoZWxmLmggJiYgdyA8PSBzaGVsZi5mcmVlKSB7XG4gICAgICAgICAgICB3YXN0ZSA9IHNoZWxmLmggLSBoO1xuICAgICAgICAgICAgaWYgKHdhc3RlIDwgYmVzdC53YXN0ZSkge1xuICAgICAgICAgICAgICAgIGJlc3Qud2FzdGUgPSB3YXN0ZTtcbiAgICAgICAgICAgICAgICBiZXN0LnNoZWxmID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChiZXN0LnNoZWxmICE9PSAtMSkge1xuICAgICAgICBzaGVsZiA9IHRoaXMuc2hlbHZlc1tiZXN0LnNoZWxmXTtcbiAgICAgICAgdGhpcy5jb3VudChoKTtcbiAgICAgICAgcmV0dXJuIHNoZWxmLmFsbG9jKHcsIGgpO1xuICAgIH1cblxuICAgIC8vIGFkZCBzaGVsZi4uXG4gICAgaWYgKGggPD0gKHRoaXMuaCAtIHkpICYmIHcgPD0gdGhpcy53KSB7XG4gICAgICAgIHNoZWxmID0gbmV3IFNoZWxmKHksIHRoaXMudywgaCk7XG4gICAgICAgIHRoaXMuc2hlbHZlcy5wdXNoKHNoZWxmKTtcbiAgICAgICAgdGhpcy5jb3VudChoKTtcbiAgICAgICAgcmV0dXJuIHNoZWxmLmFsbG9jKHcsIGgpO1xuICAgIH1cblxuICAgIC8vIG5vIG1vcmUgc3BhY2UuLlxuICAgIC8vIElmIGBhdXRvUmVzaXplYCBvcHRpb24gaXMgc2V0LCBncm93IHRoZSBzcHJpdGUgYXMgZm9sbG93czpcbiAgICAvLyAgKiBkb3VibGUgd2hpY2hldmVyIHNwcml0ZSBkaW1lbnNpb24gaXMgc21hbGxlciAoYHcxYCBvciBgaDFgKVxuICAgIC8vICAqIGlmIHNwcml0ZSBkaW1lbnNpb25zIGFyZSBlcXVhbCwgZ3JvdyB3aWR0aCBiZWZvcmUgaGVpZ2h0XG4gICAgLy8gICogYWNjb21vZGF0ZSB2ZXJ5IGxhcmdlIGJpbiByZXF1ZXN0cyAoYmlnIGB3YCBvciBgaGApXG4gICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZSkge1xuICAgICAgICB2YXIgaDEsIGgyLCB3MSwgdzI7XG5cbiAgICAgICAgaDEgPSBoMiA9IHRoaXMuaDtcbiAgICAgICAgdzEgPSB3MiA9IHRoaXMudztcblxuICAgICAgICBpZiAodzEgPD0gaDEgfHwgdyA+IHcxKSB7ICAgLy8gZ3JvdyB3aWR0aC4uXG4gICAgICAgICAgICB3MiA9IE1hdGgubWF4KHcsIHcxKSAqIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGgxIDwgdzEgfHwgaCA+IGgxKSB7ICAgIC8vIGdyb3cgaGVpZ2h0Li5cbiAgICAgICAgICAgIGgyID0gTWF0aC5tYXgoaCwgaDEpICogMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVzaXplKHcyLCBoMik7XG4gICAgICAgIHJldHVybiB0aGlzLnBhY2tPbmUodywgaCk7ICAvLyByZXRyeVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhciB0aGUgc3ByaXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBzcHJpdGUuY2xlYXIoKTtcbiAqL1xuU2hlbGZQYWNrLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2hlbHZlcyA9IFtdO1xuICAgIHRoaXMuc3RhdHMgPSB7fTtcbn07XG5cbi8qKlxuICogUmVzaXplIHRoZSBzcHJpdGUuXG4gKiBUaGUgcmVzaXplIHdpbGwgZmFpbCBpZiB0aGUgcmVxdWVzdGVkIGRpbWVuc2lvbnMgYXJlIHNtYWxsZXIgdGhhbiB0aGUgY3VycmVudCBzcHJpdGUgZGltZW5zaW9ucy5cbiAqXG4gKiBAcGFyYW0gICB7bnVtYmVyfSAgdyAgUmVxdWVzdGVkIG5ldyBzcHJpdGUgd2lkdGhcbiAqIEBwYXJhbSAgIHtudW1iZXJ9ICBoICBSZXF1ZXN0ZWQgbmV3IHNwcml0ZSBoZWlnaHRcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzaXplIHN1Y2NlZWRlZCwgYGZhbHNlYCBpZiBmYWlsZWRcbiAqIEBleGFtcGxlXG4gKiBzcHJpdGUucmVzaXplKDI1NiwgMjU2KTtcbiAqL1xuU2hlbGZQYWNrLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3LCBoKSB7XG4gICAgaWYgKHcgPCB0aGlzLncgfHwgaCA8IHRoaXMuaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy53ID0gdztcbiAgICB0aGlzLmggPSBoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zaGVsdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuc2hlbHZlc1tpXS5yZXNpemUodyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFNoZWxmLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2xhc3MgIFNoZWxmXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5ICAgVG9wIGNvb3JkaW5hdGUgb2YgdGhlIG5ldyBzaGVsZlxuICogQHBhcmFtICB7bnVtYmVyfSAgdyAgIFdpZHRoIG9mIHRoZSBuZXcgc2hlbGZcbiAqIEBwYXJhbSAge251bWJlcn0gIGggICBIZWlnaHQgb2YgdGhlIG5ldyBzaGVsZlxuICogQGV4YW1wbGVcbiAqIHZhciBzaGVsZiA9IG5ldyBTaGVsZig2NCwgNTEyLCAyNCk7XG4gKi9cbmZ1bmN0aW9uIFNoZWxmKHksIHcsIGgpIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy53ID0gdGhpcy5mcmVlID0gdztcbiAgICB0aGlzLmggPSBoO1xufVxuXG4vKipcbiAqIEFsbG9jYXRlIGEgc2luZ2xlIGJpbiBpbnRvIHRoZSBzaGVsZi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge251bWJlcn0gIHcgICBXaWR0aCBvZiB0aGUgYmluIHRvIGFsbG9jYXRlXG4gKiBAcGFyYW0gICB7bnVtYmVyfSAgaCAgIEhlaWdodCBvZiB0aGUgYmluIHRvIGFsbG9jYXRlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAgQWxsb2NhdGVkIGJpbiBvYmplY3Qgd2l0aCBgeGAsIGB5YCwgYHdgLCBgaGAgcHJvcGVydGllcywgb3IgYG51bGxgIGlmIGFsbG9jYXRpb24gZmFpbGVkXG4gKiBAZXhhbXBsZVxuICogc2hlbGYuYWxsb2MoMTIsIDE2KTtcbiAqL1xuU2hlbGYucHJvdG90eXBlLmFsbG9jID0gZnVuY3Rpb24odywgaCkge1xuICAgIGlmICh3ID4gdGhpcy5mcmVlIHx8IGggPiB0aGlzLmgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHRoaXMueCArPSB3O1xuICAgIHRoaXMuZnJlZSAtPSB3O1xuICAgIHJldHVybiB7IHg6IHgsIHk6IHRoaXMueSwgdzogdywgaDogaCwgd2lkdGg6IHcsIGhlaWdodDogaCB9O1xufTtcblxuLyoqXG4gKiBSZXNpemUgdGhlIHNoZWxmLlxuICogVGhlIHJlc2l6ZSB3aWxsIGZhaWwgaWYgdGhlIHJlcXVlc3RlZCB3aWR0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGN1cnJlbnQgc2hlbGYgd2lkdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAgIHtudW1iZXJ9ICB3ICBSZXF1ZXN0ZWQgbmV3IHdpZHRoIG9mIHRoZSBzaGVsZlxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgcmVzaXplIHN1Y2NlZWRlZCwgZmFsc2UgaWYgZmFpbGVkXG4gKiBAZXhhbXBsZVxuICogc2hlbGYucmVzaXplKDUxMik7XG4gKi9cblNoZWxmLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3KSB7XG4gICAgaWYgKHcgPCB0aGlzLncpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmZyZWUgKz0gKHcgLSB0aGlzLncpO1xuICAgIHRoaXMudyA9IHc7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIga2RidXNoID0gcmVxdWlyZSgna2RidXNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3VwZXJjbHVzdGVyO1xuXG5mdW5jdGlvbiBzdXBlcmNsdXN0ZXIob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3VwZXJDbHVzdGVyKG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBTdXBlckNsdXN0ZXIob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZChPYmplY3QuY3JlYXRlKHRoaXMub3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIHRoaXMudHJlZXMgPSBuZXcgQXJyYXkodGhpcy5vcHRpb25zLm1heFpvb20gKyAxKTtcbn1cblxuU3VwZXJDbHVzdGVyLnByb3RvdHlwZSA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIG1pblpvb206IDAsICAgLy8gbWluIHpvb20gdG8gZ2VuZXJhdGUgY2x1c3RlcnMgb25cbiAgICAgICAgbWF4Wm9vbTogMTYsICAvLyBtYXggem9vbSBsZXZlbCB0byBjbHVzdGVyIHRoZSBwb2ludHMgb25cbiAgICAgICAgcmFkaXVzOiA0MCwgICAvLyBjbHVzdGVyIHJhZGl1cyBpbiBwaXhlbHNcbiAgICAgICAgZXh0ZW50OiA1MTIsICAvLyB0aWxlIGV4dGVudCAocmFkaXVzIGlzIGNhbGN1bGF0ZWQgcmVsYXRpdmUgdG8gaXQpXG4gICAgICAgIG5vZGVTaXplOiA2NCwgLy8gc2l6ZSBvZiB0aGUgS0QtdHJlZSBsZWFmIG5vZGUsIGFmZmVjdHMgcGVyZm9ybWFuY2VcbiAgICAgICAgbG9nOiBmYWxzZSAgICAvLyB3aGV0aGVyIHRvIGxvZyB0aW1pbmcgaW5mb1xuICAgIH0sXG5cbiAgICBsb2FkOiBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgICAgIHZhciBsb2cgPSB0aGlzLm9wdGlvbnMubG9nO1xuXG4gICAgICAgIGlmIChsb2cpIGNvbnNvbGUudGltZSgndG90YWwgdGltZScpO1xuXG4gICAgICAgIHZhciB0aW1lcklkID0gJ3ByZXBhcmUgJyArIHBvaW50cy5sZW5ndGggKyAnIHBvaW50cyc7XG4gICAgICAgIGlmIChsb2cpIGNvbnNvbGUudGltZSh0aW1lcklkKTtcblxuICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcblxuICAgICAgICAvLyBnZW5lcmF0ZSBhIGNsdXN0ZXIgb2JqZWN0IGZvciBlYWNoIHBvaW50XG4gICAgICAgIHZhciBjbHVzdGVycyA9IHBvaW50cy5tYXAoY3JlYXRlUG9pbnRDbHVzdGVyKTtcbiAgICAgICAgaWYgKGxvZykgY29uc29sZS50aW1lRW5kKHRpbWVySWQpO1xuXG4gICAgICAgIC8vIGNsdXN0ZXIgcG9pbnRzIG9uIG1heCB6b29tLCB0aGVuIGNsdXN0ZXIgdGhlIHJlc3VsdHMgb24gcHJldmlvdXMgem9vbSwgZXRjLjtcbiAgICAgICAgLy8gcmVzdWx0cyBpbiBhIGNsdXN0ZXIgaGllcmFyY2h5IGFjcm9zcyB6b29tIGxldmVsc1xuICAgICAgICBmb3IgKHZhciB6ID0gdGhpcy5vcHRpb25zLm1heFpvb207IHogPj0gdGhpcy5vcHRpb25zLm1pblpvb207IHotLSkge1xuICAgICAgICAgICAgdmFyIG5vdyA9ICtEYXRlLm5vdygpO1xuXG4gICAgICAgICAgICAvLyBpbmRleCBpbnB1dCBwb2ludHMgaW50byBhIEtELXRyZWVcbiAgICAgICAgICAgIHRoaXMudHJlZXNbeiArIDFdID0ga2RidXNoKGNsdXN0ZXJzLCBnZXRYLCBnZXRZLCB0aGlzLm9wdGlvbnMubm9kZVNpemUsIEZsb2F0MzJBcnJheSk7XG5cbiAgICAgICAgICAgIGNsdXN0ZXJzID0gdGhpcy5fY2x1c3RlcihjbHVzdGVycywgeik7IC8vIGNyZWF0ZSBhIG5ldyBzZXQgb2YgY2x1c3RlcnMgZm9yIHRoZSB6b29tXG5cbiAgICAgICAgICAgIGlmIChsb2cpIGNvbnNvbGUubG9nKCd6JWQ6ICVkIGNsdXN0ZXJzIGluICVkbXMnLCB6LCBjbHVzdGVycy5sZW5ndGgsICtEYXRlLm5vdygpIC0gbm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluZGV4IHRvcC1sZXZlbCBjbHVzdGVyc1xuICAgICAgICB0aGlzLnRyZWVzW3RoaXMub3B0aW9ucy5taW5ab29tXSA9IGtkYnVzaChjbHVzdGVycywgZ2V0WCwgZ2V0WSwgdGhpcy5vcHRpb25zLm5vZGVTaXplLCBGbG9hdDMyQXJyYXkpO1xuXG4gICAgICAgIGlmIChsb2cpIGNvbnNvbGUudGltZUVuZCgndG90YWwgdGltZScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRDbHVzdGVyczogZnVuY3Rpb24gKGJib3gsIHpvb20pIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWVzW3RoaXMuX2xpbWl0Wm9vbSh6b29tKV07XG4gICAgICAgIHZhciBpZHMgPSB0cmVlLnJhbmdlKGxuZ1goYmJveFswXSksIGxhdFkoYmJveFszXSksIGxuZ1goYmJveFsyXSksIGxhdFkoYmJveFsxXSkpO1xuICAgICAgICB2YXIgY2x1c3RlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gdHJlZS5wb2ludHNbaWRzW2ldXTtcbiAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goYy5pZCAhPT0gLTEgPyB0aGlzLnBvaW50c1tjLmlkXSA6IGdldENsdXN0ZXJKU09OKGMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2x1c3RlcnM7XG4gICAgfSxcblxuICAgIGdldFRpbGU6IGZ1bmN0aW9uICh6LCB4LCB5KSB7XG4gICAgICAgIHZhciB6MiA9IE1hdGgucG93KDIsIHopO1xuICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5vcHRpb25zLmV4dGVudDtcbiAgICAgICAgdmFyIHAgPSB0aGlzLm9wdGlvbnMucmFkaXVzIC8gZXh0ZW50O1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZXNbdGhpcy5fbGltaXRab29tKHopXTtcbiAgICAgICAgdmFyIGlkcyA9IHRyZWUucmFuZ2UoXG4gICAgICAgICAgICAoeCAtIHApIC8gejIsXG4gICAgICAgICAgICAoeSAtIHApIC8gejIsXG4gICAgICAgICAgICAoeCArIDEgKyBwKSAvIHoyLFxuICAgICAgICAgICAgKHkgKyAxICsgcCkgLyB6Mik7XG5cbiAgICAgICAgaWYgKCFpZHMubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgdGlsZSA9IHtcbiAgICAgICAgICAgIGZlYXR1cmVzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSB0cmVlLnBvaW50c1tpZHNbaV1dO1xuICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogMSxcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogW1tcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZChleHRlbnQgKiAoYy54ICogejIgLSB4KSksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQoZXh0ZW50ICogKGMueSAqIHoyIC0geSkpXG4gICAgICAgICAgICAgICAgXV0sXG4gICAgICAgICAgICAgICAgdGFnczogYy5pZCAhPT0gLTEgPyB0aGlzLnBvaW50c1tjLmlkXS5wcm9wZXJ0aWVzIDogZ2V0Q2x1c3RlclByb3BlcnRpZXMoYylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aWxlLmZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgfSxcblxuICAgIF9saW1pdFpvb206IGZ1bmN0aW9uICh6KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLm9wdGlvbnMubWluWm9vbSwgTWF0aC5taW4oeiwgdGhpcy5vcHRpb25zLm1heFpvb20gKyAxKSk7XG4gICAgfSxcblxuICAgIF9jbHVzdGVyOiBmdW5jdGlvbiAocG9pbnRzLCB6b29tKSB7XG4gICAgICAgIHZhciBjbHVzdGVycyA9IFtdO1xuICAgICAgICB2YXIgciA9IHRoaXMub3B0aW9ucy5yYWRpdXMgLyAodGhpcy5vcHRpb25zLmV4dGVudCAqIE1hdGgucG93KDIsIHpvb20pKTtcblxuICAgICAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBwb2ludFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHAgPSBwb2ludHNbaV07XG4gICAgICAgICAgICAvLyBpZiB3ZSd2ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlIHBvaW50IGF0IHRoaXMgem9vbSBsZXZlbCwgc2tpcCBpdFxuICAgICAgICAgICAgaWYgKHAuem9vbSA8PSB6b29tKSBjb250aW51ZTtcbiAgICAgICAgICAgIHAuem9vbSA9IHpvb207XG5cbiAgICAgICAgICAgIC8vIGZpbmQgYWxsIG5lYXJieSBwb2ludHNcbiAgICAgICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlc1t6b29tICsgMV07XG4gICAgICAgICAgICB2YXIgbmVpZ2hib3JJZHMgPSB0cmVlLndpdGhpbihwLngsIHAueSwgcik7XG5cbiAgICAgICAgICAgIHZhciBmb3VuZE5laWdoYm9ycyA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIG51bVBvaW50cyA9IHAubnVtUG9pbnRzO1xuICAgICAgICAgICAgdmFyIHd4ID0gcC54ICogbnVtUG9pbnRzO1xuICAgICAgICAgICAgdmFyIHd5ID0gcC55ICogbnVtUG9pbnRzO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5laWdoYm9ySWRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGIgPSB0cmVlLnBvaW50c1tuZWlnaGJvcklkc1tqXV07XG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBuZWlnaGJvcnMgdGhhdCBhcmUgdG9vIGZhciBvciBhbHJlYWR5IHByb2Nlc3NlZFxuICAgICAgICAgICAgICAgIGlmICh6b29tIDwgYi56b29tKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kTmVpZ2hib3JzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYi56b29tID0gem9vbTsgLy8gc2F2ZSB0aGUgem9vbSAoc28gaXQgZG9lc24ndCBnZXQgcHJvY2Vzc2VkIHR3aWNlKVxuICAgICAgICAgICAgICAgICAgICB3eCArPSBiLnggKiBiLm51bVBvaW50czsgLy8gYWNjdW11bGF0ZSBjb29yZGluYXRlcyBmb3IgY2FsY3VsYXRpbmcgd2VpZ2h0ZWQgY2VudGVyXG4gICAgICAgICAgICAgICAgICAgIHd5ICs9IGIueSAqIGIubnVtUG9pbnRzO1xuICAgICAgICAgICAgICAgICAgICBudW1Qb2ludHMgKz0gYi5udW1Qb2ludHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbHVzdGVycy5wdXNoKGZvdW5kTmVpZ2hib3JzID8gY3JlYXRlQ2x1c3Rlcih3eCAvIG51bVBvaW50cywgd3kgLyBudW1Qb2ludHMsIG51bVBvaW50cywgLTEpIDogcCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2x1c3RlcnM7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlQ2x1c3Rlcih4LCB5LCBudW1Qb2ludHMsIGlkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCwgLy8gd2VpZ2h0ZWQgY2x1c3RlciBjZW50ZXJcbiAgICAgICAgeTogeSxcbiAgICAgICAgem9vbTogSW5maW5pdHksIC8vIHRoZSBsYXN0IHpvb20gdGhlIGNsdXN0ZXIgd2FzIHByb2Nlc3NlZCBhdFxuICAgICAgICBpZDogaWQsIC8vIGluZGV4IG9mIHRoZSBzb3VyY2UgZmVhdHVyZSBpbiB0aGUgb3JpZ2luYWwgaW5wdXQgYXJyYXlcbiAgICAgICAgbnVtUG9pbnRzOiBudW1Qb2ludHNcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQb2ludENsdXN0ZXIocCwgaSkge1xuICAgIHZhciBjb29yZHMgPSBwLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgIHJldHVybiBjcmVhdGVDbHVzdGVyKGxuZ1goY29vcmRzWzBdKSwgbGF0WShjb29yZHNbMV0pLCAxLCBpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2x1c3RlckpTT04oY2x1c3Rlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgcHJvcGVydGllczogZ2V0Q2x1c3RlclByb3BlcnRpZXMoY2x1c3RlciksXG4gICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgICB0eXBlOiAnUG9pbnQnLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFt4TG5nKGNsdXN0ZXIueCksIHlMYXQoY2x1c3Rlci55KV1cbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldENsdXN0ZXJQcm9wZXJ0aWVzKGNsdXN0ZXIpIHtcbiAgICB2YXIgY291bnQgPSBjbHVzdGVyLm51bVBvaW50cztcbiAgICB2YXIgYWJicmV2ID0gY291bnQgPj0gMTAwMDAgPyBNYXRoLnJvdW5kKGNvdW50IC8gMTAwMCkgKyAnaycgOlxuICAgICAgICAgICAgICAgICBjb3VudCA+PSAxMDAwID8gKE1hdGgucm91bmQoY291bnQgLyAxMDApIC8gMTApICsgJ2snIDogY291bnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2x1c3RlcjogdHJ1ZSxcbiAgICAgICAgcG9pbnRfY291bnQ6IGNvdW50LFxuICAgICAgICBwb2ludF9jb3VudF9hYmJyZXZpYXRlZDogYWJicmV2XG4gICAgfTtcbn1cblxuLy8gbG9uZ2l0dWRlL2xhdGl0dWRlIHRvIHNwaGVyaWNhbCBtZXJjYXRvciBpbiBbMC4uMV0gcmFuZ2VcbmZ1bmN0aW9uIGxuZ1gobG5nKSB7XG4gICAgcmV0dXJuIGxuZyAvIDM2MCArIDAuNTtcbn1cbmZ1bmN0aW9uIGxhdFkobGF0KSB7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luKGxhdCAqIE1hdGguUEkgLyAxODApLFxuICAgICAgICB5ID0gKDAuNSAtIDAuMjUgKiBNYXRoLmxvZygoMSArIHNpbikgLyAoMSAtIHNpbikpIC8gTWF0aC5QSSk7XG4gICAgcmV0dXJuIHkgPCAwID8gMCA6XG4gICAgICAgICAgIHkgPiAxID8gMSA6IHk7XG59XG5cbi8vIHNwaGVyaWNhbCBtZXJjYXRvciB0byBsb25naXR1ZGUvbGF0aXR1ZGVcbmZ1bmN0aW9uIHhMbmcoeCkge1xuICAgIHJldHVybiAoeCAtIDAuNSkgKiAzNjA7XG59XG5mdW5jdGlvbiB5TGF0KHkpIHtcbiAgICB2YXIgeTIgPSAoMTgwIC0geSAqIDM2MCkgKiBNYXRoLlBJIC8gMTgwO1xuICAgIHJldHVybiAzNjAgKiBNYXRoLmF0YW4oTWF0aC5leHAoeTIpKSAvIE1hdGguUEkgLSA5MDtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYykge1xuICAgIGZvciAodmFyIGlkIGluIHNyYykgZGVzdFtpZF0gPSBzcmNbaWRdO1xuICAgIHJldHVybiBkZXN0O1xufVxuXG5mdW5jdGlvbiBnZXRYKHApIHtcbiAgICByZXR1cm4gcC54O1xufVxuZnVuY3Rpb24gZ2V0WShwKSB7XG4gICAgcmV0dXJuIHAueTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNvcnQgPSByZXF1aXJlKCcuL3NvcnQnKTtcbnZhciByYW5nZSA9IHJlcXVpcmUoJy4vcmFuZ2UnKTtcbnZhciB3aXRoaW4gPSByZXF1aXJlKCcuL3dpdGhpbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtkYnVzaDtcblxuZnVuY3Rpb24ga2RidXNoKHBvaW50cywgZ2V0WCwgZ2V0WSwgbm9kZVNpemUsIEFycmF5VHlwZSkge1xuICAgIHJldHVybiBuZXcgS0RCdXNoKHBvaW50cywgZ2V0WCwgZ2V0WSwgbm9kZVNpemUsIEFycmF5VHlwZSk7XG59XG5cbmZ1bmN0aW9uIEtEQnVzaChwb2ludHMsIGdldFgsIGdldFksIG5vZGVTaXplLCBBcnJheVR5cGUpIHtcbiAgICBnZXRYID0gZ2V0WCB8fCBkZWZhdWx0R2V0WDtcbiAgICBnZXRZID0gZ2V0WSB8fCBkZWZhdWx0R2V0WTtcbiAgICBBcnJheVR5cGUgPSBBcnJheVR5cGUgfHwgQXJyYXk7XG5cbiAgICB0aGlzLm5vZGVTaXplID0gbm9kZVNpemUgfHwgNjQ7XG4gICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG5cbiAgICB0aGlzLmlkcyA9IG5ldyBBcnJheVR5cGUocG9pbnRzLmxlbmd0aCk7XG4gICAgdGhpcy5jb29yZHMgPSBuZXcgQXJyYXlUeXBlKHBvaW50cy5sZW5ndGggKiAyKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuaWRzW2ldID0gaTtcbiAgICAgICAgdGhpcy5jb29yZHNbMiAqIGldID0gZ2V0WChwb2ludHNbaV0pO1xuICAgICAgICB0aGlzLmNvb3Jkc1syICogaSArIDFdID0gZ2V0WShwb2ludHNbaV0pO1xuICAgIH1cblxuICAgIHNvcnQodGhpcy5pZHMsIHRoaXMuY29vcmRzLCB0aGlzLm5vZGVTaXplLCAwLCB0aGlzLmlkcy5sZW5ndGggLSAxLCAwKTtcbn1cblxuS0RCdXNoLnByb3RvdHlwZSA9IHtcbiAgICByYW5nZTogZnVuY3Rpb24gKG1pblgsIG1pblksIG1heFgsIG1heFkpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlKHRoaXMuaWRzLCB0aGlzLmNvb3JkcywgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgdGhpcy5ub2RlU2l6ZSk7XG4gICAgfSxcblxuICAgIHdpdGhpbjogZnVuY3Rpb24gKHgsIHksIHIpIHtcbiAgICAgICAgcmV0dXJuIHdpdGhpbih0aGlzLmlkcywgdGhpcy5jb29yZHMsIHgsIHksIHIsIHRoaXMubm9kZVNpemUpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXRYKHApIHsgcmV0dXJuIHBbMF07IH1cbmZ1bmN0aW9uIGRlZmF1bHRHZXRZKHApIHsgcmV0dXJuIHBbMV07IH1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByYW5nZTtcblxuZnVuY3Rpb24gcmFuZ2UoaWRzLCBjb29yZHMsIG1pblgsIG1pblksIG1heFgsIG1heFksIG5vZGVTaXplKSB7XG4gICAgdmFyIHN0YWNrID0gWzAsIGlkcy5sZW5ndGggLSAxLCAwXTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHgsIHk7XG5cbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHZhciBheGlzID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciByaWdodCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgbGVmdCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbm9kZVNpemUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsZWZ0OyBpIDw9IHJpZ2h0OyBpKyspIHtcbiAgICAgICAgICAgICAgICB4ID0gY29vcmRzWzIgKiBpXTtcbiAgICAgICAgICAgICAgICB5ID0gY29vcmRzWzIgKiBpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKHggPj0gbWluWCAmJiB4IDw9IG1heFggJiYgeSA+PSBtaW5ZICYmIHkgPD0gbWF4WSkgcmVzdWx0LnB1c2goaWRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG0gPSBNYXRoLmZsb29yKChsZWZ0ICsgcmlnaHQpIC8gMik7XG5cbiAgICAgICAgeCA9IGNvb3Jkc1syICogbV07XG4gICAgICAgIHkgPSBjb29yZHNbMiAqIG0gKyAxXTtcblxuICAgICAgICBpZiAoeCA+PSBtaW5YICYmIHggPD0gbWF4WCAmJiB5ID49IG1pblkgJiYgeSA8PSBtYXhZKSByZXN1bHQucHVzaChpZHNbbV0pO1xuXG4gICAgICAgIHZhciBuZXh0QXhpcyA9IChheGlzICsgMSkgJSAyO1xuXG4gICAgICAgIGlmIChheGlzID09PSAwID8gbWluWCA8PSB4IDogbWluWSA8PSB5KSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGxlZnQpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChtIC0gMSk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKG5leHRBeGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXhpcyA9PT0gMCA/IG1heFggPj0geCA6IG1heFkgPj0geSkge1xuICAgICAgICAgICAgc3RhY2sucHVzaChtICsgMSk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHJpZ2h0KTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobmV4dEF4aXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0S0Q7XG5cbmZ1bmN0aW9uIHNvcnRLRChpZHMsIGNvb3Jkcywgbm9kZVNpemUsIGxlZnQsIHJpZ2h0LCBkZXB0aCkge1xuICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbm9kZVNpemUpIHJldHVybjtcblxuICAgIHZhciBtID0gTWF0aC5mbG9vcigobGVmdCArIHJpZ2h0KSAvIDIpO1xuXG4gICAgc2VsZWN0KGlkcywgY29vcmRzLCBtLCBsZWZ0LCByaWdodCwgZGVwdGggJSAyKTtcblxuICAgIHNvcnRLRChpZHMsIGNvb3Jkcywgbm9kZVNpemUsIGxlZnQsIG0gLSAxLCBkZXB0aCArIDEpO1xuICAgIHNvcnRLRChpZHMsIGNvb3Jkcywgbm9kZVNpemUsIG0gKyAxLCByaWdodCwgZGVwdGggKyAxKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0KGlkcywgY29vcmRzLCBrLCBsZWZ0LCByaWdodCwgaW5jKSB7XG5cbiAgICB3aGlsZSAocmlnaHQgPiBsZWZ0KSB7XG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPiA2MDApIHtcbiAgICAgICAgICAgIHZhciBuID0gcmlnaHQgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciBtID0gayAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgdmFyIHogPSBNYXRoLmxvZyhuKTtcbiAgICAgICAgICAgIHZhciBzID0gMC41ICogTWF0aC5leHAoMiAqIHogLyAzKTtcbiAgICAgICAgICAgIHZhciBzZCA9IDAuNSAqIE1hdGguc3FydCh6ICogcyAqIChuIC0gcykgLyBuKSAqIChtIC0gbiAvIDIgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgIHZhciBuZXdMZWZ0ID0gTWF0aC5tYXgobGVmdCwgTWF0aC5mbG9vcihrIC0gbSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIHZhciBuZXdSaWdodCA9IE1hdGgubWluKHJpZ2h0LCBNYXRoLmZsb29yKGsgKyAobiAtIG0pICogcyAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgc2VsZWN0KGlkcywgY29vcmRzLCBrLCBuZXdMZWZ0LCBuZXdSaWdodCwgaW5jKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ID0gY29vcmRzWzIgKiBrICsgaW5jXTtcbiAgICAgICAgdmFyIGkgPSBsZWZ0O1xuICAgICAgICB2YXIgaiA9IHJpZ2h0O1xuXG4gICAgICAgIHN3YXBJdGVtKGlkcywgY29vcmRzLCBsZWZ0LCBrKTtcbiAgICAgICAgaWYgKGNvb3Jkc1syICogcmlnaHQgKyBpbmNdID4gdCkgc3dhcEl0ZW0oaWRzLCBjb29yZHMsIGxlZnQsIHJpZ2h0KTtcblxuICAgICAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgICAgICAgIHN3YXBJdGVtKGlkcywgY29vcmRzLCBpLCBqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIHdoaWxlIChjb29yZHNbMiAqIGkgKyBpbmNdIDwgdCkgaSsrO1xuICAgICAgICAgICAgd2hpbGUgKGNvb3Jkc1syICogaiArIGluY10gPiB0KSBqLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29vcmRzWzIgKiBsZWZ0ICsgaW5jXSA9PT0gdCkgc3dhcEl0ZW0oaWRzLCBjb29yZHMsIGxlZnQsIGopO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIHN3YXBJdGVtKGlkcywgY29vcmRzLCBqLCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA8PSBrKSBsZWZ0ID0gaiArIDE7XG4gICAgICAgIGlmIChrIDw9IGopIHJpZ2h0ID0gaiAtIDE7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzd2FwSXRlbShpZHMsIGNvb3JkcywgaSwgaikge1xuICAgIHN3YXAoaWRzLCBpLCBqKTtcbiAgICBzd2FwKGNvb3JkcywgMiAqIGksIDIgKiBqKTtcbiAgICBzd2FwKGNvb3JkcywgMiAqIGkgKyAxLCAyICogaiArIDEpO1xufVxuXG5mdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xuICAgIHZhciB0bXAgPSBhcnJbaV07XG4gICAgYXJyW2ldID0gYXJyW2pdO1xuICAgIGFycltqXSA9IHRtcDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB3aXRoaW47XG5cbmZ1bmN0aW9uIHdpdGhpbihpZHMsIGNvb3JkcywgcXgsIHF5LCByLCBub2RlU2l6ZSkge1xuICAgIHZhciBzdGFjayA9IFswLCBpZHMubGVuZ3RoIC0gMSwgMF07XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciByMiA9IHIgKiByO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB2YXIgYXhpcyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIGxlZnQgPSBzdGFjay5wb3AoKTtcblxuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0IDw9IG5vZGVTaXplKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbGVmdDsgaSA8PSByaWdodDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNxRGlzdChjb29yZHNbMiAqIGldLCBjb29yZHNbMiAqIGkgKyAxXSwgcXgsIHF5KSA8PSByMikgcmVzdWx0LnB1c2goaWRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG0gPSBNYXRoLmZsb29yKChsZWZ0ICsgcmlnaHQpIC8gMik7XG5cbiAgICAgICAgdmFyIHggPSBjb29yZHNbMiAqIG1dO1xuICAgICAgICB2YXIgeSA9IGNvb3Jkc1syICogbSArIDFdO1xuXG4gICAgICAgIGlmIChzcURpc3QoeCwgeSwgcXgsIHF5KSA8PSByMikgcmVzdWx0LnB1c2goaWRzW21dKTtcblxuICAgICAgICB2YXIgbmV4dEF4aXMgPSAoYXhpcyArIDEpICUgMjtcblxuICAgICAgICBpZiAoYXhpcyA9PT0gMCA/IHF4IC0gciA8PSB4IDogcXkgLSByIDw9IHkpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobGVmdCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKG0gLSAxKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobmV4dEF4aXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzID09PSAwID8gcXggKyByID49IHggOiBxeSArIHIgPj0geSkge1xuICAgICAgICAgICAgc3RhY2sucHVzaChtICsgMSk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHJpZ2h0KTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobmV4dEF4aXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc3FEaXN0KGF4LCBheSwgYngsIGJ5KSB7XG4gICAgdmFyIGR4ID0gYXggLSBieDtcbiAgICB2YXIgZHkgPSBheSAtIGJ5O1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDggQXBwbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gKiBhcmUgbWV0OlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgQVBQTEUgSU5DLiBgYEFTIElTJycgQU5EIEFOWVxuICogRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICogUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIEFQUExFIElOQy4gT1JcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZXG4gKiBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiBQb3J0ZWQgZnJvbSBXZWJraXRcbiAqIGh0dHA6Ly9zdm4ud2Via2l0Lm9yZy9yZXBvc2l0b3J5L3dlYmtpdC90cnVuay9Tb3VyY2UvV2ViQ29yZS9wbGF0Zm9ybS9ncmFwaGljcy9Vbml0QmV6aWVyLmhcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVuaXRCZXppZXI7XG5cbmZ1bmN0aW9uIFVuaXRCZXppZXIocDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwb2x5bm9taWFsIGNvZWZmaWNpZW50cywgaW1wbGljaXQgZmlyc3QgYW5kIGxhc3QgY29udHJvbCBwb2ludHMgYXJlICgwLDApIGFuZCAoMSwxKS5cbiAgICB0aGlzLmN4ID0gMy4wICogcDF4O1xuICAgIHRoaXMuYnggPSAzLjAgKiAocDJ4IC0gcDF4KSAtIHRoaXMuY3g7XG4gICAgdGhpcy5heCA9IDEuMCAtIHRoaXMuY3ggLSB0aGlzLmJ4O1xuXG4gICAgdGhpcy5jeSA9IDMuMCAqIHAxeTtcbiAgICB0aGlzLmJ5ID0gMy4wICogKHAyeSAtIHAxeSkgLSB0aGlzLmN5O1xuICAgIHRoaXMuYXkgPSAxLjAgLSB0aGlzLmN5IC0gdGhpcy5ieTtcblxuICAgIHRoaXMucDF4ID0gcDF4O1xuICAgIHRoaXMucDF5ID0gcDJ5O1xuICAgIHRoaXMucDJ4ID0gcDJ4O1xuICAgIHRoaXMucDJ5ID0gcDJ5O1xufVxuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZVggPSBmdW5jdGlvbih0KSB7XG4gICAgLy8gYGF4IHReMyArIGJ4IHReMiArIGN4IHQnIGV4cGFuZGVkIHVzaW5nIEhvcm5lcidzIHJ1bGUuXG4gICAgcmV0dXJuICgodGhpcy5heCAqIHQgKyB0aGlzLmJ4KSAqIHQgKyB0aGlzLmN4KSAqIHQ7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZVkgPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuICgodGhpcy5heSAqIHQgKyB0aGlzLmJ5KSAqIHQgKyB0aGlzLmN5KSAqIHQ7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZURlcml2YXRpdmVYID0gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiAoMy4wICogdGhpcy5heCAqIHQgKyAyLjAgKiB0aGlzLmJ4KSAqIHQgKyB0aGlzLmN4O1xufTtcblxuVW5pdEJlemllci5wcm90b3R5cGUuc29sdmVDdXJ2ZVggPSBmdW5jdGlvbih4LCBlcHNpbG9uKSB7XG4gICAgaWYgKHR5cGVvZiBlcHNpbG9uID09PSAndW5kZWZpbmVkJykgZXBzaWxvbiA9IDFlLTY7XG5cbiAgICB2YXIgdDAsIHQxLCB0MiwgeDIsIGk7XG5cbiAgICAvLyBGaXJzdCB0cnkgYSBmZXcgaXRlcmF0aW9ucyBvZiBOZXd0b24ncyBtZXRob2QgLS0gbm9ybWFsbHkgdmVyeSBmYXN0LlxuICAgIGZvciAodDIgPSB4LCBpID0gMDsgaSA8IDg7IGkrKykge1xuXG4gICAgICAgIHgyID0gdGhpcy5zYW1wbGVDdXJ2ZVgodDIpIC0geDtcbiAgICAgICAgaWYgKE1hdGguYWJzKHgyKSA8IGVwc2lsb24pIHJldHVybiB0MjtcblxuICAgICAgICB2YXIgZDIgPSB0aGlzLnNhbXBsZUN1cnZlRGVyaXZhdGl2ZVgodDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoZDIpIDwgMWUtNikgYnJlYWs7XG5cbiAgICAgICAgdDIgPSB0MiAtIHgyIC8gZDI7XG4gICAgfVxuXG4gICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBiaXNlY3Rpb24gbWV0aG9kIGZvciByZWxpYWJpbGl0eS5cbiAgICB0MCA9IDAuMDtcbiAgICB0MSA9IDEuMDtcbiAgICB0MiA9IHg7XG5cbiAgICBpZiAodDIgPCB0MCkgcmV0dXJuIHQwO1xuICAgIGlmICh0MiA+IHQxKSByZXR1cm4gdDE7XG5cbiAgICB3aGlsZSAodDAgPCB0MSkge1xuXG4gICAgICAgIHgyID0gdGhpcy5zYW1wbGVDdXJ2ZVgodDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeDIgLSB4KSA8IGVwc2lsb24pIHJldHVybiB0MjtcblxuICAgICAgICBpZiAoeCA+IHgyKSB7XG4gICAgICAgICAgICB0MCA9IHQyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdDEgPSB0MjtcbiAgICAgICAgfVxuXG4gICAgICAgIHQyID0gKHQxIC0gdDApICogMC41ICsgdDA7XG4gICAgfVxuXG4gICAgLy8gRmFpbHVyZS5cbiAgICByZXR1cm4gdDI7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uKHgsIGVwc2lsb24pIHtcbiAgICByZXR1cm4gdGhpcy5zYW1wbGVDdXJ2ZVkodGhpcy5zb2x2ZUN1cnZlWCh4LCBlcHNpbG9uKSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMuVmVjdG9yVGlsZSA9IHJlcXVpcmUoJy4vbGliL3ZlY3RvcnRpbGUuanMnKTtcbm1vZHVsZS5leHBvcnRzLlZlY3RvclRpbGVGZWF0dXJlID0gcmVxdWlyZSgnLi9saWIvdmVjdG9ydGlsZWZlYXR1cmUuanMnKTtcbm1vZHVsZS5leHBvcnRzLlZlY3RvclRpbGVMYXllciA9IHJlcXVpcmUoJy4vbGliL3ZlY3RvcnRpbGVsYXllci5qcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmVjdG9yVGlsZUxheWVyID0gcmVxdWlyZSgnLi92ZWN0b3J0aWxlbGF5ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3JUaWxlO1xuXG5mdW5jdGlvbiBWZWN0b3JUaWxlKHBiZiwgZW5kKSB7XG4gICAgdGhpcy5sYXllcnMgPSBwYmYucmVhZEZpZWxkcyhyZWFkVGlsZSwge30sIGVuZCk7XG59XG5cbmZ1bmN0aW9uIHJlYWRUaWxlKHRhZywgbGF5ZXJzLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAzKSB7XG4gICAgICAgIHZhciBsYXllciA9IG5ldyBWZWN0b3JUaWxlTGF5ZXIocGJmLCBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcyk7XG4gICAgICAgIGlmIChsYXllci5sZW5ndGgpIGxheWVyc1tsYXllci5uYW1lXSA9IGxheWVyO1xuICAgIH1cbn1cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGVGZWF0dXJlO1xuXG5mdW5jdGlvbiBWZWN0b3JUaWxlRmVhdHVyZShwYmYsIGVuZCwgZXh0ZW50LCBrZXlzLCB2YWx1ZXMpIHtcbiAgICAvLyBQdWJsaWNcbiAgICB0aGlzLnByb3BlcnRpZXMgPSB7fTtcbiAgICB0aGlzLmV4dGVudCA9IGV4dGVudDtcbiAgICB0aGlzLnR5cGUgPSAwO1xuXG4gICAgLy8gUHJpdmF0ZVxuICAgIHRoaXMuX3BiZiA9IHBiZjtcbiAgICB0aGlzLl9nZW9tZXRyeSA9IC0xO1xuICAgIHRoaXMuX2tleXMgPSBrZXlzO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcblxuICAgIHBiZi5yZWFkRmllbGRzKHJlYWRGZWF0dXJlLCB0aGlzLCBlbmQpO1xufVxuXG5mdW5jdGlvbiByZWFkRmVhdHVyZSh0YWcsIGZlYXR1cmUsIHBiZikge1xuICAgIGlmICh0YWcgPT0gMSkgZmVhdHVyZS5faWQgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PSAyKSByZWFkVGFnKHBiZiwgZmVhdHVyZSk7XG4gICAgZWxzZSBpZiAodGFnID09IDMpIGZlYXR1cmUudHlwZSA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09IDQpIGZlYXR1cmUuX2dlb21ldHJ5ID0gcGJmLnBvcztcbn1cblxuZnVuY3Rpb24gcmVhZFRhZyhwYmYsIGZlYXR1cmUpIHtcbiAgICB2YXIgZW5kID0gcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3M7XG5cbiAgICB3aGlsZSAocGJmLnBvcyA8IGVuZCkge1xuICAgICAgICB2YXIga2V5ID0gZmVhdHVyZS5fa2V5c1twYmYucmVhZFZhcmludCgpXSxcbiAgICAgICAgICAgIHZhbHVlID0gZmVhdHVyZS5fdmFsdWVzW3BiZi5yZWFkVmFyaW50KCldO1xuICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbn1cblxuVmVjdG9yVGlsZUZlYXR1cmUudHlwZXMgPSBbJ1Vua25vd24nLCAnUG9pbnQnLCAnTGluZVN0cmluZycsICdQb2x5Z29uJ107XG5cblZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS5sb2FkR2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGJmID0gdGhpcy5fcGJmO1xuICAgIHBiZi5wb3MgPSB0aGlzLl9nZW9tZXRyeTtcblxuICAgIHZhciBlbmQgPSBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcyxcbiAgICAgICAgY21kID0gMSxcbiAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICBsaW5lcyA9IFtdLFxuICAgICAgICBsaW5lO1xuXG4gICAgd2hpbGUgKHBiZi5wb3MgPCBlbmQpIHtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjbWRMZW4gPSBwYmYucmVhZFZhcmludCgpO1xuICAgICAgICAgICAgY21kID0gY21kTGVuICYgMHg3O1xuICAgICAgICAgICAgbGVuZ3RoID0gY21kTGVuID4+IDM7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGgtLTtcblxuICAgICAgICBpZiAoY21kID09PSAxIHx8IGNtZCA9PT0gMikge1xuICAgICAgICAgICAgeCArPSBwYmYucmVhZFNWYXJpbnQoKTtcbiAgICAgICAgICAgIHkgKz0gcGJmLnJlYWRTVmFyaW50KCk7XG5cbiAgICAgICAgICAgIGlmIChjbWQgPT09IDEpIHsgLy8gbW92ZVRvXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUpIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgbGluZSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaW5lLnB1c2gobmV3IFBvaW50KHgsIHkpKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNtZCA9PT0gNykge1xuXG4gICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcG5pay12ZWN0b3ItdGlsZS9pc3N1ZXMvOTBcbiAgICAgICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgbGluZS5wdXNoKGxpbmVbMF0uY2xvbmUoKSk7IC8vIGNsb3NlUG9seWdvblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY29tbWFuZCAnICsgY21kKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsaW5lKSBsaW5lcy5wdXNoKGxpbmUpO1xuXG4gICAgcmV0dXJuIGxpbmVzO1xufTtcblxuVmVjdG9yVGlsZUZlYXR1cmUucHJvdG90eXBlLmJib3ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGJmID0gdGhpcy5fcGJmO1xuICAgIHBiZi5wb3MgPSB0aGlzLl9nZW9tZXRyeTtcblxuICAgIHZhciBlbmQgPSBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcyxcbiAgICAgICAgY21kID0gMSxcbiAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICB4MSA9IEluZmluaXR5LFxuICAgICAgICB4MiA9IC1JbmZpbml0eSxcbiAgICAgICAgeTEgPSBJbmZpbml0eSxcbiAgICAgICAgeTIgPSAtSW5maW5pdHk7XG5cbiAgICB3aGlsZSAocGJmLnBvcyA8IGVuZCkge1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNtZExlbiA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgICAgICAgICBjbWQgPSBjbWRMZW4gJiAweDc7XG4gICAgICAgICAgICBsZW5ndGggPSBjbWRMZW4gPj4gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aC0tO1xuXG4gICAgICAgIGlmIChjbWQgPT09IDEgfHwgY21kID09PSAyKSB7XG4gICAgICAgICAgICB4ICs9IHBiZi5yZWFkU1ZhcmludCgpO1xuICAgICAgICAgICAgeSArPSBwYmYucmVhZFNWYXJpbnQoKTtcbiAgICAgICAgICAgIGlmICh4IDwgeDEpIHgxID0geDtcbiAgICAgICAgICAgIGlmICh4ID4geDIpIHgyID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgeTEpIHkxID0geTtcbiAgICAgICAgICAgIGlmICh5ID4geTIpIHkyID0geTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNtZCAhPT0gNykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGNvbW1hbmQgJyArIGNtZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3gxLCB5MSwgeDIsIHkyXTtcbn07XG5cblZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS50b0dlb0pTT04gPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLmV4dGVudCAqIE1hdGgucG93KDIsIHopLFxuICAgICAgICB4MCA9IHRoaXMuZXh0ZW50ICogeCxcbiAgICAgICAgeTAgPSB0aGlzLmV4dGVudCAqIHksXG4gICAgICAgIGNvb3JkcyA9IHRoaXMubG9hZEdlb21ldHJ5KCksXG4gICAgICAgIHR5cGUgPSBWZWN0b3JUaWxlRmVhdHVyZS50eXBlc1t0aGlzLnR5cGVdLFxuICAgICAgICBpLCBqO1xuXG4gICAgZnVuY3Rpb24gcHJvamVjdChsaW5lKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHAgPSBsaW5lW2pdLCB5MiA9IDE4MCAtIChwLnkgKyB5MCkgKiAzNjAgLyBzaXplO1xuICAgICAgICAgICAgbGluZVtqXSA9IFtcbiAgICAgICAgICAgICAgICAocC54ICsgeDApICogMzYwIC8gc2l6ZSAtIDE4MCxcbiAgICAgICAgICAgICAgICAzNjAgLyBNYXRoLlBJICogTWF0aC5hdGFuKE1hdGguZXhwKHkyICogTWF0aC5QSSAvIDE4MCkpIC0gOTBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgMTpcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludHNbaV0gPSBjb29yZHNbaV1bMF07XG4gICAgICAgIH1cbiAgICAgICAgY29vcmRzID0gcG9pbnRzO1xuICAgICAgICBwcm9qZWN0KGNvb3Jkcyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAyOlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwcm9qZWN0KGNvb3Jkc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDM6XG4gICAgICAgIGNvb3JkcyA9IGNsYXNzaWZ5UmluZ3MoY29vcmRzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHByb2plY3QoY29vcmRzW2ldW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoY29vcmRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb29yZHMgPSBjb29yZHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9ICdNdWx0aScgKyB0eXBlO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZHNcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcGVydGllczogdGhpcy5wcm9wZXJ0aWVzXG4gICAgfTtcblxuICAgIGlmICgnX2lkJyBpbiB0aGlzKSB7XG4gICAgICAgIHJlc3VsdC5pZCA9IHRoaXMuX2lkO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBjbGFzc2lmaWVzIGFuIGFycmF5IG9mIHJpbmdzIGludG8gcG9seWdvbnMgd2l0aCBvdXRlciByaW5ncyBhbmQgaG9sZXNcblxuZnVuY3Rpb24gY2xhc3NpZnlSaW5ncyhyaW5ncykge1xuICAgIHZhciBsZW4gPSByaW5ncy5sZW5ndGg7XG5cbiAgICBpZiAobGVuIDw9IDEpIHJldHVybiBbcmluZ3NdO1xuXG4gICAgdmFyIHBvbHlnb25zID0gW10sXG4gICAgICAgIHBvbHlnb24sXG4gICAgICAgIGNjdztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGFyZWEgPSBzaWduZWRBcmVhKHJpbmdzW2ldKTtcbiAgICAgICAgaWYgKGFyZWEgPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmIChjY3cgPT09IHVuZGVmaW5lZCkgY2N3ID0gYXJlYSA8IDA7XG5cbiAgICAgICAgaWYgKGNjdyA9PT0gYXJlYSA8IDApIHtcbiAgICAgICAgICAgIGlmIChwb2x5Z29uKSBwb2x5Z29ucy5wdXNoKHBvbHlnb24pO1xuICAgICAgICAgICAgcG9seWdvbiA9IFtyaW5nc1tpXV07XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvbHlnb24ucHVzaChyaW5nc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvbHlnb24pIHBvbHlnb25zLnB1c2gocG9seWdvbik7XG5cbiAgICByZXR1cm4gcG9seWdvbnM7XG59XG5cbmZ1bmN0aW9uIHNpZ25lZEFyZWEocmluZykge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByaW5nLmxlbmd0aCwgaiA9IGxlbiAtIDEsIHAxLCBwMjsgaSA8IGxlbjsgaiA9IGkrKykge1xuICAgICAgICBwMSA9IHJpbmdbaV07XG4gICAgICAgIHAyID0gcmluZ1tqXTtcbiAgICAgICAgc3VtICs9IChwMi54IC0gcDEueCkgKiAocDEueSArIHAyLnkpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmVjdG9yVGlsZUZlYXR1cmUgPSByZXF1aXJlKCcuL3ZlY3RvcnRpbGVmZWF0dXJlLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmVjdG9yVGlsZUxheWVyO1xuXG5mdW5jdGlvbiBWZWN0b3JUaWxlTGF5ZXIocGJmLCBlbmQpIHtcbiAgICAvLyBQdWJsaWNcbiAgICB0aGlzLnZlcnNpb24gPSAxO1xuICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgdGhpcy5leHRlbnQgPSA0MDk2O1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIC8vIFByaXZhdGVcbiAgICB0aGlzLl9wYmYgPSBwYmY7XG4gICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgIHRoaXMuX2ZlYXR1cmVzID0gW107XG5cbiAgICBwYmYucmVhZEZpZWxkcyhyZWFkTGF5ZXIsIHRoaXMsIGVuZCk7XG5cbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMuX2ZlYXR1cmVzLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gcmVhZExheWVyKHRhZywgbGF5ZXIsIHBiZikge1xuICAgIGlmICh0YWcgPT09IDE1KSBsYXllci52ZXJzaW9uID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDEpIGxheWVyLm5hbWUgPSBwYmYucmVhZFN0cmluZygpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNSkgbGF5ZXIuZXh0ZW50ID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDIpIGxheWVyLl9mZWF0dXJlcy5wdXNoKHBiZi5wb3MpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMykgbGF5ZXIuX2tleXMucHVzaChwYmYucmVhZFN0cmluZygpKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDQpIGxheWVyLl92YWx1ZXMucHVzaChyZWFkVmFsdWVNZXNzYWdlKHBiZikpO1xufVxuXG5mdW5jdGlvbiByZWFkVmFsdWVNZXNzYWdlKHBiZikge1xuICAgIHZhciB2YWx1ZSA9IG51bGwsXG4gICAgICAgIGVuZCA9IHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zO1xuXG4gICAgd2hpbGUgKHBiZi5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIHRhZyA9IHBiZi5yZWFkVmFyaW50KCkgPj4gMztcblxuICAgICAgICB2YWx1ZSA9IHRhZyA9PT0gMSA/IHBiZi5yZWFkU3RyaW5nKCkgOlxuICAgICAgICAgICAgdGFnID09PSAyID8gcGJmLnJlYWRGbG9hdCgpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gMyA/IHBiZi5yZWFkRG91YmxlKCkgOlxuICAgICAgICAgICAgdGFnID09PSA0ID8gcGJmLnJlYWRWYXJpbnQ2NCgpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gNSA/IHBiZi5yZWFkVmFyaW50KCkgOlxuICAgICAgICAgICAgdGFnID09PSA2ID8gcGJmLnJlYWRTVmFyaW50KCkgOlxuICAgICAgICAgICAgdGFnID09PSA3ID8gcGJmLnJlYWRCb29sZWFuKCkgOiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gcmV0dXJuIGZlYXR1cmUgYGlgIGZyb20gdGhpcyBsYXllciBhcyBhIGBWZWN0b3JUaWxlRmVhdHVyZWBcblZlY3RvclRpbGVMYXllci5wcm90b3R5cGUuZmVhdHVyZSA9IGZ1bmN0aW9uKGkpIHtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLl9mZWF0dXJlcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignZmVhdHVyZSBpbmRleCBvdXQgb2YgYm91bmRzJyk7XG5cbiAgICB0aGlzLl9wYmYucG9zID0gdGhpcy5fZmVhdHVyZXNbaV07XG5cbiAgICB2YXIgZW5kID0gdGhpcy5fcGJmLnJlYWRWYXJpbnQoKSArIHRoaXMuX3BiZi5wb3M7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3JUaWxlRmVhdHVyZSh0aGlzLl9wYmYsIGVuZCwgdGhpcy5leHRlbnQsIHRoaXMuX2tleXMsIHRoaXMuX3ZhbHVlcyk7XG59O1xuIiwidmFyIFBiZiA9IHJlcXVpcmUoJ3BiZicpXG52YXIgdnRwYiA9IHJlcXVpcmUoJy4vdmVjdG9yLXRpbGUtcGInKVxudmFyIEdlb0pTT05XcmFwcGVyID0gcmVxdWlyZSgnLi9saWIvZ2VvanNvbl93cmFwcGVyJylcblxubW9kdWxlLmV4cG9ydHMgPSBmcm9tVmVjdG9yVGlsZUpzXG5tb2R1bGUuZXhwb3J0cy5mcm9tVmVjdG9yVGlsZUpzID0gZnJvbVZlY3RvclRpbGVKc1xubW9kdWxlLmV4cG9ydHMuZnJvbUdlb2pzb25WdCA9IGZyb21HZW9qc29uVnRcbm1vZHVsZS5leHBvcnRzLkdlb0pTT05XcmFwcGVyID0gR2VvSlNPTldyYXBwZXJcblxuLyoqXG4gKiBTZXJpYWxpemUgYSB2ZWN0b3ItdGlsZS1qcy1jcmVhdGVkIHRpbGUgdG8gcGJmXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRpbGVcbiAqIEByZXR1cm4ge0J1ZmZlcn0gdW5jb21wcmVzc2VkLCBwYmYtc2VyaWFsaXplZCB0aWxlIGRhdGFcbiAqL1xuZnVuY3Rpb24gZnJvbVZlY3RvclRpbGVKcyAodGlsZSkge1xuICB2YXIgbGF5ZXJzID0gW11cbiAgZm9yICh2YXIgbCBpbiB0aWxlLmxheWVycykge1xuICAgIGxheWVycy5wdXNoKHByZXBhcmVMYXllcih0aWxlLmxheWVyc1tsXSkpXG4gIH1cblxuICB2YXIgb3V0ID0gbmV3IFBiZigpXG4gIHZ0cGIudGlsZS53cml0ZSh7IGxheWVyczogbGF5ZXJzIH0sIG91dClcbiAgcmV0dXJuIG91dC5maW5pc2goKVxufVxuXG4vKipcbiAqIFNlcmlhbGl6ZWQgYSBnZW9qc29uLXZ0LWNyZWF0ZWQgdGlsZSB0byBwYmYuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGxheWVycyAtIEFuIG9iamVjdCBtYXBwaW5nIGxheWVyIG5hbWVzIHRvIGdlb2pzb24tdnQtY3JlYXRlZCB2ZWN0b3IgdGlsZSBvYmplY3RzXG4gKiBAcmV0dXJuIHtCdWZmZXJ9IHVuY29tcHJlc3NlZCwgcGJmLXNlcmlhbGl6ZWQgdGlsZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIGZyb21HZW9qc29uVnQgKGxheWVycykge1xuICB2YXIgbCA9IHt9XG4gIGZvciAodmFyIGsgaW4gbGF5ZXJzKSB7XG4gICAgbFtrXSA9IG5ldyBHZW9KU09OV3JhcHBlcihsYXllcnNba10uZmVhdHVyZXMpXG4gICAgbFtrXS5uYW1lID0ga1xuICB9XG4gIHJldHVybiBmcm9tVmVjdG9yVGlsZUpzKHtsYXllcnM6IGx9KVxufVxuXG4vKipcbiAqIFByZXBhcmUgdGhlIGdpdmVuIGxheWVyIHRvIGJlIHNlcmlhbGl6ZWQgYnkgdGhlIGF1dG8tZ2VuZXJhdGVkIHBiZlxuICogc2VyaWFsaXplciBieSBlbmNvZGluZyB0aGUgZmVhdHVyZSBnZW9tZXRyeSBhbmQgcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gcHJlcGFyZUxheWVyIChsYXllcikge1xuICB2YXIgcHJlcGFyZWRMYXllciA9IHtcbiAgICBuYW1lOiBsYXllci5uYW1lIHx8ICcnLFxuICAgIHZlcnNpb246IGxheWVyLnZlcnNpb24gfHwgMSxcbiAgICBleHRlbnQ6IGxheWVyLmV4dGVudCB8fCA0MDk2LFxuICAgIGtleXM6IFtdLFxuICAgIHZhbHVlczogW10sXG4gICAgZmVhdHVyZXM6IFtdXG4gIH1cblxuICB2YXIga2V5Y2FjaGUgPSB7fVxuICB2YXIgdmFsdWVjYWNoZSA9IHt9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmZWF0dXJlID0gbGF5ZXIuZmVhdHVyZShpKVxuICAgIGZlYXR1cmUuZ2VvbWV0cnkgPSBlbmNvZGVHZW9tZXRyeShmZWF0dXJlLmxvYWRHZW9tZXRyeSgpKVxuXG4gICAgdmFyIHRhZ3MgPSBbXVxuICAgIGZvciAodmFyIGtleSBpbiBmZWF0dXJlLnByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBrZXlJbmRleCA9IGtleWNhY2hlW2tleV1cbiAgICAgIGlmICh0eXBlb2Yga2V5SW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHByZXBhcmVkTGF5ZXIua2V5cy5wdXNoKGtleSlcbiAgICAgICAga2V5SW5kZXggPSBwcmVwYXJlZExheWVyLmtleXMubGVuZ3RoIC0gMVxuICAgICAgICBrZXljYWNoZVtrZXldID0ga2V5SW5kZXhcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IHdyYXBWYWx1ZShmZWF0dXJlLnByb3BlcnRpZXNba2V5XSlcbiAgICAgIHZhciB2YWx1ZUluZGV4ID0gdmFsdWVjYWNoZVt2YWx1ZS5rZXldXG4gICAgICBpZiAodHlwZW9mIHZhbHVlSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHByZXBhcmVkTGF5ZXIudmFsdWVzLnB1c2godmFsdWUpXG4gICAgICAgIHZhbHVlSW5kZXggPSBwcmVwYXJlZExheWVyLnZhbHVlcy5sZW5ndGggLSAxXG4gICAgICAgIHZhbHVlY2FjaGVbdmFsdWUua2V5XSA9IHZhbHVlSW5kZXhcbiAgICAgIH1cbiAgICAgIHRhZ3MucHVzaChrZXlJbmRleClcbiAgICAgIHRhZ3MucHVzaCh2YWx1ZUluZGV4KVxuICAgIH1cblxuICAgIGZlYXR1cmUudGFncyA9IHRhZ3NcbiAgICBwcmVwYXJlZExheWVyLmZlYXR1cmVzLnB1c2goZmVhdHVyZSlcbiAgfVxuXG4gIHJldHVybiBwcmVwYXJlZExheWVyXG59XG5cbmZ1bmN0aW9uIGNvbW1hbmQgKGNtZCwgbGVuZ3RoKSB7XG4gIHJldHVybiAobGVuZ3RoIDw8IDMpICsgKGNtZCAmIDB4Nylcbn1cblxuZnVuY3Rpb24gemlnemFnIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMSkgXiAobnVtID4+IDMxKVxufVxuXG4vKipcbiAqIEVuY29kZSBhIHBvbHlnb24ncyBnZW9tZXRyeSBpbnRvIGFuIGFycmF5IHJlYWR5IHRvIGJlIHNlcmlhbGl6ZWRcbiAqIHRvIG1hcGJveCB2ZWN0b3IgdGlsZSBzcGVjaWZpZWQgZ2VvbWV0cnkgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBSaW5ncywgZWFjaCBiZWluZyBhbiBhcnJheSBvZiBbeCwgeV0gdGlsZS1zcGFjZSBjb29yZGluYXRlc1xuICogQHJldHVybiB7QXJyYXl9IGVuY29kZWQgZ2VvbWV0cnlcbiAqL1xuZnVuY3Rpb24gZW5jb2RlR2VvbWV0cnkgKGdlb21ldHJ5KSB7XG4gIHZhciBlbmNvZGVkID0gW11cbiAgdmFyIHggPSAwXG4gIHZhciB5ID0gMFxuICB2YXIgcmluZ3MgPSBnZW9tZXRyeS5sZW5ndGhcbiAgZm9yICh2YXIgciA9IDA7IHIgPCByaW5nczsgcisrKSB7XG4gICAgdmFyIHJpbmcgPSBnZW9tZXRyeVtyXVxuICAgIGVuY29kZWQucHVzaChjb21tYW5kKDEsIDEpKSAvLyBtb3ZldG9cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpID09PSAxKSB7XG4gICAgICAgIGVuY29kZWQucHVzaChjb21tYW5kKDIsIHJpbmcubGVuZ3RoIC0gMSkpIC8vIGxpbmV0b1xuICAgICAgfVxuICAgICAgdmFyIGR4ID0gcmluZ1tpXS54IC0geFxuICAgICAgdmFyIGR5ID0gcmluZ1tpXS55IC0geVxuICAgICAgZW5jb2RlZC5wdXNoKHppZ3phZyhkeCksIHppZ3phZyhkeSkpXG4gICAgICB4ICs9IGR4XG4gICAgICB5ICs9IGR5XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVuY29kZWRcbn1cblxuLyoqXG4gKiBXcmFwIGEgcHJvcGVydHkgdmFsdWUgYWNjb3JkaW5nIHRvIGl0cyB0eXBlLiBUaGUgcmV0dXJuZWQgb2JqZWN0XG4gKiBpcyBvZiB0aGUgZm9ybSB7IHh4eHhfdmFsdWU6IHByaW1pdGl2ZVZhbHVlIH0sIHdoaWNoIGlzIHdoYXQgdGhlIGdlbmVyYXRlZFxuICogcHJvdG9idWYgc2VyaWFsaXplciBleHBlY3RzLlxuICovXG5mdW5jdGlvbiB3cmFwVmFsdWUgKHZhbHVlKSB7XG4gIHZhciByZXN1bHRcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWVcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0geyBzdHJpbmdfdmFsdWU6IHZhbHVlIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICByZXN1bHQgPSB7IGJvb2xfdmFsdWU6IHZhbHVlIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgIGlmICh2YWx1ZSAhPT0gKHZhbHVlIHwgMCkpIHtcbiAgICAgIHJlc3VsdCA9IHsgZmxvYXRfdmFsdWU6IHZhbHVlIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgcmVzdWx0ID0geyBzaW50X3ZhbHVlOiB2YWx1ZSB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHsgdWludF92YWx1ZTogdmFsdWUgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB7IHN0cmluZ192YWx1ZTogJycgKyB2YWx1ZSB9XG4gIH1cblxuICByZXN1bHQua2V5ID0gdHlwZSArICc6JyArIHZhbHVlXG4gIHJldHVybiByZXN1bHRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpXG52YXIgVmVjdG9yVGlsZUZlYXR1cmUgPSByZXF1aXJlKCd2ZWN0b3ItdGlsZScpLlZlY3RvclRpbGVGZWF0dXJlXG5cbm1vZHVsZS5leHBvcnRzID0gR2VvSlNPTldyYXBwZXJcblxuLy8gY29uZm9ybSB0byB2ZWN0b3J0aWxlIGFwaVxuZnVuY3Rpb24gR2VvSlNPTldyYXBwZXIgKGZlYXR1cmVzKSB7XG4gIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlc1xuICB0aGlzLmxlbmd0aCA9IGZlYXR1cmVzLmxlbmd0aFxufVxuXG5HZW9KU09OV3JhcHBlci5wcm90b3R5cGUuZmVhdHVyZSA9IGZ1bmN0aW9uIChpKSB7XG4gIHJldHVybiBuZXcgRmVhdHVyZVdyYXBwZXIodGhpcy5mZWF0dXJlc1tpXSlcbn1cblxuZnVuY3Rpb24gRmVhdHVyZVdyYXBwZXIgKGZlYXR1cmUpIHtcbiAgdGhpcy50eXBlID0gZmVhdHVyZS50eXBlXG4gIHRoaXMucmF3R2VvbWV0cnkgPSBmZWF0dXJlLnR5cGUgPT09IDEgPyBbZmVhdHVyZS5nZW9tZXRyeV0gOiBmZWF0dXJlLmdlb21ldHJ5XG4gIHRoaXMucHJvcGVydGllcyA9IGZlYXR1cmUudGFnc1xuICB0aGlzLmV4dGVudCA9IDQwOTZcbn1cblxuRmVhdHVyZVdyYXBwZXIucHJvdG90eXBlLmxvYWRHZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJpbmdzID0gdGhpcy5yYXdHZW9tZXRyeVxuICB0aGlzLmdlb21ldHJ5ID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJpbmcgPSByaW5nc1tpXVxuICAgIHZhciBuZXdSaW5nID0gW11cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpbmcubGVuZ3RoOyBqKyspIHtcbiAgICAgIG5ld1JpbmcucHVzaChuZXcgUG9pbnQocmluZ1tqXVswXSwgcmluZ1tqXVsxXSkpXG4gICAgfVxuICAgIHRoaXMuZ2VvbWV0cnkucHVzaChuZXdSaW5nKVxuICB9XG4gIHJldHVybiB0aGlzLmdlb21ldHJ5XG59XG5cbkZlYXR1cmVXcmFwcGVyLnByb3RvdHlwZS5iYm94ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuZ2VvbWV0cnkpIHRoaXMubG9hZEdlb21ldHJ5KClcblxuICB2YXIgcmluZ3MgPSB0aGlzLmdlb21ldHJ5XG4gIHZhciB4MSA9IEluZmluaXR5XG4gIHZhciB4MiA9IC1JbmZpbml0eVxuICB2YXIgeTEgPSBJbmZpbml0eVxuICB2YXIgeTIgPSAtSW5maW5pdHlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJpbmcgPSByaW5nc1tpXVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByaW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgY29vcmQgPSByaW5nW2pdXG5cbiAgICAgIHgxID0gTWF0aC5taW4oeDEsIGNvb3JkLngpXG4gICAgICB4MiA9IE1hdGgubWF4KHgyLCBjb29yZC54KVxuICAgICAgeTEgPSBNYXRoLm1pbih5MSwgY29vcmQueSlcbiAgICAgIHkyID0gTWF0aC5tYXgoeTIsIGNvb3JkLnkpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5Ml1cbn1cblxuRmVhdHVyZVdyYXBwZXIucHJvdG90eXBlLnRvR2VvSlNPTiA9IFZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS50b0dlb0pTT05cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gdGlsZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbnZhciB0aWxlID0gZXhwb3J0cy50aWxlID0ge3JlYWQ6IHJlYWRUaWxlLCB3cml0ZTogd3JpdGVUaWxlfTtcblxudGlsZS5HZW9tVHlwZSA9IHtcbiAgICBcIlVua25vd25cIjogMCxcbiAgICBcIlBvaW50XCI6IDEsXG4gICAgXCJMaW5lU3RyaW5nXCI6IDIsXG4gICAgXCJQb2x5Z29uXCI6IDNcbn07XG5cbmZ1bmN0aW9uIHJlYWRUaWxlKHBiZiwgZW5kKSB7XG4gICAgcmV0dXJuIHBiZi5yZWFkRmllbGRzKHJlYWRUaWxlRmllbGQsIHtcImxheWVyc1wiOiBbXX0sIGVuZCk7XG59XG5cbmZ1bmN0aW9uIHJlYWRUaWxlRmllbGQodGFnLCB0aWxlLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAzKSB0aWxlLmxheWVycy5wdXNoKHJlYWRMYXllcihwYmYsIHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zKSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlVGlsZSh0aWxlLCBwYmYpIHtcbiAgICB2YXIgaTtcbiAgICBpZiAodGlsZS5sYXllcnMgIT09IHVuZGVmaW5lZCkgZm9yIChpID0gMDsgaSA8IHRpbGUubGF5ZXJzLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVNZXNzYWdlKDMsIHdyaXRlTGF5ZXIsIHRpbGUubGF5ZXJzW2ldKTtcbn1cblxuLy8gdmFsdWUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG50aWxlLnZhbHVlID0ge3JlYWQ6IHJlYWRWYWx1ZSwgd3JpdGU6IHdyaXRlVmFsdWV9O1xuXG5mdW5jdGlvbiByZWFkVmFsdWUocGJmLCBlbmQpIHtcbiAgICByZXR1cm4gcGJmLnJlYWRGaWVsZHMocmVhZFZhbHVlRmllbGQsIHt9LCBlbmQpO1xufVxuXG5mdW5jdGlvbiByZWFkVmFsdWVGaWVsZCh0YWcsIHZhbHVlLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAxKSB2YWx1ZS5zdHJpbmdfdmFsdWUgPSBwYmYucmVhZFN0cmluZygpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMikgdmFsdWUuZmxvYXRfdmFsdWUgPSBwYmYucmVhZEZsb2F0KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAzKSB2YWx1ZS5kb3VibGVfdmFsdWUgPSBwYmYucmVhZERvdWJsZSgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNCkgdmFsdWUuaW50X3ZhbHVlID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDUpIHZhbHVlLnVpbnRfdmFsdWUgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNikgdmFsdWUuc2ludF92YWx1ZSA9IHBiZi5yZWFkU1ZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNykgdmFsdWUuYm9vbF92YWx1ZSA9IHBiZi5yZWFkQm9vbGVhbigpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVZhbHVlKHZhbHVlLCBwYmYpIHtcbiAgICBpZiAodmFsdWUuc3RyaW5nX3ZhbHVlICE9PSB1bmRlZmluZWQpIHBiZi53cml0ZVN0cmluZ0ZpZWxkKDEsIHZhbHVlLnN0cmluZ192YWx1ZSk7XG4gICAgaWYgKHZhbHVlLmZsb2F0X3ZhbHVlICE9PSB1bmRlZmluZWQpIHBiZi53cml0ZUZsb2F0RmllbGQoMiwgdmFsdWUuZmxvYXRfdmFsdWUpO1xuICAgIGlmICh2YWx1ZS5kb3VibGVfdmFsdWUgIT09IHVuZGVmaW5lZCkgcGJmLndyaXRlRG91YmxlRmllbGQoMywgdmFsdWUuZG91YmxlX3ZhbHVlKTtcbiAgICBpZiAodmFsdWUuaW50X3ZhbHVlICE9PSB1bmRlZmluZWQpIHBiZi53cml0ZVZhcmludEZpZWxkKDQsIHZhbHVlLmludF92YWx1ZSk7XG4gICAgaWYgKHZhbHVlLnVpbnRfdmFsdWUgIT09IHVuZGVmaW5lZCkgcGJmLndyaXRlVmFyaW50RmllbGQoNSwgdmFsdWUudWludF92YWx1ZSk7XG4gICAgaWYgKHZhbHVlLnNpbnRfdmFsdWUgIT09IHVuZGVmaW5lZCkgcGJmLndyaXRlU1ZhcmludEZpZWxkKDYsIHZhbHVlLnNpbnRfdmFsdWUpO1xuICAgIGlmICh2YWx1ZS5ib29sX3ZhbHVlICE9PSB1bmRlZmluZWQpIHBiZi53cml0ZUJvb2xlYW5GaWVsZCg3LCB2YWx1ZS5ib29sX3ZhbHVlKTtcbn1cblxuLy8gZmVhdHVyZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbnRpbGUuZmVhdHVyZSA9IHtyZWFkOiByZWFkRmVhdHVyZSwgd3JpdGU6IHdyaXRlRmVhdHVyZX07XG5cbmZ1bmN0aW9uIHJlYWRGZWF0dXJlKHBiZiwgZW5kKSB7XG4gICAgdmFyIGZlYXR1cmUgPSBwYmYucmVhZEZpZWxkcyhyZWFkRmVhdHVyZUZpZWxkLCB7fSwgZW5kKTtcbiAgICBpZiAoZmVhdHVyZS50eXBlID09PSB1bmRlZmluZWQpIGZlYXR1cmUudHlwZSA9IFwiVW5rbm93blwiO1xuICAgIHJldHVybiBmZWF0dXJlO1xufVxuXG5mdW5jdGlvbiByZWFkRmVhdHVyZUZpZWxkKHRhZywgZmVhdHVyZSwgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMSkgZmVhdHVyZS5pZCA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAyKSBmZWF0dXJlLnRhZ3MgPSBwYmYucmVhZFBhY2tlZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMykgZmVhdHVyZS50eXBlID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDQpIGZlYXR1cmUuZ2VvbWV0cnkgPSBwYmYucmVhZFBhY2tlZFZhcmludCgpO1xufVxuXG5mdW5jdGlvbiB3cml0ZUZlYXR1cmUoZmVhdHVyZSwgcGJmKSB7XG4gICAgaWYgKGZlYXR1cmUuaWQgIT09IHVuZGVmaW5lZCkgcGJmLndyaXRlVmFyaW50RmllbGQoMSwgZmVhdHVyZS5pZCk7XG4gICAgaWYgKGZlYXR1cmUudGFncyAhPT0gdW5kZWZpbmVkKSBwYmYud3JpdGVQYWNrZWRWYXJpbnQoMiwgZmVhdHVyZS50YWdzKTtcbiAgICBpZiAoZmVhdHVyZS50eXBlICE9PSB1bmRlZmluZWQpIHBiZi53cml0ZVZhcmludEZpZWxkKDMsIGZlYXR1cmUudHlwZSk7XG4gICAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCkgcGJmLndyaXRlUGFja2VkVmFyaW50KDQsIGZlYXR1cmUuZ2VvbWV0cnkpO1xufVxuXG4vLyBsYXllciA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbnRpbGUubGF5ZXIgPSB7cmVhZDogcmVhZExheWVyLCB3cml0ZTogd3JpdGVMYXllcn07XG5cbmZ1bmN0aW9uIHJlYWRMYXllcihwYmYsIGVuZCkge1xuICAgIHJldHVybiBwYmYucmVhZEZpZWxkcyhyZWFkTGF5ZXJGaWVsZCwge1wiZmVhdHVyZXNcIjogW10sIFwia2V5c1wiOiBbXSwgXCJ2YWx1ZXNcIjogW119LCBlbmQpO1xufVxuXG5mdW5jdGlvbiByZWFkTGF5ZXJGaWVsZCh0YWcsIGxheWVyLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAxNSkgbGF5ZXIudmVyc2lvbiA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAxKSBsYXllci5uYW1lID0gcGJmLnJlYWRTdHJpbmcoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDIpIGxheWVyLmZlYXR1cmVzLnB1c2gocmVhZEZlYXR1cmUocGJmLCBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcykpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMykgbGF5ZXIua2V5cy5wdXNoKHBiZi5yZWFkU3RyaW5nKCkpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNCkgbGF5ZXIudmFsdWVzLnB1c2gocmVhZFZhbHVlKHBiZiwgcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MpKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDUpIGxheWVyLmV4dGVudCA9IHBiZi5yZWFkVmFyaW50KCk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlTGF5ZXIobGF5ZXIsIHBiZikge1xuICAgIGlmIChsYXllci52ZXJzaW9uICE9PSB1bmRlZmluZWQpIHBiZi53cml0ZVZhcmludEZpZWxkKDE1LCBsYXllci52ZXJzaW9uKTtcbiAgICBpZiAobGF5ZXIubmFtZSAhPT0gdW5kZWZpbmVkKSBwYmYud3JpdGVTdHJpbmdGaWVsZCgxLCBsYXllci5uYW1lKTtcbiAgICB2YXIgaTtcbiAgICBpZiAobGF5ZXIuZmVhdHVyZXMgIT09IHVuZGVmaW5lZCkgZm9yIChpID0gMDsgaSA8IGxheWVyLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVNZXNzYWdlKDIsIHdyaXRlRmVhdHVyZSwgbGF5ZXIuZmVhdHVyZXNbaV0pO1xuICAgIGlmIChsYXllci5rZXlzICE9PSB1bmRlZmluZWQpIGZvciAoaSA9IDA7IGkgPCBsYXllci5rZXlzLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVTdHJpbmdGaWVsZCgzLCBsYXllci5rZXlzW2ldKTtcbiAgICBpZiAobGF5ZXIudmFsdWVzICE9PSB1bmRlZmluZWQpIGZvciAoaSA9IDA7IGkgPCBsYXllci52YWx1ZXMubGVuZ3RoOyBpKyspIHBiZi53cml0ZU1lc3NhZ2UoNCwgd3JpdGVWYWx1ZSwgbGF5ZXIudmFsdWVzW2ldKTtcbiAgICBpZiAobGF5ZXIuZXh0ZW50ICE9PSB1bmRlZmluZWQpIHBiZi53cml0ZVZhcmludEZpZWxkKDUsIGxheWVyLmV4dGVudCk7XG59XG4iLCJ2YXIgYnVuZGxlRm4gPSBhcmd1bWVudHNbM107XG52YXIgc291cmNlcyA9IGFyZ3VtZW50c1s0XTtcbnZhciBjYWNoZSA9IGFyZ3VtZW50c1s1XTtcblxudmFyIHN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgb3B0aW9ucykge1xuICAgIHZhciB3a2V5O1xuICAgIHZhciBjYWNoZUtleXMgPSBPYmplY3Qua2V5cyhjYWNoZSk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNhY2hlS2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGNhY2hlS2V5c1tpXTtcbiAgICAgICAgdmFyIGV4cCA9IGNhY2hlW2tleV0uZXhwb3J0cztcbiAgICAgICAgLy8gVXNpbmcgYmFiZWwgYXMgYSB0cmFuc3BpbGVyIHRvIHVzZSBlc21vZHVsZSwgdGhlIGV4cG9ydCB3aWxsIGFsd2F5c1xuICAgICAgICAvLyBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgZGVmYXVsdCBleHBvcnQgYXMgYSBwcm9wZXJ0eSBvZiBpdC4gVG8gZW5zdXJlXG4gICAgICAgIC8vIHRoZSBleGlzdGluZyBhcGkgYW5kIGJhYmVsIGVzbW9kdWxlIGV4cG9ydHMgYXJlIGJvdGggc3VwcG9ydGVkIHdlXG4gICAgICAgIC8vIGNoZWNrIGZvciBib3RoXG4gICAgICAgIGlmIChleHAgPT09IGZuIHx8IGV4cCAmJiBleHAuZGVmYXVsdCA9PT0gZm4pIHtcbiAgICAgICAgICAgIHdrZXkgPSBrZXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghd2tleSkge1xuICAgICAgICB3a2V5ID0gTWF0aC5mbG9vcihNYXRoLnBvdygxNiwgOCkgKiBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygxNik7XG4gICAgICAgIHZhciB3Y2FjaGUgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYWNoZUtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gY2FjaGVLZXlzW2ldO1xuICAgICAgICAgICAgd2NhY2hlW2tleV0gPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlc1t3a2V5XSA9IFtcbiAgICAgICAgICAgIEZ1bmN0aW9uKFsncmVxdWlyZScsJ21vZHVsZScsJ2V4cG9ydHMnXSwgJygnICsgZm4gKyAnKShzZWxmKScpLFxuICAgICAgICAgICAgd2NhY2hlXG4gICAgICAgIF07XG4gICAgfVxuICAgIHZhciBza2V5ID0gTWF0aC5mbG9vcihNYXRoLnBvdygxNiwgOCkgKiBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygxNik7XG5cbiAgICB2YXIgc2NhY2hlID0ge307IHNjYWNoZVt3a2V5XSA9IHdrZXk7XG4gICAgc291cmNlc1tza2V5XSA9IFtcbiAgICAgICAgRnVuY3Rpb24oWydyZXF1aXJlJ10sIChcbiAgICAgICAgICAgIC8vIHRyeSB0byBjYWxsIGRlZmF1bHQgaWYgZGVmaW5lZCB0byBhbHNvIHN1cHBvcnQgYmFiZWwgZXNtb2R1bGVcbiAgICAgICAgICAgIC8vIGV4cG9ydHNcbiAgICAgICAgICAgICd2YXIgZiA9IHJlcXVpcmUoJyArIHN0cmluZ2lmeSh3a2V5KSArICcpOycgK1xuICAgICAgICAgICAgJyhmLmRlZmF1bHQgPyBmLmRlZmF1bHQgOiBmKShzZWxmKTsnXG4gICAgICAgICkpLFxuICAgICAgICBzY2FjaGVcbiAgICBdO1xuXG4gICAgdmFyIHNyYyA9ICcoJyArIGJ1bmRsZUZuICsgJykoeydcbiAgICAgICAgKyBPYmplY3Qua2V5cyhzb3VyY2VzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShrZXkpICsgJzpbJ1xuICAgICAgICAgICAgICAgICsgc291cmNlc1trZXldWzBdXG4gICAgICAgICAgICAgICAgKyAnLCcgKyBzdHJpbmdpZnkoc291cmNlc1trZXldWzFdKSArICddJ1xuICAgICAgICAgICAgO1xuICAgICAgICB9KS5qb2luKCcsJylcbiAgICAgICAgKyAnfSx7fSxbJyArIHN0cmluZ2lmeShza2V5KSArICddKSdcbiAgICA7XG5cbiAgICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkwgfHwgd2luZG93Lm1zVVJMO1xuXG4gICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbc3JjXSwgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KTtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmJhcmUpIHsgcmV0dXJuIGJsb2I7IH1cbiAgICB2YXIgd29ya2VyVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJVcmwpO1xuICAgIGlmICh0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwod29ya2VyVXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmtlcjtcbn07XG4iLCIvLyEgbW9tZW50LmpzXG4vLyEgdmVyc2lvbiA6IDIuMTMuMFxuLy8hIGF1dGhvcnMgOiBUaW0gV29vZCwgSXNrcmVuIENoZXJuZXYsIE1vbWVudC5qcyBjb250cmlidXRvcnNcbi8vISBsaWNlbnNlIDogTUlUXG4vLyEgbW9tZW50anMuY29tXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gdXRpbHNfaG9va3NfX2hvb2tzICgpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4gICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrIChjYWxsYmFjaykge1xuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgICAgIHZhciByZXMgPSBbXSwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVfdXRjX19jcmVhdGVVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbXB0eSAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVudXNlZFRva2VucyAgICA6IFtdLFxuICAgICAgICAgICAgdW51c2VkSW5wdXQgICAgIDogW10sXG4gICAgICAgICAgICBvdmVyZmxvdyAgICAgICAgOiAtMixcbiAgICAgICAgICAgIGNoYXJzTGVmdE92ZXIgICA6IDAsXG4gICAgICAgICAgICBudWxsSW5wdXQgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGludmFsaWRNb250aCAgICA6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkRm9ybWF0ICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZCA6IGZhbHNlLFxuICAgICAgICAgICAgaXNvICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBwYXJzZWREYXRlUGFydHMgOiBbXSxcbiAgICAgICAgICAgIG1lcmlkaWVtICAgICAgICA6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgICAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX3BmO1xuICAgIH1cblxuICAgIHZhciBzb21lO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgICAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZF9faXNWYWxpZChtKSB7XG4gICAgICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKTtcbiAgICAgICAgICAgIHZhciBwYXJzZWRQYXJ0cyA9IHNvbWUuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgIT0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbS5faXNWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLm51bGxJbnB1dCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLnVzZXJJbnZhbGlkYXRlZCAmJlxuICAgICAgICAgICAgICAgICghZmxhZ3MubWVyaWRpZW0gfHwgKGZsYWdzLm1lcmlkaWVtICYmIHBhcnNlZFBhcnRzKSk7XG5cbiAgICAgICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gbS5faXNWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkX19jcmVhdGVJbnZhbGlkIChmbGFncykge1xuICAgICAgICB2YXIgbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhOYU4pO1xuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXG4gICAgLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbiAgICB2YXIgbW9tZW50UHJvcGVydGllcyA9IHV0aWxzX2hvb2tzX19ob29rcy5tb21lbnRQcm9wZXJ0aWVzID0gW107XG5cbiAgICBmdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgICAgIHZhciBpLCBwcm9wLCB2YWw7XG5cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc0FNb21lbnRPYmplY3QpKSB7XG4gICAgICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faSkpIHtcbiAgICAgICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2YpKSB7XG4gICAgICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sKSkge1xuICAgICAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fc3RyaWN0KSkge1xuICAgICAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3R6bSkpIHtcbiAgICAgICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc1VUQykpIHtcbiAgICAgICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fb2Zmc2V0KSkge1xuICAgICAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3BmKSkge1xuICAgICAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbG9jYWxlKSkge1xuICAgICAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSBpbiBtb21lbnRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IG1vbWVudFByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICAgICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgICAgICAvLyBvYmplY3RzLlxuICAgICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XG4gICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgICAgIGlmICh1dGlsc19ob29rc19faG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgY29uc29sZSAhPT0gICd1bmRlZmluZWQnKSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgICAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgd2Fybihtc2cgKyAnXFxuQXJndW1lbnRzOiAnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKCcsICcpICsgJ1xcbicgKyAobmV3IEVycm9yKCkpLnN0YWNrKTtcbiAgICAgICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBmbik7XG4gICAgfVxuXG4gICAgdmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgICAgICBpZiAodXRpbHNfaG9va3NfX2hvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZV9zZXRfX3NldCAoY29uZmlnKSB7XG4gICAgICAgIHZhciBwcm9wLCBpO1xuICAgICAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAgICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfb3JkaW5hbFBhcnNlTGVuaWVudC5cbiAgICAgICAgdGhpcy5fb3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAodGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSArICd8JyArICgvXFxkezEsMn0vKS5zb3VyY2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBleHRlbmQoe30sIHBhcmVudENvbmZpZyksIHByb3A7XG4gICAgICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkgJiYgaXNPYmplY3QoY2hpbGRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBjaGlsZENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cztcblxuICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBpLCByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xuICAgIHZhciBsb2NhbGVzID0ge307XG4gICAgdmFyIGdsb2JhbExvY2FsZTtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSA/IGtleS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ18nLCAnLScpIDoga2V5O1xuICAgIH1cblxuICAgIC8vIHBpY2sgdGhlIGxvY2FsZSBmcm9tIHRoZSBhcnJheVxuICAgIC8vIHRyeSBbJ2VuLWF1JywgJ2VuLWdiJ10gYXMgJ2VuLWF1JywgJ2VuLWdiJywgJ2VuJywgYXMgaW4gbW92ZSB0aHJvdWdoIHRoZSBsaXN0IHRyeWluZyBlYWNoXG4gICAgLy8gc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxuICAgIGZ1bmN0aW9uIGNob29zZUxvY2FsZShuYW1lcykge1xuICAgICAgICB2YXIgaSA9IDAsIGosIG5leHQsIGxvY2FsZSwgc3BsaXQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubGVuZ3RoID49IGogJiYgY29tcGFyZUFycmF5cyhzcGxpdCwgbmV4dCwgdHJ1ZSkgPj0gaiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xuICAgICAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgaWYgKCFsb2NhbGVzW25hbWVdICYmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2xkTG9jYWxlID0gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGRlZmluZUxvY2FsZSBjdXJyZW50bHkgYWxzbyBzZXRzIHRoZSBnbG9iYWwgbG9jYWxlLCB3ZVxuICAgICAgICAgICAgICAgIC8vIHdhbnQgdG8gdW5kbyB0aGF0IGZvciBsYXp5IGxvYWRlZCBsb2NhbGVzXG4gICAgICAgICAgICAgICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZShvbGRMb2NhbGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUgKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGVmaW5lTG9jYWxlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBtb21lbnQuZHVyYXRpb24uX2xvY2FsZSA9IG1vbWVudC5fbG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgICAgICBnbG9iYWxMb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVMb2NhbGUgKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlJyk7XG4gICAgICAgICAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKGxvY2FsZXNbbmFtZV0uX2NvbmZpZywgY29uZmlnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXS5fY29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyZWF0IGFzIGlmIHRoZXJlIGlzIG5vIGJhc2UgY29uZmlnXG4gICAgICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZSgncGFyZW50TG9jYWxlVW5kZWZpbmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3BlY2lmaWVkIHBhcmVudExvY2FsZSBpcyBub3QgZGVmaW5lZCB5ZXQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbmV3IExvY2FsZShjb25maWcpO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKGxvY2FsZXNbbmFtZV0uX2NvbmZpZywgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgICAgIGxvY2FsZS5wYXJlbnRMb2NhbGUgPSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZTtcblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFzcyBudWxsIGZvciBjb25maWcgdG8gdW51cGRhdGUsIHVzZWZ1bCBmb3IgdGVzdHNcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgbG9jYWxlIGRhdGFcbiAgICBmdW5jdGlvbiBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIGxvY2FsZTtcblxuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlX2xvY2FsZXNfX2xpc3RMb2NhbGVzKCkge1xuICAgICAgICByZXR1cm4ga2V5cyhsb2NhbGVzKTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnZXRfc2V0X19zZXQodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0X3NldF9fZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldF9zZXRfX2dldCAobW9tLCB1bml0KSB7XG4gICAgICAgIHJldHVybiBtb20uaXNWYWxpZCgpID9cbiAgICAgICAgICAgIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldF9zZXRfX3NldCAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldCAodW5pdHMsIHZhbHVlKSB7XG4gICAgICAgIHZhciB1bml0O1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yICh1bml0IGluIHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQodW5pdCwgdW5pdHNbdW5pdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICAgICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICAgICAgcmV0dXJuIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgKyBhYnNOdW1iZXI7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nO1xuXG4gICAgdmFyIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2c7XG5cbiAgICB2YXIgZm9ybWF0RnVuY3Rpb25zID0ge307XG5cbiAgICB2YXIgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuICAgIC8vIHRva2VuOiAgICAnTSdcbiAgICAvLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4gICAgLy8gb3JkaW5hbDogICdNbydcbiAgICAvLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbiAgICBmdW5jdGlvbiBhZGRGb3JtYXRUb2tlbiAodG9rZW4sIHBhZGRlZCwgb3JkaW5hbCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFkZGVkKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvRmlsbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHBhZGRlZFsxXSwgcGFkZGVkWzJdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZGluYWwpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdG9rZW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSAnJywgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBhcnJheVtpXSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xuICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHZhciBtYXRjaDEgICAgICAgICA9IC9cXGQvOyAgICAgICAgICAgIC8vICAgICAgIDAgLSA5XG4gICAgdmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxuICAgIHZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcbiAgICB2YXIgbWF0Y2g0ICAgICAgICAgPSAvXFxkezR9LzsgICAgICAgICAvLyAgICAwMDAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XG4gICAgdmFyIG1hdGNoM3RvNCAgICAgID0gL1xcZFxcZFxcZFxcZD8vOyAgICAgLy8gICAgIDk5OSAtIDk5OTlcbiAgICB2YXIgbWF0Y2g1dG82ICAgICAgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy87IC8vICAgOTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XG4gICAgdmFyIG1hdGNoMXRvNCAgICAgID0gL1xcZHsxLDR9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbiAgICB2YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXG4gICAgdmFyIG1hdGNoU2lnbmVkICAgID0gL1srLV0/XFxkKy87ICAgICAgLy8gICAgLWluZiAtIGluZlxuXG4gICAgdmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICB2YXIgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpOyAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuXG4gICAgdmFyIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LzsgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcblxuICAgIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuICAgIC8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcbiAgICB2YXIgbWF0Y2hXb3JkID0gL1swLTldKlsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSt8W1xcdTA2MDAtXFx1MDZGRlxcL10rKFxccyo/W1xcdTA2MDAtXFx1MDZGRl0rKXsxLDJ9L2k7XG5cblxuICAgIHZhciByZWdleGVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRSZWdleFRva2VuICh0b2tlbiwgcmVnZXgsIHN0cmljdFJlZ2V4KSB7XG4gICAgICAgIHJlZ2V4ZXNbdG9rZW5dID0gaXNGdW5jdGlvbihyZWdleCkgPyByZWdleCA6IGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIChpc1N0cmljdCAmJiBzdHJpY3RSZWdleCkgPyBzdHJpY3RSZWdleCA6IHJlZ2V4O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbiAodG9rZW4sIGNvbmZpZykge1xuICAgICAgICBpZiAoIWhhc093blByb3AocmVnZXhlcywgdG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmVzY2FwZUZvcm1hdCh0b2tlbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZ2V4ZXNbdG9rZW5dKGNvbmZpZy5fc3RyaWN0LCBjb25maWcuX2xvY2FsZSk7XG4gICAgfVxuXG4gICAgLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4RXNjYXBlKHMucmVwbGFjZSgnXFxcXCcsICcnKS5yZXBsYWNlKC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csIGZ1bmN0aW9uIChtYXRjaGVkLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgcmV0dXJuIHAxIHx8IHAyIHx8IHAzIHx8IHA0O1xuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVnZXhFc2NhcGUocykge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbiAgICB9XG5cbiAgICB2YXIgdG9rZW5zID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGksIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRva2VuID0gW3Rva2VuXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFlFQVIgPSAwO1xuICAgIHZhciBNT05USCA9IDE7XG4gICAgdmFyIERBVEUgPSAyO1xuICAgIHZhciBIT1VSID0gMztcbiAgICB2YXIgTUlOVVRFID0gNDtcbiAgICB2YXIgU0VDT05EID0gNTtcbiAgICB2YXIgTUlMTElTRUNPTkQgPSA2O1xuICAgIHZhciBXRUVLID0gNztcbiAgICB2YXIgV0VFS0RBWSA9IDg7XG5cbiAgICB2YXIgaW5kZXhPZjtcblxuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAvLyBJIGtub3dcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoICsgMSwgMCkpLmdldFVUQ0RhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbW9udGgnLCAnTScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU0nLCAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgTU9OVEhTX0lOX0ZPUk1BVCA9IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMrKStNTU1NPy87XG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHMgKG0sIGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpID8gdGhpcy5fbW9udGhzW20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzW01PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCA9ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydCAobSwgZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bml0c19tb250aF9faGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRocyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuaXRzX21vbnRoX19oYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlclxuICAgICAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NJyAmJiB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc2V0TW9udGggKG1vbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksIGRheXNJbk1vbnRoKG1vbS55ZWFyKCksIHZhbHVlKSk7XG4gICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TW9udGggKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0X3NldF9fZ2V0KHRoaXMsICdNb250aCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSwgbW9tO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93IChtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdztcbiAgICAgICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XG4gICAgICAgICAgICAgICAgYVtEQVRFXSAgICAgICAgPCAxIHx8IGFbREFURV0gICAgICAgID4gZGF5c0luTW9udGgoYVtZRUFSXSwgYVtNT05USF0pID8gREFURSA6XG4gICAgICAgICAgICAgICAgYVtIT1VSXSAgICAgICAgPCAwIHx8IGFbSE9VUl0gICAgICAgID4gMjQgfHwgKGFbSE9VUl0gPT09IDI0ICYmIChhW01JTlVURV0gIT09IDAgfHwgYVtTRUNPTkRdICE9PSAwIHx8IGFbTUlMTElTRUNPTkRdICE9PSAwKSkgPyBIT1VSIDpcbiAgICAgICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxuICAgICAgICAgICAgICAgIGFbU0VDT05EXSAgICAgIDwgMCB8fCBhW1NFQ09ORF0gICAgICA+IDU5ICA/IFNFQ09ORCA6XG4gICAgICAgICAgICAgICAgYVtNSUxMSVNFQ09ORF0gPCAwIHx8IGFbTUlMTElTRUNPTkRdID4gOTk5ID8gTUlMTElTRUNPTkQgOlxuICAgICAgICAgICAgICAgIC0xO1xuXG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtzICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFSztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla2RheSAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUtEQVk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLy8gaXNvIDg2MDEgcmVnZXhcbiAgICAvLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbiAgICB2YXIgZXh0ZW5kZWRJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSktKD86XFxkXFxkLVxcZFxcZHxXXFxkXFxkLVxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OjpcXGRcXGQoPzo6XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8vO1xuICAgIHZhciBiYXNpY0lzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KSg/OlxcZFxcZFxcZFxcZHxXXFxkXFxkXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86XFxkXFxkKD86XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8vO1xuXG4gICAgdmFyIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy87XG5cbiAgICB2YXIgaXNvRGF0ZXMgPSBbXG4gICAgICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGRcXGQtXFxkL10sXG4gICAgICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgICAgIFsnWVlZWS1NTScsIC9cXGR7NH0tXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVlZWU1NREQnLCAvWystXVxcZHsxMH0vXSxcbiAgICAgICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAgICAgLy8gWVlZWU1NIGlzIE5PVCBhbGxvd2VkIGJ5IHRoZSBzdGFuZGFyZFxuICAgICAgICBbJ0dHR0dbV11XV0UnLCAvXFxkezR9V1xcZHszfS9dLFxuICAgICAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVlEREQnLCAvXFxkezd9L11cbiAgICBdO1xuXG4gICAgLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xuICAgIHZhciBpc29UaW1lcyA9IFtcbiAgICAgICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgWydISG1tc3MsU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGQsXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIJywgL1xcZFxcZC9dXG4gICAgXTtcblxuICAgIHZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgbCxcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIG1hdGNoID0gZXh0ZW5kZWRJc29SZWdleC5leGVjKHN0cmluZykgfHwgYmFzaWNJc29SZWdleC5leGVjKHN0cmluZyksXG4gICAgICAgICAgICBhbGxvd1RpbWUsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaXNvID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29EYXRlc1tpXVsxXS5leGVjKG1hdGNoWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlRm9ybWF0ID0gaXNvRGF0ZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGFsbG93VGltZSA9IGlzb0RhdGVzW2ldWzJdICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMobWF0Y2hbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aW1lRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdCBvciBmYWxsYmFja1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcblxuICAgICAgICBpZiAobWF0Y2hlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK21hdGNoZWRbMV0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUuIFRoaXMgaXMgJyArXG4gICAgICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHVwY29taW5nIG1ham9yICcgK1xuICAgICAgICAncmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvICcgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MDcgZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vY2FuJ3QganVzdCBhcHBseSgpIHRvIGNyZWF0ZSBhIGRhdGU6XG4gICAgICAgIC8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODEzNDgvaW5zdGFudGlhdGluZy1hLWphdmFzY3JpcHQtb2JqZWN0LWJ5LWNhbGxpbmctcHJvdG90eXBlLWNvbnN0cnVjdG9yLWFwcGx5XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuXG4gICAgICAgIC8vdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCAmJiBpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQ0RhdGUgKHkpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcblxuICAgICAgICAvL3RoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwICYmIGlzRmluaXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1knLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy55ZWFyKCk7XG4gICAgICAgIHJldHVybiB5IDw9IDk5OTkgPyAnJyArIHkgOiAnKycgKyB5O1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsICAgNF0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsICA1XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1knLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWScsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWScsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gaW5wdXQubGVuZ3RoID09PSAyID8gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRvSW50KGlucHV0KSArICh0b0ludChpbnB1dCkgPiA2OCA/IDE5MDAgOiAyMDAwKTtcbiAgICB9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFllYXIgPSBtYWtlR2V0U2V0KCdGdWxsWWVhcicsIHRydWUpO1xuXG4gICAgZnVuY3Rpb24gZ2V0SXNMZWFwWWVhciAoKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbiAgICB9XG5cbiAgICAvLyBzdGFydC1vZi1maXJzdC13ZWVrIC0gc3RhcnQtb2YteWVhclxuICAgIGZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXG4gICAgICAgICAgICBmd2QgPSA3ICsgZG93IC0gZG95LFxuICAgICAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICAgICAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuXG4gICAgICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xuICAgIH1cblxuICAgIC8vaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgICAgICByZXNZZWFyLCByZXNEYXlPZlllYXI7XG5cbiAgICAgICAgaWYgKGRheU9mWWVhciA8PSAwKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciAtIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlzSW5ZZWFyKHJlc1llYXIpICsgZGF5T2ZZZWFyO1xuICAgICAgICB9IGVsc2UgaWYgKGRheU9mWWVhciA+IGRheXNJblllYXIoeWVhcikpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyICsgMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhciAtIGRheXNJblllYXIoeWVhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhcjtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyLFxuICAgICAgICAgICAgZGF5T2ZZZWFyOiByZXNEYXlPZlllYXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrT2ZZZWFyKG1vbSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQobW9tLnllYXIoKSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2VlayA9IE1hdGguZmxvb3IoKG1vbS5kYXlPZlllYXIoKSAtIHdlZWtPZmZzZXQgLSAxKSAvIDcpICsgMSxcbiAgICAgICAgICAgIHJlc1dlZWssIHJlc1llYXI7XG5cbiAgICAgICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayArIHdlZWtzSW5ZZWFyKHJlc1llYXIsIGRvdywgZG95KTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2VlazogcmVzV2VlayxcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0TmV4dCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyICsgMSwgZG93LCBkb3kpO1xuICAgICAgICByZXR1cm4gKGRheXNJblllYXIoeWVhcikgLSB3ZWVrT2Zmc2V0ICsgd2Vla09mZnNldE5leHQpIC8gNztcbiAgICB9XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgICAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZSh1dGlsc19ob29rc19faG9va3Mubm93KCkpO1xuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0VVRDRnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0VVRDTW9udGgoKSwgbm93VmFsdWUuZ2V0VVRDRGF0ZSgpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXG4gICAgLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbiAgICAvLyBub3RlOiBhbGwgdmFsdWVzIHBhc3QgdGhlIHllYXIgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGxvd2VzdCBwb3NzaWJsZSB2YWx1ZS5cbiAgICAvLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tQXJyYXkgKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgZGF0ZSwgaW5wdXQgPSBbXSwgY3VycmVudERhdGUsIHllYXJUb1VzZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcblxuICAgICAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgICAgIGlmIChjb25maWcuX3cgJiYgY29uZmlnLl9hW0RBVEVdID09IG51bGwgJiYgY29uZmlnLl9hW01PTlRIXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdGhlIGRheSBvZiB0aGUgeWVhciBpcyBzZXQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihsb2NhbF9fY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhcik7XG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAxIHx8IHdlZWtkYXkgPiA3KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcblxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIobG9jYWxfX2NyZWF0ZUxvY2FsKCksIGRvdywgZG95KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIDEpO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdlZWsgPCAxIHx8IHdlZWsgPiB3ZWVrc0luWWVhcih3ZWVrWWVhciwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtkYXkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbiAgICB1dGlsc19ob29rc19faG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgICAgICBpZiAoY29uZmlnLl9mID09PSB1dGlsc19ob29rc19faG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICAgICAgaSwgcGFyc2VkSW5wdXQsIHRva2VucywgdG9rZW4sIHNraXBwZWQsXG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDA7XG5cbiAgICAgICAgdG9rZW5zID0gZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3Rva2VuJywgdG9rZW4sICdwYXJzZWRJbnB1dCcsIHBhcnNlZElucHV0LFxuICAgICAgICAgICAgLy8gICAgICAgICAncmVnZXgnLCBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPSBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xuICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgICAgICBpZiAoIXZhbGlkX19pc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICBpZiAoc2NvcmVUb0JlYXQgPT0gbnVsbCB8fCBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSk7XG4gICAgICAgIGNvbmZpZy5fYSA9IG1hcChbaS55ZWFyLCBpLm1vbnRoLCBpLmRheSB8fCBpLmRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xuXG4gICAgICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkX19jcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXZhbGlkX19pc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgICAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUodXRpbHNfaG9va3NfX2hvb2tzLm5vdygpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dC52YWx1ZU9mKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoaW5wdXQpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uZmlnRnJvbU9iamVjdChjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpbnB1dCkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgaXNVVEMpIHtcbiAgICAgICAgdmFyIGMgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mKGxvY2FsZSkgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgICAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgICAgICBjLl9sID0gbG9jYWxlO1xuICAgICAgICBjLl9pID0gaW5wdXQ7XG4gICAgICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgICAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbF9fY3JlYXRlTG9jYWwgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvdHlwZU1pbiA9IGRlcHJlY2F0ZShcbiAgICAgICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE1NDgnLFxuICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgIHZhciBvdGhlciA9IGxvY2FsX19jcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRfX2NyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICk7XG5cbiAgICB2YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNTQ4JyxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkX19jcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXggKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG4gICAgfVxuXG4gICAgdmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICsobmV3IERhdGUoKSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICAvLyByZXByZXNlbnRhdGlvbiBmb3IgZGF0ZUFkZFJlbW92ZVxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHNlY29uZHMgKiAxZTMgKyAvLyAxMDAwXG4gICAgICAgICAgICBtaW51dGVzICogNmU0ICsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBob3VycyAqIDEwMDAgKiA2MCAqIDYwOyAvL3VzaW5nIDEwMDAgKiA2MCAqIDYwIGluc3RlYWQgb2YgMzZlNSB0byBhdm9pZCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzI5NzhcbiAgICAgICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcbiAgICAgICAgICAgIHdlZWtzICogNztcbiAgICAgICAgLy8gSXQgaXMgaW1wb3NzaWJsZSB0cmFuc2xhdGUgbW9udGhzIGludG8gZGF5cyB3aXRob3V0IGtub3dpbmdcbiAgICAgICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAgICAgLy8gaXQgc2VwYXJhdGVseS5cbiAgICAgICAgdGhpcy5fbW9udGhzID0gK21vbnRocyArXG4gICAgICAgICAgICBxdWFydGVycyAqIDMgK1xuICAgICAgICAgICAgeWVhcnMgKiAxMjtcblxuICAgICAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAgICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSgpO1xuXG4gICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBzaWduID0gJysnO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2lnbiArIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgKyBzZXBhcmF0b3IgKyB6ZXJvRmlsbCh+fihvZmZzZXQpICUgNjAsIDIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvZmZzZXQoJ1onLCAnOicpO1xuICAgIG9mZnNldCgnWlonLCAnJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdaJywgIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIHRpbWV6b25lIGNodW5rZXJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbiAgICAvLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbiAgICB2YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9ICgoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKSB8fCBbXSk7XG4gICAgICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgICAgICB2YXIgcGFydHMgICA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgICAgIHZhciBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgICAgICByZXR1cm4gcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPSAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgPyBpbnB1dC52YWx1ZU9mKCkgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLnZhbHVlT2YoKSkgLSByZXMudmFsdWVPZigpO1xuICAgICAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICAgICAgcmVzLl9kLnNldFRpbWUocmVzLl9kLnZhbHVlT2YoKSArIGRpZmYpO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldCAobSkge1xuICAgICAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICAgICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDE1KSAqIDE1O1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4gICAgLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbiAgICAvLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4gICAgLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuICAgIC8vXG4gICAgLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4gICAgLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4gICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuICAgIC8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG4gICAgZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICBsb2NhbEFkanVzdDtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksIDEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRab25lIChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvVVRDIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90em0pIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChvZmZzZXRGcm9tU3RyaW5nKG1hdGNoT2Zmc2V0LCB0aGlzLl9pKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzQWxpZ25lZEhvdXJPZmZzZXQgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IGlucHV0ID8gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCAoKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICAgICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICAgICAgaWYgKGMuX2EpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKGMuX2EpIDogbG9jYWxfX2NyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTG9jYWwgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGMgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbiAgICB2YXIgYXNwTmV0UmVnZXggPSAvXihcXC0pPyg/OihcXGQqKVsuIF0pPyhcXGQrKVxcOihcXGQrKSg/OlxcOihcXGQrKVxcLj8oXFxkezN9KT9cXGQqKT8kLztcblxuICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgIC8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbiAgICB2YXIgaXNvUmVnZXggPSAvXigtKT9QKD86KC0/WzAtOSwuXSopWSk/KD86KC0/WzAtOSwuXSopTSk/KD86KC0/WzAtOSwuXSopVyk/KD86KC0/WzAtOSwuXSopRCk/KD86VCg/OigtP1swLTksLl0qKUgpPyg/OigtP1swLTksLl0qKU0pPyg/OigtP1swLTksLl0qKVMpPyk/JC87XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uIChpbnB1dCwga2V5KSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGlucHV0LFxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgICAgIHNpZ24sXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBkaWZmUmVzO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbXMgOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICAgIGQgIDogaW5wdXQuX2RheXMsXG4gICAgICAgICAgICAgICAgTSAgOiBpbnB1dC5fbW9udGhzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgIDogMCxcbiAgICAgICAgICAgICAgICBkICA6IHRvSW50KG1hdGNoW0RBVEVdKSAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbSAgOiB0b0ludChtYXRjaFtNSU5VVEVdKSAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBzICA6IHRvSW50KG1hdGNoW1NFQ09ORF0pICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG1zIDogdG9JbnQobWF0Y2hbTUlMTElTRUNPTkRdKSAqIHNpZ25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5IDogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIE0gOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgdyA6IHBhcnNlSXNvKG1hdGNoWzRdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBkIDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGggOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgbSA6IHBhcnNlSXNvKG1hdGNoWzddLCBzaWduKSxcbiAgICAgICAgICAgICAgICBzIDogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09IG51bGwpIHsvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiYgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgZGlmZlJlcyA9IG1vbWVudHNEaWZmZXJlbmNlKGxvY2FsX19jcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSwgbG9jYWxfX2NyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKSk7XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJc28gKGlucCwgc2lnbikge1xuICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzID0ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcblxuICAgICAgICByZXMubW9udGhzID0gb3RoZXIubW9udGgoKSAtIGJhc2UubW9udGgoKSArXG4gICAgICAgICAgICAob3RoZXIueWVhcigpIC0gYmFzZS55ZWFyKCkpICogMTI7XG4gICAgICAgIGlmIChiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykuaXNBZnRlcihvdGhlcikpIHtcbiAgICAgICAgICAgIC0tcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSArb3RoZXIgLSArKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBpZiAoIShiYXNlLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcbiAgICAgICAgaWYgKGJhc2UuaXNCZWZvcmUob3RoZXIpKSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2Uob3RoZXIsIGJhc2UpO1xuICAgICAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9IC1yZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNSb3VuZCAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgJ25hbWUnIGFyZyBhZnRlciBkZXByZWNhdGlvbiBpcyByZW1vdmVkXG4gICAgZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHZhciBkdXIsIHRtcDtcbiAgICAgICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxuICAgICAgICAgICAgaWYgKHBlcmlvZCAhPT0gbnVsbCAmJiAhaXNOYU4oK3BlcmlvZCkpIHtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUobmFtZSwgJ21vbWVudCgpLicgKyBuYW1lICArICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArIG5hbWUgKyAnKG51bWJlciwgcGVyaW9kKS4nKTtcbiAgICAgICAgICAgICAgICB0bXAgPSB2YWw7IHZhbCA9IHBlcmlvZDsgcGVyaW9kID0gdG1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/ICt2YWwgOiB2YWw7XG4gICAgICAgICAgICBkdXIgPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgICAgIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCAobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGRheXMgPSBhYnNSb3VuZChkdXJhdGlvbi5fZGF5cyksXG4gICAgICAgICAgICBtb250aHMgPSBhYnNSb3VuZChkdXJhdGlvbi5fbW9udGhzKTtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUobW9tLl9kLnZhbHVlT2YoKSArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgZ2V0X3NldF9fc2V0KG1vbSwgJ0RhdGUnLCBnZXRfc2V0X19nZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldF9zZXRfX2dldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkX3N1YnRyYWN0X19hZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbiAgICB2YXIgYWRkX3N1YnRyYWN0X19zdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuICAgIGZ1bmN0aW9uIG1vbWVudF9jYWxlbmRhcl9fY2FsZW5kYXIgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGxvY2FsX19jcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmKHNvZCwgJ2RheXMnLCB0cnVlKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGRpZmYgPCAtNiA/ICdzYW1lRWxzZScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAtMSA/ICdsYXN0V2VlaycgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMSA/ICdzYW1lRGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDIgPyAnbmV4dERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdHMgJiYgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKSA/IGZvcm1hdHNbZm9ybWF0XSgpIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQob3V0cHV0IHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgbG9jYWxfX2NyZWF0ZUxvY2FsKG5vdykpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPiBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKCFpc1VuZGVmaW5lZCh1bml0cykgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JldHdlZW4gKGZyb20sIHRvLCB1bml0cywgaW5jbHVzaXZpdHkpIHtcbiAgICAgICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgICAgICByZXR1cm4gKGluY2x1c2l2aXR5WzBdID09PSAnKCcgPyB0aGlzLmlzQWZ0ZXIoZnJvbSwgdW5pdHMpIDogIXRoaXMuaXNCZWZvcmUoZnJvbSwgdW5pdHMpKSAmJlxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKScgPyB0aGlzLmlzQmVmb3JlKHRvLCB1bml0cykgOiAhdGhpcy5pc0FmdGVyKHRvLCB1bml0cykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICAgICAgaW5wdXRNcztcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyB8fCAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCx1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQsXG4gICAgICAgICAgICB6b25lRGVsdGEsXG4gICAgICAgICAgICBkZWx0YSwgb3V0cHV0O1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICd5ZWFyJyB8fCB1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgICAgICBvdXRwdXQgPSB1bml0cyA9PT0gJ3NlY29uZCcgPyBkZWx0YSAvIDFlMyA6IC8vIDEwMDBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ21pbnV0ZScgPyBkZWx0YSAvIDZlNCA6IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnaG91cicgPyBkZWx0YSAvIDM2ZTUgOiAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnZGF5JyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA4NjRlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ3dlZWsnID8gKGRlbHRhIC0gem9uZURlbHRhKSAvIDYwNDhlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgZGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoRGlmZiAoYSwgYikge1xuICAgICAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgICAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xuXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jaGVjayBmb3IgbmVnYXRpdmUgemVybywgcmV0dXJuIHplcm8gaWYgbmVnYXRpdmUgemVyb1xuICAgICAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfZm9ybWF0X190b0lTT1N0cmluZyAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5jbG9uZSgpLnV0YygpO1xuICAgICAgICBpZiAoMCA8IG0ueWVhcigpICYmIG0ueWVhcigpIDw9IDk5OTkpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQgKGlucHV0U3RyaW5nKSB7XG4gICAgICAgIGlmICghaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgICAgIGlucHV0U3RyaW5nID0gdGhpcy5pc1V0YygpID8gdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXRVdGMgOiB1dGlsc19ob29rc19faG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgIGxvY2FsX19jcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20obG9jYWxfX2NyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgIGxvY2FsX19jcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih7ZnJvbTogdGhpcywgdG86IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b05vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy50byhsb2NhbF9fY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuICAgIC8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgZnVuY3Rpb24gbG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TG9jYWxlRGF0YSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydE9mICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBzd2l0Y2ggaW50ZW50aW9uYWxseSBvbWl0cyBicmVhayBrZXl3b3Jkc1xuICAgICAgICAvLyB0byB1dGlsaXplIGZhbGxpbmcgdGhyb3VnaCB0aGUgY2FzZXMuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICB0aGlzLm1vbnRoKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgdGhpcy5kYXRlKDEpO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgdGhpcy5ob3VycygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICB0aGlzLm1pbnV0ZXMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICB0aGlzLnNlY29uZHMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlZWtzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgICAgICBpZiAodW5pdHMgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ2lzb1dlZWsnKSB7XG4gICAgICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBxdWFydGVycyBhcmUgYWxzbyBzcGVjaWFsXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICB0aGlzLm1vbnRoKE1hdGguZmxvb3IodGhpcy5tb250aCgpIC8gMykgKiAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ2RhdGUnIGlzIGFuIGFsaWFzIGZvciAnZGF5Jywgc28gaXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgc3VjaC5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgIHVuaXRzID0gJ2RheSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mKHVuaXRzKS5hZGQoMSwgKHVuaXRzID09PSAnaXNvV2VlaycgPyAnd2VlaycgOiB1bml0cykpLnN1YnRyYWN0KDEsICdtcycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvX3R5cGVfX3ZhbHVlT2YgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAoKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bml4ICgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkgLyAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0RhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0ID8gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpIDogdGhpcy5fZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b09iamVjdCAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfdmFsaWRfX2lzVmFsaWQgKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRfX2lzVmFsaWQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2luZ0ZsYWdzICgpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQgKCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0aW9uRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLl9pLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLl9mLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgICAgICBpc1VUQzogdGhpcy5faXNVVEMsXG4gICAgICAgICAgICBzdHJpY3Q6IHRoaXMuX3N0cmljdFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuICh0b2tlbiwgZ2V0dGVyKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbiAgICB9XG5cbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHRycsICAnaXNvV2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdnJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsIHRoaXMuaXNvV2VlaygpLCB0aGlzLmlzb1dlZWtkYXkoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIgKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFySGVscGVyKGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla3NUYXJnZXQ7XG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Vla09mWWVhcih0aGlzLCBkb3csIGRveSkueWVhcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdlZWtzVGFyZ2V0ID0gd2Vla3NJblllYXIoaW5wdXQsIGRvdywgZG95KTtcbiAgICAgICAgICAgIGlmICh3ZWVrID4gd2Vla3NUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB3ZWVrID0gd2Vla3NUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2V0V2Vla0FsbC5jYWxsKHRoaXMsIGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRXZWVrQWxsKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoZGF5T2ZZZWFyRGF0YS55ZWFyLCAwLCBkYXlPZlllYXJEYXRhLmRheU9mWWVhcik7XG5cbiAgICAgICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICAgICAgdGhpcy5kYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9ICh0b0ludChpbnB1dCkgLSAxKSAqIDM7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRRdWFydGVyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd3JywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsgKG1vbSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID8gbG9jYWxlLl9vcmRpbmFsUGFyc2UgOiBsb2NhbGUuX29yZGluYWxQYXJzZUxlbmllbnQ7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnRCcsICdERCddLCBEQVRFKTtcbiAgICBhZGRQYXJzZVRva2VuKCdEbycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbREFURV0gPSB0b0ludChpbnB1dC5tYXRjaChtYXRjaDF0bzIpWzBdLCAxMCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkJywgMCwgJ2RvJywgJ2RheScpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xuICAgIGFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrZGF5JywgJ0UnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2QnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2UnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0UnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2RkJywgJ2RkZCcsICdkZGRkJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgd2Vla2RheSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgICAgICBpZiAod2Vla2RheSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3ZWVrLmQgPSB3ZWVrZGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZFdlZWtkYXkgPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkJywgJ2UnLCAnRSddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID0gJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzIChtLCBmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXNbbS5kYXkoKV0gOlxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbdGhpcy5fd2Vla2RheXMuaXNGb3JtYXQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20uZGF5KCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydCAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlfb2Zfd2Vla19faGFuZGxlU3RyaWN0UGFyc2Uod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSB3ZWVrZGF5TmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzUGFyc2UgKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZGF5X29mX3dlZWtfX2hhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgd2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG5cbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkZCcgJiYgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZCcgJiYgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZCcgJiYgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gdGhpcy5kYXkoKSB8fCA3IDogdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyBpbnB1dCA6IGlucHV0IC0gNyk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzTWluUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlICgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pblBpZWNlcyA9IFtdLCBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgICAgICBpLCBtb20sIG1pbnAsIHNob3J0cCwgbG9uZ3A7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgbWlucCA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICBzaG9ydHAgPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICBsb25ncCA9IHRoaXMud2Vla2RheXMobW9tLCAnJyk7XG4gICAgICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaW5QaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0RERCcsICBtYXRjaDF0bzMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBoRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga0Zvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbSAodG9rZW4sIGxvd2VyY2FzZSkge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKHRoaXMuaG91cnMoKSwgdGhpcy5taW51dGVzKCksIGxvd2VyY2FzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1lcmlkaWVtKCdhJywgdHJ1ZSk7XG4gICAgbWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbSAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xuICAgIH1cblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignaCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkUmVnZXhUb2tlbignaG1tJywgbWF0Y2gzdG80KTtcbiAgICBhZGRSZWdleFRva2VuKCdobW1zcycsIG1hdGNoNXRvNik7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tJywgbWF0Y2gzdG80KTtcbiAgICBhZGRSZWdleFRva2VuKCdIbW1zcycsIG1hdGNoNXRvNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnSCcsICdISCddLCBIT1VSKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2lzUG0gPSBjb25maWcuX2xvY2FsZS5pc1BNKGlucHV0KTtcbiAgICAgICAgY29uZmlnLl9tZXJpZGllbSA9IGlucHV0O1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oWydoJywgJ2hoJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignaG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignaG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgICAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICAgICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUlzUE0gKGlucHV0KSB7XG4gICAgICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAgICAgLy8gVXNpbmcgY2hhckF0IHNob3VsZCBiZSBtb3JlIGNvbXBhdGlibGUuXG4gICAgICAgIHJldHVybiAoKGlucHV0ICsgJycpLnRvTG93ZXJDYXNlKCkuY2hhckF0KDApID09PSAncCcpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSA9IC9bYXBdXFwuP20/XFwuPy9pO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1lcmlkaWVtIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xuICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncG0nIDogJ1BNJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIC8vIFNldHRpbmcgdGhlIGhvdXIgc2hvdWxkIGtlZXAgdGhlIHRpbWUsIGJlY2F1c2UgdGhlIHVzZXIgZXhwbGljaXRseVxuICAgIC8vIHNwZWNpZmllZCB3aGljaCBob3VyIGhlIHdhbnRzLiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cbiAgICAvLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbiAgICAvLyB0aGlzIHJ1bGUuXG4gICAgdmFyIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ20nLCBbJ21tJywgMl0sIDAsICdtaW51dGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWludXRlJywgJ20nKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ20nLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigncycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG4gICAgfSk7XG5cblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1MnLCAgICBtYXRjaDF0bzMsIG1hdGNoMSk7XG4gICAgYWRkUmVnZXhUb2tlbignU1MnLCAgIG1hdGNoMXRvMywgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdTU1MnLCAgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuXG4gICAgdmFyIHRva2VuO1xuICAgIGZvciAodG9rZW4gPSAnU1NTUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xuICAgIH1cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWlsbGlzZWNvbmQgPSBtYWtlR2V0U2V0KCdNaWxsaXNlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigneicsICAwLCAwLCAnem9uZUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFpvbmVBYmJyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRab25lTmFtZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZScgOiAnJztcbiAgICB9XG5cbiAgICB2YXIgbW9tZW50UHJvdG90eXBlX19wcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmFkZCAgICAgICAgICAgICAgID0gYWRkX3N1YnRyYWN0X19hZGQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jYWxlbmRhciAgICAgICAgICA9IG1vbWVudF9jYWxlbmRhcl9fY2FsZW5kYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jbG9uZSAgICAgICAgICAgICA9IGNsb25lO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGlmZiAgICAgICAgICAgICAgPSBkaWZmO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZW5kT2YgICAgICAgICAgICAgPSBlbmRPZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZvcm1hdCAgICAgICAgICAgID0gZm9ybWF0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZnJvbSAgICAgICAgICAgICAgPSBmcm9tO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZnJvbU5vdyAgICAgICAgICAgPSBmcm9tTm93O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG8gICAgICAgICAgICAgICAgPSB0bztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvTm93ICAgICAgICAgICAgID0gdG9Ob3c7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5nZXQgICAgICAgICAgICAgICA9IGdldFNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmludmFsaWRBdCAgICAgICAgID0gaW52YWxpZEF0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNBZnRlciAgICAgICAgICAgPSBpc0FmdGVyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNCZWZvcmUgICAgICAgICAgPSBpc0JlZm9yZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQmV0d2VlbiAgICAgICAgID0gaXNCZXR3ZWVuO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNTYW1lICAgICAgICAgICAgPSBpc1NhbWU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1NhbWVPckFmdGVyICAgICA9IGlzU2FtZU9yQWZ0ZXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1NhbWVPckJlZm9yZSAgICA9IGlzU2FtZU9yQmVmb3JlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNWYWxpZCAgICAgICAgICAgPSBtb21lbnRfdmFsaWRfX2lzVmFsaWQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sYW5nICAgICAgICAgICAgICA9IGxhbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbGUgICAgICAgICAgICA9IGxvY2FsZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxvY2FsZURhdGEgICAgICAgID0gbG9jYWxlRGF0YTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1heCAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWF4O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWluICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNaW47XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5wYXJzaW5nRmxhZ3MgICAgICA9IHBhcnNpbmdGbGFncztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNldCAgICAgICAgICAgICAgID0gZ2V0U2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc3RhcnRPZiAgICAgICAgICAgPSBzdGFydE9mO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc3VidHJhY3QgICAgICAgICAgPSBhZGRfc3VidHJhY3RfX3N1YnRyYWN0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9BcnJheSAgICAgICAgICAgPSB0b0FycmF5O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9PYmplY3QgICAgICAgICAgPSB0b09iamVjdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvRGF0ZSAgICAgICAgICAgID0gdG9EYXRlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9JU09TdHJpbmcgICAgICAgPSBtb21lbnRfZm9ybWF0X190b0lTT1N0cmluZztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvSlNPTiAgICAgICAgICAgID0gdG9KU09OO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9TdHJpbmcgICAgICAgICAgPSB0b1N0cmluZztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnVuaXggICAgICAgICAgICAgID0gdW5peDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnZhbHVlT2YgICAgICAgICAgID0gdG9fdHlwZV9fdmFsdWVPZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmNyZWF0aW9uRGF0YSAgICAgID0gY3JlYXRpb25EYXRhO1xuXG4gICAgLy8gWWVhclxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ueWVhciAgICAgICA9IGdldFNldFllYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcblxuICAgIC8vIFdlZWsgWWVhclxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla1llYXIgICAgPSBnZXRTZXRXZWVrWWVhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG5cbiAgICAvLyBRdWFydGVyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5xdWFydGVyID0gbW9tZW50UHJvdG90eXBlX19wcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XG5cbiAgICAvLyBNb250aFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubW9udGggICAgICAgPSBnZXRTZXRNb250aDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG5cbiAgICAvLyBXZWVrXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla3MgICAgICAgID0gZ2V0U2V0V2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWsgICAgICAgID0gbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrcyAgICAgPSBnZXRTZXRJU09XZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla3NJblllYXIgICAgPSBnZXRXZWVrc0luWWVhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG5cbiAgICAvLyBEYXlcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRhdGUgICAgICAgPSBnZXRTZXREYXlPZk1vbnRoO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5ICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5cyAgICAgICAgICAgICA9IGdldFNldERheU9mV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtkYXkgICAgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5T2ZZZWFyICA9IGdldFNldERheU9mWWVhcjtcblxuICAgIC8vIEhvdXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhvdXIgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcblxuICAgIC8vIE1pbnV0ZVxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWludXRlID0gbW9tZW50UHJvdG90eXBlX19wcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuXG4gICAgLy8gU2Vjb25kXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zZWNvbmQgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG5cbiAgICAvLyBNaWxsaXNlY29uZFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWlsbGlzZWNvbmQgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuXG4gICAgLy8gT2Zmc2V0XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbCAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvTG9jYWw7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzRFNUICAgICAgICAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0RTVFNoaWZ0ZWQgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzTG9jYWwgICAgICAgICAgICAgID0gaXNMb2NhbDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVXRjT2Zmc2V0ICAgICAgICAgID0gaXNVdGNPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1V0YyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVVEMgICAgICAgICAgICAgICAgPSBpc1V0YztcblxuICAgIC8vIFRpbWV6b25lXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZU5hbWUgPSBnZXRab25lTmFtZTtcblxuICAgIC8vIERlcHJlY2F0aW9uc1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF0ZXMgID0gZGVwcmVjYXRlKCdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsIGdldFNldERheU9mTW9udGgpO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubW9udGhzID0gZGVwcmVjYXRlKCdtb250aHMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbnRoIGluc3RlYWQnLCBnZXRTZXRNb250aCk7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by55ZWFycyAgPSBkZXByZWNhdGUoJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLCBnZXRTZXRZZWFyKTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmUgICA9IGRlcHJlY2F0ZSgnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNzc5JywgZ2V0U2V0Wm9uZSk7XG5cbiAgICB2YXIgbW9tZW50UHJvdG90eXBlID0gbW9tZW50UHJvdG90eXBlX19wcm90bztcblxuICAgIGZ1bmN0aW9uIG1vbWVudF9fY3JlYXRlVW5peCAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCAqIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudF9fY3JlYXRlSW5ab25lICgpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XG4gICAgICAgIHNhbWVEYXkgOiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgIGxhc3REYXkgOiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgICAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlX2NhbGVuZGFyX19jYWxlbmRhciAoa2V5LCBtb20sIG5vdykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KSA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFMgIDogJ2g6bW06c3MgQScsXG4gICAgICAgIExUICAgOiAnaDptbSBBJyxcbiAgICAgICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEwgICA6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlci5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbiAgICB2YXIgZGVmYXVsdE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdCAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgICAgIHBhc3QgICA6ICclcyBhZ28nLFxuICAgICAgICBzICA6ICdhIGZldyBzZWNvbmRzJyxcbiAgICAgICAgbSAgOiAnYSBtaW51dGUnLFxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgaCAgOiAnYW4gaG91cicsXG4gICAgICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICAgICAgZCAgOiAnYSBkYXknLFxuICAgICAgICBkZCA6ICclZCBkYXlzJyxcbiAgICAgICAgTSAgOiAnYSBtb250aCcsXG4gICAgICAgIE1NIDogJyVkIG1vbnRocycsXG4gICAgICAgIHkgIDogJ2EgeWVhcicsXG4gICAgICAgIHl5IDogJyVkIHllYXJzJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZV9fcmVsYXRpdmVUaW1lIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX3JlbGF0aXZlVGltZVtzdHJpbmddO1xuICAgICAgICByZXR1cm4gKGlzRnVuY3Rpb24ob3V0cHV0KSkgP1xuICAgICAgICAgICAgb3V0cHV0KG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkgOlxuICAgICAgICAgICAgb3V0cHV0LnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFzdEZ1dHVyZSAoZGlmZiwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbZGlmZiA+IDAgPyAnZnV0dXJlJyA6ICdwYXN0J107XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGZvcm1hdCkgPyBmb3JtYXQob3V0cHV0KSA6IGZvcm1hdC5yZXBsYWNlKC8lcy9pLCBvdXRwdXQpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVfX3Byb3RvID0gTG9jYWxlLnByb3RvdHlwZTtcblxuICAgIHByb3RvdHlwZV9fcHJvdG8uX2NhbGVuZGFyICAgICAgID0gZGVmYXVsdENhbGVuZGFyO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uY2FsZW5kYXIgICAgICAgID0gbG9jYWxlX2NhbGVuZGFyX19jYWxlbmRhcjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9sb25nRGF0ZUZvcm1hdCA9IGRlZmF1bHRMb25nRGF0ZUZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX2ludmFsaWREYXRlICAgID0gZGVmYXVsdEludmFsaWREYXRlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XG4gICAgcHJvdG90eXBlX19wcm90by5fb3JkaW5hbCAgICAgICAgPSBkZWZhdWx0T3JkaW5hbDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLm9yZGluYWwgICAgICAgICA9IG9yZGluYWw7XG4gICAgcHJvdG90eXBlX19wcm90by5fb3JkaW5hbFBhcnNlICAgPSBkZWZhdWx0T3JkaW5hbFBhcnNlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucG9zdGZvcm1hdCAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3JlbGF0aXZlVGltZSAgID0gZGVmYXVsdFJlbGF0aXZlVGltZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnJlbGF0aXZlVGltZSAgICA9IHJlbGF0aXZlX19yZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG90eXBlX19wcm90by5wYXN0RnV0dXJlICAgICAgPSBwYXN0RnV0dXJlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uc2V0ICAgICAgICAgICAgID0gbG9jYWxlX3NldF9fc2V0O1xuXG4gICAgLy8gTW9udGhcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRocyAgICAgICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRocztcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9tb250aHMgICAgICAgICAgID0gZGVmYXVsdExvY2FsZU1vbnRocztcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1Nob3J0ICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1Nob3J0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX21vbnRoc1Nob3J0ICAgICAgPSBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHNQYXJzZSAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9tb250aHNSZWdleCAgICAgID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzUmVnZXggICAgICAgPSBtb250aHNSZWdleDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHNTaG9ydFJlZ2V4ICA9IG1vbnRoc1Nob3J0UmVnZXg7XG5cbiAgICAvLyBXZWVrXG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrID0gbG9jYWxlV2VlaztcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrID0gZGVmYXVsdExvY2FsZVdlZWs7XG4gICAgcHJvdG90eXBlX19wcm90by5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcblxuICAgIC8vIERheSBvZiBXZWVrXG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5cyAgICAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5cztcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5cyAgICAgID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG90eXBlX19wcm90by5fd2Vla2RheXNNaW4gICA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzU2hvcnQgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by5fd2Vla2RheXNTaG9ydCA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWtkYXlzUmVnZXggICAgICA9IGRlZmF1bHRXZWVrZGF5c1JlZ2V4O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNSZWdleCAgICAgICA9ICAgICAgICB3ZWVrZGF5c1JlZ2V4O1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c1Nob3J0UmVnZXggID0gICAgICAgIHdlZWtkYXlzU2hvcnRSZWdleDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5c01pblJlZ2V4ICAgPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzTWluUmVnZXggICAgPSAgICAgICAgd2Vla2RheXNNaW5SZWdleDtcblxuICAgIC8vIEhvdXJzXG4gICAgcHJvdG90eXBlX19wcm90by5pc1BNID0gbG9jYWxlSXNQTTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9tZXJpZGllbVBhcnNlID0gZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2U7XG4gICAgcHJvdG90eXBlX19wcm90by5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2dldCAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSgpO1xuICAgICAgICB2YXIgdXRjID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKCkuc2V0KHNldHRlciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc0ltcGwgKGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0c19fZ2V0KGZvcm1hdCwgaW5kZXgsIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBsaXN0c19fZ2V0KGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgLy8gKClcbiAgICAvLyAoNSlcbiAgICAvLyAoZm10LCA1KVxuICAgIC8vIChmbXQpXG4gICAgLy8gKHRydWUpXG4gICAgLy8gKHRydWUsIDUpXG4gICAgLy8gKHRydWUsIGZtdCwgNSlcbiAgICAvLyAodHJ1ZSwgZm10KVxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBsb2NhbGVTb3J0ZWQ7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGxvY2FsZVNvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbGUgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdHNfX2dldChmb3JtYXQsIChpbmRleCArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBsaXN0c19fZ2V0KGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdE1vbnRoc1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzU2hvcnQgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RXZWVrZGF5c01pbiAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG4gICAgfVxuXG4gICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxhbmcgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJywgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSk7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJywgbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWJzX19hYnMgKCkge1xuICAgICAgICB2YXIgZGF0YSAgICAgICAgICAgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IG1hdGhBYnModGhpcy5fbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgdGhpcy5fZGF5cyAgICAgICAgID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdGhpcy5fbW9udGhzICAgICAgID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzICA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICAgPSBtYXRoQWJzKGRhdGEuc2Vjb25kcyk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgICA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICAgICAgZGF0YS5tb250aHMgICAgICAgID0gbWF0aEFicyhkYXRhLm1vbnRocyk7XG4gICAgICAgIGRhdGEueWVhcnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCAoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZCAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX3N1YnRyYWN0IChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzQ2VpbCAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xuICAgICAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzLCBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgICAgICBpZiAoISgobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApKSkge1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgICAgICBzZWNvbmRzICAgICAgICAgICA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcblxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgPSBob3VycyAlIDI0O1xuXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICBkYXRhLmRheXMgICA9IGRheXM7XG4gICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgICAgICBkYXRhLnllYXJzICA9IHllYXJzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzVG9EYXlzIChtb250aHMpIHtcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgIHJldHVybiBtb250aHMgKiAxNDYwOTcgLyA0ODAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgICAgICB2YXIgZGF5cztcbiAgICAgICAgdmFyIG1vbnRocztcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyAgID0gdGhpcy5fZGF5cyAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XG4gICAgICAgICAgICByZXR1cm4gdW5pdHMgPT09ICdtb250aCcgPyBtb250aHMgOiBtb250aHMgLyAxMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3VyJyAgIDogcmV0dXJuIGRheXMgKiAyNCAgICArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYXNfX3ZhbHVlT2YgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xuICAgIHZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xuICAgIHZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xuICAgIHZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xuICAgIHZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xuICAgIHZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xuICAgIHZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xuICAgIHZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fZ2V0X19nZXQgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICByZXR1cm4gdGhpc1t1bml0cyArICdzJ10oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhW25hbWVdO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKTtcbiAgICB2YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xuICAgIHZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG4gICAgdmFyIGhvdXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ2hvdXJzJyk7XG4gICAgdmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbiAgICB2YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG4gICAgdmFyIHllYXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ3llYXJzJyk7XG5cbiAgICBmdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgdmFyIHRocmVzaG9sZHMgPSB7XG4gICAgICAgIHM6IDQ1LCAgLy8gc2Vjb25kcyB0byBtaW51dGVcbiAgICAgICAgbTogNDUsICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICAgICAgaDogMjIsICAvLyBob3VycyB0byBkYXlcbiAgICAgICAgZDogMjYsICAvLyBkYXlzIHRvIG1vbnRoXG4gICAgICAgIE06IDExICAgLy8gbW9udGhzIHRvIHllYXJcbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9odW1hbml6ZV9fcmVsYXRpdmVUaW1lIChwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xuICAgICAgICB2YXIgc2Vjb25kcyAgPSByb3VuZChkdXJhdGlvbi5hcygncycpKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgID0gcm91bmQoZHVyYXRpb24uYXMoJ20nKSk7XG4gICAgICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xuICAgICAgICB2YXIgZGF5cyAgICAgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKTtcbiAgICAgICAgdmFyIG1vbnRocyAgID0gcm91bmQoZHVyYXRpb24uYXMoJ00nKSk7XG4gICAgICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xuXG4gICAgICAgIHZhciBhID0gc2Vjb25kcyA8IHRocmVzaG9sZHMucyAmJiBbJ3MnLCBzZWNvbmRzXSAgfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDw9IDEgICAgICAgICAgICYmIFsnbSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8PSAxICAgICAgICAgICAmJiBbJ2gnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBob3VycyAgIDwgdGhyZXNob2xkcy5oICYmIFsnaGgnLCBob3Vyc10gICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPD0gMSAgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA8IHRocmVzaG9sZHMuZCAmJiBbJ2RkJywgZGF5c10gICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDw9IDEgICAgICAgICAgICYmIFsnTSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPCB0aHJlc2hvbGRzLk0gJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICAgICAgeWVhcnMgICA8PSAxICAgICAgICAgICAmJiBbJ3knXSAgICAgICAgICAgfHwgWyd5eScsIHllYXJzXTtcblxuICAgICAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICAgICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgICAgIGFbNF0gPSBsb2NhbGU7XG4gICAgICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9odW1hbml6ZV9fZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkICh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xuICAgICAgICB9XG4gICAgICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBodW1hbml6ZSAod2l0aFN1ZmZpeCkge1xuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIHZhciBvdXRwdXQgPSBkdXJhdGlvbl9odW1hbml6ZV9fcmVsYXRpdmVUaW1lKHRoaXMsICF3aXRoU3VmZml4LCBsb2NhbGUpO1xuXG4gICAgICAgIGlmICh3aXRoU3VmZml4KSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBsb2NhbGUucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2NhbGUucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIHZhciBpc29fc3RyaW5nX19hYnMgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nKCkge1xuICAgICAgICAvLyBmb3IgSVNPIHN0cmluZ3Mgd2UgZG8gbm90IHVzZSB0aGUgbm9ybWFsIGJ1YmJsaW5nIHJ1bGVzOlxuICAgICAgICAvLyAgKiBtaWxsaXNlY29uZHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIGhvdXJzXG4gICAgICAgIC8vICAqIGRheXMgZG8gbm90IGJ1YmJsZSBhdCBhbGxcbiAgICAgICAgLy8gICogbW9udGhzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSB5ZWFyc1xuICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gY29udGV4dC1mcmVlIGNvbnZlcnNpb24gYmV0d2VlbiBob3VycyBhbmQgZGF5c1xuICAgICAgICAvLyAodGhpbmsgb2YgY2xvY2sgY2hhbmdlcylcbiAgICAgICAgLy8gYW5kIGFsc28gbm90IGJldHdlZW4gZGF5cyBhbmQgbW9udGhzICgyOC0zMSBkYXlzIHBlciBtb250aClcbiAgICAgICAgdmFyIHNlY29uZHMgPSBpc29fc3RyaW5nX19hYnModGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDA7XG4gICAgICAgIHZhciBkYXlzICAgICAgICAgPSBpc29fc3RyaW5nX19hYnModGhpcy5fZGF5cyk7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSBpc29fc3RyaW5nX19hYnModGhpcy5fbW9udGhzKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycztcblxuICAgICAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcbiAgICAgICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIHNlY29uZHMgJT0gNjA7XG4gICAgICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyAgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuXG4gICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgIHZhciBZID0geWVhcnM7XG4gICAgICAgIHZhciBNID0gbW9udGhzO1xuICAgICAgICB2YXIgRCA9IGRheXM7XG4gICAgICAgIHZhciBoID0gaG91cnM7XG4gICAgICAgIHZhciBtID0gbWludXRlcztcbiAgICAgICAgdmFyIHMgPSBzZWNvbmRzO1xuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpO1xuXG4gICAgICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAnUDBEJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAodG90YWwgPCAwID8gJy0nIDogJycpICtcbiAgICAgICAgICAgICdQJyArXG4gICAgICAgICAgICAoWSA/IFkgKyAnWScgOiAnJykgK1xuICAgICAgICAgICAgKE0gPyBNICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChEID8gRCArICdEJyA6ICcnKSArXG4gICAgICAgICAgICAoKGggfHwgbSB8fCBzKSA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAoaCA/IGggKyAnSCcgOiAnJykgK1xuICAgICAgICAgICAgKG0gPyBtICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChzID8gcyArICdTJyA6ICcnKTtcbiAgICB9XG5cbiAgICB2YXIgZHVyYXRpb25fcHJvdG90eXBlX19wcm90byA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYWJzICAgICAgICAgICAgPSBkdXJhdGlvbl9hYnNfX2FicztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFkZCAgICAgICAgICAgID0gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGQ7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5zdWJ0cmFjdCAgICAgICA9IGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fc3VidHJhY3Q7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hcyAgICAgICAgICAgICA9IGFzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzU2Vjb25kcyAgICAgID0gYXNTZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNaW51dGVzICAgICAgPSBhc01pbnV0ZXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc0hvdXJzICAgICAgICA9IGFzSG91cnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc0RheXMgICAgICAgICA9IGFzRGF5cztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzV2Vla3MgICAgICAgID0gYXNXZWVrcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzTW9udGhzICAgICAgID0gYXNNb250aHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc1llYXJzICAgICAgICA9IGFzWWVhcnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by52YWx1ZU9mICAgICAgICA9IGR1cmF0aW9uX2FzX192YWx1ZU9mO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uX2J1YmJsZSAgICAgICAgPSBidWJibGU7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5nZXQgICAgICAgICAgICA9IGR1cmF0aW9uX2dldF9fZ2V0O1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubWlsbGlzZWNvbmRzICAgPSBtaWxsaXNlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5zZWNvbmRzICAgICAgICA9IHNlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5taW51dGVzICAgICAgICA9IG1pbnV0ZXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5ob3VycyAgICAgICAgICA9IGhvdXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uZGF5cyAgICAgICAgICAgPSBkYXlzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ud2Vla3MgICAgICAgICAgPSB3ZWVrcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1vbnRocyAgICAgICAgID0gbW9udGhzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ueWVhcnMgICAgICAgICAgPSB5ZWFycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmh1bWFuaXplICAgICAgID0gaHVtYW5pemU7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0lTT1N0cmluZyAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9TdHJpbmcgICAgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvSlNPTiAgICAgICAgID0gaXNvX3N0cmluZ19fdG9JU09TdHJpbmc7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sb2NhbGUgICAgICAgICA9IGxvY2FsZTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmxvY2FsZURhdGEgICAgID0gbG9jYWxlRGF0YTtcblxuICAgIC8vIERlcHJlY2F0aW9uc1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9Jc29TdHJpbmcgPSBkZXByZWNhdGUoJ3RvSXNvU3RyaW5nKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0b0lTT1N0cmluZygpIGluc3RlYWQgKG5vdGljZSB0aGUgY2FwaXRhbHMpJywgaXNvX3N0cmluZ19fdG9JU09TdHJpbmcpO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubGFuZyA9IGxhbmc7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCwgMTApICogMTAwMCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG5cbiAgICB1dGlsc19ob29rc19faG9va3MudmVyc2lvbiA9ICcyLjEzLjAnO1xuXG4gICAgc2V0SG9va0NhbGxiYWNrKGxvY2FsX19jcmVhdGVMb2NhbCk7XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuZm4gICAgICAgICAgICAgICAgICAgID0gbW9tZW50UHJvdG90eXBlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5taW4gICAgICAgICAgICAgICAgICAgPSBtaW47XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1heCAgICAgICAgICAgICAgICAgICA9IG1heDtcbiAgICB1dGlsc19ob29rc19faG9va3Mubm93ICAgICAgICAgICAgICAgICAgID0gbm93O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy51dGMgICAgICAgICAgICAgICAgICAgPSBjcmVhdGVfdXRjX19jcmVhdGVVVEM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnVuaXggICAgICAgICAgICAgICAgICA9IG1vbWVudF9fY3JlYXRlVW5peDtcbiAgICB1dGlsc19ob29rc19faG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdHNfX2xpc3RNb250aHM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmlzRGF0ZSAgICAgICAgICAgICAgICA9IGlzRGF0ZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubG9jYWxlICAgICAgICAgICAgICAgID0gbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZTtcbiAgICB1dGlsc19ob29rc19faG9va3MuaW52YWxpZCAgICAgICAgICAgICAgID0gdmFsaWRfX2NyZWF0ZUludmFsaWQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmR1cmF0aW9uICAgICAgICAgICAgICA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb247XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmlzTW9tZW50ICAgICAgICAgICAgICA9IGlzTW9tZW50O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5cyAgICAgICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVpvbmUgICAgICAgICAgICAgPSBtb21lbnRfX2NyZWF0ZUluWm9uZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubG9jYWxlRGF0YSAgICAgICAgICAgID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZTtcbiAgICB1dGlsc19ob29rc19faG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcbiAgICB1dGlsc19ob29rc19faG9va3MubW9udGhzU2hvcnQgICAgICAgICAgID0gbGlzdHNfX2xpc3RNb250aHNTaG9ydDtcbiAgICB1dGlsc19ob29rc19faG9va3Mud2Vla2RheXNNaW4gICAgICAgICAgID0gbGlzdHNfX2xpc3RXZWVrZGF5c01pbjtcbiAgICB1dGlsc19ob29rc19faG9va3MuZGVmaW5lTG9jYWxlICAgICAgICAgID0gZGVmaW5lTG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVMb2NhbGUgICAgICAgICAgPSB1cGRhdGVMb2NhbGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxvY2FsZXMgICAgICAgICAgICAgICA9IGxvY2FsZV9sb2NhbGVzX19saXN0TG9jYWxlcztcbiAgICB1dGlsc19ob29rc19faG9va3Mud2Vla2RheXNTaG9ydCAgICAgICAgID0gbGlzdHNfX2xpc3RXZWVrZGF5c1Nob3J0O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5ub3JtYWxpemVVbml0cyAgICAgICAgPSBub3JtYWxpemVVbml0cztcbiAgICB1dGlsc19ob29rc19faG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZHVyYXRpb25faHVtYW5pemVfX2dldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcbiAgICB1dGlsc19ob29rc19faG9va3MucHJvdG90eXBlICAgICAgICAgICAgID0gbW9tZW50UHJvdG90eXBlO1xuXG4gICAgdmFyIF9tb21lbnQgPSB1dGlsc19ob29rc19faG9va3M7XG5cbiAgICByZXR1cm4gX21vbWVudDtcblxufSkpOyIsIlwidXNlIHN0cmljdFwiO1xudmFyIHdpbmRvdyA9IHJlcXVpcmUoXCJnbG9iYWwvd2luZG93XCIpXG52YXIgb25jZSA9IHJlcXVpcmUoXCJvbmNlXCIpXG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoXCJpcy1mdW5jdGlvblwiKVxudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoXCJwYXJzZS1oZWFkZXJzXCIpXG52YXIgeHRlbmQgPSByZXF1aXJlKFwieHRlbmRcIilcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVYSFJcbmNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCB8fCBub29wXG5jcmVhdGVYSFIuWERvbWFpblJlcXVlc3QgPSBcIndpdGhDcmVkZW50aWFsc1wiIGluIChuZXcgY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0KCkpID8gY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0IDogd2luZG93LlhEb21haW5SZXF1ZXN0XG5cbmZvckVhY2hBcnJheShbXCJnZXRcIiwgXCJwdXRcIiwgXCJwb3N0XCIsIFwicGF0Y2hcIiwgXCJoZWFkXCIsIFwiZGVsZXRlXCJdLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBjcmVhdGVYSFJbbWV0aG9kID09PSBcImRlbGV0ZVwiID8gXCJkZWxcIiA6IG1ldGhvZF0gPSBmdW5jdGlvbih1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVYSFIob3B0aW9ucylcbiAgICB9XG59KVxuXG5mdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRvcihhcnJheVtpXSlcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHkob2JqKXtcbiAgICBmb3IodmFyIGkgaW4gb2JqKXtcbiAgICAgICAgaWYob2JqLmhhc093blByb3BlcnR5KGkpKSByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHBhcmFtcyA9IHVyaVxuXG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICAgIGlmICh0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7dXJpOnVyaX1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtcyA9IHh0ZW5kKG9wdGlvbnMsIHt1cmk6IHVyaX0pXG4gICAgfVxuXG4gICAgcGFyYW1zLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICByZXR1cm4gcGFyYW1zXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVhIUih1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgb3B0aW9ucyA9IGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICByZXR1cm4gX2NyZWF0ZVhIUihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlWEhSKG9wdGlvbnMpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrXG4gICAgaWYodHlwZW9mIGNhbGxiYWNrID09PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FsbGJhY2sgYXJndW1lbnQgbWlzc2luZ1wiKVxuICAgIH1cbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spXG5cbiAgICBmdW5jdGlvbiByZWFkeXN0YXRlY2hhbmdlKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIGxvYWRGdW5jKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJvZHkoKSB7XG4gICAgICAgIC8vIENocm9tZSB3aXRoIHJlcXVlc3RUeXBlPWJsb2IgdGhyb3dzIGVycm9ycyBhcnJvdW5kIHdoZW4gZXZlbiB0ZXN0aW5nIGFjY2VzcyB0byByZXNwb25zZVRleHRcbiAgICAgICAgdmFyIGJvZHkgPSB1bmRlZmluZWRcblxuICAgICAgICBpZiAoeGhyLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICBib2R5ID0geGhyLnJlc3BvbnNlXG4gICAgICAgIH0gZWxzZSBpZiAoeGhyLnJlc3BvbnNlVHlwZSA9PT0gXCJ0ZXh0XCIgfHwgIXhoci5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VUZXh0IHx8IHhoci5yZXNwb25zZVhNTFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSnNvbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib2R5XG4gICAgfVxuXG4gICAgdmFyIGZhaWx1cmVSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBib2R5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogMCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICB1cmw6IHVyaSxcbiAgICAgICAgICAgICAgICByYXdSZXF1ZXN0OiB4aHJcbiAgICAgICAgICAgIH1cblxuICAgIGZ1bmN0aW9uIGVycm9yRnVuYyhldnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcilcbiAgICAgICAgaWYoIShldnQgaW5zdGFuY2VvZiBFcnJvcikpe1xuICAgICAgICAgICAgZXZ0ID0gbmV3IEVycm9yKFwiXCIgKyAoZXZ0IHx8IFwiVW5rbm93biBYTUxIdHRwUmVxdWVzdCBFcnJvclwiKSApXG4gICAgICAgIH1cbiAgICAgICAgZXZ0LnN0YXR1c0NvZGUgPSAwXG4gICAgICAgIGNhbGxiYWNrKGV2dCwgZmFpbHVyZVJlc3BvbnNlKVxuICAgIH1cblxuICAgIC8vIHdpbGwgbG9hZCB0aGUgZGF0YSAmIHByb2Nlc3MgdGhlIHJlc3BvbnNlIGluIGEgc3BlY2lhbCByZXNwb25zZSBvYmplY3RcbiAgICBmdW5jdGlvbiBsb2FkRnVuYygpIHtcbiAgICAgICAgaWYgKGFib3J0ZWQpIHJldHVyblxuICAgICAgICB2YXIgc3RhdHVzXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpXG4gICAgICAgIGlmKG9wdGlvbnMudXNlWERSICYmIHhoci5zdGF0dXM9PT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vSUU4IENPUlMgR0VUIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgZG9lc24ndCBoYXZlIGEgc3RhdHVzIGZpZWxkLCBidXQgYm9keSBpcyBmaW5lXG4gICAgICAgICAgICBzdGF0dXMgPSAyMDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXR1cyA9ICh4aHIuc3RhdHVzID09PSAxMjIzID8gMjA0IDogeGhyLnN0YXR1cylcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzcG9uc2UgPSBmYWlsdXJlUmVzcG9uc2VcbiAgICAgICAgdmFyIGVyciA9IG51bGxcblxuICAgICAgICBpZiAoc3RhdHVzICE9PSAwKXtcbiAgICAgICAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGdldEJvZHkoKSxcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXMsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgdXJsOiB1cmksXG4gICAgICAgICAgICAgICAgcmF3UmVxdWVzdDogeGhyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKXsgLy9yZW1lbWJlciB4aHIgY2FuIGluIGZhY3QgYmUgWERSIGZvciBDT1JTIGluIElFXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycyA9IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoXCJJbnRlcm5hbCBYTUxIdHRwUmVxdWVzdCBFcnJvclwiKVxuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2UsIHJlc3BvbnNlLmJvZHkpXG5cbiAgICB9XG5cbiAgICB2YXIgeGhyID0gb3B0aW9ucy54aHIgfHwgbnVsbFxuXG4gICAgaWYgKCF4aHIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29ycyB8fCBvcHRpb25zLnVzZVhEUikge1xuICAgICAgICAgICAgeGhyID0gbmV3IGNyZWF0ZVhIUi5YRG9tYWluUmVxdWVzdCgpXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgeGhyID0gbmV3IGNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5XG4gICAgdmFyIGFib3J0ZWRcbiAgICB2YXIgdXJpID0geGhyLnVybCA9IG9wdGlvbnMudXJpIHx8IG9wdGlvbnMudXJsXG4gICAgdmFyIG1ldGhvZCA9IHhoci5tZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiXG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHkgfHwgb3B0aW9ucy5kYXRhIHx8IG51bGxcbiAgICB2YXIgaGVhZGVycyA9IHhoci5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9XG4gICAgdmFyIHN5bmMgPSAhIW9wdGlvbnMuc3luY1xuICAgIHZhciBpc0pzb24gPSBmYWxzZVxuICAgIHZhciB0aW1lb3V0VGltZXJcblxuICAgIGlmIChcImpzb25cIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlzSnNvbiA9IHRydWVcbiAgICAgICAgaGVhZGVyc1tcImFjY2VwdFwiXSB8fCBoZWFkZXJzW1wiQWNjZXB0XCJdIHx8IChoZWFkZXJzW1wiQWNjZXB0XCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIC8vRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgYWNjZXB0IGhlYWRlciBkZWNsYXJlZCBieSB1c2VyXG4gICAgICAgIGlmIChtZXRob2QgIT09IFwiR0VUXCIgJiYgbWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSB8fCBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdIHx8IChoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIC8vRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgYWNjZXB0IGhlYWRlciBkZWNsYXJlZCBieSB1c2VyXG4gICAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5qc29uKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHJlYWR5c3RhdGVjaGFuZ2VcbiAgICB4aHIub25sb2FkID0gbG9hZEZ1bmNcbiAgICB4aHIub25lcnJvciA9IGVycm9yRnVuY1xuICAgIC8vIElFOSBtdXN0IGhhdmUgb25wcm9ncmVzcyBiZSBzZXQgdG8gYSB1bmlxdWUgZnVuY3Rpb24uXG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElFIG11c3QgZGllXG4gICAgfVxuICAgIHhoci5vbnRpbWVvdXQgPSBlcnJvckZ1bmNcbiAgICB4aHIub3BlbihtZXRob2QsIHVyaSwgIXN5bmMsIG9wdGlvbnMudXNlcm5hbWUsIG9wdGlvbnMucGFzc3dvcmQpXG4gICAgLy9oYXMgdG8gYmUgYWZ0ZXIgb3BlblxuICAgIGlmKCFzeW5jKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSAhIW9wdGlvbnMud2l0aENyZWRlbnRpYWxzXG4gICAgfVxuICAgIC8vIENhbm5vdCBzZXQgdGltZW91dCB3aXRoIHN5bmMgcmVxdWVzdFxuICAgIC8vIG5vdCBzZXR0aW5nIHRpbWVvdXQgb24gdGhlIHhociBvYmplY3QsIGJlY2F1c2Ugb2Ygb2xkIHdlYmtpdHMgZXRjLiBub3QgaGFuZGxpbmcgdGhhdCBjb3JyZWN0bHlcbiAgICAvLyBib3RoIG5wbSdzIHJlcXVlc3QgYW5kIGpxdWVyeSAxLnggdXNlIHRoaXMga2luZCBvZiB0aW1lb3V0LCBzbyB0aGlzIGlzIGJlaW5nIGNvbnNpc3RlbnRcbiAgICBpZiAoIXN5bmMgJiYgb3B0aW9ucy50aW1lb3V0ID4gMCApIHtcbiAgICAgICAgdGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgYWJvcnRlZD10cnVlLy9JRTkgbWF5IHN0aWxsIGNhbGwgcmVhZHlzdGF0ZWNoYW5nZVxuICAgICAgICAgICAgeGhyLmFib3J0KFwidGltZW91dFwiKVxuICAgICAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoXCJYTUxIdHRwUmVxdWVzdCB0aW1lb3V0XCIpXG4gICAgICAgICAgICBlLmNvZGUgPSBcIkVUSU1FRE9VVFwiXG4gICAgICAgICAgICBlcnJvckZ1bmMoZSlcbiAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0IClcbiAgICB9XG5cbiAgICBpZiAoeGhyLnNldFJlcXVlc3RIZWFkZXIpIHtcbiAgICAgICAgZm9yKGtleSBpbiBoZWFkZXJzKXtcbiAgICAgICAgICAgIGlmKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSl7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBoZWFkZXJzW2tleV0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaGVhZGVycyAmJiAhaXNFbXB0eShvcHRpb25zLmhlYWRlcnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhlYWRlcnMgY2Fubm90IGJlIHNldCBvbiBhbiBYRG9tYWluUmVxdWVzdCBvYmplY3RcIilcbiAgICB9XG5cbiAgICBpZiAoXCJyZXNwb25zZVR5cGVcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZVxuICAgIH1cblxuICAgIGlmIChcImJlZm9yZVNlbmRcIiBpbiBvcHRpb25zICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmJlZm9yZVNlbmQgPT09IFwiZnVuY3Rpb25cIlxuICAgICkge1xuICAgICAgICBvcHRpb25zLmJlZm9yZVNlbmQoeGhyKVxuICAgIH1cblxuICAgIHhoci5zZW5kKGJvZHkpXG5cbiAgICByZXR1cm4geGhyXG5cblxufVxuXG5mdW5jdGlvbiBub29wKCkge31cbiIsImlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgIG1vZHVsZS5leHBvcnRzID0gc2VsZjtcbn0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7fTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvblxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKGZuKSB7XG4gIHZhciBzdHJpbmcgPSB0b1N0cmluZy5jYWxsKGZuKVxuICByZXR1cm4gc3RyaW5nID09PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8XG4gICAgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiBzdHJpbmcgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB8fFxuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAvLyBJRTggYW5kIGJlbG93XG4gICAgIChmbiA9PT0gd2luZG93LnNldFRpbWVvdXQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuYWxlcnQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuY29uZmlybSB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5wcm9tcHQpKVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gb25jZVxuXG5vbmNlLnByb3RvID0gb25jZShmdW5jdGlvbiAoKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdW5jdGlvbi5wcm90b3R5cGUsICdvbmNlJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb25jZSh0aGlzKVxuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG59KVxuXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm5cbiAgICBjYWxsZWQgPSB0cnVlXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxufVxuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1mdW5jdGlvbicpXG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaFxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG5cbmZ1bmN0aW9uIGZvckVhY2gobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oaXRlcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpXG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgIGNvbnRleHQgPSB0aGlzXG4gICAgfVxuICAgIFxuICAgIGlmICh0b1N0cmluZy5jYWxsKGxpc3QpID09PSAnW29iamVjdCBBcnJheV0nKVxuICAgICAgICBmb3JFYWNoQXJyYXkobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG4gICAgZWxzZSBpZiAodHlwZW9mIGxpc3QgPT09ICdzdHJpbmcnKVxuICAgICAgICBmb3JFYWNoU3RyaW5nKGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxuICAgIGVsc2VcbiAgICAgICAgZm9yRWFjaE9iamVjdChsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbn1cblxuZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFycmF5LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgYXJyYXlbaV0sIGksIGFycmF5KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoU3RyaW5nKHN0cmluZywgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIG5vIHN1Y2ggdGhpbmcgYXMgYSBzcGFyc2Ugc3RyaW5nLlxuICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHN0cmluZy5jaGFyQXQoaSksIGksIHN0cmluZylcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hPYmplY3Qob2JqZWN0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaykpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqZWN0W2tdLCBrLCBvYmplY3QpXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHRyaW07XG5cbmZ1bmN0aW9uIHRyaW0oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJyk7XG59XG5cbmV4cG9ydHMubGVmdCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJyk7XG59O1xuXG5leHBvcnRzLnJpZ2h0ID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn07XG4iLCJ2YXIgdHJpbSA9IHJlcXVpcmUoJ3RyaW0nKVxuICAsIGZvckVhY2ggPSByZXF1aXJlKCdmb3ItZWFjaCcpXG4gICwgaXNBcnJheSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaGVhZGVycykge1xuICBpZiAoIWhlYWRlcnMpXG4gICAgcmV0dXJuIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHt9XG5cbiAgZm9yRWFjaChcbiAgICAgIHRyaW0oaGVhZGVycykuc3BsaXQoJ1xcbicpXG4gICAgLCBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJvdy5pbmRleE9mKCc6JylcbiAgICAgICAgICAsIGtleSA9IHRyaW0ocm93LnNsaWNlKDAsIGluZGV4KSkudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICwgdmFsdWUgPSB0cmltKHJvdy5zbGljZShpbmRleCArIDEpKVxuXG4gICAgICAgIGlmICh0eXBlb2YocmVzdWx0W2tleV0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHJlc3VsdFtrZXldKSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBbIHJlc3VsdFtrZXldLCB2YWx1ZSBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgKVxuXG4gIHJldHVybiByZXN1bHRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuIl19
